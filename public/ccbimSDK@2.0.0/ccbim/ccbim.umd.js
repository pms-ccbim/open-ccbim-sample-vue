!(function (t, e) {
  'object' == typeof exports && 'undefined' != typeof module
    ? e(exports)
    : 'function' == typeof define && define.amd
    ? define(['exports'], e)
    : e(
        (((t = 'undefined' != typeof globalThis ? globalThis : t || self).PMS =
          t.PMS || {}),
        (t.PMS.CCBIM = {})),
      );
})(this, function (t) {
  'use strict';
  function e() {}
  Object.assign(e.prototype, {
    addEventListener: function (t, e) {
      void 0 === this._listeners && (this._listeners = {});
      var n = this._listeners;
      void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e);
    },
    hasEventListener: function (t, e) {
      if (void 0 === this._listeners) return !1;
      var n = this._listeners;
      return void 0 !== n[t] && -1 !== n[t].indexOf(e);
    },
    removeEventListener: function (t, e) {
      if (void 0 !== this._listeners) {
        var n = this._listeners[t];
        if (void 0 !== n) {
          var i = n.indexOf(e);
          -1 !== i && n.splice(i, 1);
        }
      }
    },
    dispatchEvent: function (t) {
      if (void 0 !== this._listeners) {
        var e = this._listeners[t.type];
        if (void 0 !== e) {
          t.target = this;
          for (var n = e.slice(0), i = 0, r = n.length; i < r; i++)
            n[i].call(this, t);
        }
      }
    },
  });
  const n = { renderFinish: 'renderFinish' };
  void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)),
    void 0 === Number.isInteger &&
      (Number.isInteger = function (t) {
        return 'number' == typeof t && isFinite(t) && Math.floor(t) === t;
      }),
    void 0 === Math.sign &&
      (Math.sign = function (t) {
        return t < 0 ? -1 : t > 0 ? 1 : +t;
      }),
    'name' in Function.prototype == !1 &&
      Object.defineProperty(Function.prototype, 'name', {
        get: function () {
          return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
        },
      }),
    void 0 === Object.assign &&
      (Object.assign = function (t) {
        if (null == t)
          throw new TypeError('Cannot convert undefined or null to object');
        for (var e = Object(t), n = 1; n < arguments.length; n++) {
          var i = arguments[n];
          if (null != i)
            for (var r in i)
              Object.prototype.hasOwnProperty.call(i, r) && (e[r] = i[r]);
        }
        return e;
      });
  var i = 100,
    r = 306,
    o = 1e3,
    s = 1001,
    a = 1002,
    c = 1003,
    l = 1004,
    h = 1005,
    u = 1006,
    d = 1008,
    p = 1009,
    f = 1012,
    m = 1014,
    b = 1015,
    g = 1016,
    y = 1020,
    v = 1021,
    _ = 1022,
    x = 1023,
    w = 1026,
    A = 1027,
    M = 2300,
    S = 2301,
    I = 2302,
    E = 2400,
    D = 2401,
    C = 2402,
    T = 3e3,
    L = 3001,
    R = 7680,
    F = 35044,
    P = 35048;
  function B() {}
  Object.assign(B.prototype, {
    addEventListener: function (t, e) {
      void 0 === this._listeners && (this._listeners = {});
      var n = this._listeners;
      void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e);
    },
    hasEventListener: function (t, e) {
      if (void 0 === this._listeners) return !1;
      var n = this._listeners;
      return void 0 !== n[t] && -1 !== n[t].indexOf(e);
    },
    removeEventListener: function (t, e) {
      if (void 0 !== this._listeners) {
        var n = this._listeners[t];
        if (void 0 !== n) {
          var i = n.indexOf(e);
          -1 !== i && n.splice(i, 1);
        }
      }
    },
    dispatchEvent: function (t) {
      if (void 0 !== this._listeners) {
        var e = this._listeners[t.type];
        if (void 0 !== e) {
          t.target = this;
          for (var n = e.slice(0), i = 0, r = n.length; i < r; i++)
            n[i].call(this, t);
        }
      }
    },
  });
  for (var O = [], V = 0; V < 256; V++)
    O[V] = (V < 16 ? '0' : '') + V.toString(16);
  var N,
    k = {
      DEG2RAD: Math.PI / 180,
      RAD2DEG: 180 / Math.PI,
      generateUUID: function () {
        var t = (4294967295 * Math.random()) | 0,
          e = (4294967295 * Math.random()) | 0,
          n = (4294967295 * Math.random()) | 0,
          i = (4294967295 * Math.random()) | 0;
        return (
          O[255 & t] +
          O[(t >> 8) & 255] +
          O[(t >> 16) & 255] +
          O[(t >> 24) & 255] +
          '-' +
          O[255 & e] +
          O[(e >> 8) & 255] +
          '-' +
          O[((e >> 16) & 15) | 64] +
          O[(e >> 24) & 255] +
          '-' +
          O[(63 & n) | 128] +
          O[(n >> 8) & 255] +
          '-' +
          O[(n >> 16) & 255] +
          O[(n >> 24) & 255] +
          O[255 & i] +
          O[(i >> 8) & 255] +
          O[(i >> 16) & 255] +
          O[(i >> 24) & 255]
        ).toUpperCase();
      },
      clamp: function (t, e, n) {
        return Math.max(e, Math.min(n, t));
      },
      euclideanModulo: function (t, e) {
        return ((t % e) + e) % e;
      },
      mapLinear: function (t, e, n, i, r) {
        return i + ((t - e) * (r - i)) / (n - e);
      },
      lerp: function (t, e, n) {
        return (1 - n) * t + n * e;
      },
      smoothstep: function (t, e, n) {
        return t <= e
          ? 0
          : t >= n
          ? 1
          : (t = (t - e) / (n - e)) * t * (3 - 2 * t);
      },
      smootherstep: function (t, e, n) {
        return t <= e
          ? 0
          : t >= n
          ? 1
          : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10);
      },
      randInt: function (t, e) {
        return t + Math.floor(Math.random() * (e - t + 1));
      },
      randFloat: function (t, e) {
        return t + Math.random() * (e - t);
      },
      randFloatSpread: function (t) {
        return t * (0.5 - Math.random());
      },
      degToRad: function (t) {
        return t * k.DEG2RAD;
      },
      radToDeg: function (t) {
        return t * k.RAD2DEG;
      },
      isPowerOfTwo: function (t) {
        return 0 == (t & (t - 1)) && 0 !== t;
      },
      ceilPowerOfTwo: function (t) {
        return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));
      },
      floorPowerOfTwo: function (t) {
        return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
      },
      setQuaternionFromProperEuler: function (t, e, n, i, r) {
        var o = Math.cos,
          s = Math.sin,
          a = o(n / 2),
          c = s(n / 2),
          l = o((e + i) / 2),
          h = s((e + i) / 2),
          u = o((e - i) / 2),
          d = s((e - i) / 2),
          p = o((i - e) / 2),
          f = s((i - e) / 2);
        'XYX' === r
          ? t.set(a * h, c * u, c * d, a * l)
          : 'YZY' === r
          ? t.set(c * d, a * h, c * u, a * l)
          : 'ZXZ' === r
          ? t.set(c * u, c * d, a * h, a * l)
          : 'XZX' === r
          ? t.set(a * h, c * f, c * p, a * l)
          : 'YXY' === r
          ? t.set(c * p, a * h, c * f, a * l)
          : 'ZYZ' === r
          ? t.set(c * f, c * p, a * h, a * l)
          : console.warn(
              'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order.',
            );
      },
    };
  function U(t, e) {
    (this.x = t || 0), (this.y = e || 0);
  }
  function G() {
    (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      arguments.length > 0 &&
        console.error(
          'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.',
        );
  }
  Object.defineProperties(U.prototype, {
    width: {
      get: function () {
        return this.x;
      },
      set: function (t) {
        this.x = t;
      },
    },
    height: {
      get: function () {
        return this.y;
      },
      set: function (t) {
        this.y = t;
      },
    },
  }),
    Object.assign(U.prototype, {
      isVector2: !0,
      set: function (t, e) {
        return (this.x = t), (this.y = e), this;
      },
      setScalar: function (t) {
        return (this.x = t), (this.y = t), this;
      },
      setX: function (t) {
        return (this.x = t), this;
      },
      setY: function (t) {
        return (this.y = t), this;
      },
      setComponent: function (t, e) {
        switch (t) {
          case 0:
            this.x = e;
            break;
          case 1:
            this.y = e;
            break;
          default:
            throw new Error('index is out of range: ' + t);
        }
        return this;
      },
      getComponent: function (t) {
        switch (t) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          default:
            throw new Error('index is out of range: ' + t);
        }
      },
      clone: function () {
        return new this.constructor(this.x, this.y);
      },
      copy: function (t) {
        return (this.x = t.x), (this.y = t.y), this;
      },
      add: function (t, e) {
        return void 0 !== e
          ? (console.warn(
              'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.',
            ),
            this.addVectors(t, e))
          : ((this.x += t.x), (this.y += t.y), this);
      },
      addScalar: function (t) {
        return (this.x += t), (this.y += t), this;
      },
      addVectors: function (t, e) {
        return (this.x = t.x + e.x), (this.y = t.y + e.y), this;
      },
      addScaledVector: function (t, e) {
        return (this.x += t.x * e), (this.y += t.y * e), this;
      },
      sub: function (t, e) {
        return void 0 !== e
          ? (console.warn(
              'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.',
            ),
            this.subVectors(t, e))
          : ((this.x -= t.x), (this.y -= t.y), this);
      },
      subScalar: function (t) {
        return (this.x -= t), (this.y -= t), this;
      },
      subVectors: function (t, e) {
        return (this.x = t.x - e.x), (this.y = t.y - e.y), this;
      },
      multiply: function (t) {
        return (this.x *= t.x), (this.y *= t.y), this;
      },
      multiplyScalar: function (t) {
        return (this.x *= t), (this.y *= t), this;
      },
      divide: function (t) {
        return (this.x /= t.x), (this.y /= t.y), this;
      },
      divideScalar: function (t) {
        return this.multiplyScalar(1 / t);
      },
      applyMatrix3: function (t) {
        var e = this.x,
          n = this.y,
          i = t.elements;
        return (
          (this.x = i[0] * e + i[3] * n + i[6]),
          (this.y = i[1] * e + i[4] * n + i[7]),
          this
        );
      },
      min: function (t) {
        return (
          (this.x = Math.min(this.x, t.x)),
          (this.y = Math.min(this.y, t.y)),
          this
        );
      },
      max: function (t) {
        return (
          (this.x = Math.max(this.x, t.x)),
          (this.y = Math.max(this.y, t.y)),
          this
        );
      },
      clamp: function (t, e) {
        return (
          (this.x = Math.max(t.x, Math.min(e.x, this.x))),
          (this.y = Math.max(t.y, Math.min(e.y, this.y))),
          this
        );
      },
      clampScalar: function (t, e) {
        return (
          (this.x = Math.max(t, Math.min(e, this.x))),
          (this.y = Math.max(t, Math.min(e, this.y))),
          this
        );
      },
      clampLength: function (t, e) {
        var n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(
          Math.max(t, Math.min(e, n)),
        );
      },
      floor: function () {
        return (
          (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this
        );
      },
      ceil: function () {
        return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
      },
      round: function () {
        return (
          (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this
        );
      },
      roundToZero: function () {
        return (
          (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
          (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
          this
        );
      },
      negate: function () {
        return (this.x = -this.x), (this.y = -this.y), this;
      },
      dot: function (t) {
        return this.x * t.x + this.y * t.y;
      },
      cross: function (t) {
        return this.x * t.y - this.y * t.x;
      },
      lengthSq: function () {
        return this.x * this.x + this.y * this.y;
      },
      length: function () {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      },
      manhattanLength: function () {
        return Math.abs(this.x) + Math.abs(this.y);
      },
      normalize: function () {
        return this.divideScalar(this.length() || 1);
      },
      angle: function () {
        return Math.atan2(-this.y, -this.x) + Math.PI;
      },
      distanceTo: function (t) {
        return Math.sqrt(this.distanceToSquared(t));
      },
      distanceToSquared: function (t) {
        var e = this.x - t.x,
          n = this.y - t.y;
        return e * e + n * n;
      },
      manhattanDistanceTo: function (t) {
        return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
      },
      setLength: function (t) {
        return this.normalize().multiplyScalar(t);
      },
      lerp: function (t, e) {
        return (
          (this.x += (t.x - this.x) * e), (this.y += (t.y - this.y) * e), this
        );
      },
      lerpVectors: function (t, e, n) {
        return this.subVectors(e, t).multiplyScalar(n).add(t);
      },
      equals: function (t) {
        return t.x === this.x && t.y === this.y;
      },
      fromArray: function (t, e) {
        return (
          void 0 === e && (e = 0), (this.x = t[e]), (this.y = t[e + 1]), this
        );
      },
      toArray: function (t, e) {
        return (
          void 0 === t && (t = []),
          void 0 === e && (e = 0),
          (t[e] = this.x),
          (t[e + 1] = this.y),
          t
        );
      },
      fromBufferAttribute: function (t, e, n) {
        return (
          void 0 !== n &&
            console.warn(
              'THREE.Vector2: offset has been removed from .fromBufferAttribute().',
            ),
          (this.x = t.getX(e)),
          (this.y = t.getY(e)),
          this
        );
      },
      rotateAround: function (t, e) {
        var n = Math.cos(e),
          i = Math.sin(e),
          r = this.x - t.x,
          o = this.y - t.y;
        return (
          (this.x = r * n - o * i + t.x), (this.y = r * i + o * n + t.y), this
        );
      },
    }),
    Object.assign(G.prototype, {
      isMatrix3: !0,
      set: function (t, e, n, i, r, o, s, a, c) {
        var l = this.elements;
        return (
          (l[0] = t),
          (l[1] = i),
          (l[2] = s),
          (l[3] = e),
          (l[4] = r),
          (l[5] = a),
          (l[6] = n),
          (l[7] = o),
          (l[8] = c),
          this
        );
      },
      identity: function () {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
      },
      clone: function () {
        return new this.constructor().fromArray(this.elements);
      },
      copy: function (t) {
        var e = this.elements,
          n = t.elements;
        return (
          (e[0] = n[0]),
          (e[1] = n[1]),
          (e[2] = n[2]),
          (e[3] = n[3]),
          (e[4] = n[4]),
          (e[5] = n[5]),
          (e[6] = n[6]),
          (e[7] = n[7]),
          (e[8] = n[8]),
          this
        );
      },
      extractBasis: function (t, e, n) {
        return (
          t.setFromMatrix3Column(this, 0),
          e.setFromMatrix3Column(this, 1),
          n.setFromMatrix3Column(this, 2),
          this
        );
      },
      setFromMatrix4: function (t) {
        var e = t.elements;
        return (
          this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
        );
      },
      multiply: function (t) {
        return this.multiplyMatrices(this, t);
      },
      premultiply: function (t) {
        return this.multiplyMatrices(t, this);
      },
      multiplyMatrices: function (t, e) {
        var n = t.elements,
          i = e.elements,
          r = this.elements,
          o = n[0],
          s = n[3],
          a = n[6],
          c = n[1],
          l = n[4],
          h = n[7],
          u = n[2],
          d = n[5],
          p = n[8],
          f = i[0],
          m = i[3],
          b = i[6],
          g = i[1],
          y = i[4],
          v = i[7],
          _ = i[2],
          x = i[5],
          w = i[8];
        return (
          (r[0] = o * f + s * g + a * _),
          (r[3] = o * m + s * y + a * x),
          (r[6] = o * b + s * v + a * w),
          (r[1] = c * f + l * g + h * _),
          (r[4] = c * m + l * y + h * x),
          (r[7] = c * b + l * v + h * w),
          (r[2] = u * f + d * g + p * _),
          (r[5] = u * m + d * y + p * x),
          (r[8] = u * b + d * v + p * w),
          this
        );
      },
      multiplyScalar: function (t) {
        var e = this.elements;
        return (
          (e[0] *= t),
          (e[3] *= t),
          (e[6] *= t),
          (e[1] *= t),
          (e[4] *= t),
          (e[7] *= t),
          (e[2] *= t),
          (e[5] *= t),
          (e[8] *= t),
          this
        );
      },
      determinant: function () {
        var t = this.elements,
          e = t[0],
          n = t[1],
          i = t[2],
          r = t[3],
          o = t[4],
          s = t[5],
          a = t[6],
          c = t[7],
          l = t[8];
        return (
          e * o * l - e * s * c - n * r * l + n * s * a + i * r * c - i * o * a
        );
      },
      getInverse: function (t, e) {
        void 0 !== e &&
          console.warn(
            'THREE.Matrix3: .getInverse() can no longer be configured to throw on degenerate.',
          );
        var n = t.elements,
          i = this.elements,
          r = n[0],
          o = n[1],
          s = n[2],
          a = n[3],
          c = n[4],
          l = n[5],
          h = n[6],
          u = n[7],
          d = n[8],
          p = d * c - l * u,
          f = l * h - d * a,
          m = u * a - c * h,
          b = r * p + o * f + s * m;
        if (0 === b) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        var g = 1 / b;
        return (
          (i[0] = p * g),
          (i[1] = (s * u - d * o) * g),
          (i[2] = (l * o - s * c) * g),
          (i[3] = f * g),
          (i[4] = (d * r - s * h) * g),
          (i[5] = (s * a - l * r) * g),
          (i[6] = m * g),
          (i[7] = (o * h - u * r) * g),
          (i[8] = (c * r - o * a) * g),
          this
        );
      },
      transpose: function () {
        var t,
          e = this.elements;
        return (
          (t = e[1]),
          (e[1] = e[3]),
          (e[3] = t),
          (t = e[2]),
          (e[2] = e[6]),
          (e[6] = t),
          (t = e[5]),
          (e[5] = e[7]),
          (e[7] = t),
          this
        );
      },
      getNormalMatrix: function (t) {
        return this.setFromMatrix4(t).getInverse(this).transpose();
      },
      transposeIntoArray: function (t) {
        var e = this.elements;
        return (
          (t[0] = e[0]),
          (t[1] = e[3]),
          (t[2] = e[6]),
          (t[3] = e[1]),
          (t[4] = e[4]),
          (t[5] = e[7]),
          (t[6] = e[2]),
          (t[7] = e[5]),
          (t[8] = e[8]),
          this
        );
      },
      setUvTransform: function (t, e, n, i, r, o, s) {
        var a = Math.cos(r),
          c = Math.sin(r);
        this.set(
          n * a,
          n * c,
          -n * (a * o + c * s) + o + t,
          -i * c,
          i * a,
          -i * (-c * o + a * s) + s + e,
          0,
          0,
          1,
        );
      },
      scale: function (t, e) {
        var n = this.elements;
        return (
          (n[0] *= t),
          (n[3] *= t),
          (n[6] *= t),
          (n[1] *= e),
          (n[4] *= e),
          (n[7] *= e),
          this
        );
      },
      rotate: function (t) {
        var e = Math.cos(t),
          n = Math.sin(t),
          i = this.elements,
          r = i[0],
          o = i[3],
          s = i[6],
          a = i[1],
          c = i[4],
          l = i[7];
        return (
          (i[0] = e * r + n * a),
          (i[3] = e * o + n * c),
          (i[6] = e * s + n * l),
          (i[1] = -n * r + e * a),
          (i[4] = -n * o + e * c),
          (i[7] = -n * s + e * l),
          this
        );
      },
      translate: function (t, e) {
        var n = this.elements;
        return (
          (n[0] += t * n[2]),
          (n[3] += t * n[5]),
          (n[6] += t * n[8]),
          (n[1] += e * n[2]),
          (n[4] += e * n[5]),
          (n[7] += e * n[8]),
          this
        );
      },
      equals: function (t) {
        for (var e = this.elements, n = t.elements, i = 0; i < 9; i++)
          if (e[i] !== n[i]) return !1;
        return !0;
      },
      fromArray: function (t, e) {
        void 0 === e && (e = 0);
        for (var n = 0; n < 9; n++) this.elements[n] = t[n + e];
        return this;
      },
      toArray: function (t, e) {
        void 0 === t && (t = []), void 0 === e && (e = 0);
        var n = this.elements;
        return (
          (t[e] = n[0]),
          (t[e + 1] = n[1]),
          (t[e + 2] = n[2]),
          (t[e + 3] = n[3]),
          (t[e + 4] = n[4]),
          (t[e + 5] = n[5]),
          (t[e + 6] = n[6]),
          (t[e + 7] = n[7]),
          (t[e + 8] = n[8]),
          t
        );
      },
    });
  var z = {
      getDataURL: function (t) {
        var e;
        if ('undefined' == typeof HTMLCanvasElement) return t.src;
        if (t instanceof HTMLCanvasElement) e = t;
        else {
          void 0 === N &&
            (N = document.createElementNS(
              'http://www.w3.org/1999/xhtml',
              'canvas',
            )),
            (N.width = t.width),
            (N.height = t.height);
          var n = N.getContext('2d');
          t instanceof ImageData
            ? n.putImageData(t, 0, 0)
            : n.drawImage(t, 0, 0, t.width, t.height),
            (e = N);
        }
        return e.width > 2048 || e.height > 2048
          ? e.toDataURL('image/jpeg', 0.6)
          : e.toDataURL('image/png');
      },
    },
    j = 0;
  function H(t, e, n, i, r, o, a, c, l, h) {
    Object.defineProperty(this, 'id', { value: j++ }),
      (this.uuid = k.generateUUID()),
      (this.name = ''),
      (this.image = void 0 !== t ? t : H.DEFAULT_IMAGE),
      (this.mipmaps = []),
      (this.mapping = void 0 !== e ? e : H.DEFAULT_MAPPING),
      (this.wrapS = void 0 !== n ? n : s),
      (this.wrapT = void 0 !== i ? i : s),
      (this.magFilter = void 0 !== r ? r : u),
      (this.minFilter = void 0 !== o ? o : d),
      (this.anisotropy = void 0 !== l ? l : 1),
      (this.format = void 0 !== a ? a : x),
      (this.internalFormat = null),
      (this.type = void 0 !== c ? c : p),
      (this.offset = new U(0, 0)),
      (this.repeat = new U(1, 1)),
      (this.center = new U(0, 0)),
      (this.rotation = 0),
      (this.matrixAutoUpdate = !0),
      (this.matrix = new G()),
      (this.generateMipmaps = !0),
      (this.premultiplyAlpha = !1),
      (this.flipY = !0),
      (this.unpackAlignment = 4),
      (this.encoding = void 0 !== h ? h : T),
      (this.version = 0),
      (this.onUpdate = null);
  }
  function W(t, e, n, i) {
    (this.x = t || 0),
      (this.y = e || 0),
      (this.z = n || 0),
      (this.w = void 0 !== i ? i : 1);
  }
  function X(t, e, n) {
    (this.width = t),
      (this.height = e),
      (this.scissor = new W(0, 0, t, e)),
      (this.scissorTest = !1),
      (this.viewport = new W(0, 0, t, e)),
      (n = n || {}),
      (this.texture = new H(
        void 0,
        n.mapping,
        n.wrapS,
        n.wrapT,
        n.magFilter,
        n.minFilter,
        n.format,
        n.type,
        n.anisotropy,
        n.encoding,
      )),
      (this.texture.image = {}),
      (this.texture.image.width = t),
      (this.texture.image.height = e),
      (this.texture.generateMipmaps =
        void 0 !== n.generateMipmaps && n.generateMipmaps),
      (this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : u),
      (this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer),
      (this.stencilBuffer = void 0 === n.stencilBuffer || n.stencilBuffer),
      (this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null),
      (this.frameBuffer = null);
  }
  function Z(t, e, n) {
    X.call(this, t, e, n),
      (n = n || {}),
      (this.samples = void 0 !== n.samples ? n.samples : 4);
  }
  function Y(t, e, n, i) {
    (this._x = t || 0),
      (this._y = e || 0),
      (this._z = n || 0),
      (this._w = void 0 !== i ? i : 1);
  }
  (H.DEFAULT_IMAGE = void 0),
    (H.DEFAULT_MAPPING = 300),
    (H.prototype = Object.assign(Object.create(B.prototype), {
      constructor: H,
      isTexture: !0,
      updateMatrix: function () {
        this.matrix.setUvTransform(
          this.offset.x,
          this.offset.y,
          this.repeat.x,
          this.repeat.y,
          this.rotation,
          this.center.x,
          this.center.y,
        );
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (t) {
        return (
          (this.name = t.name),
          (this.image = t.image),
          (this.mipmaps = t.mipmaps.slice(0)),
          (this.mapping = t.mapping),
          (this.wrapS = t.wrapS),
          (this.wrapT = t.wrapT),
          (this.magFilter = t.magFilter),
          (this.minFilter = t.minFilter),
          (this.anisotropy = t.anisotropy),
          (this.format = t.format),
          (this.internalFormat = t.internalFormat),
          (this.type = t.type),
          this.offset.copy(t.offset),
          this.repeat.copy(t.repeat),
          this.center.copy(t.center),
          (this.rotation = t.rotation),
          (this.matrixAutoUpdate = t.matrixAutoUpdate),
          this.matrix.copy(t.matrix),
          (this.generateMipmaps = t.generateMipmaps),
          (this.premultiplyAlpha = t.premultiplyAlpha),
          (this.flipY = t.flipY),
          (this.unpackAlignment = t.unpackAlignment),
          (this.encoding = t.encoding),
          this
        );
      },
      toJSON: function (t) {
        var e = void 0 === t || 'string' == typeof t;
        if (!e && void 0 !== t.textures[this.uuid])
          return t.textures[this.uuid];
        var n = {
          metadata: {
            version: 4.5,
            type: 'Texture',
            generator: 'Texture.toJSON',
          },
          uuid: this.uuid,
          name: this.name,
          mapping: this.mapping,
          repeat: [this.repeat.x, this.repeat.y],
          offset: [this.offset.x, this.offset.y],
          center: [this.center.x, this.center.y],
          rotation: this.rotation,
          wrap: [this.wrapS, this.wrapT],
          format: this.format,
          type: this.type,
          encoding: this.encoding,
          minFilter: this.minFilter,
          magFilter: this.magFilter,
          anisotropy: this.anisotropy,
          flipY: this.flipY,
          premultiplyAlpha: this.premultiplyAlpha,
          unpackAlignment: this.unpackAlignment,
        };
        if (void 0 !== this.image) {
          var i = this.image;
          if (
            (void 0 === i.uuid && (i.uuid = k.generateUUID()),
            !e && void 0 === t.images[i.uuid])
          ) {
            var r;
            if (Array.isArray(i)) {
              r = [];
              for (var o = 0, s = i.length; o < s; o++)
                r.push(z.getDataURL(i[o]));
            } else r = z.getDataURL(i);
            t.images[i.uuid] = { uuid: i.uuid, url: r };
          }
          n.image = i.uuid;
        }
        return e || (t.textures[this.uuid] = n), n;
      },
      dispose: function () {
        this.dispatchEvent({ type: 'dispose' });
      },
      transformUv: function (t) {
        if (300 !== this.mapping) return t;
        if ((t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1))
          switch (this.wrapS) {
            case o:
              t.x = t.x - Math.floor(t.x);
              break;
            case s:
              t.x = t.x < 0 ? 0 : 1;
              break;
            case a:
              1 === Math.abs(Math.floor(t.x) % 2)
                ? (t.x = Math.ceil(t.x) - t.x)
                : (t.x = t.x - Math.floor(t.x));
          }
        if (t.y < 0 || t.y > 1)
          switch (this.wrapT) {
            case o:
              t.y = t.y - Math.floor(t.y);
              break;
            case s:
              t.y = t.y < 0 ? 0 : 1;
              break;
            case a:
              1 === Math.abs(Math.floor(t.y) % 2)
                ? (t.y = Math.ceil(t.y) - t.y)
                : (t.y = t.y - Math.floor(t.y));
          }
        return this.flipY && (t.y = 1 - t.y), t;
      },
    })),
    Object.defineProperty(H.prototype, 'needsUpdate', {
      set: function (t) {
        !0 === t && this.version++;
      },
    }),
    Object.defineProperties(W.prototype, {
      width: {
        get: function () {
          return this.z;
        },
        set: function (t) {
          this.z = t;
        },
      },
      height: {
        get: function () {
          return this.w;
        },
        set: function (t) {
          this.w = t;
        },
      },
    }),
    Object.assign(W.prototype, {
      isVector4: !0,
      set: function (t, e, n, i) {
        return (this.x = t), (this.y = e), (this.z = n), (this.w = i), this;
      },
      setScalar: function (t) {
        return (this.x = t), (this.y = t), (this.z = t), (this.w = t), this;
      },
      setX: function (t) {
        return (this.x = t), this;
      },
      setY: function (t) {
        return (this.y = t), this;
      },
      setZ: function (t) {
        return (this.z = t), this;
      },
      setW: function (t) {
        return (this.w = t), this;
      },
      setComponent: function (t, e) {
        switch (t) {
          case 0:
            this.x = e;
            break;
          case 1:
            this.y = e;
            break;
          case 2:
            this.z = e;
            break;
          case 3:
            this.w = e;
            break;
          default:
            throw new Error('index is out of range: ' + t);
        }
        return this;
      },
      getComponent: function (t) {
        switch (t) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          case 3:
            return this.w;
          default:
            throw new Error('index is out of range: ' + t);
        }
      },
      clone: function () {
        return new this.constructor(this.x, this.y, this.z, this.w);
      },
      copy: function (t) {
        return (
          (this.x = t.x),
          (this.y = t.y),
          (this.z = t.z),
          (this.w = void 0 !== t.w ? t.w : 1),
          this
        );
      },
      add: function (t, e) {
        return void 0 !== e
          ? (console.warn(
              'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.',
            ),
            this.addVectors(t, e))
          : ((this.x += t.x),
            (this.y += t.y),
            (this.z += t.z),
            (this.w += t.w),
            this);
      },
      addScalar: function (t) {
        return (this.x += t), (this.y += t), (this.z += t), (this.w += t), this;
      },
      addVectors: function (t, e) {
        return (
          (this.x = t.x + e.x),
          (this.y = t.y + e.y),
          (this.z = t.z + e.z),
          (this.w = t.w + e.w),
          this
        );
      },
      addScaledVector: function (t, e) {
        return (
          (this.x += t.x * e),
          (this.y += t.y * e),
          (this.z += t.z * e),
          (this.w += t.w * e),
          this
        );
      },
      sub: function (t, e) {
        return void 0 !== e
          ? (console.warn(
              'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.',
            ),
            this.subVectors(t, e))
          : ((this.x -= t.x),
            (this.y -= t.y),
            (this.z -= t.z),
            (this.w -= t.w),
            this);
      },
      subScalar: function (t) {
        return (this.x -= t), (this.y -= t), (this.z -= t), (this.w -= t), this;
      },
      subVectors: function (t, e) {
        return (
          (this.x = t.x - e.x),
          (this.y = t.y - e.y),
          (this.z = t.z - e.z),
          (this.w = t.w - e.w),
          this
        );
      },
      multiplyScalar: function (t) {
        return (this.x *= t), (this.y *= t), (this.z *= t), (this.w *= t), this;
      },
      applyMatrix4: function (t) {
        var e = this.x,
          n = this.y,
          i = this.z,
          r = this.w,
          o = t.elements;
        return (
          (this.x = o[0] * e + o[4] * n + o[8] * i + o[12] * r),
          (this.y = o[1] * e + o[5] * n + o[9] * i + o[13] * r),
          (this.z = o[2] * e + o[6] * n + o[10] * i + o[14] * r),
          (this.w = o[3] * e + o[7] * n + o[11] * i + o[15] * r),
          this
        );
      },
      divideScalar: function (t) {
        return this.multiplyScalar(1 / t);
      },
      setAxisAngleFromQuaternion: function (t) {
        this.w = 2 * Math.acos(t.w);
        var e = Math.sqrt(1 - t.w * t.w);
        return (
          e < 1e-4
            ? ((this.x = 1), (this.y = 0), (this.z = 0))
            : ((this.x = t.x / e), (this.y = t.y / e), (this.z = t.z / e)),
          this
        );
      },
      setAxisAngleFromRotationMatrix: function (t) {
        var e,
          n,
          i,
          r,
          o = 0.01,
          s = 0.1,
          a = t.elements,
          c = a[0],
          l = a[4],
          h = a[8],
          u = a[1],
          d = a[5],
          p = a[9],
          f = a[2],
          m = a[6],
          b = a[10];
        if (Math.abs(l - u) < o && Math.abs(h - f) < o && Math.abs(p - m) < o) {
          if (
            Math.abs(l + u) < s &&
            Math.abs(h + f) < s &&
            Math.abs(p + m) < s &&
            Math.abs(c + d + b - 3) < s
          )
            return this.set(1, 0, 0, 0), this;
          e = Math.PI;
          var g = (c + 1) / 2,
            y = (d + 1) / 2,
            v = (b + 1) / 2,
            _ = (l + u) / 4,
            x = (h + f) / 4,
            w = (p + m) / 4;
          return (
            g > y && g > v
              ? g < o
                ? ((n = 0), (i = 0.707106781), (r = 0.707106781))
                : ((i = _ / (n = Math.sqrt(g))), (r = x / n))
              : y > v
              ? y < o
                ? ((n = 0.707106781), (i = 0), (r = 0.707106781))
                : ((n = _ / (i = Math.sqrt(y))), (r = w / i))
              : v < o
              ? ((n = 0.707106781), (i = 0.707106781), (r = 0))
              : ((n = x / (r = Math.sqrt(v))), (i = w / r)),
            this.set(n, i, r, e),
            this
          );
        }
        var A = Math.sqrt(
          (m - p) * (m - p) + (h - f) * (h - f) + (u - l) * (u - l),
        );
        return (
          Math.abs(A) < 0.001 && (A = 1),
          (this.x = (m - p) / A),
          (this.y = (h - f) / A),
          (this.z = (u - l) / A),
          (this.w = Math.acos((c + d + b - 1) / 2)),
          this
        );
      },
      min: function (t) {
        return (
          (this.x = Math.min(this.x, t.x)),
          (this.y = Math.min(this.y, t.y)),
          (this.z = Math.min(this.z, t.z)),
          (this.w = Math.min(this.w, t.w)),
          this
        );
      },
      max: function (t) {
        return (
          (this.x = Math.max(this.x, t.x)),
          (this.y = Math.max(this.y, t.y)),
          (this.z = Math.max(this.z, t.z)),
          (this.w = Math.max(this.w, t.w)),
          this
        );
      },
      clamp: function (t, e) {
        return (
          (this.x = Math.max(t.x, Math.min(e.x, this.x))),
          (this.y = Math.max(t.y, Math.min(e.y, this.y))),
          (this.z = Math.max(t.z, Math.min(e.z, this.z))),
          (this.w = Math.max(t.w, Math.min(e.w, this.w))),
          this
        );
      },
      clampScalar: function (t, e) {
        return (
          (this.x = Math.max(t, Math.min(e, this.x))),
          (this.y = Math.max(t, Math.min(e, this.y))),
          (this.z = Math.max(t, Math.min(e, this.z))),
          (this.w = Math.max(t, Math.min(e, this.w))),
          this
        );
      },
      clampLength: function (t, e) {
        var n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(
          Math.max(t, Math.min(e, n)),
        );
      },
      floor: function () {
        return (
          (this.x = Math.floor(this.x)),
          (this.y = Math.floor(this.y)),
          (this.z = Math.floor(this.z)),
          (this.w = Math.floor(this.w)),
          this
        );
      },
      ceil: function () {
        return (
          (this.x = Math.ceil(this.x)),
          (this.y = Math.ceil(this.y)),
          (this.z = Math.ceil(this.z)),
          (this.w = Math.ceil(this.w)),
          this
        );
      },
      round: function () {
        return (
          (this.x = Math.round(this.x)),
          (this.y = Math.round(this.y)),
          (this.z = Math.round(this.z)),
          (this.w = Math.round(this.w)),
          this
        );
      },
      roundToZero: function () {
        return (
          (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
          (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
          (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
          (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
          this
        );
      },
      negate: function () {
        return (
          (this.x = -this.x),
          (this.y = -this.y),
          (this.z = -this.z),
          (this.w = -this.w),
          this
        );
      },
      dot: function (t) {
        return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
      },
      lengthSq: function () {
        return (
          this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        );
      },
      length: function () {
        return Math.sqrt(
          this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w,
        );
      },
      manhattanLength: function () {
        return (
          Math.abs(this.x) +
          Math.abs(this.y) +
          Math.abs(this.z) +
          Math.abs(this.w)
        );
      },
      normalize: function () {
        return this.divideScalar(this.length() || 1);
      },
      setLength: function (t) {
        return this.normalize().multiplyScalar(t);
      },
      lerp: function (t, e) {
        return (
          (this.x += (t.x - this.x) * e),
          (this.y += (t.y - this.y) * e),
          (this.z += (t.z - this.z) * e),
          (this.w += (t.w - this.w) * e),
          this
        );
      },
      lerpVectors: function (t, e, n) {
        return this.subVectors(e, t).multiplyScalar(n).add(t);
      },
      equals: function (t) {
        return (
          t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
        );
      },
      fromArray: function (t, e) {
        return (
          void 0 === e && (e = 0),
          (this.x = t[e]),
          (this.y = t[e + 1]),
          (this.z = t[e + 2]),
          (this.w = t[e + 3]),
          this
        );
      },
      toArray: function (t, e) {
        return (
          void 0 === t && (t = []),
          void 0 === e && (e = 0),
          (t[e] = this.x),
          (t[e + 1] = this.y),
          (t[e + 2] = this.z),
          (t[e + 3] = this.w),
          t
        );
      },
      fromBufferAttribute: function (t, e, n) {
        return (
          void 0 !== n &&
            console.warn(
              'THREE.Vector4: offset has been removed from .fromBufferAttribute().',
            ),
          (this.x = t.getX(e)),
          (this.y = t.getY(e)),
          (this.z = t.getZ(e)),
          (this.w = t.getW(e)),
          this
        );
      },
    }),
    (X.prototype = Object.assign(Object.create(B.prototype), {
      constructor: X,
      isWebGLRenderTarget: !0,
      setFrameBuffer: function (t) {
        this.frameBuffer = t;
      },
      getFrameBuffer: function () {
        return this.frameBuffer;
      },
      setSize: function (t, e) {
        (this.width === t && this.height === e) ||
          ((this.width = t),
          (this.height = e),
          (this.texture.image.width = t),
          (this.texture.image.height = e),
          (this.frameBuffer = null),
          this.dispose()),
          this.viewport.set(0, 0, t, e),
          this.scissor.set(0, 0, t, e);
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (t) {
        return (
          (this.width = t.width),
          (this.height = t.height),
          this.viewport.copy(t.viewport),
          (this.texture = t.texture.clone()),
          (this.depthBuffer = t.depthBuffer),
          (this.stencilBuffer = t.stencilBuffer),
          (this.depthTexture = t.depthTexture),
          this
        );
      },
      dispose: function () {
        this.dispatchEvent({ type: 'dispose' });
      },
    })),
    (Z.prototype = Object.assign(Object.create(X.prototype), {
      constructor: Z,
      isWebGLMultisampleRenderTarget: !0,
      copy: function (t) {
        return X.prototype.copy.call(this, t), (this.samples = t.samples), this;
      },
    })),
    Object.assign(Y, {
      slerp: function (t, e, n, i) {
        return n.copy(t).slerp(e, i);
      },
      slerpFlat: function (t, e, n, i, r, o, s) {
        var a = n[i + 0],
          c = n[i + 1],
          l = n[i + 2],
          h = n[i + 3],
          u = r[o + 0],
          d = r[o + 1],
          p = r[o + 2],
          f = r[o + 3];
        if (h !== f || a !== u || c !== d || l !== p) {
          var m = 1 - s,
            b = a * u + c * d + l * p + h * f,
            g = b >= 0 ? 1 : -1,
            y = 1 - b * b;
          if (y > Number.EPSILON) {
            var v = Math.sqrt(y),
              _ = Math.atan2(v, b * g);
            (m = Math.sin(m * _) / v), (s = Math.sin(s * _) / v);
          }
          var x = s * g;
          if (
            ((a = a * m + u * x),
            (c = c * m + d * x),
            (l = l * m + p * x),
            (h = h * m + f * x),
            m === 1 - s)
          ) {
            var w = 1 / Math.sqrt(a * a + c * c + l * l + h * h);
            (a *= w), (c *= w), (l *= w), (h *= w);
          }
        }
        (t[e] = a), (t[e + 1] = c), (t[e + 2] = l), (t[e + 3] = h);
      },
    }),
    Object.defineProperties(Y.prototype, {
      x: {
        get: function () {
          return this._x;
        },
        set: function (t) {
          (this._x = t), this._onChangeCallback();
        },
      },
      y: {
        get: function () {
          return this._y;
        },
        set: function (t) {
          (this._y = t), this._onChangeCallback();
        },
      },
      z: {
        get: function () {
          return this._z;
        },
        set: function (t) {
          (this._z = t), this._onChangeCallback();
        },
      },
      w: {
        get: function () {
          return this._w;
        },
        set: function (t) {
          (this._w = t), this._onChangeCallback();
        },
      },
    }),
    Object.assign(Y.prototype, {
      isQuaternion: !0,
      set: function (t, e, n, i) {
        return (
          (this._x = t),
          (this._y = e),
          (this._z = n),
          (this._w = i),
          this._onChangeCallback(),
          this
        );
      },
      clone: function () {
        return new this.constructor(this._x, this._y, this._z, this._w);
      },
      copy: function (t) {
        return (
          (this._x = t.x),
          (this._y = t.y),
          (this._z = t.z),
          (this._w = t.w),
          this._onChangeCallback(),
          this
        );
      },
      setFromEuler: function (t, e) {
        if (!t || !t.isEuler)
          throw new Error(
            'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.',
          );
        var n = t._x,
          i = t._y,
          r = t._z,
          o = t.order,
          s = Math.cos,
          a = Math.sin,
          c = s(n / 2),
          l = s(i / 2),
          h = s(r / 2),
          u = a(n / 2),
          d = a(i / 2),
          p = a(r / 2);
        return (
          'XYZ' === o
            ? ((this._x = u * l * h + c * d * p),
              (this._y = c * d * h - u * l * p),
              (this._z = c * l * p + u * d * h),
              (this._w = c * l * h - u * d * p))
            : 'YXZ' === o
            ? ((this._x = u * l * h + c * d * p),
              (this._y = c * d * h - u * l * p),
              (this._z = c * l * p - u * d * h),
              (this._w = c * l * h + u * d * p))
            : 'ZXY' === o
            ? ((this._x = u * l * h - c * d * p),
              (this._y = c * d * h + u * l * p),
              (this._z = c * l * p + u * d * h),
              (this._w = c * l * h - u * d * p))
            : 'ZYX' === o
            ? ((this._x = u * l * h - c * d * p),
              (this._y = c * d * h + u * l * p),
              (this._z = c * l * p - u * d * h),
              (this._w = c * l * h + u * d * p))
            : 'YZX' === o
            ? ((this._x = u * l * h + c * d * p),
              (this._y = c * d * h + u * l * p),
              (this._z = c * l * p - u * d * h),
              (this._w = c * l * h - u * d * p))
            : 'XZY' === o &&
              ((this._x = u * l * h - c * d * p),
              (this._y = c * d * h - u * l * p),
              (this._z = c * l * p + u * d * h),
              (this._w = c * l * h + u * d * p)),
          !1 !== e && this._onChangeCallback(),
          this
        );
      },
      setFromAxisAngle: function (t, e) {
        var n = e / 2,
          i = Math.sin(n);
        return (
          (this._x = t.x * i),
          (this._y = t.y * i),
          (this._z = t.z * i),
          (this._w = Math.cos(n)),
          this._onChangeCallback(),
          this
        );
      },
      setFromRotationMatrix: function (t) {
        var e,
          n = t.elements,
          i = n[0],
          r = n[4],
          o = n[8],
          s = n[1],
          a = n[5],
          c = n[9],
          l = n[2],
          h = n[6],
          u = n[10],
          d = i + a + u;
        return (
          d > 0
            ? ((e = 0.5 / Math.sqrt(d + 1)),
              (this._w = 0.25 / e),
              (this._x = (h - c) * e),
              (this._y = (o - l) * e),
              (this._z = (s - r) * e))
            : i > a && i > u
            ? ((e = 2 * Math.sqrt(1 + i - a - u)),
              (this._w = (h - c) / e),
              (this._x = 0.25 * e),
              (this._y = (r + s) / e),
              (this._z = (o + l) / e))
            : a > u
            ? ((e = 2 * Math.sqrt(1 + a - i - u)),
              (this._w = (o - l) / e),
              (this._x = (r + s) / e),
              (this._y = 0.25 * e),
              (this._z = (c + h) / e))
            : ((e = 2 * Math.sqrt(1 + u - i - a)),
              (this._w = (s - r) / e),
              (this._x = (o + l) / e),
              (this._y = (c + h) / e),
              (this._z = 0.25 * e)),
          this._onChangeCallback(),
          this
        );
      },
      setFromUnitVectors: function (t, e) {
        var n = t.dot(e) + 1;
        return (
          n < 1e-6
            ? ((n = 0),
              Math.abs(t.x) > Math.abs(t.z)
                ? ((this._x = -t.y),
                  (this._y = t.x),
                  (this._z = 0),
                  (this._w = n))
                : ((this._x = 0),
                  (this._y = -t.z),
                  (this._z = t.y),
                  (this._w = n)))
            : ((this._x = t.y * e.z - t.z * e.y),
              (this._y = t.z * e.x - t.x * e.z),
              (this._z = t.x * e.y - t.y * e.x),
              (this._w = n)),
          this.normalize()
        );
      },
      angleTo: function (t) {
        return 2 * Math.acos(Math.abs(k.clamp(this.dot(t), -1, 1)));
      },
      rotateTowards: function (t, e) {
        var n = this.angleTo(t);
        if (0 === n) return this;
        var i = Math.min(1, e / n);
        return this.slerp(t, i), this;
      },
      inverse: function () {
        return this.conjugate();
      },
      conjugate: function () {
        return (
          (this._x *= -1),
          (this._y *= -1),
          (this._z *= -1),
          this._onChangeCallback(),
          this
        );
      },
      dot: function (t) {
        return (
          this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
        );
      },
      lengthSq: function () {
        return (
          this._x * this._x +
          this._y * this._y +
          this._z * this._z +
          this._w * this._w
        );
      },
      length: function () {
        return Math.sqrt(
          this._x * this._x +
            this._y * this._y +
            this._z * this._z +
            this._w * this._w,
        );
      },
      normalize: function () {
        var t = this.length();
        return (
          0 === t
            ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
            : ((t = 1 / t),
              (this._x = this._x * t),
              (this._y = this._y * t),
              (this._z = this._z * t),
              (this._w = this._w * t)),
          this._onChangeCallback(),
          this
        );
      },
      multiply: function (t, e) {
        return void 0 !== e
          ? (console.warn(
              'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.',
            ),
            this.multiplyQuaternions(t, e))
          : this.multiplyQuaternions(this, t);
      },
      premultiply: function (t) {
        return this.multiplyQuaternions(t, this);
      },
      multiplyQuaternions: function (t, e) {
        var n = t._x,
          i = t._y,
          r = t._z,
          o = t._w,
          s = e._x,
          a = e._y,
          c = e._z,
          l = e._w;
        return (
          (this._x = n * l + o * s + i * c - r * a),
          (this._y = i * l + o * a + r * s - n * c),
          (this._z = r * l + o * c + n * a - i * s),
          (this._w = o * l - n * s - i * a - r * c),
          this._onChangeCallback(),
          this
        );
      },
      slerp: function (t, e) {
        if (0 === e) return this;
        if (1 === e) return this.copy(t);
        var n = this._x,
          i = this._y,
          r = this._z,
          o = this._w,
          s = o * t._w + n * t._x + i * t._y + r * t._z;
        if (
          (s < 0
            ? ((this._w = -t._w),
              (this._x = -t._x),
              (this._y = -t._y),
              (this._z = -t._z),
              (s = -s))
            : this.copy(t),
          s >= 1)
        )
          return (
            (this._w = o), (this._x = n), (this._y = i), (this._z = r), this
          );
        var a = 1 - s * s;
        if (a <= Number.EPSILON) {
          var c = 1 - e;
          return (
            (this._w = c * o + e * this._w),
            (this._x = c * n + e * this._x),
            (this._y = c * i + e * this._y),
            (this._z = c * r + e * this._z),
            this.normalize(),
            this._onChangeCallback(),
            this
          );
        }
        var l = Math.sqrt(a),
          h = Math.atan2(l, s),
          u = Math.sin((1 - e) * h) / l,
          d = Math.sin(e * h) / l;
        return (
          (this._w = o * u + this._w * d),
          (this._x = n * u + this._x * d),
          (this._y = i * u + this._y * d),
          (this._z = r * u + this._z * d),
          this._onChangeCallback(),
          this
        );
      },
      equals: function (t) {
        return (
          t._x === this._x &&
          t._y === this._y &&
          t._z === this._z &&
          t._w === this._w
        );
      },
      fromArray: function (t, e) {
        return (
          void 0 === e && (e = 0),
          (this._x = t[e]),
          (this._y = t[e + 1]),
          (this._z = t[e + 2]),
          (this._w = t[e + 3]),
          this._onChangeCallback(),
          this
        );
      },
      toArray: function (t, e) {
        return (
          void 0 === t && (t = []),
          void 0 === e && (e = 0),
          (t[e] = this._x),
          (t[e + 1] = this._y),
          (t[e + 2] = this._z),
          (t[e + 3] = this._w),
          t
        );
      },
      fromBufferAttribute: function (t, e) {
        return (
          (this._x = t.getX(e)),
          (this._y = t.getY(e)),
          (this._z = t.getZ(e)),
          (this._w = t.getW(e)),
          this
        );
      },
      _onChange: function (t) {
        return (this._onChangeCallback = t), this;
      },
      _onChangeCallback: function () {},
    });
  var q = new J(),
    Q = new Y();
  function J(t, e, n) {
    (this.x = t || 0), (this.y = e || 0), (this.z = n || 0);
  }
  Object.assign(J.prototype, {
    isVector3: !0,
    set: function (t, e, n) {
      return (this.x = t), (this.y = e), (this.z = n), this;
    },
    setScalar: function (t) {
      return (this.x = t), (this.y = t), (this.z = t), this;
    },
    setX: function (t) {
      return (this.x = t), this;
    },
    setY: function (t) {
      return (this.y = t), this;
    },
    setZ: function (t) {
      return (this.z = t), this;
    },
    setComponent: function (t, e) {
      switch (t) {
        case 0:
          this.x = e;
          break;
        case 1:
          this.y = e;
          break;
        case 2:
          this.z = e;
          break;
        default:
          throw new Error('index is out of range: ' + t);
      }
      return this;
    },
    getComponent: function (t) {
      switch (t) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        default:
          throw new Error('index is out of range: ' + t);
      }
    },
    clone: function () {
      return new this.constructor(this.x, this.y, this.z);
    },
    copy: function (t) {
      return (this.x = t.x), (this.y = t.y), (this.z = t.z), this;
    },
    add: function (t, e) {
      return void 0 !== e
        ? (console.warn(
            'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.',
          ),
          this.addVectors(t, e))
        : ((this.x += t.x), (this.y += t.y), (this.z += t.z), this);
    },
    addScalar: function (t) {
      return (this.x += t), (this.y += t), (this.z += t), this;
    },
    addVectors: function (t, e) {
      return (
        (this.x = t.x + e.x), (this.y = t.y + e.y), (this.z = t.z + e.z), this
      );
    },
    addScaledVector: function (t, e) {
      return (
        (this.x += t.x * e), (this.y += t.y * e), (this.z += t.z * e), this
      );
    },
    sub: function (t, e) {
      return void 0 !== e
        ? (console.warn(
            'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.',
          ),
          this.subVectors(t, e))
        : ((this.x -= t.x), (this.y -= t.y), (this.z -= t.z), this);
    },
    subScalar: function (t) {
      return (this.x -= t), (this.y -= t), (this.z -= t), this;
    },
    subVectors: function (t, e) {
      return (
        (this.x = t.x - e.x), (this.y = t.y - e.y), (this.z = t.z - e.z), this
      );
    },
    multiply: function (t, e) {
      return void 0 !== e
        ? (console.warn(
            'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.',
          ),
          this.multiplyVectors(t, e))
        : ((this.x *= t.x), (this.y *= t.y), (this.z *= t.z), this);
    },
    multiplyScalar: function (t) {
      return (this.x *= t), (this.y *= t), (this.z *= t), this;
    },
    multiplyVectors: function (t, e) {
      return (
        (this.x = t.x * e.x), (this.y = t.y * e.y), (this.z = t.z * e.z), this
      );
    },
    applyEuler: function (t) {
      return (
        (t && t.isEuler) ||
          console.error(
            'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.',
          ),
        this.applyQuaternion(Q.setFromEuler(t))
      );
    },
    applyAxisAngle: function (t, e) {
      return this.applyQuaternion(Q.setFromAxisAngle(t, e));
    },
    applyMatrix3: function (t) {
      var e = this.x,
        n = this.y,
        i = this.z,
        r = t.elements;
      return (
        (this.x = r[0] * e + r[3] * n + r[6] * i),
        (this.y = r[1] * e + r[4] * n + r[7] * i),
        (this.z = r[2] * e + r[5] * n + r[8] * i),
        this
      );
    },
    applyNormalMatrix: function (t) {
      return this.applyMatrix3(t).normalize();
    },
    applyMatrix4: function (t) {
      var e = this.x,
        n = this.y,
        i = this.z,
        r = t.elements,
        o = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
      return (
        (this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * o),
        (this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * o),
        (this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * o),
        this
      );
    },
    applyQuaternion: function (t) {
      var e = this.x,
        n = this.y,
        i = this.z,
        r = t.x,
        o = t.y,
        s = t.z,
        a = t.w,
        c = a * e + o * i - s * n,
        l = a * n + s * e - r * i,
        h = a * i + r * n - o * e,
        u = -r * e - o * n - s * i;
      return (
        (this.x = c * a + u * -r + l * -s - h * -o),
        (this.y = l * a + u * -o + h * -r - c * -s),
        (this.z = h * a + u * -s + c * -o - l * -r),
        this
      );
    },
    project: function (t) {
      return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(
        t.projectionMatrix,
      );
    },
    unproject: function (t) {
      return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(
        t.matrixWorld,
      );
    },
    transformDirection: function (t) {
      var e = this.x,
        n = this.y,
        i = this.z,
        r = t.elements;
      return (
        (this.x = r[0] * e + r[4] * n + r[8] * i),
        (this.y = r[1] * e + r[5] * n + r[9] * i),
        (this.z = r[2] * e + r[6] * n + r[10] * i),
        this.normalize()
      );
    },
    divide: function (t) {
      return (this.x /= t.x), (this.y /= t.y), (this.z /= t.z), this;
    },
    divideScalar: function (t) {
      return this.multiplyScalar(1 / t);
    },
    min: function (t) {
      return (
        (this.x = Math.min(this.x, t.x)),
        (this.y = Math.min(this.y, t.y)),
        (this.z = Math.min(this.z, t.z)),
        this
      );
    },
    max: function (t) {
      return (
        (this.x = Math.max(this.x, t.x)),
        (this.y = Math.max(this.y, t.y)),
        (this.z = Math.max(this.z, t.z)),
        this
      );
    },
    clamp: function (t, e) {
      return (
        (this.x = Math.max(t.x, Math.min(e.x, this.x))),
        (this.y = Math.max(t.y, Math.min(e.y, this.y))),
        (this.z = Math.max(t.z, Math.min(e.z, this.z))),
        this
      );
    },
    clampScalar: function (t, e) {
      return (
        (this.x = Math.max(t, Math.min(e, this.x))),
        (this.y = Math.max(t, Math.min(e, this.y))),
        (this.z = Math.max(t, Math.min(e, this.z))),
        this
      );
    },
    clampLength: function (t, e) {
      var n = this.length();
      return this.divideScalar(n || 1).multiplyScalar(
        Math.max(t, Math.min(e, n)),
      );
    },
    floor: function () {
      return (
        (this.x = Math.floor(this.x)),
        (this.y = Math.floor(this.y)),
        (this.z = Math.floor(this.z)),
        this
      );
    },
    ceil: function () {
      return (
        (this.x = Math.ceil(this.x)),
        (this.y = Math.ceil(this.y)),
        (this.z = Math.ceil(this.z)),
        this
      );
    },
    round: function () {
      return (
        (this.x = Math.round(this.x)),
        (this.y = Math.round(this.y)),
        (this.z = Math.round(this.z)),
        this
      );
    },
    roundToZero: function () {
      return (
        (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
        (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
        (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
        this
      );
    },
    negate: function () {
      return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
    },
    dot: function (t) {
      return this.x * t.x + this.y * t.y + this.z * t.z;
    },
    lengthSq: function () {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    },
    length: function () {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    },
    manhattanLength: function () {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    },
    normalize: function () {
      return this.divideScalar(this.length() || 1);
    },
    setLength: function (t) {
      return this.normalize().multiplyScalar(t);
    },
    lerp: function (t, e) {
      return (
        (this.x += (t.x - this.x) * e),
        (this.y += (t.y - this.y) * e),
        (this.z += (t.z - this.z) * e),
        this
      );
    },
    lerpVectors: function (t, e, n) {
      return this.subVectors(e, t).multiplyScalar(n).add(t);
    },
    cross: function (t, e) {
      return void 0 !== e
        ? (console.warn(
            'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.',
          ),
          this.crossVectors(t, e))
        : this.crossVectors(this, t);
    },
    crossVectors: function (t, e) {
      var n = t.x,
        i = t.y,
        r = t.z,
        o = e.x,
        s = e.y,
        a = e.z;
      return (
        (this.x = i * a - r * s),
        (this.y = r * o - n * a),
        (this.z = n * s - i * o),
        this
      );
    },
    projectOnVector: function (t) {
      var e = t.lengthSq();
      if (0 === e) return this.set(0, 0, 0);
      var n = t.dot(this) / e;
      return this.copy(t).multiplyScalar(n);
    },
    projectOnPlane: function (t) {
      return q.copy(this).projectOnVector(t), this.sub(q);
    },
    reflect: function (t) {
      return this.sub(q.copy(t).multiplyScalar(2 * this.dot(t)));
    },
    angleTo: function (t) {
      var e = Math.sqrt(this.lengthSq() * t.lengthSq());
      if (0 === e) return Math.PI / 2;
      var n = this.dot(t) / e;
      return Math.acos(k.clamp(n, -1, 1));
    },
    distanceTo: function (t) {
      return Math.sqrt(this.distanceToSquared(t));
    },
    distanceToSquared: function (t) {
      var e = this.x - t.x,
        n = this.y - t.y,
        i = this.z - t.z;
      return e * e + n * n + i * i;
    },
    manhattanDistanceTo: function (t) {
      return (
        Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
      );
    },
    setFromSpherical: function (t) {
      return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
    },
    setFromSphericalCoords: function (t, e, n) {
      var i = Math.sin(e) * t;
      return (
        (this.x = i * Math.sin(n)),
        (this.y = Math.cos(e) * t),
        (this.z = i * Math.cos(n)),
        this
      );
    },
    setFromCylindrical: function (t) {
      return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
    },
    setFromCylindricalCoords: function (t, e, n) {
      return (
        (this.x = t * Math.sin(e)),
        (this.y = n),
        (this.z = t * Math.cos(e)),
        this
      );
    },
    setFromMatrixPosition: function (t) {
      var e = t.elements;
      return (this.x = e[12]), (this.y = e[13]), (this.z = e[14]), this;
    },
    setFromMatrixScale: function (t) {
      var e = this.setFromMatrixColumn(t, 0).length(),
        n = this.setFromMatrixColumn(t, 1).length(),
        i = this.setFromMatrixColumn(t, 2).length();
      return (this.x = e), (this.y = n), (this.z = i), this;
    },
    setFromMatrixColumn: function (t, e) {
      return this.fromArray(t.elements, 4 * e);
    },
    setFromMatrix3Column: function (t, e) {
      return this.fromArray(t.elements, 3 * e);
    },
    equals: function (t) {
      return t.x === this.x && t.y === this.y && t.z === this.z;
    },
    fromArray: function (t, e) {
      return (
        void 0 === e && (e = 0),
        (this.x = t[e]),
        (this.y = t[e + 1]),
        (this.z = t[e + 2]),
        this
      );
    },
    toArray: function (t, e) {
      return (
        void 0 === t && (t = []),
        void 0 === e && (e = 0),
        (t[e] = this.x),
        (t[e + 1] = this.y),
        (t[e + 2] = this.z),
        t
      );
    },
    fromBufferAttribute: function (t, e, n) {
      return (
        void 0 !== n &&
          console.warn(
            'THREE.Vector3: offset has been removed from .fromBufferAttribute().',
          ),
        (this.x = t.getX(e)),
        (this.y = t.getY(e)),
        (this.z = t.getZ(e)),
        this
      );
    },
  });
  var $ = new J(),
    K = new ot(),
    tt = new J(0, 0, 0),
    et = new J(1, 1, 1),
    nt = new J(),
    it = new J(),
    rt = new J();
  function ot() {
    (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
      arguments.length > 0 &&
        console.error(
          'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.',
        );
  }
  Object.assign(ot.prototype, {
    isMatrix4: !0,
    set: function (t, e, n, i, r, o, s, a, c, l, h, u, d, p, f, m) {
      var b = this.elements;
      return (
        (b[0] = t),
        (b[4] = e),
        (b[8] = n),
        (b[12] = i),
        (b[1] = r),
        (b[5] = o),
        (b[9] = s),
        (b[13] = a),
        (b[2] = c),
        (b[6] = l),
        (b[10] = h),
        (b[14] = u),
        (b[3] = d),
        (b[7] = p),
        (b[11] = f),
        (b[15] = m),
        this
      );
    },
    identity: function () {
      return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    },
    clone: function () {
      return new ot().fromArray(this.elements);
    },
    copy: function (t) {
      var e = this.elements,
        n = t.elements;
      return (
        (e[0] = n[0]),
        (e[1] = n[1]),
        (e[2] = n[2]),
        (e[3] = n[3]),
        (e[4] = n[4]),
        (e[5] = n[5]),
        (e[6] = n[6]),
        (e[7] = n[7]),
        (e[8] = n[8]),
        (e[9] = n[9]),
        (e[10] = n[10]),
        (e[11] = n[11]),
        (e[12] = n[12]),
        (e[13] = n[13]),
        (e[14] = n[14]),
        (e[15] = n[15]),
        this
      );
    },
    copyPosition: function (t) {
      var e = this.elements,
        n = t.elements;
      return (e[12] = n[12]), (e[13] = n[13]), (e[14] = n[14]), this;
    },
    extractBasis: function (t, e, n) {
      return (
        t.setFromMatrixColumn(this, 0),
        e.setFromMatrixColumn(this, 1),
        n.setFromMatrixColumn(this, 2),
        this
      );
    },
    makeBasis: function (t, e, n) {
      return (
        this.set(
          t.x,
          e.x,
          n.x,
          0,
          t.y,
          e.y,
          n.y,
          0,
          t.z,
          e.z,
          n.z,
          0,
          0,
          0,
          0,
          1,
        ),
        this
      );
    },
    extractRotation: function (t) {
      var e = this.elements,
        n = t.elements,
        i = 1 / $.setFromMatrixColumn(t, 0).length(),
        r = 1 / $.setFromMatrixColumn(t, 1).length(),
        o = 1 / $.setFromMatrixColumn(t, 2).length();
      return (
        (e[0] = n[0] * i),
        (e[1] = n[1] * i),
        (e[2] = n[2] * i),
        (e[3] = 0),
        (e[4] = n[4] * r),
        (e[5] = n[5] * r),
        (e[6] = n[6] * r),
        (e[7] = 0),
        (e[8] = n[8] * o),
        (e[9] = n[9] * o),
        (e[10] = n[10] * o),
        (e[11] = 0),
        (e[12] = 0),
        (e[13] = 0),
        (e[14] = 0),
        (e[15] = 1),
        this
      );
    },
    makeRotationFromEuler: function (t) {
      (t && t.isEuler) ||
        console.error(
          'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.',
        );
      var e = this.elements,
        n = t.x,
        i = t.y,
        r = t.z,
        o = Math.cos(n),
        s = Math.sin(n),
        a = Math.cos(i),
        c = Math.sin(i),
        l = Math.cos(r),
        h = Math.sin(r);
      if ('XYZ' === t.order) {
        var u = o * l,
          d = o * h,
          p = s * l,
          f = s * h;
        (e[0] = a * l),
          (e[4] = -a * h),
          (e[8] = c),
          (e[1] = d + p * c),
          (e[5] = u - f * c),
          (e[9] = -s * a),
          (e[2] = f - u * c),
          (e[6] = p + d * c),
          (e[10] = o * a);
      } else if ('YXZ' === t.order) {
        var m = a * l,
          b = a * h,
          g = c * l,
          y = c * h;
        (e[0] = m + y * s),
          (e[4] = g * s - b),
          (e[8] = o * c),
          (e[1] = o * h),
          (e[5] = o * l),
          (e[9] = -s),
          (e[2] = b * s - g),
          (e[6] = y + m * s),
          (e[10] = o * a);
      } else if ('ZXY' === t.order) {
        (m = a * l), (b = a * h), (g = c * l), (y = c * h);
        (e[0] = m - y * s),
          (e[4] = -o * h),
          (e[8] = g + b * s),
          (e[1] = b + g * s),
          (e[5] = o * l),
          (e[9] = y - m * s),
          (e[2] = -o * c),
          (e[6] = s),
          (e[10] = o * a);
      } else if ('ZYX' === t.order) {
        (u = o * l), (d = o * h), (p = s * l), (f = s * h);
        (e[0] = a * l),
          (e[4] = p * c - d),
          (e[8] = u * c + f),
          (e[1] = a * h),
          (e[5] = f * c + u),
          (e[9] = d * c - p),
          (e[2] = -c),
          (e[6] = s * a),
          (e[10] = o * a);
      } else if ('YZX' === t.order) {
        var v = o * a,
          _ = o * c,
          x = s * a,
          w = s * c;
        (e[0] = a * l),
          (e[4] = w - v * h),
          (e[8] = x * h + _),
          (e[1] = h),
          (e[5] = o * l),
          (e[9] = -s * l),
          (e[2] = -c * l),
          (e[6] = _ * h + x),
          (e[10] = v - w * h);
      } else if ('XZY' === t.order) {
        (v = o * a), (_ = o * c), (x = s * a), (w = s * c);
        (e[0] = a * l),
          (e[4] = -h),
          (e[8] = c * l),
          (e[1] = v * h + w),
          (e[5] = o * l),
          (e[9] = _ * h - x),
          (e[2] = x * h - _),
          (e[6] = s * l),
          (e[10] = w * h + v);
      }
      return (
        (e[3] = 0),
        (e[7] = 0),
        (e[11] = 0),
        (e[12] = 0),
        (e[13] = 0),
        (e[14] = 0),
        (e[15] = 1),
        this
      );
    },
    makeRotationFromQuaternion: function (t) {
      return this.compose(tt, t, et);
    },
    lookAt: function (t, e, n) {
      var i = this.elements;
      return (
        rt.subVectors(t, e),
        0 === rt.lengthSq() && (rt.z = 1),
        rt.normalize(),
        nt.crossVectors(n, rt),
        0 === nt.lengthSq() &&
          (1 === Math.abs(n.z) ? (rt.x += 1e-4) : (rt.z += 1e-4),
          rt.normalize(),
          nt.crossVectors(n, rt)),
        nt.normalize(),
        it.crossVectors(rt, nt),
        (i[0] = nt.x),
        (i[4] = it.x),
        (i[8] = rt.x),
        (i[1] = nt.y),
        (i[5] = it.y),
        (i[9] = rt.y),
        (i[2] = nt.z),
        (i[6] = it.z),
        (i[10] = rt.z),
        this
      );
    },
    multiply: function (t, e) {
      return void 0 !== e
        ? (console.warn(
            'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.',
          ),
          this.multiplyMatrices(t, e))
        : this.multiplyMatrices(this, t);
    },
    premultiply: function (t) {
      return this.multiplyMatrices(t, this);
    },
    multiplyMatrices: function (t, e) {
      var n = t.elements,
        i = e.elements,
        r = this.elements,
        o = n[0],
        s = n[4],
        a = n[8],
        c = n[12],
        l = n[1],
        h = n[5],
        u = n[9],
        d = n[13],
        p = n[2],
        f = n[6],
        m = n[10],
        b = n[14],
        g = n[3],
        y = n[7],
        v = n[11],
        _ = n[15],
        x = i[0],
        w = i[4],
        A = i[8],
        M = i[12],
        S = i[1],
        I = i[5],
        E = i[9],
        D = i[13],
        C = i[2],
        T = i[6],
        L = i[10],
        R = i[14],
        F = i[3],
        P = i[7],
        B = i[11],
        O = i[15];
      return (
        (r[0] = o * x + s * S + a * C + c * F),
        (r[4] = o * w + s * I + a * T + c * P),
        (r[8] = o * A + s * E + a * L + c * B),
        (r[12] = o * M + s * D + a * R + c * O),
        (r[1] = l * x + h * S + u * C + d * F),
        (r[5] = l * w + h * I + u * T + d * P),
        (r[9] = l * A + h * E + u * L + d * B),
        (r[13] = l * M + h * D + u * R + d * O),
        (r[2] = p * x + f * S + m * C + b * F),
        (r[6] = p * w + f * I + m * T + b * P),
        (r[10] = p * A + f * E + m * L + b * B),
        (r[14] = p * M + f * D + m * R + b * O),
        (r[3] = g * x + y * S + v * C + _ * F),
        (r[7] = g * w + y * I + v * T + _ * P),
        (r[11] = g * A + y * E + v * L + _ * B),
        (r[15] = g * M + y * D + v * R + _ * O),
        this
      );
    },
    multiplyScalar: function (t) {
      var e = this.elements;
      return (
        (e[0] *= t),
        (e[4] *= t),
        (e[8] *= t),
        (e[12] *= t),
        (e[1] *= t),
        (e[5] *= t),
        (e[9] *= t),
        (e[13] *= t),
        (e[2] *= t),
        (e[6] *= t),
        (e[10] *= t),
        (e[14] *= t),
        (e[3] *= t),
        (e[7] *= t),
        (e[11] *= t),
        (e[15] *= t),
        this
      );
    },
    determinant: function () {
      var t = this.elements,
        e = t[0],
        n = t[4],
        i = t[8],
        r = t[12],
        o = t[1],
        s = t[5],
        a = t[9],
        c = t[13],
        l = t[2],
        h = t[6],
        u = t[10],
        d = t[14];
      return (
        t[3] *
          (+r * a * h -
            i * c * h -
            r * s * u +
            n * c * u +
            i * s * d -
            n * a * d) +
        t[7] *
          (+e * a * d -
            e * c * u +
            r * o * u -
            i * o * d +
            i * c * l -
            r * a * l) +
        t[11] *
          (+e * c * h -
            e * s * d -
            r * o * h +
            n * o * d +
            r * s * l -
            n * c * l) +
        t[15] *
          (-i * s * l -
            e * a * h +
            e * s * u +
            i * o * h -
            n * o * u +
            n * a * l)
      );
    },
    transpose: function () {
      var t,
        e = this.elements;
      return (
        (t = e[1]),
        (e[1] = e[4]),
        (e[4] = t),
        (t = e[2]),
        (e[2] = e[8]),
        (e[8] = t),
        (t = e[6]),
        (e[6] = e[9]),
        (e[9] = t),
        (t = e[3]),
        (e[3] = e[12]),
        (e[12] = t),
        (t = e[7]),
        (e[7] = e[13]),
        (e[13] = t),
        (t = e[11]),
        (e[11] = e[14]),
        (e[14] = t),
        this
      );
    },
    setPosition: function (t, e, n) {
      var i = this.elements;
      return (
        t.isVector3
          ? ((i[12] = t.x), (i[13] = t.y), (i[14] = t.z))
          : ((i[12] = t), (i[13] = e), (i[14] = n)),
        this
      );
    },
    getInverse: function (t, e) {
      void 0 !== e &&
        console.warn(
          'THREE.Matrix4: .getInverse() can no longer be configured to throw on degenerate.',
        );
      var n = this.elements,
        i = t.elements,
        r = i[0],
        o = i[1],
        s = i[2],
        a = i[3],
        c = i[4],
        l = i[5],
        h = i[6],
        u = i[7],
        d = i[8],
        p = i[9],
        f = i[10],
        m = i[11],
        b = i[12],
        g = i[13],
        y = i[14],
        v = i[15],
        _ =
          p * y * u - g * f * u + g * h * m - l * y * m - p * h * v + l * f * v,
        x =
          b * f * u - d * y * u - b * h * m + c * y * m + d * h * v - c * f * v,
        w =
          d * g * u - b * p * u + b * l * m - c * g * m - d * l * v + c * p * v,
        A =
          b * p * h - d * g * h - b * l * f + c * g * f + d * l * y - c * p * y,
        M = r * _ + o * x + s * w + a * A;
      if (0 === M)
        return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      var S = 1 / M;
      return (
        (n[0] = _ * S),
        (n[1] =
          (g * f * a -
            p * y * a -
            g * s * m +
            o * y * m +
            p * s * v -
            o * f * v) *
          S),
        (n[2] =
          (l * y * a -
            g * h * a +
            g * s * u -
            o * y * u -
            l * s * v +
            o * h * v) *
          S),
        (n[3] =
          (p * h * a -
            l * f * a -
            p * s * u +
            o * f * u +
            l * s * m -
            o * h * m) *
          S),
        (n[4] = x * S),
        (n[5] =
          (d * y * a -
            b * f * a +
            b * s * m -
            r * y * m -
            d * s * v +
            r * f * v) *
          S),
        (n[6] =
          (b * h * a -
            c * y * a -
            b * s * u +
            r * y * u +
            c * s * v -
            r * h * v) *
          S),
        (n[7] =
          (c * f * a -
            d * h * a +
            d * s * u -
            r * f * u -
            c * s * m +
            r * h * m) *
          S),
        (n[8] = w * S),
        (n[9] =
          (b * p * a -
            d * g * a -
            b * o * m +
            r * g * m +
            d * o * v -
            r * p * v) *
          S),
        (n[10] =
          (c * g * a -
            b * l * a +
            b * o * u -
            r * g * u -
            c * o * v +
            r * l * v) *
          S),
        (n[11] =
          (d * l * a -
            c * p * a -
            d * o * u +
            r * p * u +
            c * o * m -
            r * l * m) *
          S),
        (n[12] = A * S),
        (n[13] =
          (d * g * s -
            b * p * s +
            b * o * f -
            r * g * f -
            d * o * y +
            r * p * y) *
          S),
        (n[14] =
          (b * l * s -
            c * g * s -
            b * o * h +
            r * g * h +
            c * o * y -
            r * l * y) *
          S),
        (n[15] =
          (c * p * s -
            d * l * s +
            d * o * h -
            r * p * h -
            c * o * f +
            r * l * f) *
          S),
        this
      );
    },
    scale: function (t) {
      var e = this.elements,
        n = t.x,
        i = t.y,
        r = t.z;
      return (
        (e[0] *= n),
        (e[4] *= i),
        (e[8] *= r),
        (e[1] *= n),
        (e[5] *= i),
        (e[9] *= r),
        (e[2] *= n),
        (e[6] *= i),
        (e[10] *= r),
        (e[3] *= n),
        (e[7] *= i),
        (e[11] *= r),
        this
      );
    },
    getMaxScaleOnAxis: function () {
      var t = this.elements,
        e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
        n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
        i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
      return Math.sqrt(Math.max(e, n, i));
    },
    makeTranslation: function (t, e, n) {
      return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this;
    },
    makeRotationX: function (t) {
      var e = Math.cos(t),
        n = Math.sin(t);
      return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this;
    },
    makeRotationY: function (t) {
      var e = Math.cos(t),
        n = Math.sin(t);
      return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this;
    },
    makeRotationZ: function (t) {
      var e = Math.cos(t),
        n = Math.sin(t);
      return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    },
    makeRotationAxis: function (t, e) {
      var n = Math.cos(e),
        i = Math.sin(e),
        r = 1 - n,
        o = t.x,
        s = t.y,
        a = t.z,
        c = r * o,
        l = r * s;
      return (
        this.set(
          c * o + n,
          c * s - i * a,
          c * a + i * s,
          0,
          c * s + i * a,
          l * s + n,
          l * a - i * o,
          0,
          c * a - i * s,
          l * a + i * o,
          r * a * a + n,
          0,
          0,
          0,
          0,
          1,
        ),
        this
      );
    },
    makeScale: function (t, e, n) {
      return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
    },
    makeShear: function (t, e, n) {
      return this.set(1, e, n, 0, t, 1, n, 0, t, e, 1, 0, 0, 0, 0, 1), this;
    },
    compose: function (t, e, n) {
      var i = this.elements,
        r = e._x,
        o = e._y,
        s = e._z,
        a = e._w,
        c = r + r,
        l = o + o,
        h = s + s,
        u = r * c,
        d = r * l,
        p = r * h,
        f = o * l,
        m = o * h,
        b = s * h,
        g = a * c,
        y = a * l,
        v = a * h,
        _ = n.x,
        x = n.y,
        w = n.z;
      return (
        (i[0] = (1 - (f + b)) * _),
        (i[1] = (d + v) * _),
        (i[2] = (p - y) * _),
        (i[3] = 0),
        (i[4] = (d - v) * x),
        (i[5] = (1 - (u + b)) * x),
        (i[6] = (m + g) * x),
        (i[7] = 0),
        (i[8] = (p + y) * w),
        (i[9] = (m - g) * w),
        (i[10] = (1 - (u + f)) * w),
        (i[11] = 0),
        (i[12] = t.x),
        (i[13] = t.y),
        (i[14] = t.z),
        (i[15] = 1),
        this
      );
    },
    decompose: function (t, e, n) {
      var i = this.elements,
        r = $.set(i[0], i[1], i[2]).length(),
        o = $.set(i[4], i[5], i[6]).length(),
        s = $.set(i[8], i[9], i[10]).length();
      this.determinant() < 0 && (r = -r),
        (t.x = i[12]),
        (t.y = i[13]),
        (t.z = i[14]),
        K.copy(this);
      var a = 1 / r,
        c = 1 / o,
        l = 1 / s;
      return (
        (K.elements[0] *= a),
        (K.elements[1] *= a),
        (K.elements[2] *= a),
        (K.elements[4] *= c),
        (K.elements[5] *= c),
        (K.elements[6] *= c),
        (K.elements[8] *= l),
        (K.elements[9] *= l),
        (K.elements[10] *= l),
        e.setFromRotationMatrix(K),
        (n.x = r),
        (n.y = o),
        (n.z = s),
        this
      );
    },
    makePerspective: function (t, e, n, i, r, o) {
      void 0 === o &&
        console.warn(
          'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.',
        );
      var s = this.elements,
        a = (2 * r) / (e - t),
        c = (2 * r) / (n - i),
        l = (e + t) / (e - t),
        h = (n + i) / (n - i),
        u = -(o + r) / (o - r),
        d = (-2 * o * r) / (o - r);
      return (
        (s[0] = a),
        (s[4] = 0),
        (s[8] = l),
        (s[12] = 0),
        (s[1] = 0),
        (s[5] = c),
        (s[9] = h),
        (s[13] = 0),
        (s[2] = 0),
        (s[6] = 0),
        (s[10] = u),
        (s[14] = d),
        (s[3] = 0),
        (s[7] = 0),
        (s[11] = -1),
        (s[15] = 0),
        this
      );
    },
    makeOrthographic: function (t, e, n, i, r, o) {
      var s = this.elements,
        a = 1 / (e - t),
        c = 1 / (n - i),
        l = 1 / (o - r),
        h = (e + t) * a,
        u = (n + i) * c,
        d = (o + r) * l;
      return (
        (s[0] = 2 * a),
        (s[4] = 0),
        (s[8] = 0),
        (s[12] = -h),
        (s[1] = 0),
        (s[5] = 2 * c),
        (s[9] = 0),
        (s[13] = -u),
        (s[2] = 0),
        (s[6] = 0),
        (s[10] = -2 * l),
        (s[14] = -d),
        (s[3] = 0),
        (s[7] = 0),
        (s[11] = 0),
        (s[15] = 1),
        this
      );
    },
    equals: function (t) {
      for (var e = this.elements, n = t.elements, i = 0; i < 16; i++)
        if (e[i] !== n[i]) return !1;
      return !0;
    },
    fromArray: function (t, e) {
      void 0 === e && (e = 0);
      for (var n = 0; n < 16; n++) this.elements[n] = t[n + e];
      return this;
    },
    toArray: function (t, e) {
      void 0 === t && (t = []), void 0 === e && (e = 0);
      var n = this.elements;
      return (
        (t[e] = n[0]),
        (t[e + 1] = n[1]),
        (t[e + 2] = n[2]),
        (t[e + 3] = n[3]),
        (t[e + 4] = n[4]),
        (t[e + 5] = n[5]),
        (t[e + 6] = n[6]),
        (t[e + 7] = n[7]),
        (t[e + 8] = n[8]),
        (t[e + 9] = n[9]),
        (t[e + 10] = n[10]),
        (t[e + 11] = n[11]),
        (t[e + 12] = n[12]),
        (t[e + 13] = n[13]),
        (t[e + 14] = n[14]),
        (t[e + 15] = n[15]),
        t
      );
    },
  });
  var st = new ot(),
    at = new Y();
  function ct(t, e, n, i) {
    (this._x = t || 0),
      (this._y = e || 0),
      (this._z = n || 0),
      (this._order = i || ct.DefaultOrder);
  }
  function lt() {
    this.mask = 1;
  }
  (ct.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX']),
    (ct.DefaultOrder = 'XYZ'),
    Object.defineProperties(ct.prototype, {
      x: {
        get: function () {
          return this._x;
        },
        set: function (t) {
          (this._x = t), this._onChangeCallback();
        },
      },
      y: {
        get: function () {
          return this._y;
        },
        set: function (t) {
          (this._y = t), this._onChangeCallback();
        },
      },
      z: {
        get: function () {
          return this._z;
        },
        set: function (t) {
          (this._z = t), this._onChangeCallback();
        },
      },
      order: {
        get: function () {
          return this._order;
        },
        set: function (t) {
          (this._order = t), this._onChangeCallback();
        },
      },
    }),
    Object.assign(ct.prototype, {
      isEuler: !0,
      set: function (t, e, n, i) {
        return (
          (this._x = t),
          (this._y = e),
          (this._z = n),
          (this._order = i || this._order),
          this._onChangeCallback(),
          this
        );
      },
      clone: function () {
        return new this.constructor(this._x, this._y, this._z, this._order);
      },
      copy: function (t) {
        return (
          (this._x = t._x),
          (this._y = t._y),
          (this._z = t._z),
          (this._order = t._order),
          this._onChangeCallback(),
          this
        );
      },
      setFromRotationMatrix: function (t, e, n) {
        var i = k.clamp,
          r = t.elements,
          o = r[0],
          s = r[4],
          a = r[8],
          c = r[1],
          l = r[5],
          h = r[9],
          u = r[2],
          d = r[6],
          p = r[10];
        return (
          'XYZ' === (e = e || this._order)
            ? ((this._y = Math.asin(i(a, -1, 1))),
              Math.abs(a) < 0.9999999
                ? ((this._x = Math.atan2(-h, p)), (this._z = Math.atan2(-s, o)))
                : ((this._x = Math.atan2(d, l)), (this._z = 0)))
            : 'YXZ' === e
            ? ((this._x = Math.asin(-i(h, -1, 1))),
              Math.abs(h) < 0.9999999
                ? ((this._y = Math.atan2(a, p)), (this._z = Math.atan2(c, l)))
                : ((this._y = Math.atan2(-u, o)), (this._z = 0)))
            : 'ZXY' === e
            ? ((this._x = Math.asin(i(d, -1, 1))),
              Math.abs(d) < 0.9999999
                ? ((this._y = Math.atan2(-u, p)), (this._z = Math.atan2(-s, l)))
                : ((this._y = 0), (this._z = Math.atan2(c, o))))
            : 'ZYX' === e
            ? ((this._y = Math.asin(-i(u, -1, 1))),
              Math.abs(u) < 0.9999999
                ? ((this._x = Math.atan2(d, p)), (this._z = Math.atan2(c, o)))
                : ((this._x = 0), (this._z = Math.atan2(-s, l))))
            : 'YZX' === e
            ? ((this._z = Math.asin(i(c, -1, 1))),
              Math.abs(c) < 0.9999999
                ? ((this._x = Math.atan2(-h, l)), (this._y = Math.atan2(-u, o)))
                : ((this._x = 0), (this._y = Math.atan2(a, p))))
            : 'XZY' === e
            ? ((this._z = Math.asin(-i(s, -1, 1))),
              Math.abs(s) < 0.9999999
                ? ((this._x = Math.atan2(d, l)), (this._y = Math.atan2(a, o)))
                : ((this._x = Math.atan2(-h, p)), (this._y = 0)))
            : console.warn(
                'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' +
                  e,
              ),
          (this._order = e),
          !1 !== n && this._onChangeCallback(),
          this
        );
      },
      setFromQuaternion: function (t, e, n) {
        return (
          st.makeRotationFromQuaternion(t), this.setFromRotationMatrix(st, e, n)
        );
      },
      setFromVector3: function (t, e) {
        return this.set(t.x, t.y, t.z, e || this._order);
      },
      reorder: function (t) {
        return at.setFromEuler(this), this.setFromQuaternion(at, t);
      },
      equals: function (t) {
        return (
          t._x === this._x &&
          t._y === this._y &&
          t._z === this._z &&
          t._order === this._order
        );
      },
      fromArray: function (t) {
        return (
          (this._x = t[0]),
          (this._y = t[1]),
          (this._z = t[2]),
          void 0 !== t[3] && (this._order = t[3]),
          this._onChangeCallback(),
          this
        );
      },
      toArray: function (t, e) {
        return (
          void 0 === t && (t = []),
          void 0 === e && (e = 0),
          (t[e] = this._x),
          (t[e + 1] = this._y),
          (t[e + 2] = this._z),
          (t[e + 3] = this._order),
          t
        );
      },
      toVector3: function (t) {
        return t
          ? t.set(this._x, this._y, this._z)
          : new J(this._x, this._y, this._z);
      },
      _onChange: function (t) {
        return (this._onChangeCallback = t), this;
      },
      _onChangeCallback: function () {},
    }),
    Object.assign(lt.prototype, {
      set: function (t) {
        this.mask = (1 << t) | 0;
      },
      enable: function (t) {
        this.mask |= (1 << t) | 0;
      },
      enableAll: function () {
        this.mask = -1;
      },
      toggle: function (t) {
        this.mask ^= (1 << t) | 0;
      },
      disable: function (t) {
        this.mask &= ~((1 << t) | 0);
      },
      disableAll: function () {
        this.mask = 0;
      },
      test: function (t) {
        return 0 != (this.mask & t.mask);
      },
    });
  var ht = 0,
    ut = new J(),
    dt = new Y(),
    pt = new ot(),
    ft = new J(),
    mt = new J(),
    bt = new J(),
    gt = new Y(),
    yt = new J(1, 0, 0),
    vt = new J(0, 1, 0),
    _t = new J(0, 0, 1),
    xt = { type: 'added' },
    wt = { type: 'removed' };
  function At() {
    Object.defineProperty(this, 'id', { value: ht++ }),
      (this.uuid = k.generateUUID()),
      (this.name = ''),
      (this.type = 'Object3D'),
      (this.parent = null),
      (this.children = []),
      (this.up = At.DefaultUp.clone());
    var t = new J(),
      e = new ct(),
      n = new Y(),
      i = new J(1, 1, 1);
    e._onChange(function () {
      n.setFromEuler(e, !1);
    }),
      n._onChange(function () {
        e.setFromQuaternion(n, void 0, !1);
      }),
      Object.defineProperties(this, {
        position: { configurable: !0, enumerable: !0, value: t },
        rotation: { configurable: !0, enumerable: !0, value: e },
        quaternion: { configurable: !0, enumerable: !0, value: n },
        scale: { configurable: !0, enumerable: !0, value: i },
        modelViewMatrix: { value: new ot() },
        normalMatrix: { value: new G() },
      }),
      (this.matrix = new ot()),
      (this.matrixWorld = new ot()),
      (this.matrixAutoUpdate = At.DefaultMatrixAutoUpdate),
      (this.matrixWorldNeedsUpdate = !1),
      (this.layers = new lt()),
      (this.visible = !0),
      (this.castShadow = !1),
      (this.receiveShadow = !1),
      (this.frustumCulled = !0),
      (this.renderOrder = 0),
      (this.instanceDrawing = !1),
      (this.userData = {});
  }
  function Mt() {
    At.call(this),
      (this.type = 'Scene'),
      (this.background = null),
      (this.environment = null),
      (this.fog = null),
      (this.overrideMaterial = null),
      (this.autoUpdate = !0),
      'undefined' != typeof __THREE_DEVTOOLS__ &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent('observe', { detail: this }),
        );
  }
  (At.DefaultUp = new J(0, 1, 0)),
    (At.DefaultMatrixAutoUpdate = !0),
    (At.prototype = Object.assign(Object.create(B.prototype), {
      constructor: At,
      isObject3D: !0,
      onBeforeRender: function () {},
      onAfterRender: function () {},
      applyMatrix4: function (t) {
        this.matrixAutoUpdate && this.updateMatrix(),
          this.matrix.premultiply(t),
          this.matrix.decompose(this.position, this.quaternion, this.scale);
      },
      applyQuaternion: function (t) {
        return this.quaternion.premultiply(t), this;
      },
      setRotationFromAxisAngle: function (t, e) {
        this.quaternion.setFromAxisAngle(t, e);
      },
      setRotationFromEuler: function (t) {
        this.quaternion.setFromEuler(t, !0);
      },
      setRotationFromMatrix: function (t) {
        this.quaternion.setFromRotationMatrix(t);
      },
      setRotationFromQuaternion: function (t) {
        this.quaternion.copy(t);
      },
      rotateOnAxis: function (t, e) {
        return dt.setFromAxisAngle(t, e), this.quaternion.multiply(dt), this;
      },
      rotateOnWorldAxis: function (t, e) {
        return dt.setFromAxisAngle(t, e), this.quaternion.premultiply(dt), this;
      },
      rotateX: function (t) {
        return this.rotateOnAxis(yt, t);
      },
      rotateY: function (t) {
        return this.rotateOnAxis(vt, t);
      },
      rotateZ: function (t) {
        return this.rotateOnAxis(_t, t);
      },
      translateOnAxis: function (t, e) {
        return (
          ut.copy(t).applyQuaternion(this.quaternion),
          this.position.add(ut.multiplyScalar(e)),
          this
        );
      },
      translateX: function (t) {
        return this.translateOnAxis(yt, t);
      },
      translateY: function (t) {
        return this.translateOnAxis(vt, t);
      },
      translateZ: function (t) {
        return this.translateOnAxis(_t, t);
      },
      localToWorld: function (t) {
        return t.applyMatrix4(this.matrixWorld);
      },
      worldToLocal: function (t) {
        return t.applyMatrix4(pt.getInverse(this.matrixWorld));
      },
      lookAt: function (t, e, n) {
        t.isVector3 ? ft.copy(t) : ft.set(t, e, n);
        var i = this.parent;
        this.updateWorldMatrix(!0, !1),
          mt.setFromMatrixPosition(this.matrixWorld),
          this.isCamera || this.isLight
            ? pt.lookAt(mt, ft, this.up)
            : pt.lookAt(ft, mt, this.up),
          this.quaternion.setFromRotationMatrix(pt),
          i &&
            (pt.extractRotation(i.matrixWorld),
            dt.setFromRotationMatrix(pt),
            this.quaternion.premultiply(dt.inverse()));
      },
      add: function (t) {
        if (arguments.length > 1) {
          for (var e = 0; e < arguments.length; e++) this.add(arguments[e]);
          return this;
        }
        return t === this
          ? (console.error(
              "THREE.Object3D.add: object can't be added as a child of itself.",
              t,
            ),
            this)
          : (t && t.isObject3D
              ? (null !== t.parent && t.parent.remove(t),
                (t.parent = this),
                this.children.push(t),
                t.dispatchEvent(xt))
              : console.error(
                  'THREE.Object3D.add: object not an instance of THREE.Object3D.',
                  t,
                ),
            this);
      },
      remove: function (t) {
        if (arguments.length > 1) {
          for (var e = 0; e < arguments.length; e++) this.remove(arguments[e]);
          return this;
        }
        var n = this.children.indexOf(t);
        return (
          -1 !== n &&
            ((t.parent = null),
            this.children.splice(n, 1),
            t.dispatchEvent(wt)),
          this
        );
      },
      dispose: function () {
        this.dispatchEvent({ type: 'dispose' });
      },
      removeAll: function () {
        for (var t = 0; t < this.children.length; t++) {
          var e = this.children[t];
          'Group' === e.type && e.removeAll(),
            (e.parent = null),
            e.dispatchEvent(wt),
            e.dispose();
        }
        return (this.children = []), this;
      },
      attach: function (t) {
        return (
          this.updateWorldMatrix(!0, !1),
          pt.getInverse(this.matrixWorld),
          null !== t.parent &&
            (t.parent.updateWorldMatrix(!0, !1),
            pt.multiply(t.parent.matrixWorld)),
          t.applyMatrix4(pt),
          t.updateWorldMatrix(!1, !1),
          this.add(t),
          this
        );
      },
      getObjectById: function (t) {
        return this.getObjectByProperty('id', t);
      },
      getObjectByName: function (t) {
        return this.getObjectByProperty('name', t);
      },
      getObjectByProperty: function (t, e) {
        if (this[t] === e) return this;
        for (var n = 0, i = this.children.length; n < i; n++) {
          var r = this.children[n].getObjectByProperty(t, e);
          if (void 0 !== r) return r;
        }
      },
      getWorldPosition: function (t) {
        return (
          void 0 === t &&
            (console.warn(
              'THREE.Object3D: .getWorldPosition() target is now required',
            ),
            (t = new J())),
          this.updateMatrixWorld(!0),
          t.setFromMatrixPosition(this.matrixWorld)
        );
      },
      getWorldQuaternion: function (t) {
        return (
          void 0 === t &&
            (console.warn(
              'THREE.Object3D: .getWorldQuaternion() target is now required',
            ),
            (t = new Y())),
          this.updateMatrixWorld(!0),
          this.matrixWorld.decompose(mt, t, bt),
          t
        );
      },
      getWorldScale: function (t) {
        return (
          void 0 === t &&
            (console.warn(
              'THREE.Object3D: .getWorldScale() target is now required',
            ),
            (t = new J())),
          this.updateMatrixWorld(!0),
          this.matrixWorld.decompose(mt, gt, t),
          t
        );
      },
      getWorldDirection: function (t) {
        void 0 === t &&
          (console.warn(
            'THREE.Object3D: .getWorldDirection() target is now required',
          ),
          (t = new J())),
          this.updateMatrixWorld(!0);
        var e = this.matrixWorld.elements;
        return t.set(e[8], e[9], e[10]).normalize();
      },
      raycast: function () {},
      traverse: function (t) {
        t(this);
        for (var e = this.children, n = 0, i = e.length; n < i; n++)
          e[n].traverse(t);
      },
      traverseVisible: function (t) {
        if (!1 !== this.visible) {
          t(this);
          for (var e = this.children, n = 0, i = e.length; n < i; n++)
            e[n].traverseVisible(t);
        }
      },
      traverseAncestors: function (t) {
        var e = this.parent;
        null !== e && (t(e), e.traverseAncestors(t));
      },
      updateMatrix: function (t) {
        this.matrix.compose(this.position, this.quaternion, this.scale),
          (this.matrixWorldNeedsUpdate = !0);
      },
      updateMatrixWorld: function (t, e) {
        this.matrixAutoUpdate && this.updateMatrix(e),
          (this.matrixWorldNeedsUpdate || t) &&
            (null === this.parent
              ? this.matrixWorld.copy(this.matrix)
              : this.matrixWorld.multiplyMatrices(
                  this.parent.matrixWorld,
                  this.matrix,
                ),
            (this.matrixWorldNeedsUpdate = !1),
            (t = !0));
        for (var n = this.children, i = 0, r = n.length; i < r; i++)
          n[i].updateMatrixWorld(t, e);
      },
      updateWorldMatrix: function (t, e) {
        var n = this.parent;
        if (
          (!0 === t && null !== n && n.updateWorldMatrix(!0, !1),
          this.matrixAutoUpdate && this.updateMatrix(),
          null === this.parent
            ? this.matrixWorld.copy(this.matrix)
            : this.matrixWorld.multiplyMatrices(
                this.parent.matrixWorld,
                this.matrix,
              ),
          !0 === e)
        )
          for (var i = this.children, r = 0, o = i.length; r < o; r++)
            i[r].updateWorldMatrix(!1, !0);
      },
      toJSON: function (t) {
        var e = void 0 === t || 'string' == typeof t,
          n = {};
        e &&
          ((t = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
          }),
          (n.metadata = {
            version: 4.5,
            type: 'Object',
            generator: 'Object3D.toJSON',
          }));
        var i = {};
        function r(e, n) {
          return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid;
        }
        if (
          ((i.uuid = this.uuid),
          (i.type = this.type),
          '' !== this.name && (i.name = this.name),
          !0 === this.castShadow && (i.castShadow = !0),
          !0 === this.receiveShadow && (i.receiveShadow = !0),
          !1 === this.visible && (i.visible = !1),
          !1 === this.frustumCulled && (i.frustumCulled = !1),
          0 !== this.renderOrder && (i.renderOrder = this.renderOrder),
          '{}' !== JSON.stringify(this.userData) &&
            (i.userData = this.userData),
          (i.layers = this.layers.mask),
          (i.matrix = this.matrix.toArray()),
          !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1),
          this.isInstancedMesh &&
            ((i.type = 'InstancedMesh'),
            (i.count = this.count),
            (i.instanceMatrix = this.instanceMatrix.toJSON())),
          this.isMesh || this.isLine || this.isPoints)
        ) {
          i.geometry = r(t.geometries, this.geometry);
          var o = this.geometry.parameters;
          if (void 0 !== o && void 0 !== o.shapes) {
            var s = o.shapes;
            if (Array.isArray(s))
              for (var a = 0, c = s.length; a < c; a++) {
                var l = s[a];
                r(t.shapes, l);
              }
            else r(t.shapes, s);
          }
        }
        if (void 0 !== this.material)
          if (Array.isArray(this.material)) {
            var h = [];
            for (a = 0, c = this.material.length; a < c; a++)
              h.push(r(t.materials, this.material[a]));
            i.material = h;
          } else i.material = r(t.materials, this.material);
        if (this.children.length > 0) {
          i.children = [];
          for (a = 0; a < this.children.length; a++)
            i.children.push(this.children[a].toJSON(t).object);
        }
        if (e) {
          var u = m(t.geometries),
            d = m(t.materials),
            p = m(t.textures),
            f = m(t.images);
          s = m(t.shapes);
          u.length > 0 && (n.geometries = u),
            d.length > 0 && (n.materials = d),
            p.length > 0 && (n.textures = p),
            f.length > 0 && (n.images = f),
            s.length > 0 && (n.shapes = s);
        }
        return (n.object = i), n;
        function m(t) {
          var e = [];
          for (var n in t) {
            var i = t[n];
            delete i.metadata, e.push(i);
          }
          return e;
        }
      },
      clone: function (t) {
        return new this.constructor().copy(this, t);
      },
      copy: function (t, e) {
        if (
          (void 0 === e && (e = !0),
          (this.name = t.name),
          this.up.copy(t.up),
          this.position.copy(t.position),
          this.quaternion.copy(t.quaternion),
          this.scale.copy(t.scale),
          this.matrix.copy(t.matrix),
          this.matrixWorld.copy(t.matrixWorld),
          (this.matrixAutoUpdate = t.matrixAutoUpdate),
          (this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate),
          (this.layers.mask = t.layers.mask),
          (this.visible = t.visible),
          (this.castShadow = t.castShadow),
          (this.receiveShadow = t.receiveShadow),
          (this.frustumCulled = t.frustumCulled),
          (this.renderOrder = t.renderOrder),
          (this.instanceDrawing = t.instanceDrawing),
          (this.userData = JSON.parse(JSON.stringify(t.userData))),
          !0 === e)
        )
          for (var n = 0; n < t.children.length; n++) {
            var i = t.children[n];
            this.add(i.clone());
          }
        return this;
      },
    })),
    (Mt.prototype = Object.assign(Object.create(At.prototype), {
      constructor: Mt,
      isScene: !0,
      copy: function (t, e) {
        return (
          At.prototype.copy.call(this, t, e),
          null !== t.background && (this.background = t.background.clone()),
          null !== t.environment && (this.environment = t.environment.clone()),
          null !== t.fog && (this.fog = t.fog.clone()),
          null !== t.overrideMaterial &&
            (this.overrideMaterial = t.overrideMaterial.clone()),
          (this.autoUpdate = t.autoUpdate),
          (this.matrixAutoUpdate = t.matrixAutoUpdate),
          this
        );
      },
      toJSON: function (t) {
        var e = At.prototype.toJSON.call(this, t);
        return (
          null !== this.background &&
            (e.object.background = this.background.toJSON(t)),
          null !== this.environment &&
            (e.object.environment = this.environment.toJSON(t)),
          null !== this.fog && (e.object.fog = this.fog.toJSON()),
          e
        );
      },
      dispose: function () {
        this.dispatchEvent({ type: 'dispose' });
      },
    }));
  var St = [
      new J(),
      new J(),
      new J(),
      new J(),
      new J(),
      new J(),
      new J(),
      new J(),
    ],
    It = new J(),
    Et = new Nt(),
    Dt = new J(),
    Ct = new J(),
    Tt = new J(),
    Lt = new J(),
    Rt = new J(),
    Ft = new J(),
    Pt = new J(),
    Bt = new J(),
    Ot = new J(),
    Vt = new J();
  function Nt(t, e) {
    (this.min = void 0 !== t ? t : new J(1 / 0, 1 / 0, 1 / 0)),
      (this.max = void 0 !== e ? e : new J(-1 / 0, -1 / 0, -1 / 0));
  }
  function kt(t, e, n, i, r) {
    var o, s;
    for (o = 0, s = t.length - 3; o <= s; o += 3) {
      Vt.fromArray(t, o);
      var a =
          r.x * Math.abs(Vt.x) + r.y * Math.abs(Vt.y) + r.z * Math.abs(Vt.z),
        c = e.dot(Vt),
        l = n.dot(Vt),
        h = i.dot(Vt);
      if (Math.max(-Math.max(c, l, h), Math.min(c, l, h)) > a) return !1;
    }
    return !0;
  }
  Object.assign(Nt.prototype, {
    isBox3: !0,
    set: function (t, e) {
      return this.min.copy(t), this.max.copy(e), this;
    },
    reset: function () {
      this.min.set(1 / 0, 1 / 0, 1 / 0), this.max.set(-1 / 0, -1 / 0, -1 / 0);
    },
    setFromArray: function (t) {
      for (
        var e = 1 / 0,
          n = 1 / 0,
          i = 1 / 0,
          r = -1 / 0,
          o = -1 / 0,
          s = -1 / 0,
          a = 0,
          c = t.length;
        a < c;
        a += 3
      ) {
        var l = t[a],
          h = t[a + 1],
          u = t[a + 2];
        l < e && (e = l),
          h < n && (n = h),
          u < i && (i = u),
          l > r && (r = l),
          h > o && (o = h),
          u > s && (s = u);
      }
      return this.min.set(e, n, i), this.max.set(r, o, s), this;
    },
    setFromBufferAttribute: function (t) {
      for (
        var e = 1 / 0,
          n = 1 / 0,
          i = 1 / 0,
          r = -1 / 0,
          o = -1 / 0,
          s = -1 / 0,
          a = 0,
          c = t.count;
        a < c;
        a++
      ) {
        var l = t.getX(a),
          h = t.getY(a),
          u = t.getZ(a);
        l < e && (e = l),
          h < n && (n = h),
          u < i && (i = u),
          l > r && (r = l),
          h > o && (o = h),
          u > s && (s = u);
      }
      return this.min.set(e, n, i), this.max.set(r, o, s), this;
    },
    setFromPoints: function (t) {
      this.makeEmpty();
      for (var e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
      return this;
    },
    setFromCenterAndSize: function (t, e) {
      var n = It.copy(e).multiplyScalar(0.5);
      return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
    },
    setFromObject: function (t) {
      return this.makeEmpty(), this.expandByObject(t);
    },
    clone: function () {
      return new this.constructor().copy(this);
    },
    copy: function (t) {
      return this.min.copy(t.min), this.max.copy(t.max), this;
    },
    makeEmpty: function () {
      return (
        (this.min.x = this.min.y = this.min.z = 1 / 0),
        (this.max.x = this.max.y = this.max.z = -1 / 0),
        this
      );
    },
    isEmpty: function () {
      return (
        this.max.x < this.min.x ||
        this.max.y < this.min.y ||
        this.max.z < this.min.z
      );
    },
    getCenter: function (t) {
      return (
        void 0 === t &&
          (console.warn('THREE.Box3: .getCenter() target is now required'),
          (t = new J())),
        this.isEmpty()
          ? t.set(0, 0, 0)
          : t.addVectors(this.min, this.max).multiplyScalar(0.5)
      );
    },
    getSize: function (t) {
      return (
        void 0 === t &&
          (console.warn('THREE.Box3: .getSize() target is now required'),
          (t = new J())),
        this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
      );
    },
    expandByPoint: function (t) {
      return this.min.min(t), this.max.max(t), this;
    },
    expandByVector: function (t) {
      return this.min.sub(t), this.max.add(t), this;
    },
    expandByScalar: function (t) {
      return this.min.addScalar(-t), this.max.addScalar(t), this;
    },
    expandByObject: function (t) {
      t.updateWorldMatrix(!1, !1);
      var e = t.geometry;
      void 0 !== e &&
        (null === e.boundingBox && e.computeBoundingBox(),
        Et.copy(e.boundingBox),
        Et.applyMatrix4(t.matrixWorld),
        this.union(Et));
      for (var n = t.children, i = 0, r = n.length; i < r; i++)
        this.expandByObject(n[i]);
      return this;
    },
    containsPoint: function (t) {
      return !(
        t.x < this.min.x ||
        t.x > this.max.x ||
        t.y < this.min.y ||
        t.y > this.max.y ||
        t.z < this.min.z ||
        t.z > this.max.z
      );
    },
    containsBox: function (t) {
      return (
        this.min.x <= t.min.x &&
        t.max.x <= this.max.x &&
        this.min.y <= t.min.y &&
        t.max.y <= this.max.y &&
        this.min.z <= t.min.z &&
        t.max.z <= this.max.z
      );
    },
    getParameter: function (t, e) {
      return (
        void 0 === e &&
          (console.warn('THREE.Box3: .getParameter() target is now required'),
          (e = new J())),
        e.set(
          (t.x - this.min.x) / (this.max.x - this.min.x),
          (t.y - this.min.y) / (this.max.y - this.min.y),
          (t.z - this.min.z) / (this.max.z - this.min.z),
        )
      );
    },
    intersectsBox: function (t) {
      return !(
        t.max.x < this.min.x ||
        t.min.x > this.max.x ||
        t.max.y < this.min.y ||
        t.min.y > this.max.y ||
        t.max.z < this.min.z ||
        t.min.z > this.max.z
      );
    },
    intersectsSphere: function (t) {
      return (
        this.clampPoint(t.center, It),
        It.distanceToSquared(t.center) <= t.radius * t.radius
      );
    },
    intersectsPlane: function (t) {
      var e, n;
      return (
        t.normal.x > 0
          ? ((e = t.normal.x * this.min.x), (n = t.normal.x * this.max.x))
          : ((e = t.normal.x * this.max.x), (n = t.normal.x * this.min.x)),
        t.normal.y > 0
          ? ((e += t.normal.y * this.min.y), (n += t.normal.y * this.max.y))
          : ((e += t.normal.y * this.max.y), (n += t.normal.y * this.min.y)),
        t.normal.z > 0
          ? ((e += t.normal.z * this.min.z), (n += t.normal.z * this.max.z))
          : ((e += t.normal.z * this.max.z), (n += t.normal.z * this.min.z)),
        e <= -t.constant && n >= -t.constant
      );
    },
    intersectsTriangle: function (t) {
      if (this.isEmpty()) return !1;
      this.getCenter(Pt),
        Bt.subVectors(this.max, Pt),
        Dt.subVectors(t.a, Pt),
        Ct.subVectors(t.b, Pt),
        Tt.subVectors(t.c, Pt),
        Lt.subVectors(Ct, Dt),
        Rt.subVectors(Tt, Ct),
        Ft.subVectors(Dt, Tt);
      var e = [
        0,
        -Lt.z,
        Lt.y,
        0,
        -Rt.z,
        Rt.y,
        0,
        -Ft.z,
        Ft.y,
        Lt.z,
        0,
        -Lt.x,
        Rt.z,
        0,
        -Rt.x,
        Ft.z,
        0,
        -Ft.x,
        -Lt.y,
        Lt.x,
        0,
        -Rt.y,
        Rt.x,
        0,
        -Ft.y,
        Ft.x,
        0,
      ];
      return (
        !!kt(e, Dt, Ct, Tt, Bt) &&
        !!kt((e = [1, 0, 0, 0, 1, 0, 0, 0, 1]), Dt, Ct, Tt, Bt) &&
        (Ot.crossVectors(Lt, Rt), kt((e = [Ot.x, Ot.y, Ot.z]), Dt, Ct, Tt, Bt))
      );
    },
    clampPoint: function (t, e) {
      return (
        void 0 === e &&
          (console.warn('THREE.Box3: .clampPoint() target is now required'),
          (e = new J())),
        e.copy(t).clamp(this.min, this.max)
      );
    },
    distanceToPoint: function (t) {
      return It.copy(t).clamp(this.min, this.max).sub(t).length();
    },
    getBoundingSphere: function (t) {
      return (
        void 0 === t &&
          console.error(
            'THREE.Box3: .getBoundingSphere() target is now required',
          ),
        this.getCenter(t.center),
        (t.radius = 0.5 * this.getSize(It).length()),
        t
      );
    },
    intersect: function (t) {
      return (
        this.min.max(t.min),
        this.max.min(t.max),
        this.isEmpty() && this.makeEmpty(),
        this
      );
    },
    union: function (t) {
      return this.min.min(t.min), this.max.max(t.max), this;
    },
    applyMatrix4: function (t) {
      return (
        this.isEmpty() ||
          (St[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
          St[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
          St[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
          St[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
          St[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
          St[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
          St[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
          St[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
          this.setFromPoints(St)),
        this
      );
    },
    translate: function (t) {
      return this.min.add(t), this.max.add(t), this;
    },
    equals: function (t) {
      return t.min.equals(this.min) && t.max.equals(this.max);
    },
  });
  var Ut = new Nt();
  function Gt(t, e) {
    (this.center = void 0 !== t ? t : new J()),
      (this.radius = void 0 !== e ? e : 0);
  }
  Object.assign(Gt.prototype, {
    set: function (t, e) {
      return this.center.copy(t), (this.radius = e), this;
    },
    setFromPoints: function (t, e) {
      var n = this.center;
      void 0 !== e ? n.copy(e) : Ut.setFromPoints(t).getCenter(n);
      for (var i = 0, r = 0, o = t.length; r < o; r++)
        i = Math.max(i, n.distanceToSquared(t[r]));
      return (this.radius = Math.sqrt(i)), this;
    },
    clone: function () {
      return new this.constructor().copy(this);
    },
    copy: function (t) {
      return this.center.copy(t.center), (this.radius = t.radius), this;
    },
    empty: function () {
      return this.radius <= 0;
    },
    containsPoint: function (t) {
      return t.distanceToSquared(this.center) <= this.radius * this.radius;
    },
    distanceToPoint: function (t) {
      return t.distanceTo(this.center) - this.radius;
    },
    intersectsSphere: function (t) {
      var e = this.radius + t.radius;
      return t.center.distanceToSquared(this.center) <= e * e;
    },
    intersectsBox: function (t) {
      return t.intersectsSphere(this);
    },
    intersectsPlane: function (t) {
      return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
    },
    clampPoint: function (t, e) {
      var n = this.center.distanceToSquared(t);
      return (
        void 0 === e &&
          (console.warn('THREE.Sphere: .clampPoint() target is now required'),
          (e = new J())),
        e.copy(t),
        n > this.radius * this.radius &&
          (e.sub(this.center).normalize(),
          e.multiplyScalar(this.radius).add(this.center)),
        e
      );
    },
    getBoundingBox: function (t) {
      return (
        void 0 === t &&
          (console.warn(
            'THREE.Sphere: .getBoundingBox() target is now required',
          ),
          (t = new Nt())),
        t.set(this.center, this.center),
        t.expandByScalar(this.radius),
        t
      );
    },
    expandBySphere: function (t) {
      if (t.empty()) return;
      if (this.empty()) return void this.copy(t);
      let e = this.center.distanceTo(t.center);
      if (e + t.radius <= this.radius) return;
      if (e + this.radius <= t.radius) return void this.copy(t);
      let n = 0.5 * (this.radius + e + t.radius),
        i = (n - this.radius) / e;
      (this.center.x += (t.center.x - this.center.x) * i),
        (this.center.y += (t.center.y - this.center.y) * i),
        (this.center.z += (t.center.z - this.center.z) * i),
        (this.radius = n);
    },
    applyMatrix4: function (t) {
      return (
        this.center.applyMatrix4(t),
        (this.radius = this.radius * t.getMaxScaleOnAxis()),
        this
      );
    },
    translate: function (t) {
      return this.center.add(t), this;
    },
    equals: function (t) {
      return t.center.equals(this.center) && t.radius === this.radius;
    },
  });
  var zt = new J(),
    jt = new J(),
    Ht = new J(),
    Wt = new J(),
    Xt = new J(),
    Zt = new J(),
    Yt = new J();
  function qt(t, e) {
    (this.origin = void 0 !== t ? t : new J()),
      (this.direction = void 0 !== e ? e : new J(0, 0, -1));
  }
  Object.assign(qt.prototype, {
    set: function (t, e) {
      return this.origin.copy(t), this.direction.copy(e), this;
    },
    clone: function () {
      return new this.constructor().copy(this);
    },
    copy: function (t) {
      return this.origin.copy(t.origin), this.direction.copy(t.direction), this;
    },
    at: function (t, e) {
      return (
        void 0 === e &&
          (console.warn('THREE.Ray: .at() target is now required'),
          (e = new J())),
        e.copy(this.direction).multiplyScalar(t).add(this.origin)
      );
    },
    lookAt: function (t) {
      return this.direction.copy(t).sub(this.origin).normalize(), this;
    },
    recast: function (t) {
      return this.origin.copy(this.at(t, zt)), this;
    },
    closestPointToPoint: function (t, e) {
      void 0 === e &&
        (console.warn(
          'THREE.Ray: .closestPointToPoint() target is now required',
        ),
        (e = new J())),
        e.subVectors(t, this.origin);
      var n = e.dot(this.direction);
      return n < 0
        ? e.copy(this.origin)
        : e.copy(this.direction).multiplyScalar(n).add(this.origin);
    },
    distanceToPoint: function (t) {
      return Math.sqrt(this.distanceSqToPoint(t));
    },
    distanceSqToPoint: function (t) {
      var e = zt.subVectors(t, this.origin).dot(this.direction);
      return e < 0
        ? this.origin.distanceToSquared(t)
        : (zt.copy(this.direction).multiplyScalar(e).add(this.origin),
          zt.distanceToSquared(t));
    },
    distanceSqToSegment: function (t, e, n, i) {
      jt.copy(t).add(e).multiplyScalar(0.5),
        Ht.copy(e).sub(t).normalize(),
        Wt.copy(this.origin).sub(jt);
      var r,
        o,
        s,
        a,
        c = 0.5 * t.distanceTo(e),
        l = -this.direction.dot(Ht),
        h = Wt.dot(this.direction),
        u = -Wt.dot(Ht),
        d = Wt.lengthSq(),
        p = Math.abs(1 - l * l);
      if (p > 0)
        if (((o = l * h - u), (a = c * p), (r = l * u - h) >= 0))
          if (o >= -a)
            if (o <= a) {
              var f = 1 / p;
              s =
                (r *= f) * (r + l * (o *= f) + 2 * h) +
                o * (l * r + o + 2 * u) +
                d;
            } else
              (o = c),
                (s =
                  -(r = Math.max(0, -(l * o + h))) * r + o * (o + 2 * u) + d);
          else
            (o = -c),
              (s = -(r = Math.max(0, -(l * o + h))) * r + o * (o + 2 * u) + d);
        else
          o <= -a
            ? (s =
                -(r = Math.max(0, -(-l * c + h))) * r +
                (o = r > 0 ? -c : Math.min(Math.max(-c, -u), c)) * (o + 2 * u) +
                d)
            : o <= a
            ? ((r = 0),
              (s = (o = Math.min(Math.max(-c, -u), c)) * (o + 2 * u) + d))
            : (s =
                -(r = Math.max(0, -(l * c + h))) * r +
                (o = r > 0 ? c : Math.min(Math.max(-c, -u), c)) * (o + 2 * u) +
                d);
      else
        (o = l > 0 ? -c : c),
          (s = -(r = Math.max(0, -(l * o + h))) * r + o * (o + 2 * u) + d);
      return (
        n && n.copy(this.direction).multiplyScalar(r).add(this.origin),
        i && i.copy(Ht).multiplyScalar(o).add(jt),
        s
      );
    },
    intersectSphere: function (t, e) {
      zt.subVectors(t.center, this.origin);
      var n = zt.dot(this.direction),
        i = zt.dot(zt) - n * n,
        r = t.radius * t.radius;
      if (i > r) return null;
      var o = Math.sqrt(r - i),
        s = n - o,
        a = n + o;
      return s < 0 && a < 0 ? null : s < 0 ? this.at(a, e) : this.at(s, e);
    },
    intersectsSphere: function (t) {
      return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
    },
    distanceToPlane: function (t) {
      var e = t.normal.dot(this.direction);
      if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
      var n = -(this.origin.dot(t.normal) + t.constant) / e;
      return n >= 0 ? n : null;
    },
    intersectPlane: function (t, e) {
      var n = this.distanceToPlane(t);
      return null === n ? null : this.at(n, e);
    },
    intersectsPlane: function (t) {
      var e = t.distanceToPoint(this.origin);
      return 0 === e || t.normal.dot(this.direction) * e < 0;
    },
    intersectBox: function (t, e) {
      var n,
        i,
        r,
        o,
        s,
        a,
        c = 1 / this.direction.x,
        l = 1 / this.direction.y,
        h = 1 / this.direction.z,
        u = this.origin;
      return (
        c >= 0
          ? ((n = (t.min.x - u.x) * c), (i = (t.max.x - u.x) * c))
          : ((n = (t.max.x - u.x) * c), (i = (t.min.x - u.x) * c)),
        l >= 0
          ? ((r = (t.min.y - u.y) * l), (o = (t.max.y - u.y) * l))
          : ((r = (t.max.y - u.y) * l), (o = (t.min.y - u.y) * l)),
        n > o || r > i
          ? null
          : ((r > n || n != n) && (n = r),
            (o < i || i != i) && (i = o),
            h >= 0
              ? ((s = (t.min.z - u.z) * h), (a = (t.max.z - u.z) * h))
              : ((s = (t.max.z - u.z) * h), (a = (t.min.z - u.z) * h)),
            n > a || s > i
              ? null
              : ((s > n || n != n) && (n = s),
                (a < i || i != i) && (i = a),
                i < 0 ? null : this.at(n >= 0 ? n : i, e)))
      );
    },
    intersectsBox: function (t) {
      return null !== this.intersectBox(t, zt);
    },
    intersectTriangle: function (t, e, n, i, r) {
      Xt.subVectors(e, t), Zt.subVectors(n, t), Yt.crossVectors(Xt, Zt);
      var o,
        s = this.direction.dot(Yt);
      if (s > 0) {
        if (i) return null;
        o = 1;
      } else {
        if (!(s < 0)) return null;
        (o = -1), (s = -s);
      }
      Wt.subVectors(this.origin, t);
      var a = o * this.direction.dot(Zt.crossVectors(Wt, Zt));
      if (a < 0) return null;
      var c = o * this.direction.dot(Xt.cross(Wt));
      if (c < 0) return null;
      if (a + c > s) return null;
      var l = -o * Wt.dot(Yt);
      return l < 0 ? null : this.at(l / s, r);
    },
    applyMatrix4: function (t) {
      return (
        this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
      );
    },
    equals: function (t) {
      return t.origin.equals(this.origin) && t.direction.equals(this.direction);
    },
  });
  var Qt = new J(),
    Jt = new J(),
    $t = new G();
  function Kt(t, e) {
    (this.normal = void 0 !== t ? t : new J(1, 0, 0)),
      (this.constant = void 0 !== e ? e : 0);
  }
  Object.assign(Kt.prototype, {
    isPlane: !0,
    set: function (t, e) {
      return this.normal.copy(t), (this.constant = e), this;
    },
    setComponents: function (t, e, n, i) {
      return this.normal.set(t, e, n), (this.constant = i), this;
    },
    setFromNormalAndCoplanarPoint: function (t, e) {
      return this.normal.copy(t), (this.constant = -e.dot(this.normal)), this;
    },
    setFromCoplanarPoints: function (t, e, n) {
      var i = Qt.subVectors(n, e).cross(Jt.subVectors(t, e)).normalize();
      return this.setFromNormalAndCoplanarPoint(i, t), this;
    },
    clone: function () {
      return new this.constructor().copy(this);
    },
    copy: function (t) {
      return this.normal.copy(t.normal), (this.constant = t.constant), this;
    },
    normalize: function () {
      var t = 1 / this.normal.length();
      return this.normal.multiplyScalar(t), (this.constant *= t), this;
    },
    negate: function () {
      return (this.constant *= -1), this.normal.negate(), this;
    },
    distanceToPoint: function (t) {
      return this.normal.dot(t) + this.constant;
    },
    distanceToSphere: function (t) {
      return this.distanceToPoint(t.center) - t.radius;
    },
    projectPoint: function (t, e) {
      return (
        void 0 === e &&
          (console.warn('THREE.Plane: .projectPoint() target is now required'),
          (e = new J())),
        e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
      );
    },
    intersectLine: function (t, e) {
      void 0 === e &&
        (console.warn('THREE.Plane: .intersectLine() target is now required'),
        (e = new J()));
      var n = t.delta(Qt),
        i = this.normal.dot(n);
      if (0 === i)
        return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : void 0;
      var r = -(t.start.dot(this.normal) + this.constant) / i;
      return r < 0 || r > 1 ? void 0 : e.copy(n).multiplyScalar(r).add(t.start);
    },
    intersectsLine: function (t) {
      var e = this.distanceToPoint(t.start),
        n = this.distanceToPoint(t.end);
      return (e < 0 && n > 0) || (n < 0 && e > 0);
    },
    intersectsBox: function (t) {
      return t.intersectsPlane(this);
    },
    intersectsSphere: function (t) {
      return t.intersectsPlane(this);
    },
    coplanarPoint: function (t) {
      return (
        void 0 === t &&
          (console.warn('THREE.Plane: .coplanarPoint() target is now required'),
          (t = new J())),
        t.copy(this.normal).multiplyScalar(-this.constant)
      );
    },
    applyMatrix4: function (t, e) {
      var n = e || $t.getNormalMatrix(t),
        i = this.coplanarPoint(Qt).applyMatrix4(t),
        r = this.normal.applyMatrix3(n).normalize();
      return (this.constant = -i.dot(r)), this;
    },
    translate: function (t) {
      return (this.constant -= t.dot(this.normal)), this;
    },
    equals: function (t) {
      return t.normal.equals(this.normal) && t.constant === this.constant;
    },
  });
  var te = new J(),
    ee = new J(),
    ne = new J(),
    ie = new J(),
    re = new J(),
    oe = new J(),
    se = new J(),
    ae = new J(),
    ce = new J(),
    le = new J();
  function he(t, e, n) {
    (this.a = void 0 !== t ? t : new J()),
      (this.b = void 0 !== e ? e : new J()),
      (this.c = void 0 !== n ? n : new J());
  }
  Object.assign(he, {
    getNormal: function (t, e, n, i) {
      void 0 === i &&
        (console.warn('THREE.Triangle: .getNormal() target is now required'),
        (i = new J())),
        i.subVectors(n, e),
        te.subVectors(t, e),
        i.cross(te);
      var r = i.lengthSq();
      return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0);
    },
    getBarycoord: function (t, e, n, i, r) {
      te.subVectors(i, e), ee.subVectors(n, e), ne.subVectors(t, e);
      var o = te.dot(te),
        s = te.dot(ee),
        a = te.dot(ne),
        c = ee.dot(ee),
        l = ee.dot(ne),
        h = o * c - s * s;
      if (
        (void 0 === r &&
          (console.warn(
            'THREE.Triangle: .getBarycoord() target is now required',
          ),
          (r = new J())),
        0 === h)
      )
        return r.set(-2, -1, -1);
      var u = 1 / h,
        d = (c * a - s * l) * u,
        p = (o * l - s * a) * u;
      return r.set(1 - d - p, p, d);
    },
    containsPoint: function (t, e, n, i) {
      return (
        he.getBarycoord(t, e, n, i, ie),
        ie.x >= 0 && ie.y >= 0 && ie.x + ie.y <= 1
      );
    },
    getUV: function (t, e, n, i, r, o, s, a) {
      return (
        this.getBarycoord(t, e, n, i, ie),
        a.set(0, 0),
        a.addScaledVector(r, ie.x),
        a.addScaledVector(o, ie.y),
        a.addScaledVector(s, ie.z),
        a
      );
    },
    isFrontFacing: function (t, e, n, i) {
      return te.subVectors(n, e), ee.subVectors(t, e), te.cross(ee).dot(i) < 0;
    },
  }),
    Object.assign(he.prototype, {
      set: function (t, e, n) {
        return this.a.copy(t), this.b.copy(e), this.c.copy(n), this;
      },
      setFromPointsAndIndices: function (t, e, n, i) {
        return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this;
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (t) {
        return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
      },
      getArea: function () {
        return (
          te.subVectors(this.c, this.b),
          ee.subVectors(this.a, this.b),
          0.5 * te.cross(ee).length()
        );
      },
      getMidpoint: function (t) {
        return (
          void 0 === t &&
            (console.warn(
              'THREE.Triangle: .getMidpoint() target is now required',
            ),
            (t = new J())),
          t
            .addVectors(this.a, this.b)
            .add(this.c)
            .multiplyScalar(1 / 3)
        );
      },
      getNormal: function (t) {
        return he.getNormal(this.a, this.b, this.c, t);
      },
      getPlane: function (t) {
        return (
          void 0 === t &&
            (console.warn('THREE.Triangle: .getPlane() target is now required'),
            (t = new Kt())),
          t.setFromCoplanarPoints(this.a, this.b, this.c)
        );
      },
      getBarycoord: function (t, e) {
        return he.getBarycoord(t, this.a, this.b, this.c, e);
      },
      getUV: function (t, e, n, i, r) {
        return he.getUV(t, this.a, this.b, this.c, e, n, i, r);
      },
      containsPoint: function (t) {
        return he.containsPoint(t, this.a, this.b, this.c);
      },
      isFrontFacing: function (t) {
        return he.isFrontFacing(this.a, this.b, this.c, t);
      },
      intersectsBox: function (t) {
        return t.intersectsTriangle(this);
      },
      closestPointToPoint: function (t, e) {
        void 0 === e &&
          (console.warn(
            'THREE.Triangle: .closestPointToPoint() target is now required',
          ),
          (e = new J()));
        var n,
          i,
          r = this.a,
          o = this.b,
          s = this.c;
        re.subVectors(o, r), oe.subVectors(s, r), ae.subVectors(t, r);
        var a = re.dot(ae),
          c = oe.dot(ae);
        if (a <= 0 && c <= 0) return e.copy(r);
        ce.subVectors(t, o);
        var l = re.dot(ce),
          h = oe.dot(ce);
        if (l >= 0 && h <= l) return e.copy(o);
        var u = a * h - l * c;
        if (u <= 0 && a >= 0 && l <= 0)
          return (n = a / (a - l)), e.copy(r).addScaledVector(re, n);
        le.subVectors(t, s);
        var d = re.dot(le),
          p = oe.dot(le);
        if (p >= 0 && d <= p) return e.copy(s);
        var f = d * c - a * p;
        if (f <= 0 && c >= 0 && p <= 0)
          return (i = c / (c - p)), e.copy(r).addScaledVector(oe, i);
        var m = l * p - d * h;
        if (m <= 0 && h - l >= 0 && d - p >= 0)
          return (
            se.subVectors(s, o),
            (i = (h - l) / (h - l + (d - p))),
            e.copy(o).addScaledVector(se, i)
          );
        var b = 1 / (m + f + u);
        return (
          (n = f * b),
          (i = u * b),
          e.copy(r).addScaledVector(re, n).addScaledVector(oe, i)
        );
      },
      equals: function (t) {
        return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c);
      },
    });
  var ue = {
      aliceblue: 15792383,
      antiquewhite: 16444375,
      aqua: 65535,
      aquamarine: 8388564,
      azure: 15794175,
      beige: 16119260,
      bisque: 16770244,
      black: 0,
      blanchedalmond: 16772045,
      blue: 255,
      blueviolet: 9055202,
      brown: 10824234,
      burlywood: 14596231,
      cadetblue: 6266528,
      chartreuse: 8388352,
      chocolate: 13789470,
      coral: 16744272,
      cornflowerblue: 6591981,
      cornsilk: 16775388,
      crimson: 14423100,
      cyan: 65535,
      darkblue: 139,
      darkcyan: 35723,
      darkgoldenrod: 12092939,
      darkgray: 11119017,
      darkgreen: 25600,
      darkgrey: 11119017,
      darkkhaki: 12433259,
      darkmagenta: 9109643,
      darkolivegreen: 5597999,
      darkorange: 16747520,
      darkorchid: 10040012,
      darkred: 9109504,
      darksalmon: 15308410,
      darkseagreen: 9419919,
      darkslateblue: 4734347,
      darkslategray: 3100495,
      darkslategrey: 3100495,
      darkturquoise: 52945,
      darkviolet: 9699539,
      deeppink: 16716947,
      deepskyblue: 49151,
      dimgray: 6908265,
      dimgrey: 6908265,
      dodgerblue: 2003199,
      firebrick: 11674146,
      floralwhite: 16775920,
      forestgreen: 2263842,
      fuchsia: 16711935,
      gainsboro: 14474460,
      ghostwhite: 16316671,
      gold: 16766720,
      goldenrod: 14329120,
      gray: 8421504,
      green: 32768,
      greenyellow: 11403055,
      grey: 8421504,
      honeydew: 15794160,
      hotpink: 16738740,
      indianred: 13458524,
      indigo: 4915330,
      ivory: 16777200,
      khaki: 15787660,
      lavender: 15132410,
      lavenderblush: 16773365,
      lawngreen: 8190976,
      lemonchiffon: 16775885,
      lightblue: 11393254,
      lightcoral: 15761536,
      lightcyan: 14745599,
      lightgoldenrodyellow: 16448210,
      lightgray: 13882323,
      lightgreen: 9498256,
      lightgrey: 13882323,
      lightpink: 16758465,
      lightsalmon: 16752762,
      lightseagreen: 2142890,
      lightskyblue: 8900346,
      lightslategray: 7833753,
      lightslategrey: 7833753,
      lightsteelblue: 11584734,
      lightyellow: 16777184,
      lime: 65280,
      limegreen: 3329330,
      linen: 16445670,
      magenta: 16711935,
      maroon: 8388608,
      mediumaquamarine: 6737322,
      mediumblue: 205,
      mediumorchid: 12211667,
      mediumpurple: 9662683,
      mediumseagreen: 3978097,
      mediumslateblue: 8087790,
      mediumspringgreen: 64154,
      mediumturquoise: 4772300,
      mediumvioletred: 13047173,
      midnightblue: 1644912,
      mintcream: 16121850,
      mistyrose: 16770273,
      moccasin: 16770229,
      navajowhite: 16768685,
      navy: 128,
      oldlace: 16643558,
      olive: 8421376,
      olivedrab: 7048739,
      orange: 16753920,
      orangered: 16729344,
      orchid: 14315734,
      palegoldenrod: 15657130,
      palegreen: 10025880,
      paleturquoise: 11529966,
      palevioletred: 14381203,
      papayawhip: 16773077,
      peachpuff: 16767673,
      peru: 13468991,
      pink: 16761035,
      plum: 14524637,
      powderblue: 11591910,
      purple: 8388736,
      rebeccapurple: 6697881,
      red: 16711680,
      rosybrown: 12357519,
      royalblue: 4286945,
      saddlebrown: 9127187,
      salmon: 16416882,
      sandybrown: 16032864,
      seagreen: 3050327,
      seashell: 16774638,
      sienna: 10506797,
      silver: 12632256,
      skyblue: 8900331,
      slateblue: 6970061,
      slategray: 7372944,
      slategrey: 7372944,
      snow: 16775930,
      springgreen: 65407,
      steelblue: 4620980,
      tan: 13808780,
      teal: 32896,
      thistle: 14204888,
      tomato: 16737095,
      turquoise: 4251856,
      violet: 15631086,
      wheat: 16113331,
      white: 16777215,
      whitesmoke: 16119285,
      yellow: 16776960,
      yellowgreen: 10145074,
    },
    de = { h: 0, s: 0, l: 0 },
    pe = { h: 0, s: 0, l: 0 };
  function fe(t, e, n) {
    return void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n);
  }
  function me(t, e, n) {
    return (
      n < 0 && (n += 1),
      n > 1 && (n -= 1),
      n < 1 / 6
        ? t + 6 * (e - t) * n
        : n < 0.5
        ? e
        : n < 2 / 3
        ? t + 6 * (e - t) * (2 / 3 - n)
        : t
    );
  }
  function be(t) {
    return t < 0.04045
      ? 0.0773993808 * t
      : Math.pow(0.9478672986 * t + 0.0521327014, 2.4);
  }
  function ge(t) {
    return t < 0.0031308 ? 12.92 * t : 1.055 * Math.pow(t, 0.41666) - 0.055;
  }
  function ye(t, e, n, i, r, o) {
    (this.a = t),
      (this.b = e),
      (this.c = n),
      (this.normal = i && i.isVector3 ? i : new J()),
      (this.vertexNormals = Array.isArray(i) ? i : []),
      (this.color = r && r.isColor ? r : new fe()),
      (this.vertexColors = Array.isArray(r) ? r : []),
      (this.materialIndex = void 0 !== o ? o : 0);
  }
  Object.assign(fe.prototype, {
    isColor: !0,
    r: 1,
    g: 1,
    b: 1,
    set: function (t) {
      return (
        t && t.isColor
          ? this.copy(t)
          : 'number' == typeof t
          ? this.setHex(t)
          : 'string' == typeof t && this.setStyle(t),
        this
      );
    },
    setScalar: function (t) {
      return (this.r = t), (this.g = t), (this.b = t), this;
    },
    setHex: function (t) {
      return (
        (t = Math.floor(t)),
        (this.r = ((t >> 16) & 255) / 255),
        (this.g = ((t >> 8) & 255) / 255),
        (this.b = (255 & t) / 255),
        this
      );
    },
    setRGB: function (t, e, n) {
      return (this.r = t), (this.g = e), (this.b = n), this;
    },
    setHSL: function (t, e, n) {
      if (
        ((t = k.euclideanModulo(t, 1)),
        (e = k.clamp(e, 0, 1)),
        (n = k.clamp(n, 0, 1)),
        0 === e)
      )
        this.r = this.g = this.b = n;
      else {
        var i = n <= 0.5 ? n * (1 + e) : n + e - n * e,
          r = 2 * n - i;
        (this.r = me(r, i, t + 1 / 3)),
          (this.g = me(r, i, t)),
          (this.b = me(r, i, t - 1 / 3));
      }
      return this;
    },
    setStyle: function (t) {
      function e(e) {
        void 0 !== e &&
          parseFloat(e) < 1 &&
          console.warn(
            'THREE.Color: Alpha component of ' + t + ' will be ignored.',
          );
      }
      var n;
      if ((n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t))) {
        var i,
          r = n[1],
          o = n[2];
        switch (r) {
          case 'rgb':
          case 'rgba':
            if (
              (i =
                /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
                  o,
                ))
            )
              return (
                (this.r = Math.min(255, parseInt(i[1], 10)) / 255),
                (this.g = Math.min(255, parseInt(i[2], 10)) / 255),
                (this.b = Math.min(255, parseInt(i[3], 10)) / 255),
                e(i[5]),
                this
              );
            if (
              (i =
                /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
                  o,
                ))
            )
              return (
                (this.r = Math.min(100, parseInt(i[1], 10)) / 100),
                (this.g = Math.min(100, parseInt(i[2], 10)) / 100),
                (this.b = Math.min(100, parseInt(i[3], 10)) / 100),
                e(i[5]),
                this
              );
            break;
          case 'hsl':
          case 'hsla':
            if (
              (i =
                /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
                  o,
                ))
            ) {
              var s = parseFloat(i[1]) / 360,
                a = parseInt(i[2], 10) / 100,
                c = parseInt(i[3], 10) / 100;
              return e(i[5]), this.setHSL(s, a, c);
            }
        }
      } else if ((n = /^\#([A-Fa-f0-9]+)$/.exec(t))) {
        var l = n[1],
          h = l.length;
        if (3 === h)
          return (
            (this.r = parseInt(l.charAt(0) + l.charAt(0), 16) / 255),
            (this.g = parseInt(l.charAt(1) + l.charAt(1), 16) / 255),
            (this.b = parseInt(l.charAt(2) + l.charAt(2), 16) / 255),
            this
          );
        if (6 === h)
          return (
            (this.r = parseInt(l.charAt(0) + l.charAt(1), 16) / 255),
            (this.g = parseInt(l.charAt(2) + l.charAt(3), 16) / 255),
            (this.b = parseInt(l.charAt(4) + l.charAt(5), 16) / 255),
            this
          );
      }
      return t && t.length > 0 ? this.setColorName(t) : this;
    },
    setColorName: function (t) {
      var e = ue[t];
      return (
        void 0 !== e
          ? this.setHex(e)
          : console.warn('THREE.Color: Unknown color ' + t),
        this
      );
    },
    clone: function () {
      return new this.constructor(this.r, this.g, this.b);
    },
    copy: function (t) {
      return (this.r = t.r), (this.g = t.g), (this.b = t.b), this;
    },
    copyGammaToLinear: function (t, e) {
      return (
        void 0 === e && (e = 2),
        (this.r = Math.pow(t.r, e)),
        (this.g = Math.pow(t.g, e)),
        (this.b = Math.pow(t.b, e)),
        this
      );
    },
    copyLinearToGamma: function (t, e) {
      void 0 === e && (e = 2);
      var n = e > 0 ? 1 / e : 1;
      return (
        (this.r = Math.pow(t.r, n)),
        (this.g = Math.pow(t.g, n)),
        (this.b = Math.pow(t.b, n)),
        this
      );
    },
    convertGammaToLinear: function (t) {
      return this.copyGammaToLinear(this, t), this;
    },
    convertLinearToGamma: function (t) {
      return this.copyLinearToGamma(this, t), this;
    },
    copySRGBToLinear: function (t) {
      return (this.r = be(t.r)), (this.g = be(t.g)), (this.b = be(t.b)), this;
    },
    copyLinearToSRGB: function (t) {
      return (this.r = ge(t.r)), (this.g = ge(t.g)), (this.b = ge(t.b)), this;
    },
    convertSRGBToLinear: function () {
      return this.copySRGBToLinear(this), this;
    },
    convertLinearToSRGB: function () {
      return this.copyLinearToSRGB(this), this;
    },
    getHex: function () {
      return (
        ((255 * this.r) << 16) ^ ((255 * this.g) << 8) ^ ((255 * this.b) << 0)
      );
    },
    getHexString: function () {
      return ('000000' + this.getHex().toString(16)).slice(-6);
    },
    getHSL: function (t) {
      void 0 === t &&
        (console.warn('THREE.Color: .getHSL() target is now required'),
        (t = { h: 0, s: 0, l: 0 }));
      var e,
        n,
        i = this.r,
        r = this.g,
        o = this.b,
        s = Math.max(i, r, o),
        a = Math.min(i, r, o),
        c = (a + s) / 2;
      if (a === s) (e = 0), (n = 0);
      else {
        var l = s - a;
        switch (((n = c <= 0.5 ? l / (s + a) : l / (2 - s - a)), s)) {
          case i:
            e = (r - o) / l + (r < o ? 6 : 0);
            break;
          case r:
            e = (o - i) / l + 2;
            break;
          case o:
            e = (i - r) / l + 4;
        }
        e /= 6;
      }
      return (t.h = e), (t.s = n), (t.l = c), t;
    },
    getStyle: function () {
      return (
        'rgb(' +
        ((255 * this.r) | 0) +
        ',' +
        ((255 * this.g) | 0) +
        ',' +
        ((255 * this.b) | 0) +
        ')'
      );
    },
    offsetHSL: function (t, e, n) {
      return (
        this.getHSL(de),
        (de.h += t),
        (de.s += e),
        (de.l += n),
        this.setHSL(de.h, de.s, de.l),
        this
      );
    },
    add: function (t) {
      return (this.r += t.r), (this.g += t.g), (this.b += t.b), this;
    },
    addColors: function (t, e) {
      return (
        (this.r = t.r + e.r), (this.g = t.g + e.g), (this.b = t.b + e.b), this
      );
    },
    addScalar: function (t) {
      return (this.r += t), (this.g += t), (this.b += t), this;
    },
    sub: function (t) {
      return (
        (this.r = Math.max(0, this.r - t.r)),
        (this.g = Math.max(0, this.g - t.g)),
        (this.b = Math.max(0, this.b - t.b)),
        this
      );
    },
    multiply: function (t) {
      return (this.r *= t.r), (this.g *= t.g), (this.b *= t.b), this;
    },
    multiplyScalar: function (t) {
      return (this.r *= t), (this.g *= t), (this.b *= t), this;
    },
    lerp: function (t, e) {
      return (
        (this.r += (t.r - this.r) * e),
        (this.g += (t.g - this.g) * e),
        (this.b += (t.b - this.b) * e),
        this
      );
    },
    lerpHSL: function (t, e) {
      this.getHSL(de), t.getHSL(pe);
      var n = k.lerp(de.h, pe.h, e),
        i = k.lerp(de.s, pe.s, e),
        r = k.lerp(de.l, pe.l, e);
      return this.setHSL(n, i, r), this;
    },
    equals: function (t) {
      return t.r === this.r && t.g === this.g && t.b === this.b;
    },
    fromArray: function (t, e) {
      return (
        void 0 === e && (e = 0),
        (this.r = t[e]),
        (this.g = t[e + 1]),
        (this.b = t[e + 2]),
        this
      );
    },
    toArray: function (t, e) {
      return (
        void 0 === t && (t = []),
        void 0 === e && (e = 0),
        (t[e] = this.r),
        (t[e + 1] = this.g),
        (t[e + 2] = this.b),
        t
      );
    },
    toJSON: function () {
      return this.getHex();
    },
  }),
    (fe.NAMES = ue),
    Object.assign(ye.prototype, {
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (t) {
        (this.a = t.a),
          (this.b = t.b),
          (this.c = t.c),
          this.normal.copy(t.normal),
          this.color.copy(t.color),
          (this.materialIndex = t.materialIndex);
        for (var e = 0, n = t.vertexNormals.length; e < n; e++)
          this.vertexNormals[e] = t.vertexNormals[e].clone();
        for (e = 0, n = t.vertexColors.length; e < n; e++)
          this.vertexColors[e] = t.vertexColors[e].clone();
        return this;
      },
    });
  var ve = 0;
  function _e() {
    Object.defineProperty(this, 'id', { value: ve++ }),
      (this.uuid = k.generateUUID()),
      (this.name = ''),
      (this.type = 'Material'),
      (this.fog = !0),
      (this.blending = 1),
      (this.side = 0),
      (this.flatShading = !1),
      (this.vertexColors = !1),
      (this.opacity = 1),
      (this.transparent = !1),
      (this.blendSrc = 204),
      (this.blendDst = 205),
      (this.blendEquation = i),
      (this.blendSrcAlpha = null),
      (this.blendDstAlpha = null),
      (this.blendEquationAlpha = null),
      (this.depthFunc = 3),
      (this.depthTest = !0),
      (this.depthWrite = !0),
      (this.stencilWriteMask = 255),
      (this.stencilFunc = 519),
      (this.stencilRef = 0),
      (this.stencilFuncMask = 255),
      (this.stencilFail = R),
      (this.stencilZFail = R),
      (this.stencilZPass = R),
      (this.stencilWrite = !1),
      (this.clippingPlanes = null),
      (this.clipIntersection = !1),
      (this.clipShadows = !1),
      (this.shadowSide = null),
      (this.colorWrite = !0),
      (this.precision = null),
      (this.polygonOffset = !1),
      (this.polygonOffsetFactor = 0),
      (this.polygonOffsetUnits = 0),
      (this.dithering = !1),
      (this.alphaTest = 0),
      (this.premultipliedAlpha = !1),
      (this.visible = !0),
      (this.toneMapped = !0),
      (this.userData = {}),
      (this.version = 0),
      (this.vertexOffset = 0),
      (this.smoothLighting = !1),
      (this.depthRange = null);
  }
  function xe(t) {
    _e.call(this),
      (this.type = 'MeshBasicMaterial'),
      (this.color = new fe(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = 0),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = 'round'),
      (this.wireframeLinejoin = 'round'),
      (this.skinning = !1),
      (this.morphTargets = !1),
      this.setValues(t);
  }
  (_e.prototype = Object.assign(Object.create(B.prototype), {
    constructor: _e,
    isMaterial: !0,
    onBeforeCompile: function () {},
    setOpacity: function (t) {
      (this.opacity = t), (this.transparent = this.opacity < 0.99);
    },
    setVertexOffset: function (t) {
      this.vertexOffset = t;
    },
    setDepthRange: function (t) {
      this.depthRange = t;
    },
    setSmoothLighting: function (t) {
      this.smoothLighting = t;
    },
    setValues: function (t) {
      if (void 0 !== t)
        for (var e in t) {
          var n = t[e];
          if (void 0 !== n)
            if ('shading' !== e) {
              var i = this[e];
              void 0 !== i
                ? i && i.isColor
                  ? i.set(n)
                  : i && i.isVector3 && n && n.isVector3
                  ? i.copy(n)
                  : (this[e] = n)
                : console.warn(
                    'THREE.' +
                      this.type +
                      ": '" +
                      e +
                      "' is not a property of this material.",
                  );
            } else
              console.warn(
                'THREE.' +
                  this.type +
                  ': .shading has been removed. Use the boolean .flatShading instead.',
              ),
                (this.flatShading = 1 === n);
          else
            console.warn("THREE.Material: '" + e + "' parameter is undefined.");
        }
    },
    toJSON: function (t) {
      var e = void 0 === t || 'string' == typeof t;
      e && (t = { textures: {}, images: {} });
      var n = {
        metadata: {
          version: 4.5,
          type: 'Material',
          generator: 'Material.toJSON',
        },
      };
      function i(t) {
        var e = [];
        for (var n in t) {
          var i = t[n];
          delete i.metadata, e.push(i);
        }
        return e;
      }
      if (
        ((n.uuid = this.uuid),
        (n.type = this.type),
        '' !== this.name && (n.name = this.name),
        this.color && this.color.isColor && (n.color = this.color.getHex()),
        void 0 !== this.roughness && (n.roughness = this.roughness),
        void 0 !== this.metalness && (n.metalness = this.metalness),
        this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()),
        this.emissive &&
          this.emissive.isColor &&
          (n.emissive = this.emissive.getHex()),
        this.emissiveIntensity &&
          1 !== this.emissiveIntensity &&
          (n.emissiveIntensity = this.emissiveIntensity),
        this.specular &&
          this.specular.isColor &&
          (n.specular = this.specular.getHex()),
        void 0 !== this.shininess && (n.shininess = this.shininess),
        void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
        void 0 !== this.clearcoatRoughness &&
          (n.clearcoatRoughness = this.clearcoatRoughness),
        this.clearcoatMap &&
          this.clearcoatMap.isTexture &&
          (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid),
        this.clearcoatRoughnessMap &&
          this.clearcoatRoughnessMap.isTexture &&
          (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid),
        this.clearcoatNormalMap &&
          this.clearcoatNormalMap.isTexture &&
          ((n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid),
          (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
        this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid),
        this.matcap &&
          this.matcap.isTexture &&
          (n.matcap = this.matcap.toJSON(t).uuid),
        this.alphaMap &&
          this.alphaMap.isTexture &&
          (n.alphaMap = this.alphaMap.toJSON(t).uuid),
        this.lightMap &&
          this.lightMap.isTexture &&
          (n.lightMap = this.lightMap.toJSON(t).uuid),
        this.aoMap &&
          this.aoMap.isTexture &&
          ((n.aoMap = this.aoMap.toJSON(t).uuid),
          (n.aoMapIntensity = this.aoMapIntensity)),
        this.bumpMap &&
          this.bumpMap.isTexture &&
          ((n.bumpMap = this.bumpMap.toJSON(t).uuid),
          (n.bumpScale = this.bumpScale)),
        this.normalMap &&
          this.normalMap.isTexture &&
          ((n.normalMap = this.normalMap.toJSON(t).uuid),
          (n.normalMapType = this.normalMapType),
          (n.normalScale = this.normalScale.toArray())),
        this.displacementMap &&
          this.displacementMap.isTexture &&
          ((n.displacementMap = this.displacementMap.toJSON(t).uuid),
          (n.displacementScale = this.displacementScale),
          (n.displacementBias = this.displacementBias)),
        this.roughnessMap &&
          this.roughnessMap.isTexture &&
          (n.roughnessMap = this.roughnessMap.toJSON(t).uuid),
        this.metalnessMap &&
          this.metalnessMap.isTexture &&
          (n.metalnessMap = this.metalnessMap.toJSON(t).uuid),
        this.emissiveMap &&
          this.emissiveMap.isTexture &&
          (n.emissiveMap = this.emissiveMap.toJSON(t).uuid),
        this.specularMap &&
          this.specularMap.isTexture &&
          (n.specularMap = this.specularMap.toJSON(t).uuid),
        this.envMap &&
          this.envMap.isTexture &&
          ((n.envMap = this.envMap.toJSON(t).uuid),
          (n.reflectivity = this.reflectivity),
          (n.refractionRatio = this.refractionRatio),
          void 0 !== this.combine && (n.combine = this.combine),
          void 0 !== this.envMapIntensity &&
            (n.envMapIntensity = this.envMapIntensity)),
        this.gradientMap &&
          this.gradientMap.isTexture &&
          (n.gradientMap = this.gradientMap.toJSON(t).uuid),
        void 0 !== this.size && (n.size = this.size),
        void 0 !== this.sizeAttenuation &&
          (n.sizeAttenuation = this.sizeAttenuation),
        1 !== this.blending && (n.blending = this.blending),
        !0 === this.flatShading && (n.flatShading = this.flatShading),
        0 !== this.side && (n.side = this.side),
        this.vertexColors && (n.vertexColors = !0),
        this.opacity < 1 && (n.opacity = this.opacity),
        !0 === this.transparent && (n.transparent = this.transparent),
        (n.depthFunc = this.depthFunc),
        (n.depthTest = this.depthTest),
        (n.depthWrite = this.depthWrite),
        (n.stencilWrite = this.stencilWrite),
        (n.stencilWriteMask = this.stencilWriteMask),
        (n.stencilFunc = this.stencilFunc),
        (n.stencilRef = this.stencilRef),
        (n.stencilFuncMask = this.stencilFuncMask),
        (n.stencilFail = this.stencilFail),
        (n.stencilZFail = this.stencilZFail),
        (n.stencilZPass = this.stencilZPass),
        this.rotation && 0 !== this.rotation && (n.rotation = this.rotation),
        !0 === this.polygonOffset && (n.polygonOffset = !0),
        0 !== this.polygonOffsetFactor &&
          (n.polygonOffsetFactor = this.polygonOffsetFactor),
        0 !== this.polygonOffsetUnits &&
          (n.polygonOffsetUnits = this.polygonOffsetUnits),
        this.linewidth &&
          1 !== this.linewidth &&
          (n.linewidth = this.linewidth),
        void 0 !== this.dashSize && (n.dashSize = this.dashSize),
        void 0 !== this.gapSize && (n.gapSize = this.gapSize),
        void 0 !== this.scale && (n.scale = this.scale),
        !0 === this.dithering && (n.dithering = !0),
        this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
        !0 === this.premultipliedAlpha &&
          (n.premultipliedAlpha = this.premultipliedAlpha),
        !0 === this.wireframe && (n.wireframe = this.wireframe),
        this.wireframeLinewidth > 1 &&
          (n.wireframeLinewidth = this.wireframeLinewidth),
        'round' !== this.wireframeLinecap &&
          (n.wireframeLinecap = this.wireframeLinecap),
        'round' !== this.wireframeLinejoin &&
          (n.wireframeLinejoin = this.wireframeLinejoin),
        !0 === this.morphTargets && (n.morphTargets = !0),
        !0 === this.morphNormals && (n.morphNormals = !0),
        !0 === this.skinning && (n.skinning = !0),
        !1 === this.visible && (n.visible = !1),
        !1 === this.toneMapped && (n.toneMapped = !1),
        '{}' !== JSON.stringify(this.userData) && (n.userData = this.userData),
        e)
      ) {
        var r = i(t.textures),
          o = i(t.images);
        r.length > 0 && (n.textures = r), o.length > 0 && (n.images = o);
      }
      return n;
    },
    clone: function () {
      return new this.constructor().copy(this);
    },
    copy: function (t) {
      (this.name = t.name),
        (this.fog = t.fog),
        (this.blending = t.blending),
        (this.side = t.side),
        (this.flatShading = t.flatShading),
        (this.vertexColors = t.vertexColors),
        (this.opacity = t.opacity),
        (this.transparent = t.transparent),
        (this.blendSrc = t.blendSrc),
        (this.blendDst = t.blendDst),
        (this.blendEquation = t.blendEquation),
        (this.blendSrcAlpha = t.blendSrcAlpha),
        (this.blendDstAlpha = t.blendDstAlpha),
        (this.blendEquationAlpha = t.blendEquationAlpha),
        (this.depthFunc = t.depthFunc),
        (this.depthTest = t.depthTest),
        (this.depthWrite = t.depthWrite),
        (this.stencilWriteMask = t.stencilWriteMask),
        (this.stencilFunc = t.stencilFunc),
        (this.stencilRef = t.stencilRef),
        (this.stencilFuncMask = t.stencilFuncMask),
        (this.stencilFail = t.stencilFail),
        (this.stencilZFail = t.stencilZFail),
        (this.stencilZPass = t.stencilZPass),
        (this.stencilWrite = t.stencilWrite);
      var e = t.clippingPlanes,
        n = null;
      if (null !== e) {
        var i = e.length;
        n = new Array(i);
        for (var r = 0; r !== i; ++r) n[r] = e[r].clone();
      }
      return (
        (this.clippingPlanes = n),
        (this.clipIntersection = t.clipIntersection),
        (this.clipShadows = t.clipShadows),
        (this.shadowSide = t.shadowSide),
        (this.colorWrite = t.colorWrite),
        (this.precision = t.precision),
        (this.polygonOffset = t.polygonOffset),
        (this.polygonOffsetFactor = t.polygonOffsetFactor),
        (this.polygonOffsetUnits = t.polygonOffsetUnits),
        (this.dithering = t.dithering),
        (this.alphaTest = t.alphaTest),
        (this.premultipliedAlpha = t.premultipliedAlpha),
        (this.visible = t.visible),
        (this.toneMapped = t.toneMapped),
        (this.userData = JSON.parse(JSON.stringify(t.userData))),
        this
      );
    },
    dispose: function () {
      this.dispatchEvent({ type: 'dispose' });
    },
  })),
    Object.defineProperty(_e.prototype, 'needsUpdate', {
      set: function (t) {
        !0 === t && this.version++;
      },
    }),
    (xe.prototype = Object.assign(Object.create(_e.prototype), {
      constructor: xe,
      isMeshBasicMaterial: !0,
      copy: function (t) {
        return (
          _e.prototype.copy.call(this, t),
          this.color.copy(t.color),
          (this.map = t.map),
          (this.lightMap = t.lightMap),
          (this.lightMapIntensity = t.lightMapIntensity),
          (this.aoMap = t.aoMap),
          (this.aoMapIntensity = t.aoMapIntensity),
          (this.specularMap = t.specularMap),
          (this.alphaMap = t.alphaMap),
          (this.envMap = t.envMap),
          (this.combine = t.combine),
          (this.reflectivity = t.reflectivity),
          (this.refractionRatio = t.refractionRatio),
          (this.wireframe = t.wireframe),
          (this.wireframeLinewidth = t.wireframeLinewidth),
          (this.wireframeLinecap = t.wireframeLinecap),
          (this.wireframeLinejoin = t.wireframeLinejoin),
          (this.skinning = t.skinning),
          (this.morphTargets = t.morphTargets),
          this
        );
      },
    }));
  var we = new J();
  function Ae(t, e, n) {
    if (Array.isArray(t))
      throw new TypeError(
        'THREE.BufferAttribute: array should be a Typed Array.',
      );
    (this.name = ''),
      (this.array = t),
      (this.itemSize = e),
      (this.count = void 0 !== t ? t.length / e : 0),
      (this.normalized = !0 === n),
      (this.usage = F),
      (this.updateRange = { offset: 0, count: -1 }),
      (this.version = 0);
  }
  function Me(t, e, n) {
    Ae.call(this, new Int8Array(t), e, n);
  }
  function Se(t, e, n) {
    Ae.call(this, new Uint8Array(t), e, n);
  }
  function Ie(t, e, n) {
    Ae.call(this, new Uint8ClampedArray(t), e, n);
  }
  function Ee(t, e, n) {
    Ae.call(this, new Int16Array(t), e, n);
  }
  function De(t, e, n) {
    Ae.call(this, new Uint16Array(t), e, n);
  }
  function Ce(t, e, n) {
    Ae.call(this, new Int32Array(t), e, n);
  }
  function Te(t, e, n) {
    Ae.call(this, new Uint32Array(t), e, n);
  }
  function Le(t, e, n) {
    Ae.call(this, t, e, n);
  }
  function Re(t, e, n) {
    Ae.call(this, new Float32Array(t), e, n);
  }
  function Fe(t, e, n) {
    Ae.call(this, t, e, n);
  }
  function Pe(t, e, n) {
    Ae.call(this, new Float64Array(t), e, n);
  }
  function Be() {
    (this.vertices = []),
      (this.normals = []),
      (this.colors = []),
      (this.uvs = []),
      (this.uvs2 = []),
      (this.groups = []),
      (this.morphTargets = {}),
      (this.skinWeights = []),
      (this.skinIndices = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.verticesNeedUpdate = !1),
      (this.normalsNeedUpdate = !1),
      (this.colorsNeedUpdate = !1),
      (this.uvsNeedUpdate = !1),
      (this.groupsNeedUpdate = !1);
  }
  function Oe(t) {
    if (0 === t.length) return -1 / 0;
    for (var e = t[0], n = 1, i = t.length; n < i; ++n) t[n] > e && (e = t[n]);
    return e;
  }
  Object.defineProperty(Ae.prototype, 'needsUpdate', {
    set: function (t) {
      !0 === t && this.version++;
    },
  }),
    Object.assign(Ae.prototype, {
      isBufferAttribute: !0,
      onUploadCallback: function () {},
      setUsage: function (t) {
        return (this.usage = t), this;
      },
      copy: function (t) {
        return (
          (this.name = t.name),
          (this.array = new t.array.constructor(t.array)),
          (this.itemSize = t.itemSize),
          (this.count = t.count),
          (this.normalized = t.normalized),
          (this.usage = t.usage),
          this
        );
      },
      copyAt: function (t, e, n) {
        (t *= this.itemSize), (n *= e.itemSize);
        for (var i = 0, r = this.itemSize; i < r; i++)
          this.array[t + i] = e.array[n + i];
        return this;
      },
      copyArray: function (t) {
        return this.array.set(t), this;
      },
      copyColorsArray: function (t) {
        for (var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) {
          var o = t[i];
          void 0 === o &&
            (console.warn(
              'THREE.BufferAttribute.copyColorsArray(): color is undefined',
              i,
            ),
            (o = new fe())),
            (e[n++] = o.r),
            (e[n++] = o.g),
            (e[n++] = o.b);
        }
        return this;
      },
      copyVector2sArray: function (t) {
        for (var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) {
          var o = t[i];
          void 0 === o &&
            (console.warn(
              'THREE.BufferAttribute.copyVector2sArray(): vector is undefined',
              i,
            ),
            (o = new U())),
            (e[n++] = o.x),
            (e[n++] = o.y);
        }
        return this;
      },
      copyVector3sArray: function (t) {
        for (var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) {
          var o = t[i];
          void 0 === o &&
            (console.warn(
              'THREE.BufferAttribute.copyVector3sArray(): vector is undefined',
              i,
            ),
            (o = new J())),
            (e[n++] = o.x),
            (e[n++] = o.y),
            (e[n++] = o.z);
        }
        return this;
      },
      copyVector4sArray: function (t) {
        for (var e = this.array, n = 0, i = 0, r = t.length; i < r; i++) {
          var o = t[i];
          void 0 === o &&
            (console.warn(
              'THREE.BufferAttribute.copyVector4sArray(): vector is undefined',
              i,
            ),
            (o = new W())),
            (e[n++] = o.x),
            (e[n++] = o.y),
            (e[n++] = o.z),
            (e[n++] = o.w);
        }
        return this;
      },
      applyMatrix3: function (t) {
        for (var e = 0, n = this.count; e < n; e++)
          (we.x = this.getX(e)),
            (we.y = this.getY(e)),
            (we.z = this.getZ(e)),
            we.applyMatrix3(t),
            this.setXYZ(e, we.x, we.y, we.z);
        return this;
      },
      applyMatrix4: function (t) {
        for (var e = 0, n = this.count; e < n; e++)
          (we.x = this.getX(e)),
            (we.y = this.getY(e)),
            (we.z = this.getZ(e)),
            we.applyMatrix4(t),
            this.setXYZ(e, we.x, we.y, we.z);
        return this;
      },
      applyNormalMatrix: function (t) {
        for (var e = 0, n = this.count; e < n; e++)
          (we.x = this.getX(e)),
            (we.y = this.getY(e)),
            (we.z = this.getZ(e)),
            we.applyNormalMatrix(t),
            this.setXYZ(e, we.x, we.y, we.z);
        return this;
      },
      transformDirection: function (t) {
        for (var e = 0, n = this.count; e < n; e++)
          (we.x = this.getX(e)),
            (we.y = this.getY(e)),
            (we.z = this.getZ(e)),
            we.transformDirection(t),
            this.setXYZ(e, we.x, we.y, we.z);
        return this;
      },
      set: function (t, e) {
        return void 0 === e && (e = 0), this.array.set(t, e), this;
      },
      getX: function (t) {
        return this.array[t * this.itemSize];
      },
      setX: function (t, e) {
        return (this.array[t * this.itemSize] = e), this;
      },
      getY: function (t) {
        return this.array[t * this.itemSize + 1];
      },
      setY: function (t, e) {
        return (this.array[t * this.itemSize + 1] = e), this;
      },
      getZ: function (t) {
        return this.array[t * this.itemSize + 2];
      },
      setZ: function (t, e) {
        return (this.array[t * this.itemSize + 2] = e), this;
      },
      getW: function (t) {
        return this.array[t * this.itemSize + 3];
      },
      setW: function (t, e) {
        return (this.array[t * this.itemSize + 3] = e), this;
      },
      setXY: function (t, e, n) {
        return (
          (t *= this.itemSize),
          (this.array[t + 0] = e),
          (this.array[t + 1] = n),
          this
        );
      },
      setXYZ: function (t, e, n, i) {
        return (
          (t *= this.itemSize),
          (this.array[t + 0] = e),
          (this.array[t + 1] = n),
          (this.array[t + 2] = i),
          this
        );
      },
      setXYZW: function (t, e, n, i, r) {
        return (
          (t *= this.itemSize),
          (this.array[t + 0] = e),
          (this.array[t + 1] = n),
          (this.array[t + 2] = i),
          (this.array[t + 3] = r),
          this
        );
      },
      onUpload: function (t) {
        return (this.onUploadCallback = t), this;
      },
      clone: function () {
        return new this.constructor(this.array, this.itemSize).copy(this);
      },
      toJSON: function () {
        return {
          itemSize: this.itemSize,
          type: this.array.constructor.name,
          array: Array.prototype.slice.call(this.array),
          normalized: this.normalized,
        };
      },
    }),
    (Me.prototype = Object.create(Ae.prototype)),
    (Me.prototype.constructor = Me),
    (Se.prototype = Object.create(Ae.prototype)),
    (Se.prototype.constructor = Se),
    (Ie.prototype = Object.create(Ae.prototype)),
    (Ie.prototype.constructor = Ie),
    (Ee.prototype = Object.create(Ae.prototype)),
    (Ee.prototype.constructor = Ee),
    (De.prototype = Object.create(Ae.prototype)),
    (De.prototype.constructor = De),
    (Ce.prototype = Object.create(Ae.prototype)),
    (Ce.prototype.constructor = Ce),
    (Te.prototype = Object.create(Ae.prototype)),
    (Te.prototype.constructor = Te),
    (Le.prototype = Object.create(Ae.prototype)),
    (Le.prototype.constructor = Le),
    (Re.prototype = Object.create(Ae.prototype)),
    (Re.prototype.constructor = Re),
    (Fe.prototype = Object.create(Ae.prototype)),
    (Fe.prototype.constructor = Fe),
    (Pe.prototype = Object.create(Ae.prototype)),
    (Pe.prototype.constructor = Pe),
    Object.assign(Be.prototype, {
      computeGroups: function (t) {
        for (var e, n = [], i = void 0, r = t.faces, o = 0; o < r.length; o++) {
          var s = r[o];
          s.materialIndex !== i &&
            ((i = s.materialIndex),
            void 0 !== e && ((e.count = 3 * o - e.start), n.push(e)),
            (e = { start: 3 * o, materialIndex: i }));
        }
        void 0 !== e && ((e.count = 3 * o - e.start), n.push(e)),
          (this.groups = n);
      },
      fromGeometry: function (t) {
        var e,
          n = t.faces,
          i = t.vertices,
          r = t.faceVertexUvs,
          o = r[0] && r[0].length > 0,
          s = r[1] && r[1].length > 0,
          a = t.morphTargets,
          c = a.length;
        if (c > 0) {
          e = [];
          for (var l = 0; l < c; l++) e[l] = { name: a[l].name, data: [] };
          this.morphTargets.position = e;
        }
        var h,
          u = t.morphNormals,
          d = u.length;
        if (d > 0) {
          h = [];
          for (l = 0; l < d; l++) h[l] = { name: u[l].name, data: [] };
          this.morphTargets.normal = h;
        }
        var p = t.skinIndices,
          f = t.skinWeights,
          m = p.length === i.length,
          b = f.length === i.length;
        i.length > 0 &&
          0 === n.length &&
          console.error(
            'THREE.DirectGeometry: Faceless geometries are not supported.',
          );
        for (l = 0; l < n.length; l++) {
          var g = n[l];
          this.vertices.push(i[g.a], i[g.b], i[g.c]);
          var y = g.vertexNormals;
          if (3 === y.length) this.normals.push(y[0], y[1], y[2]);
          else {
            var v = g.normal;
            this.normals.push(v, v, v);
          }
          var _,
            x = g.vertexColors;
          if (3 === x.length) this.colors.push(x[0], x[1], x[2]);
          else {
            var w = g.color;
            this.colors.push(w, w, w);
          }
          if (!0 === o)
            void 0 !== (_ = r[0][l])
              ? this.uvs.push(_[0], _[1], _[2])
              : (console.warn(
                  'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ',
                  l,
                ),
                this.uvs.push(new U(), new U(), new U()));
          if (!0 === s)
            void 0 !== (_ = r[1][l])
              ? this.uvs2.push(_[0], _[1], _[2])
              : (console.warn(
                  'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ',
                  l,
                ),
                this.uvs2.push(new U(), new U(), new U()));
          for (var A = 0; A < c; A++) {
            var M = a[A].vertices;
            e[A].data.push(M[g.a], M[g.b], M[g.c]);
          }
          for (A = 0; A < d; A++) {
            var S = u[A].vertexNormals[l];
            h[A].data.push(S.a, S.b, S.c);
          }
          m && this.skinIndices.push(p[g.a], p[g.b], p[g.c]),
            b && this.skinWeights.push(f[g.a], f[g.b], f[g.c]);
        }
        return (
          this.computeGroups(t),
          (this.verticesNeedUpdate = t.verticesNeedUpdate),
          (this.normalsNeedUpdate = t.normalsNeedUpdate),
          (this.colorsNeedUpdate = t.colorsNeedUpdate),
          (this.uvsNeedUpdate = t.uvsNeedUpdate),
          (this.groupsNeedUpdate = t.groupsNeedUpdate),
          null !== t.boundingSphere &&
            (this.boundingSphere = t.boundingSphere.clone()),
          null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
          this
        );
      },
    });
  var Ve = 1,
    Ne = new ot(),
    ke = new At(),
    Ue = new J(),
    Ge = new Nt(),
    ze = new Nt(),
    je = new J();
  function He() {
    Object.defineProperty(this, 'id', { value: (Ve += 2) }),
      (this.uuid = k.generateUUID()),
      (this.name = ''),
      (this.type = 'BufferGeometry'),
      (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.morphTargetsRelative = !1),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.drawRange = { start: 0, count: 1 / 0 }),
      (this.userData = {});
  }
  He.prototype = Object.assign(Object.create(B.prototype), {
    constructor: He,
    isBufferGeometry: !0,
    getIndex: function () {
      return this.index;
    },
    setIndex: function (t) {
      Array.isArray(t)
        ? (this.index = new (Oe(t) > 65535 ? Te : De)(t, 1))
        : (this.index = t);
    },
    getAttribute: function (t) {
      return this.attributes[t];
    },
    setAttribute: function (t, e) {
      return (this.attributes[t] = e), this;
    },
    deleteAttribute: function (t) {
      return delete this.attributes[t], this;
    },
    addGroup: function (t, e, n) {
      this.groups.push({
        start: t,
        count: e,
        materialIndex: void 0 !== n ? n : 0,
      });
    },
    clearGroups: function () {
      this.groups = [];
    },
    setDrawRange: function (t, e) {
      (this.drawRange.start = t), (this.drawRange.count = e);
    },
    applyMatrix4: function (t) {
      var e = this.attributes.position;
      void 0 !== e && (e.applyMatrix4(t), (e.needsUpdate = !0));
      var n = this.attributes.normal;
      if (void 0 !== n) {
        var i = new G().getNormalMatrix(t);
        n.applyNormalMatrix(i), (n.needsUpdate = !0);
      }
      var r = this.attributes.tangent;
      return (
        void 0 !== r && (r.transformDirection(t), (r.needsUpdate = !0)),
        null !== this.boundingBox && this.computeBoundingBox(),
        null !== this.boundingSphere && this.computeBoundingSphere(),
        this
      );
    },
    rotateX: function (t) {
      return Ne.makeRotationX(t), this.applyMatrix4(Ne), this;
    },
    rotateY: function (t) {
      return Ne.makeRotationY(t), this.applyMatrix4(Ne), this;
    },
    rotateZ: function (t) {
      return Ne.makeRotationZ(t), this.applyMatrix4(Ne), this;
    },
    translate: function (t, e, n) {
      return Ne.makeTranslation(t, e, n), this.applyMatrix4(Ne), this;
    },
    scale: function (t, e, n) {
      return Ne.makeScale(t, e, n), this.applyMatrix4(Ne), this;
    },
    lookAt: function (t) {
      return (
        ke.lookAt(t), ke.updateMatrix(), this.applyMatrix4(ke.matrix), this
      );
    },
    center: function () {
      return (
        this.computeBoundingBox(),
        this.boundingBox.getCenter(Ue).negate(),
        this.translate(Ue.x, Ue.y, Ue.z),
        this
      );
    },
    setFromObject: function (t) {
      var e = t.geometry;
      if (t.isPoints || t.isLine) {
        var n = new Re(3 * e.vertices.length, 3),
          i = new Re(3 * e.colors.length, 3);
        if (
          (this.setAttribute('position', n.copyVector3sArray(e.vertices)),
          this.setAttribute('color', i.copyColorsArray(e.colors)),
          e.lineDistances && e.lineDistances.length === e.vertices.length)
        ) {
          var r = new Re(e.lineDistances.length, 1);
          this.setAttribute('lineDistance', r.copyArray(e.lineDistances));
        }
        null !== e.boundingSphere &&
          (this.boundingSphere = e.boundingSphere.clone()),
          null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone());
      } else t.isMesh && e && e.isGeometry && this.fromGeometry(e);
      return this;
    },
    setFromPoints: function (t) {
      for (var e = [], n = 0, i = t.length; n < i; n++) {
        var r = t[n];
        e.push(r.x, r.y, r.z || 0);
      }
      return this.setAttribute('position', new Re(e, 3)), this;
    },
    updateFromObject: function (t) {
      var e,
        n = t.geometry;
      if (t.isMesh) {
        var i = n.__directGeometry;
        if (
          (!0 === n.elementsNeedUpdate &&
            ((i = void 0), (n.elementsNeedUpdate = !1)),
          void 0 === i)
        )
          return this.fromGeometry(n);
        (i.verticesNeedUpdate = n.verticesNeedUpdate),
          (i.normalsNeedUpdate = n.normalsNeedUpdate),
          (i.colorsNeedUpdate = n.colorsNeedUpdate),
          (i.uvsNeedUpdate = n.uvsNeedUpdate),
          (i.groupsNeedUpdate = n.groupsNeedUpdate),
          (n.verticesNeedUpdate = !1),
          (n.normalsNeedUpdate = !1),
          (n.colorsNeedUpdate = !1),
          (n.uvsNeedUpdate = !1),
          (n.groupsNeedUpdate = !1),
          (n = i);
      }
      return (
        !0 === n.verticesNeedUpdate &&
          (void 0 !== (e = this.attributes.position) &&
            (e.copyVector3sArray(n.vertices), (e.needsUpdate = !0)),
          (n.verticesNeedUpdate = !1)),
        !0 === n.normalsNeedUpdate &&
          (void 0 !== (e = this.attributes.normal) &&
            (e.copyVector3sArray(n.normals), (e.needsUpdate = !0)),
          (n.normalsNeedUpdate = !1)),
        !0 === n.colorsNeedUpdate &&
          (void 0 !== (e = this.attributes.color) &&
            (e.copyColorsArray(n.colors), (e.needsUpdate = !0)),
          (n.colorsNeedUpdate = !1)),
        n.uvsNeedUpdate &&
          (void 0 !== (e = this.attributes.uv) &&
            (e.copyVector2sArray(n.uvs), (e.needsUpdate = !0)),
          (n.uvsNeedUpdate = !1)),
        n.lineDistancesNeedUpdate &&
          (void 0 !== (e = this.attributes.lineDistance) &&
            (e.copyArray(n.lineDistances), (e.needsUpdate = !0)),
          (n.lineDistancesNeedUpdate = !1)),
        n.groupsNeedUpdate &&
          (n.computeGroups(t.geometry),
          (this.groups = n.groups),
          (n.groupsNeedUpdate = !1)),
        this
      );
    },
    fromGeometry: function (t) {
      return (
        (t.__directGeometry = new Be().fromGeometry(t)),
        this.fromDirectGeometry(t.__directGeometry)
      );
    },
    fromDirectGeometry: function (t) {
      var e = new Float32Array(3 * t.vertices.length);
      if (
        (this.setAttribute(
          'position',
          new Ae(e, 3).copyVector3sArray(t.vertices),
        ),
        t.normals.length > 0)
      ) {
        var n = new Float32Array(3 * t.normals.length);
        this.setAttribute('normal', new Ae(n, 3).copyVector3sArray(t.normals));
      }
      if (t.colors.length > 0) {
        var i = new Float32Array(3 * t.colors.length);
        this.setAttribute('color', new Ae(i, 3).copyColorsArray(t.colors));
      }
      if (t.uvs.length > 0) {
        var r = new Float32Array(2 * t.uvs.length);
        this.setAttribute('uv', new Ae(r, 2).copyVector2sArray(t.uvs));
      }
      if (t.uvs2.length > 0) {
        var o = new Float32Array(2 * t.uvs2.length);
        this.setAttribute('uv2', new Ae(o, 2).copyVector2sArray(t.uvs2));
      }
      for (var s in ((this.groups = t.groups), t.morphTargets)) {
        for (
          var a = [], c = t.morphTargets[s], l = 0, h = c.length;
          l < h;
          l++
        ) {
          var u = c[l],
            d = new Re(3 * u.data.length, 3);
          (d.name = u.name), a.push(d.copyVector3sArray(u.data));
        }
        this.morphAttributes[s] = a;
      }
      if (t.skinIndices.length > 0) {
        var p = new Re(4 * t.skinIndices.length, 4);
        this.setAttribute('skinIndex', p.copyVector4sArray(t.skinIndices));
      }
      if (t.skinWeights.length > 0) {
        var f = new Re(4 * t.skinWeights.length, 4);
        this.setAttribute('skinWeight', f.copyVector4sArray(t.skinWeights));
      }
      return (
        null !== t.boundingSphere &&
          (this.boundingSphere = t.boundingSphere.clone()),
        null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
        this
      );
    },
    computeBoundingBox: function () {
      null === this.boundingBox && (this.boundingBox = new Nt());
      var t = this.attributes.position,
        e = this.morphAttributes.position;
      if (void 0 !== t) {
        if ((this.boundingBox.setFromBufferAttribute(t), e))
          for (var n = 0, i = e.length; n < i; n++) {
            var r = e[n];
            Ge.setFromBufferAttribute(r),
              this.morphTargetsRelative
                ? (je.addVectors(this.boundingBox.min, Ge.min),
                  this.boundingBox.expandByPoint(je),
                  je.addVectors(this.boundingBox.max, Ge.max),
                  this.boundingBox.expandByPoint(je))
                : (this.boundingBox.expandByPoint(Ge.min),
                  this.boundingBox.expandByPoint(Ge.max));
          }
      } else this.boundingBox.makeEmpty();
      (isNaN(this.boundingBox.min.x) ||
        isNaN(this.boundingBox.min.y) ||
        isNaN(this.boundingBox.min.z)) &&
        console.error(
          'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
          this,
        );
    },
    computeBoundingSphere: function () {
      null === this.boundingSphere && (this.boundingSphere = new Gt());
      var t = this.attributes.position,
        e = this.morphAttributes.position;
      if (t) {
        var n = this.boundingSphere.center;
        if ((Ge.setFromBufferAttribute(t), e))
          for (var i = 0, r = e.length; i < r; i++) {
            var o = e[i];
            ze.setFromBufferAttribute(o),
              this.morphTargetsRelative
                ? (je.addVectors(Ge.min, ze.min),
                  Ge.expandByPoint(je),
                  je.addVectors(Ge.max, ze.max),
                  Ge.expandByPoint(je))
                : (Ge.expandByPoint(ze.min), Ge.expandByPoint(ze.max));
          }
        Ge.getCenter(n);
        var s = 0;
        for (i = 0, r = t.count; i < r; i++)
          je.fromBufferAttribute(t, i),
            (s = Math.max(s, n.distanceToSquared(je)));
        if (e)
          for (i = 0, r = e.length; i < r; i++) {
            o = e[i];
            for (
              var a = this.morphTargetsRelative, c = 0, l = o.count;
              c < l;
              c++
            )
              je.fromBufferAttribute(o, c),
                a && (Ue.fromBufferAttribute(t, c), je.add(Ue)),
                (s = Math.max(s, n.distanceToSquared(je)));
          }
        (this.boundingSphere.radius = Math.sqrt(s)),
          isNaN(this.boundingSphere.radius) &&
            console.error(
              'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
              this,
            );
      }
    },
    updateBounding: function () {
      this.boundingBox &&
        (this.boundingBox.makeEmpty(), this.computeBoundingBox()),
        this.boundingSphere && this.computeBoundingSphere();
    },
    computeFaceNormals: function () {},
    computeVertexNormals: function () {
      var t = this.index,
        e = this.attributes;
      if (e.position) {
        var n = e.position.array;
        if (void 0 === e.normal)
          this.setAttribute('normal', new Ae(new Float32Array(n.length), 3));
        else
          for (var i = e.normal.array, r = 0, o = i.length; r < o; r++)
            i[r] = 0;
        var s,
          a,
          c,
          l = e.normal.array,
          h = new J(),
          u = new J(),
          d = new J(),
          p = new J(),
          f = new J();
        if (t) {
          var m = t.array;
          for (r = 0, o = t.count; r < o; r += 3)
            (s = 3 * m[r + 0]),
              (a = 3 * m[r + 1]),
              (c = 3 * m[r + 2]),
              h.fromArray(n, s),
              u.fromArray(n, a),
              d.fromArray(n, c),
              p.subVectors(d, u),
              f.subVectors(h, u),
              p.cross(f),
              (l[s] += p.x),
              (l[s + 1] += p.y),
              (l[s + 2] += p.z),
              (l[a] += p.x),
              (l[a + 1] += p.y),
              (l[a + 2] += p.z),
              (l[c] += p.x),
              (l[c + 1] += p.y),
              (l[c + 2] += p.z);
        } else
          for (r = 0, o = n.length; r < o; r += 9)
            h.fromArray(n, r),
              u.fromArray(n, r + 3),
              d.fromArray(n, r + 6),
              p.subVectors(d, u),
              f.subVectors(h, u),
              p.cross(f),
              (l[r] = p.x),
              (l[r + 1] = p.y),
              (l[r + 2] = p.z),
              (l[r + 3] = p.x),
              (l[r + 4] = p.y),
              (l[r + 5] = p.z),
              (l[r + 6] = p.x),
              (l[r + 7] = p.y),
              (l[r + 8] = p.z);
        this.normalizeNormals(), (e.normal.needsUpdate = !0);
      }
    },
    merge: function (t, e) {
      if (t && t.isBufferGeometry) {
        void 0 === e &&
          ((e = 0),
          console.warn(
            'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.',
          ));
        var n = this.attributes;
        for (var i in n)
          if (void 0 !== t.attributes[i])
            for (
              var r = n[i].array,
                o = t.attributes[i],
                s = o.array,
                a = o.itemSize * e,
                c = Math.min(s.length, r.length - a),
                l = 0,
                h = a;
              l < c;
              l++, h++
            )
              r[h] = s[l];
        return this;
      }
      console.error(
        'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.',
        t,
      );
    },
    normalizeNormals: function () {
      for (var t = this.attributes.normal, e = 0, n = t.count; e < n; e++)
        (je.x = t.getX(e)),
          (je.y = t.getY(e)),
          (je.z = t.getZ(e)),
          je.normalize(),
          t.setXYZ(e, je.x, je.y, je.z);
    },
    toNonIndexed: function () {
      function t(t, e) {
        for (
          var n = t.array,
            i = t.itemSize,
            r = new n.constructor(e.length * i),
            o = 0,
            s = 0,
            a = 0,
            c = e.length;
          a < c;
          a++
        ) {
          o = e[a] * i;
          for (var l = 0; l < i; l++) r[s++] = n[o++];
        }
        return new Ae(r, i);
      }
      if (null === this.index)
        return (
          console.warn(
            'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.',
          ),
          this
        );
      var e = new He(),
        n = this.index.array,
        i = this.attributes;
      for (var r in i) {
        var o = t(i[r], n);
        e.setAttribute(r, o);
      }
      var s = this.morphAttributes;
      for (r in s) {
        for (var a = [], c = s[r], l = 0, h = c.length; l < h; l++) {
          o = t(c[l], n);
          a.push(o);
        }
        e.morphAttributes[r] = a;
      }
      e.morphTargetsRelative = this.morphTargetsRelative;
      for (var u = this.groups, d = ((l = 0), u.length); l < d; l++) {
        var p = u[l];
        e.addGroup(p.start, p.count, p.materialIndex);
      }
      return e;
    },
    toJSON: function () {
      var t = {
        metadata: {
          version: 4.5,
          type: 'BufferGeometry',
          generator: 'BufferGeometry.toJSON',
        },
      };
      if (
        ((t.uuid = this.uuid),
        (t.type = this.type),
        '' !== this.name && (t.name = this.name),
        Object.keys(this.userData).length > 0 && (t.userData = this.userData),
        void 0 !== this.parameters)
      ) {
        var e = this.parameters;
        for (var n in e) void 0 !== e[n] && (t[n] = e[n]);
        return t;
      }
      t.data = { attributes: {} };
      var i = this.index;
      null !== i &&
        (t.data.index = {
          type: i.array.constructor.name,
          array: Array.prototype.slice.call(i.array),
        });
      var r = this.attributes;
      for (var n in r) {
        var o = (d = r[n]).toJSON();
        '' !== d.name && (o.name = d.name), (t.data.attributes[n] = o);
      }
      var s = {},
        a = !1;
      for (var n in this.morphAttributes) {
        for (
          var c = this.morphAttributes[n], l = [], h = 0, u = c.length;
          h < u;
          h++
        ) {
          var d;
          o = (d = c[h]).toJSON();
          '' !== d.name && (o.name = d.name), l.push(o);
        }
        l.length > 0 && ((s[n] = l), (a = !0));
      }
      a &&
        ((t.data.morphAttributes = s),
        (t.data.morphTargetsRelative = this.morphTargetsRelative));
      var p = this.groups;
      p.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(p)));
      var f = this.boundingSphere;
      return (
        null !== f &&
          (t.data.boundingSphere = {
            center: f.center.toArray(),
            radius: f.radius,
          }),
        t
      );
    },
    clone: function () {
      return new He().copy(this);
    },
    copy: function (t) {
      var e, n, i;
      (this.index = null),
        (this.attributes = {}),
        (this.morphAttributes = {}),
        (this.groups = []),
        (this.boundingBox = null),
        (this.boundingSphere = null),
        (this.name = t.name);
      var r = t.index;
      null !== r && this.setIndex(r.clone());
      var o = t.attributes;
      for (e in o) {
        var s = o[e];
        this.setAttribute(e, s.clone());
      }
      var a = t.morphAttributes;
      for (e in a) {
        var c = [],
          l = a[e];
        for (n = 0, i = l.length; n < i; n++) c.push(l[n].clone());
        this.morphAttributes[e] = c;
      }
      this.morphTargetsRelative = t.morphTargetsRelative;
      var h = t.groups;
      for (n = 0, i = h.length; n < i; n++) {
        var u = h[n];
        this.addGroup(u.start, u.count, u.materialIndex);
      }
      var d = t.boundingBox;
      null !== d && (this.boundingBox = d.clone());
      var p = t.boundingSphere;
      return (
        null !== p && (this.boundingSphere = p.clone()),
        (this.drawRange.start = t.drawRange.start),
        (this.drawRange.count = t.drawRange.count),
        (this.userData = t.userData),
        this
      );
    },
    dispose: function () {
      this.dispatchEvent({ type: 'dispose' });
    },
  });
  var We = new ot(),
    Xe = new qt(),
    Ze = new Gt(),
    Ye = new J(),
    qe = new J(),
    Qe = new J(),
    Je = new J(),
    $e = new J(),
    Ke = new J(),
    tn = new J(),
    en = new J(),
    nn = new J(),
    rn = new U(),
    on = new U(),
    sn = new U(),
    an = new J(),
    cn = new J();
  function ln(t, e) {
    At.call(this),
      (this.type = 'Mesh'),
      (this.geometry = void 0 !== t ? t : new He()),
      (this.material = void 0 !== e ? e : new xe()),
      this.updateMorphTargets();
  }
  function hn(t, e, n, i, r, o, s, a) {
    if (
      null ===
      (1 === e.side
        ? i.intersectTriangle(s, o, r, !0, a)
        : i.intersectTriangle(r, o, s, 2 !== e.side, a))
    )
      return null;
    cn.copy(a), cn.applyMatrix4(t.matrixWorld);
    var c = n.ray.origin.distanceTo(cn);
    return c < n.near || c > n.far
      ? null
      : { distance: c, point: cn.clone(), object: t };
  }
  function un(t, e, n, i, r, o, s, a, c, l, h, u) {
    Ye.fromBufferAttribute(r, l),
      qe.fromBufferAttribute(r, h),
      Qe.fromBufferAttribute(r, u);
    var d = t.morphTargetInfluences;
    if (e.morphTargets && o && d) {
      tn.set(0, 0, 0), en.set(0, 0, 0), nn.set(0, 0, 0);
      for (var p = 0, f = o.length; p < f; p++) {
        var m = d[p],
          b = o[p];
        0 !== m &&
          (Je.fromBufferAttribute(b, l),
          $e.fromBufferAttribute(b, h),
          Ke.fromBufferAttribute(b, u),
          s
            ? (tn.addScaledVector(Je, m),
              en.addScaledVector($e, m),
              nn.addScaledVector(Ke, m))
            : (tn.addScaledVector(Je.sub(Ye), m),
              en.addScaledVector($e.sub(qe), m),
              nn.addScaledVector(Ke.sub(Qe), m)));
      }
      Ye.add(tn), qe.add(en), Qe.add(nn);
    }
    var g = hn(t, e, n, i, Ye, qe, Qe, an);
    if (g) {
      a &&
        (rn.fromBufferAttribute(a, l),
        on.fromBufferAttribute(a, h),
        sn.fromBufferAttribute(a, u),
        (g.uv = he.getUV(an, Ye, qe, Qe, rn, on, sn, new U()))),
        c &&
          (rn.fromBufferAttribute(c, l),
          on.fromBufferAttribute(c, h),
          sn.fromBufferAttribute(c, u),
          (g.uv2 = he.getUV(an, Ye, qe, Qe, rn, on, sn, new U())));
      var y = new ye(l, h, u);
      he.getNormal(Ye, qe, Qe, y.normal), (g.face = y);
    }
    return g;
  }
  ln.prototype = Object.assign(Object.create(At.prototype), {
    constructor: ln,
    isMesh: !0,
    copy: function (t) {
      return (
        At.prototype.copy.call(this, t),
        void 0 !== t.morphTargetInfluences &&
          (this.morphTargetInfluences = t.morphTargetInfluences.slice()),
        void 0 !== t.morphTargetDictionary &&
          (this.morphTargetDictionary = Object.assign(
            {},
            t.morphTargetDictionary,
          )),
        this
      );
    },
    updateMorphTargets: function () {
      var t,
        e,
        n,
        i = this.geometry;
      if (i.isBufferGeometry) {
        var r = i.morphAttributes,
          o = Object.keys(r);
        if (o.length > 0) {
          var s = r[o[0]];
          if (void 0 !== s)
            for (
              this.morphTargetInfluences = [],
                this.morphTargetDictionary = {},
                t = 0,
                e = s.length;
              t < e;
              t++
            )
              (n = s[t].name || String(t)),
                this.morphTargetInfluences.push(0),
                (this.morphTargetDictionary[n] = t);
        }
      } else {
        var a = i.morphTargets;
        void 0 !== a &&
          a.length > 0 &&
          console.error(
            'THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.',
          );
      }
    },
    raycast: function (t, e) {
      var n,
        i = this.geometry,
        r = this.material,
        o = this.matrixWorld;
      if (
        void 0 !== r &&
        (null === i.boundingSphere && i.computeBoundingSphere(),
        Ze.copy(i.boundingSphere),
        Ze.applyMatrix4(o),
        !1 !== t.ray.intersectsSphere(Ze) &&
          (We.getInverse(o),
          Xe.copy(t.ray).applyMatrix4(We),
          null === i.boundingBox || !1 !== Xe.intersectsBox(i.boundingBox)))
      )
        if (i.isBufferGeometry) {
          var s,
            a,
            c,
            l,
            h,
            u,
            d,
            p,
            f,
            m = i.index,
            b = i.attributes.position,
            g = i.morphAttributes.position,
            y = i.morphTargetsRelative,
            v = i.attributes.uv,
            _ = i.attributes.uv2,
            x = i.groups,
            w = i.drawRange;
          if (null !== m)
            if (Array.isArray(r))
              for (l = 0, u = x.length; l < u; l++)
                for (
                  f = r[(p = x[l]).materialIndex],
                    h = Math.max(p.start, w.start),
                    d = Math.min(p.start + p.count, w.start + w.count);
                  h < d;
                  h += 3
                )
                  (s = m.getX(h)),
                    (a = m.getX(h + 1)),
                    (c = m.getX(h + 2)),
                    (n = un(this, f, t, Xe, b, g, y, v, _, s, a, c)) &&
                      ((n.faceIndex = Math.floor(h / 3)),
                      (n.face.materialIndex = p.materialIndex),
                      e.push(n));
            else
              for (
                l = Math.max(0, w.start),
                  u = Math.min(m.count, w.start + w.count);
                l < u;
                l += 3
              )
                (s = m.getX(l)),
                  (a = m.getX(l + 1)),
                  (c = m.getX(l + 2)),
                  (n = un(this, r, t, Xe, b, g, y, v, _, s, a, c)) &&
                    ((n.faceIndex = Math.floor(l / 3)), e.push(n));
          else if (void 0 !== b)
            if (Array.isArray(r))
              for (l = 0, u = x.length; l < u; l++)
                for (
                  f = r[(p = x[l]).materialIndex],
                    h = Math.max(p.start, w.start),
                    d = Math.min(p.start + p.count, w.start + w.count);
                  h < d;
                  h += 3
                )
                  (n = un(
                    this,
                    f,
                    t,
                    Xe,
                    b,
                    g,
                    y,
                    v,
                    _,
                    (s = h),
                    (a = h + 1),
                    (c = h + 2),
                  )) &&
                    ((n.faceIndex = Math.floor(h / 3)),
                    (n.face.materialIndex = p.materialIndex),
                    e.push(n));
            else
              for (
                l = Math.max(0, w.start),
                  u = Math.min(b.count, w.start + w.count);
                l < u;
                l += 3
              )
                (n = un(
                  this,
                  r,
                  t,
                  Xe,
                  b,
                  g,
                  y,
                  v,
                  _,
                  (s = l),
                  (a = l + 1),
                  (c = l + 2),
                )) && ((n.faceIndex = Math.floor(l / 3)), e.push(n));
        } else if (i.isGeometry) {
          var A,
            M,
            S,
            I,
            E = Array.isArray(r),
            D = i.vertices,
            C = i.faces,
            T = i.faceVertexUvs[0];
          T.length > 0 && (I = T);
          for (var L = 0, R = C.length; L < R; L++) {
            var F = C[L],
              P = E ? r[F.materialIndex] : r;
            if (
              void 0 !== P &&
              ((A = D[F.a]),
              (M = D[F.b]),
              (S = D[F.c]),
              (n = hn(this, P, t, Xe, A, M, S, an)))
            ) {
              if (I && I[L]) {
                var B = I[L];
                rn.copy(B[0]),
                  on.copy(B[1]),
                  sn.copy(B[2]),
                  (n.uv = he.getUV(an, A, M, S, rn, on, sn, new U()));
              }
              (n.face = F), (n.faceIndex = L), e.push(n);
            }
          }
        }
    },
    clone: function () {
      return new this.constructor(this.geometry, this.material).copy(this);
    },
  });
  var dn = 0,
    pn = new ot(),
    fn = new At(),
    mn = new J();
  function bn() {
    Object.defineProperty(this, 'id', { value: (dn += 2) }),
      (this.uuid = k.generateUUID()),
      (this.name = ''),
      (this.type = 'Geometry'),
      (this.vertices = []),
      (this.colors = []),
      (this.faces = []),
      (this.faceVertexUvs = [[]]),
      (this.morphTargets = []),
      (this.morphNormals = []),
      (this.skinWeights = []),
      (this.skinIndices = []),
      (this.lineDistances = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.elementsNeedUpdate = !1),
      (this.verticesNeedUpdate = !1),
      (this.uvsNeedUpdate = !1),
      (this.normalsNeedUpdate = !1),
      (this.colorsNeedUpdate = !1),
      (this.lineDistancesNeedUpdate = !1),
      (this.groupsNeedUpdate = !1);
  }
  bn.prototype = Object.assign(Object.create(B.prototype), {
    constructor: bn,
    isGeometry: !0,
    applyMatrix4: function (t) {
      for (
        var e = new G().getNormalMatrix(t), n = 0, i = this.vertices.length;
        n < i;
        n++
      ) {
        this.vertices[n].applyMatrix4(t);
      }
      for (n = 0, i = this.faces.length; n < i; n++) {
        var r = this.faces[n];
        r.normal.applyMatrix3(e).normalize();
        for (var o = 0, s = r.vertexNormals.length; o < s; o++)
          r.vertexNormals[o].applyMatrix3(e).normalize();
      }
      return (
        null !== this.boundingBox && this.computeBoundingBox(),
        null !== this.boundingSphere && this.computeBoundingSphere(),
        (this.verticesNeedUpdate = !0),
        (this.normalsNeedUpdate = !0),
        this
      );
    },
    rotateX: function (t) {
      return pn.makeRotationX(t), this.applyMatrix4(pn), this;
    },
    rotateY: function (t) {
      return pn.makeRotationY(t), this.applyMatrix4(pn), this;
    },
    rotateZ: function (t) {
      return pn.makeRotationZ(t), this.applyMatrix4(pn), this;
    },
    translate: function (t, e, n) {
      return pn.makeTranslation(t, e, n), this.applyMatrix4(pn), this;
    },
    scale: function (t, e, n) {
      return pn.makeScale(t, e, n), this.applyMatrix4(pn), this;
    },
    lookAt: function (t) {
      return (
        fn.lookAt(t), fn.updateMatrix(), this.applyMatrix4(fn.matrix), this
      );
    },
    fromBufferGeometry: function (t) {
      var e = this,
        n = null !== t.index ? t.index.array : void 0,
        i = t.attributes;
      if (void 0 === i.position)
        return (
          console.error(
            'THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.',
          ),
          this
        );
      var r = i.position.array,
        o = void 0 !== i.normal ? i.normal.array : void 0,
        s = void 0 !== i.color ? i.color.array : void 0,
        a = void 0 !== i.uv ? i.uv.array : void 0,
        c = void 0 !== i.uv2 ? i.uv2.array : void 0;
      void 0 !== c && (this.faceVertexUvs[1] = []);
      for (var l = 0; l < r.length; l += 3)
        e.vertices.push(new J().fromArray(r, l)),
          void 0 !== s && e.colors.push(new fe().fromArray(s, l));
      function h(t, n, i, r) {
        var l =
            void 0 === s
              ? []
              : [e.colors[t].clone(), e.colors[n].clone(), e.colors[i].clone()],
          h = new ye(
            t,
            n,
            i,
            void 0 === o
              ? []
              : [
                  new J().fromArray(o, 3 * t),
                  new J().fromArray(o, 3 * n),
                  new J().fromArray(o, 3 * i),
                ],
            l,
            r,
          );
        e.faces.push(h),
          void 0 !== a &&
            e.faceVertexUvs[0].push([
              new U().fromArray(a, 2 * t),
              new U().fromArray(a, 2 * n),
              new U().fromArray(a, 2 * i),
            ]),
          void 0 !== c &&
            e.faceVertexUvs[1].push([
              new U().fromArray(c, 2 * t),
              new U().fromArray(c, 2 * n),
              new U().fromArray(c, 2 * i),
            ]);
      }
      var u = t.groups;
      if (u.length > 0)
        for (l = 0; l < u.length; l++)
          for (var d = u[l], p = d.start, f = p, m = p + d.count; f < m; f += 3)
            void 0 !== n
              ? h(n[f], n[f + 1], n[f + 2], d.materialIndex)
              : h(f, f + 1, f + 2, d.materialIndex);
      else if (void 0 !== n)
        for (l = 0; l < n.length; l += 3) h(n[l], n[l + 1], n[l + 2]);
      else for (l = 0; l < r.length / 3; l += 3) h(l, l + 1, l + 2);
      return (
        this.computeFaceNormals(),
        null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
        null !== t.boundingSphere &&
          (this.boundingSphere = t.boundingSphere.clone()),
        this
      );
    },
    center: function () {
      return (
        this.computeBoundingBox(),
        this.boundingBox.getCenter(mn).negate(),
        this.translate(mn.x, mn.y, mn.z),
        this
      );
    },
    normalize: function () {
      this.computeBoundingSphere();
      var t = this.boundingSphere.center,
        e = this.boundingSphere.radius,
        n = 0 === e ? 1 : 1 / e,
        i = new ot();
      return (
        i.set(
          n,
          0,
          0,
          -n * t.x,
          0,
          n,
          0,
          -n * t.y,
          0,
          0,
          n,
          -n * t.z,
          0,
          0,
          0,
          1,
        ),
        this.applyMatrix4(i),
        this
      );
    },
    computeFaceNormals: function () {
      for (
        var t = new J(), e = new J(), n = 0, i = this.faces.length;
        n < i;
        n++
      ) {
        var r = this.faces[n],
          o = this.vertices[r.a],
          s = this.vertices[r.b],
          a = this.vertices[r.c];
        t.subVectors(a, s),
          e.subVectors(o, s),
          t.cross(e),
          t.normalize(),
          r.normal.copy(t);
      }
    },
    computeVertexNormals: function (t) {
      var e, n, i, r, o, s;
      for (
        void 0 === t && (t = !0),
          s = new Array(this.vertices.length),
          e = 0,
          n = this.vertices.length;
        e < n;
        e++
      )
        s[e] = new J();
      if (t) {
        var a,
          c,
          l,
          h = new J(),
          u = new J();
        for (i = 0, r = this.faces.length; i < r; i++)
          (o = this.faces[i]),
            (a = this.vertices[o.a]),
            (c = this.vertices[o.b]),
            (l = this.vertices[o.c]),
            h.subVectors(l, c),
            u.subVectors(a, c),
            h.cross(u),
            s[o.a].add(h),
            s[o.b].add(h),
            s[o.c].add(h);
      } else
        for (
          this.computeFaceNormals(), i = 0, r = this.faces.length;
          i < r;
          i++
        )
          s[(o = this.faces[i]).a].add(o.normal),
            s[o.b].add(o.normal),
            s[o.c].add(o.normal);
      for (e = 0, n = this.vertices.length; e < n; e++) s[e].normalize();
      for (i = 0, r = this.faces.length; i < r; i++) {
        var d = (o = this.faces[i]).vertexNormals;
        3 === d.length
          ? (d[0].copy(s[o.a]), d[1].copy(s[o.b]), d[2].copy(s[o.c]))
          : ((d[0] = s[o.a].clone()),
            (d[1] = s[o.b].clone()),
            (d[2] = s[o.c].clone()));
      }
      this.faces.length > 0 && (this.normalsNeedUpdate = !0);
    },
    computeFlatVertexNormals: function () {
      var t, e, n;
      for (
        this.computeFaceNormals(), t = 0, e = this.faces.length;
        t < e;
        t++
      ) {
        var i = (n = this.faces[t]).vertexNormals;
        3 === i.length
          ? (i[0].copy(n.normal), i[1].copy(n.normal), i[2].copy(n.normal))
          : ((i[0] = n.normal.clone()),
            (i[1] = n.normal.clone()),
            (i[2] = n.normal.clone()));
      }
      this.faces.length > 0 && (this.normalsNeedUpdate = !0);
    },
    computeMorphNormals: function () {
      var t, e, n, i, r;
      for (n = 0, i = this.faces.length; n < i; n++)
        for (
          (r = this.faces[n]).__originalFaceNormal
            ? r.__originalFaceNormal.copy(r.normal)
            : (r.__originalFaceNormal = r.normal.clone()),
            r.__originalVertexNormals || (r.__originalVertexNormals = []),
            t = 0,
            e = r.vertexNormals.length;
          t < e;
          t++
        )
          r.__originalVertexNormals[t]
            ? r.__originalVertexNormals[t].copy(r.vertexNormals[t])
            : (r.__originalVertexNormals[t] = r.vertexNormals[t].clone());
      var o = new bn();
      for (
        o.faces = this.faces, t = 0, e = this.morphTargets.length;
        t < e;
        t++
      ) {
        if (!this.morphNormals[t]) {
          (this.morphNormals[t] = {}),
            (this.morphNormals[t].faceNormals = []),
            (this.morphNormals[t].vertexNormals = []);
          var s = this.morphNormals[t].faceNormals,
            a = this.morphNormals[t].vertexNormals;
          for (n = 0, i = this.faces.length; n < i; n++)
            (c = new J()),
              (l = { a: new J(), b: new J(), c: new J() }),
              s.push(c),
              a.push(l);
        }
        var c,
          l,
          h = this.morphNormals[t];
        for (
          o.vertices = this.morphTargets[t].vertices,
            o.computeFaceNormals(),
            o.computeVertexNormals(),
            n = 0,
            i = this.faces.length;
          n < i;
          n++
        )
          (r = this.faces[n]),
            (c = h.faceNormals[n]),
            (l = h.vertexNormals[n]),
            c.copy(r.normal),
            l.a.copy(r.vertexNormals[0]),
            l.b.copy(r.vertexNormals[1]),
            l.c.copy(r.vertexNormals[2]);
      }
      for (n = 0, i = this.faces.length; n < i; n++)
        ((r = this.faces[n]).normal = r.__originalFaceNormal),
          (r.vertexNormals = r.__originalVertexNormals);
    },
    computeBoundingBox: function () {
      null === this.boundingBox && (this.boundingBox = new Nt()),
        this.boundingBox.setFromPoints(this.vertices);
    },
    computeBoundingSphere: function () {
      null === this.boundingSphere && (this.boundingSphere = new Gt()),
        this.boundingSphere.setFromPoints(this.vertices);
    },
    merge: function (t, e, n) {
      if (t && t.isGeometry) {
        var i,
          r = this.vertices.length,
          o = this.vertices,
          s = t.vertices,
          a = this.faces,
          c = t.faces,
          l = this.colors,
          h = t.colors;
        void 0 === n && (n = 0),
          void 0 !== e && (i = new G().getNormalMatrix(e));
        for (var u = 0, d = s.length; u < d; u++) {
          var p = s[u].clone();
          void 0 !== e && p.applyMatrix4(e), o.push(p);
        }
        for (u = 0, d = h.length; u < d; u++) l.push(h[u].clone());
        for (u = 0, d = c.length; u < d; u++) {
          var f,
            m,
            b,
            g = c[u],
            y = g.vertexNormals,
            v = g.vertexColors;
          (f = new ye(g.a + r, g.b + r, g.c + r)).normal.copy(g.normal),
            void 0 !== i && f.normal.applyMatrix3(i).normalize();
          for (var _ = 0, x = y.length; _ < x; _++)
            (m = y[_].clone()),
              void 0 !== i && m.applyMatrix3(i).normalize(),
              f.vertexNormals.push(m);
          f.color.copy(g.color);
          for (_ = 0, x = v.length; _ < x; _++)
            (b = v[_]), f.vertexColors.push(b.clone());
          (f.materialIndex = g.materialIndex + n), a.push(f);
        }
        for (u = 0, d = t.faceVertexUvs.length; u < d; u++) {
          var w = t.faceVertexUvs[u];
          void 0 === this.faceVertexUvs[u] && (this.faceVertexUvs[u] = []);
          for (_ = 0, x = w.length; _ < x; _++) {
            for (var A = w[_], M = [], S = 0, I = A.length; S < I; S++)
              M.push(A[S].clone());
            this.faceVertexUvs[u].push(M);
          }
        }
      } else
        console.error(
          'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.',
          t,
        );
    },
    mergeMesh: function (t) {
      t && t.isMesh
        ? (t.matrixAutoUpdate && t.updateMatrix(),
          this.merge(t.geometry, t.matrix))
        : console.error(
            'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.',
            t,
          );
    },
    mergeVertices: function () {
      var t,
        e,
        n,
        i,
        r,
        o,
        s,
        a,
        c = {},
        l = [],
        h = [],
        u = Math.pow(10, 4);
      for (n = 0, i = this.vertices.length; n < i; n++)
        (t = this.vertices[n]),
          void 0 ===
          c[
            (e =
              Math.round(t.x * u) +
              '_' +
              Math.round(t.y * u) +
              '_' +
              Math.round(t.z * u))
          ]
            ? ((c[e] = n), l.push(this.vertices[n]), (h[n] = l.length - 1))
            : (h[n] = h[c[e]]);
      var d = [];
      for (n = 0, i = this.faces.length; n < i; n++) {
        ((r = this.faces[n]).a = h[r.a]),
          (r.b = h[r.b]),
          (r.c = h[r.c]),
          (o = [r.a, r.b, r.c]);
        for (var p = 0; p < 3; p++)
          if (o[p] === o[(p + 1) % 3]) {
            d.push(n);
            break;
          }
      }
      for (n = d.length - 1; n >= 0; n--) {
        var f = d[n];
        for (
          this.faces.splice(f, 1), s = 0, a = this.faceVertexUvs.length;
          s < a;
          s++
        )
          this.faceVertexUvs[s].splice(f, 1);
      }
      var m = this.vertices.length - l.length;
      return (this.vertices = l), m;
    },
    setFromPoints: function (t) {
      this.vertices = [];
      for (var e = 0, n = t.length; e < n; e++) {
        var i = t[e];
        this.vertices.push(new J(i.x, i.y, i.z || 0));
      }
      return this;
    },
    sortFacesByMaterialIndex: function () {
      for (var t = this.faces, e = t.length, n = 0; n < e; n++) t[n]._id = n;
      t.sort(function (t, e) {
        return t.materialIndex - e.materialIndex;
      });
      var i,
        r,
        o = this.faceVertexUvs[0],
        s = this.faceVertexUvs[1];
      o && o.length === e && (i = []), s && s.length === e && (r = []);
      for (n = 0; n < e; n++) {
        var a = t[n]._id;
        i && i.push(o[a]), r && r.push(s[a]);
      }
      i && (this.faceVertexUvs[0] = i), r && (this.faceVertexUvs[1] = r);
    },
    toJSON: function () {
      var t = {
        metadata: {
          version: 4.5,
          type: 'Geometry',
          generator: 'Geometry.toJSON',
        },
      };
      if (
        ((t.uuid = this.uuid),
        (t.type = this.type),
        '' !== this.name && (t.name = this.name),
        void 0 !== this.parameters)
      ) {
        var e = this.parameters;
        for (var n in e) void 0 !== e[n] && (t[n] = e[n]);
        return t;
      }
      for (var i = [], r = 0; r < this.vertices.length; r++) {
        var o = this.vertices[r];
        i.push(o.x, o.y, o.z);
      }
      var s = [],
        a = [],
        c = {},
        l = [],
        h = {},
        u = [],
        d = {};
      for (r = 0; r < this.faces.length; r++) {
        var p = this.faces[r],
          f = void 0 !== this.faceVertexUvs[0][r],
          m = p.normal.length() > 0,
          b = p.vertexNormals.length > 0,
          g = 1 !== p.color.r || 1 !== p.color.g || 1 !== p.color.b,
          y = p.vertexColors.length > 0,
          v = 0;
        if (
          ((v = A(v, 0, 0)),
          (v = A(v, 1, !0)),
          (v = A(v, 2, !1)),
          (v = A(v, 3, f)),
          (v = A(v, 4, m)),
          (v = A(v, 5, b)),
          (v = A(v, 6, g)),
          (v = A(v, 7, y)),
          s.push(v),
          s.push(p.a, p.b, p.c),
          s.push(p.materialIndex),
          f)
        ) {
          var _ = this.faceVertexUvs[0][r];
          s.push(I(_[0]), I(_[1]), I(_[2]));
        }
        if ((m && s.push(M(p.normal)), b)) {
          var x = p.vertexNormals;
          s.push(M(x[0]), M(x[1]), M(x[2]));
        }
        if ((g && s.push(S(p.color)), y)) {
          var w = p.vertexColors;
          s.push(S(w[0]), S(w[1]), S(w[2]));
        }
      }
      function A(t, e, n) {
        return n ? t | (1 << e) : t & ~(1 << e);
      }
      function M(t) {
        var e = t.x.toString() + t.y.toString() + t.z.toString();
        return (
          void 0 !== c[e] || ((c[e] = a.length / 3), a.push(t.x, t.y, t.z)),
          c[e]
        );
      }
      function S(t) {
        var e = t.r.toString() + t.g.toString() + t.b.toString();
        return void 0 !== h[e] || ((h[e] = l.length), l.push(t.getHex())), h[e];
      }
      function I(t) {
        var e = t.x.toString() + t.y.toString();
        return (
          void 0 !== d[e] || ((d[e] = u.length / 2), u.push(t.x, t.y)), d[e]
        );
      }
      return (
        (t.data = {}),
        (t.data.vertices = i),
        (t.data.normals = a),
        l.length > 0 && (t.data.colors = l),
        u.length > 0 && (t.data.uvs = [u]),
        (t.data.faces = s),
        t
      );
    },
    clone: function () {
      return new bn().copy(this);
    },
    copy: function (t) {
      var e, n, i, r, o, s;
      (this.vertices = []),
        (this.colors = []),
        (this.faces = []),
        (this.faceVertexUvs = [[]]),
        (this.morphTargets = []),
        (this.morphNormals = []),
        (this.skinWeights = []),
        (this.skinIndices = []),
        (this.lineDistances = []),
        (this.boundingBox = null),
        (this.boundingSphere = null),
        (this.name = t.name);
      var a = t.vertices;
      for (e = 0, n = a.length; e < n; e++) this.vertices.push(a[e].clone());
      var c = t.colors;
      for (e = 0, n = c.length; e < n; e++) this.colors.push(c[e].clone());
      var l = t.faces;
      for (e = 0, n = l.length; e < n; e++) this.faces.push(l[e].clone());
      for (e = 0, n = t.faceVertexUvs.length; e < n; e++) {
        var h = t.faceVertexUvs[e];
        for (
          void 0 === this.faceVertexUvs[e] && (this.faceVertexUvs[e] = []),
            i = 0,
            r = h.length;
          i < r;
          i++
        ) {
          var u = h[i],
            d = [];
          for (o = 0, s = u.length; o < s; o++) {
            var p = u[o];
            d.push(p.clone());
          }
          this.faceVertexUvs[e].push(d);
        }
      }
      var f = t.morphTargets;
      for (e = 0, n = f.length; e < n; e++) {
        var m = {};
        if (((m.name = f[e].name), void 0 !== f[e].vertices))
          for (m.vertices = [], i = 0, r = f[e].vertices.length; i < r; i++)
            m.vertices.push(f[e].vertices[i].clone());
        if (void 0 !== f[e].normals)
          for (m.normals = [], i = 0, r = f[e].normals.length; i < r; i++)
            m.normals.push(f[e].normals[i].clone());
        this.morphTargets.push(m);
      }
      var b = t.morphNormals;
      for (e = 0, n = b.length; e < n; e++) {
        var g = {};
        if (void 0 !== b[e].vertexNormals)
          for (
            g.vertexNormals = [], i = 0, r = b[e].vertexNormals.length;
            i < r;
            i++
          ) {
            var y = b[e].vertexNormals[i],
              v = {};
            (v.a = y.a.clone()),
              (v.b = y.b.clone()),
              (v.c = y.c.clone()),
              g.vertexNormals.push(v);
          }
        if (void 0 !== b[e].faceNormals)
          for (
            g.faceNormals = [], i = 0, r = b[e].faceNormals.length;
            i < r;
            i++
          )
            g.faceNormals.push(b[e].faceNormals[i].clone());
        this.morphNormals.push(g);
      }
      var _ = t.skinWeights;
      for (e = 0, n = _.length; e < n; e++) this.skinWeights.push(_[e].clone());
      var x = t.skinIndices;
      for (e = 0, n = x.length; e < n; e++) this.skinIndices.push(x[e].clone());
      var w = t.lineDistances;
      for (e = 0, n = w.length; e < n; e++) this.lineDistances.push(w[e]);
      var A = t.boundingBox;
      null !== A && (this.boundingBox = A.clone());
      var M = t.boundingSphere;
      return (
        null !== M && (this.boundingSphere = M.clone()),
        (this.elementsNeedUpdate = t.elementsNeedUpdate),
        (this.verticesNeedUpdate = t.verticesNeedUpdate),
        (this.uvsNeedUpdate = t.uvsNeedUpdate),
        (this.normalsNeedUpdate = t.normalsNeedUpdate),
        (this.colorsNeedUpdate = t.colorsNeedUpdate),
        (this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate),
        (this.groupsNeedUpdate = t.groupsNeedUpdate),
        this
      );
    },
    dispose: function () {
      this.dispatchEvent({ type: 'dispose' });
    },
  });
  class gn extends bn {
    constructor(t, e, n, i, r, o) {
      super(),
        (this.type = 'BoxGeometry'),
        (this.parameters = {
          width: t,
          height: e,
          depth: n,
          widthSegments: i,
          heightSegments: r,
          depthSegments: o,
        }),
        this.fromBufferGeometry(new yn(t, e, n, i, r, o)),
        this.mergeVertices();
    }
  }
  class yn extends He {
    constructor(t, e, n, i, r, o) {
      super(),
        (this.type = 'BoxBufferGeometry'),
        (this.parameters = {
          width: t,
          height: e,
          depth: n,
          widthSegments: i,
          heightSegments: r,
          depthSegments: o,
        });
      var s = this;
      (t = t || 1),
        (e = e || 1),
        (n = n || 1),
        (i = Math.floor(i) || 1),
        (r = Math.floor(r) || 1),
        (o = Math.floor(o) || 1);
      var a = [],
        c = [],
        l = [],
        h = [],
        u = 0,
        d = 0;
      function p(t, e, n, i, r, o, p, f, m, b, g) {
        var y,
          v,
          _ = o / m,
          x = p / b,
          w = o / 2,
          A = p / 2,
          M = f / 2,
          S = m + 1,
          I = b + 1,
          E = 0,
          D = 0,
          C = new J();
        for (v = 0; v < I; v++) {
          var T = v * x - A;
          for (y = 0; y < S; y++) {
            var L = y * _ - w;
            (C[t] = L * i),
              (C[e] = T * r),
              (C[n] = M),
              c.push(C.x, C.y, C.z),
              (C[t] = 0),
              (C[e] = 0),
              (C[n] = f > 0 ? 1 : -1),
              l.push(C.x, C.y, C.z),
              h.push(y / m),
              h.push(1 - v / b),
              (E += 1);
          }
        }
        for (v = 0; v < b; v++)
          for (y = 0; y < m; y++) {
            var R = u + y + S * v,
              F = u + y + S * (v + 1),
              P = u + (y + 1) + S * (v + 1),
              B = u + (y + 1) + S * v;
            a.push(R, F, B), a.push(F, P, B), (D += 6);
          }
        s.addGroup(d, D, g), (d += D), (u += E);
      }
      p('z', 'y', 'x', -1, -1, n, e, t, o, r, 0),
        p('z', 'y', 'x', 1, -1, n, e, -t, o, r, 1),
        p('x', 'z', 'y', 1, 1, t, n, e, i, o, 2),
        p('x', 'z', 'y', 1, -1, t, n, -e, i, o, 3),
        p('x', 'y', 'z', 1, -1, t, e, n, i, r, 4),
        p('x', 'y', 'z', -1, -1, t, e, -n, i, r, 5),
        this.setIndex(a),
        this.setAttribute('position', new Re(c, 3)),
        this.setAttribute('normal', new Re(l, 3)),
        this.setAttribute('uv', new Re(h, 2));
    }
  }
  function vn(t) {
    var e = {};
    for (var n in t)
      for (var i in ((e[n] = {}), t[n])) {
        var r = t[n][i];
        r &&
        (r.isColor ||
          r.isMatrix3 ||
          r.isMatrix4 ||
          r.isVector2 ||
          r.isVector3 ||
          r.isVector4 ||
          r.isTexture)
          ? (e[n][i] = r.clone())
          : Array.isArray(r)
          ? (e[n][i] = r.slice())
          : (e[n][i] = r);
      }
    return e;
  }
  function _n(t) {
    for (var e = {}, n = 0; n < t.length; n++) {
      var i = vn(t[n]);
      for (var r in i) e[r] = i[r];
    }
    return e;
  }
  var xn = { clone: vn, merge: _n };
  function wn(t) {
    _e.call(this),
      (this.type = 'ShaderMaterial'),
      (this.defines = {}),
      (this.uniforms = {}),
      (this.vertexShader =
        '\nvoid main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n'),
      (this.fragmentShader =
        '\nvoid main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}\n'),
      (this.linewidth = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      (this.clipping = !1),
      (this.skinning = !1),
      (this.morphTargets = !1),
      (this.morphNormals = !1),
      (this.extensions = {
        derivatives: !1,
        fragDepth: !1,
        drawBuffers: !1,
        shaderTextureLOD: !1,
      }),
      (this.defaultAttributeValues = {
        color: [1, 1, 1],
        uv: [0, 0],
        uv2: [0, 0],
      }),
      (this.index0AttributeName = void 0),
      (this.uniformsNeedUpdate = !1),
      void 0 !== t &&
        (void 0 !== t.attributes &&
          console.error(
            'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.',
          ),
        this.setValues(t));
  }
  function An() {
    At.call(this),
      (this.type = 'Camera'),
      (this.matrixWorldInverse = new ot()),
      (this.projectionMatrix = new ot()),
      (this.projectionMatrixInverse = new ot());
  }
  function Mn(t, e, n, i) {
    An.call(this),
      (this.type = 'PerspectiveCamera'),
      (this.fov = void 0 !== t ? t : 50),
      (this.zoom = 1),
      (this.near = void 0 !== n ? n : 0.1),
      (this.far = void 0 !== i ? i : 2e3),
      (this.focus = 10),
      (this.aspect = void 0 !== e ? e : 1),
      (this.view = null),
      (this.filmGauge = 35),
      (this.filmOffset = 0),
      this.updateProjectionMatrix();
  }
  (wn.prototype = Object.create(_e.prototype)),
    (wn.prototype.constructor = wn),
    (wn.prototype.isShaderMaterial = !0),
    (wn.prototype.copy = function (t) {
      return (
        _e.prototype.copy.call(this, t),
        (this.fragmentShader = t.fragmentShader),
        (this.vertexShader = t.vertexShader),
        (this.uniforms = vn(t.uniforms)),
        (this.defines = Object.assign({}, t.defines)),
        (this.wireframe = t.wireframe),
        (this.wireframeLinewidth = t.wireframeLinewidth),
        (this.lights = t.lights),
        (this.clipping = t.clipping),
        (this.skinning = t.skinning),
        (this.morphTargets = t.morphTargets),
        (this.morphNormals = t.morphNormals),
        (this.extensions = t.extensions),
        this
      );
    }),
    (wn.prototype.toJSON = function (t) {
      var e = _e.prototype.toJSON.call(this, t);
      for (var n in ((e.uniforms = {}), this.uniforms)) {
        var i = this.uniforms[n].value;
        i && i.isTexture
          ? (e.uniforms[n] = { type: 't', value: i.toJSON(t).uuid })
          : i && i.isColor
          ? (e.uniforms[n] = { type: 'c', value: i.getHex() })
          : i && i.isVector2
          ? (e.uniforms[n] = { type: 'v2', value: i.toArray() })
          : i && i.isVector3
          ? (e.uniforms[n] = { type: 'v3', value: i.toArray() })
          : i && i.isVector4
          ? (e.uniforms[n] = { type: 'v4', value: i.toArray() })
          : i && i.isMatrix3
          ? (e.uniforms[n] = { type: 'm3', value: i.toArray() })
          : i && i.isMatrix4
          ? (e.uniforms[n] = { type: 'm4', value: i.toArray() })
          : (e.uniforms[n] = { value: i });
      }
      Object.keys(this.defines).length > 0 && (e.defines = this.defines),
        (e.vertexShader = this.vertexShader),
        (e.fragmentShader = this.fragmentShader);
      var r = {};
      for (var o in this.extensions) !0 === this.extensions[o] && (r[o] = !0);
      return Object.keys(r).length > 0 && (e.extensions = r), e;
    }),
    (An.prototype = Object.assign(Object.create(At.prototype), {
      constructor: An,
      isCamera: !0,
      copy: function (t, e) {
        return (
          At.prototype.copy.call(this, t, e),
          this.matrixWorldInverse.copy(t.matrixWorldInverse),
          this.projectionMatrix.copy(t.projectionMatrix),
          this.projectionMatrixInverse.copy(t.projectionMatrixInverse),
          this
        );
      },
      getWorldDirection: function (t) {
        void 0 === t &&
          (console.warn(
            'THREE.Camera: .getWorldDirection() target is now required',
          ),
          (t = new J())),
          this.updateMatrixWorld(!0);
        var e = this.matrixWorld.elements;
        return t.set(-e[8], -e[9], -e[10]).normalize();
      },
      updateMatrixWorld: function (t) {
        At.prototype.updateMatrixWorld.call(this, t),
          this.matrixWorldInverse.getInverse(this.matrixWorld);
      },
      updateWorldMatrix: function (t, e) {
        At.prototype.updateWorldMatrix.call(this, t, e),
          this.matrixWorldInverse.getInverse(this.matrixWorld);
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
    })),
    (Mn.prototype = Object.assign(Object.create(An.prototype), {
      constructor: Mn,
      isPerspectiveCamera: !0,
      copy: function (t, e) {
        return (
          An.prototype.copy.call(this, t, e),
          (this.fov = t.fov),
          (this.zoom = t.zoom),
          (this.near = t.near),
          (this.far = t.far),
          (this.focus = t.focus),
          (this.aspect = t.aspect),
          (this.view = null === t.view ? null : Object.assign({}, t.view)),
          (this.filmGauge = t.filmGauge),
          (this.filmOffset = t.filmOffset),
          this
        );
      },
      setFocalLength: function (t) {
        var e = (0.5 * this.getFilmHeight()) / t;
        (this.fov = 2 * k.RAD2DEG * Math.atan(e)),
          this.updateProjectionMatrix();
      },
      getFocalLength: function () {
        var t = Math.tan(0.5 * k.DEG2RAD * this.fov);
        return (0.5 * this.getFilmHeight()) / t;
      },
      getEffectiveFOV: function () {
        return (
          2 *
          k.RAD2DEG *
          Math.atan(Math.tan(0.5 * k.DEG2RAD * this.fov) / this.zoom)
        );
      },
      getFilmWidth: function () {
        return this.filmGauge * Math.min(this.aspect, 1);
      },
      getFilmHeight: function () {
        return this.filmGauge / Math.max(this.aspect, 1);
      },
      setViewOffset: function (t, e, n, i, r, o) {
        (this.aspect = t / e),
          null === this.view &&
            (this.view = {
              enabled: !0,
              fullWidth: 1,
              fullHeight: 1,
              offsetX: 0,
              offsetY: 0,
              width: 1,
              height: 1,
            }),
          (this.view.enabled = !0),
          (this.view.fullWidth = t),
          (this.view.fullHeight = e),
          (this.view.offsetX = n),
          (this.view.offsetY = i),
          (this.view.width = r),
          (this.view.height = o),
          this.updateProjectionMatrix();
      },
      clearViewOffset: function () {
        null !== this.view && (this.view.enabled = !1),
          this.updateProjectionMatrix();
      },
      updateProjectionMatrix: function () {
        var t = this.near,
          e = (t * Math.tan(0.5 * k.DEG2RAD * this.fov)) / this.zoom,
          n = 2 * e,
          i = this.aspect * n,
          r = -0.5 * i,
          o = this.view;
        if (null !== this.view && this.view.enabled) {
          var s = o.fullWidth,
            a = o.fullHeight;
          (r += (o.offsetX * i) / s),
            (e -= (o.offsetY * n) / a),
            (i *= o.width / s),
            (n *= o.height / a);
        }
        var c = this.filmOffset;
        0 !== c && (r += (t * c) / this.getFilmWidth()),
          this.projectionMatrix.makePerspective(
            r,
            r + i,
            e,
            e - n,
            t,
            this.far,
          ),
          this.projectionMatrixInverse.getInverse(this.projectionMatrix);
      },
      toJSON: function (t) {
        var e = At.prototype.toJSON.call(this, t);
        return (
          (e.object.fov = this.fov),
          (e.object.zoom = this.zoom),
          (e.object.near = this.near),
          (e.object.far = this.far),
          (e.object.focus = this.focus),
          (e.object.aspect = this.aspect),
          null !== this.view && (e.object.view = Object.assign({}, this.view)),
          (e.object.filmGauge = this.filmGauge),
          (e.object.filmOffset = this.filmOffset),
          e
        );
      },
    }));
  var Sn = 90;
  function In(t, e, n, i) {
    At.call(this), (this.type = 'CubeCamera');
    var r = new Mn(Sn, 1, t, e);
    r.up.set(0, -1, 0), r.lookAt(new J(1, 0, 0)), this.add(r);
    var o = new Mn(Sn, 1, t, e);
    o.up.set(0, -1, 0), o.lookAt(new J(-1, 0, 0)), this.add(o);
    var s = new Mn(Sn, 1, t, e);
    s.up.set(0, 0, 1), s.lookAt(new J(0, 1, 0)), this.add(s);
    var a = new Mn(Sn, 1, t, e);
    a.up.set(0, 0, -1), a.lookAt(new J(0, -1, 0)), this.add(a);
    var c = new Mn(Sn, 1, t, e);
    c.up.set(0, -1, 0), c.lookAt(new J(0, 0, 1)), this.add(c);
    var l = new Mn(Sn, 1, t, e);
    l.up.set(0, -1, 0),
      l.lookAt(new J(0, 0, -1)),
      this.add(l),
      (i = i || { format: _, magFilter: u, minFilter: u }),
      (this.renderTarget = new En(n, i)),
      (this.renderTarget.texture.name = 'CubeCamera'),
      (this.update = function (t, e) {
        null === this.parent && this.updateMatrixWorld();
        var n = t.getRenderTarget(),
          i = this.renderTarget,
          h = i.texture.generateMipmaps;
        (i.texture.generateMipmaps = !1),
          t.setRenderTarget(i, 0),
          t.render(e, r),
          t.setRenderTarget(i, 1),
          t.render(e, o),
          t.setRenderTarget(i, 2),
          t.render(e, s),
          t.setRenderTarget(i, 3),
          t.render(e, a),
          t.setRenderTarget(i, 4),
          t.render(e, c),
          (i.texture.generateMipmaps = h),
          t.setRenderTarget(i, 5),
          t.render(e, l),
          t.setRenderTarget(n);
      }),
      (this.clear = function (t, e, n, i) {
        for (
          var r = t.getRenderTarget(), o = this.renderTarget, s = 0;
          s < 6;
          s++
        )
          t.setRenderTarget(o, s), t.clear(e, n, i);
        t.setRenderTarget(r);
      });
  }
  function En(t, e, n) {
    Number.isInteger(e) &&
      (console.warn(
        'THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )',
      ),
      (e = n)),
      X.call(this, t, t, e);
  }
  function Dn(t, e, n, i, r, o, s, a, l, h, u, d) {
    H.call(this, null, o, s, a, l, h, i, r, u, d),
      (this.image = { data: t || null, width: e || 1, height: n || 1 }),
      (this.magFilter = void 0 !== l ? l : c),
      (this.minFilter = void 0 !== h ? h : c),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1),
      (this.needsUpdate = !0);
  }
  (In.prototype = Object.create(At.prototype)),
    (In.prototype.constructor = In),
    (En.prototype = Object.create(X.prototype)),
    (En.prototype.constructor = En),
    (En.prototype.isWebGLCubeRenderTarget = !0),
    (En.prototype.fromEquirectangularTexture = function (t, e) {
      (this.texture.type = e.type),
        (this.texture.format = e.format),
        (this.texture.encoding = e.encoding);
      var n = new Mt(),
        i = {
          uniforms: { tEquirect: { value: null } },
          vertexShader: [
            'varying vec3 vWorldDirection;',
            'vec3 transformDirection( in vec3 dir, in mat4 matrix ) {',
            '\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );',
            '}',
            'void main() {',
            '\tvWorldDirection = transformDirection( position, modelMatrix );',
            '\t#include <begin_vertex>',
            '\t#include <project_vertex>',
            '}',
          ].join('\n'),
          fragmentShader: [
            'uniform sampler2D tEquirect;',
            'varying vec3 vWorldDirection;',
            '#define RECIPROCAL_PI 0.31830988618',
            '#define RECIPROCAL_PI2 0.15915494',
            'void main() {',
            '\tvec3 direction = normalize( vWorldDirection );',
            '\tvec2 sampleUV;',
            '\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;',
            '\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;',
            '\tgl_FragColor = texture2D( tEquirect, sampleUV );',
            '}',
          ].join('\n'),
        },
        r = new wn({
          type: 'CubemapFromEquirect',
          uniforms: vn(i.uniforms),
          vertexShader: i.vertexShader,
          fragmentShader: i.fragmentShader,
          side: 1,
          blending: 0,
        });
      r.uniforms.tEquirect.value = e;
      var o = new ln(new yn(5, 5, 5), r);
      n.add(o);
      var s = new In(1, 10, 1);
      return (
        (s.renderTarget = this),
        (s.renderTarget.texture.name = 'CubeCameraTexture'),
        s.update(t, n),
        o.geometry.dispose(),
        o.material.dispose(),
        this
      );
    }),
    (Dn.prototype = Object.create(H.prototype)),
    (Dn.prototype.constructor = Dn),
    (Dn.prototype.isDataTexture = !0);
  var Cn = new Gt(),
    Tn = new J();
  function Ln(t, e, n, i, r, o) {
    this.planes = [
      void 0 !== t ? t : new Kt(),
      void 0 !== e ? e : new Kt(),
      void 0 !== n ? n : new Kt(),
      void 0 !== i ? i : new Kt(),
      void 0 !== r ? r : new Kt(),
      void 0 !== o ? o : new Kt(),
    ];
  }
  Object.assign(Ln.prototype, {
    set: function (t, e, n, i, r, o) {
      var s = this.planes;
      return (
        s[0].copy(t),
        s[1].copy(e),
        s[2].copy(n),
        s[3].copy(i),
        s[4].copy(r),
        s[5].copy(o),
        this
      );
    },
    clone: function () {
      return new this.constructor().copy(this);
    },
    copy: function (t) {
      for (var e = this.planes, n = 0; n < 6; n++) e[n].copy(t.planes[n]);
      return this;
    },
    setFromProjectionMatrix: function (t) {
      var e = this.planes,
        n = t.elements,
        i = n[0],
        r = n[1],
        o = n[2],
        s = n[3],
        a = n[4],
        c = n[5],
        l = n[6],
        h = n[7],
        u = n[8],
        d = n[9],
        p = n[10],
        f = n[11],
        m = n[12],
        b = n[13],
        g = n[14],
        y = n[15];
      return (
        e[0].setComponents(s - i, h - a, f - u, y - m).normalize(),
        e[1].setComponents(s + i, h + a, f + u, y + m).normalize(),
        e[2].setComponents(s + r, h + c, f + d, y + b).normalize(),
        e[3].setComponents(s - r, h - c, f - d, y - b).normalize(),
        e[4].setComponents(s - o, h - l, f - p, y - g).normalize(),
        e[5].setComponents(s + o, h + l, f + p, y + g).normalize(),
        this
      );
    },
    intersectsObject: function (t) {
      var e = t.geometry;
      return (
        null === e.boundingSphere && e.computeBoundingSphere(),
        Cn.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),
        this.intersectsSphere(Cn)
      );
    },
    intersectsSprite: function (t) {
      return (
        Cn.center.set(0, 0, 0),
        (Cn.radius = 0.7071067811865476),
        Cn.applyMatrix4(t.matrixWorld),
        this.intersectsSphere(Cn)
      );
    },
    intersectsSphere: function (t) {
      for (
        var e = this.planes, n = t.center, i = -t.radius, r = 0;
        r < 6;
        r++
      ) {
        if (e[r].distanceToPoint(n) < i) return !1;
      }
      return !0;
    },
    intersectsBox: function (t) {
      for (var e = this.planes, n = 0; n < 6; n++) {
        var i = e[n];
        if (
          ((Tn.x = i.normal.x > 0 ? t.max.x : t.min.x),
          (Tn.y = i.normal.y > 0 ? t.max.y : t.min.y),
          (Tn.z = i.normal.z > 0 ? t.max.z : t.min.z),
          i.distanceToPoint(Tn) < 0)
        )
          return !1;
      }
      return !0;
    },
    containsPoint: function (t) {
      for (var e = this.planes, n = 0; n < 6; n++)
        if (e[n].distanceToPoint(t) < 0) return !1;
      return !0;
    },
  });
  var Rn = {
    common: {
      diffuse: { value: new fe(15658734) },
      opacity: { value: 1 },
      map: { value: null },
      uvTransform: { value: new G() },
      uv2Transform: { value: new G() },
      alphaMap: { value: null },
    },
    specularmap: { specularMap: { value: null } },
    envmap: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      refractionRatio: { value: 0.98 },
      maxMipLevel: { value: 0 },
    },
    aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
    lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } },
    emissivemap: { emissiveMap: { value: null } },
    bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
    normalmap: {
      normalMap: { value: null },
      normalScale: { value: new U(1, 1) },
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 },
    },
    roughnessmap: { roughnessMap: { value: null } },
    metalnessmap: { metalnessMap: { value: null } },
    gradientmap: { gradientMap: { value: null } },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new fe(16777215) },
    },
    lights: {
      ambientLightColor: { value: [] },
      lightProbe: { value: [] },
      directionalLights: {
        value: [],
        properties: { direction: {}, color: {} },
      },
      directionalLightShadows: {
        value: [],
        properties: { shadowBias: {}, shadowRadius: {}, shadowMapSize: {} },
      },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {},
        },
      },
      spotLightShadows: {
        value: [],
        properties: { shadowBias: {}, shadowRadius: {}, shadowMapSize: {} },
      },
      spotShadowMap: { value: [] },
      spotShadowMatrix: { value: [] },
      pointLights: {
        value: [],
        properties: { color: {}, position: {}, decay: {}, distance: {} },
      },
      pointLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {},
        },
      },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: {
        value: [],
        properties: { direction: {}, skyColor: {}, groundColor: {} },
      },
      rectAreaLights: {
        value: [],
        properties: { color: {}, position: {}, width: {}, height: {} },
      },
    },
    points: {
      diffuse: { value: new fe(15658734) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      alphaMap: { value: null },
      uvTransform: { value: new G() },
    },
    sprite: {
      diffuse: { value: new fe(15658734) },
      opacity: { value: 1 },
      center: { value: new U(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      alphaMap: { value: null },
      uvTransform: { value: new G() },
    },
  };
  function Fn() {
    var t = null,
      e = !1,
      n = null;
    function i(r, o) {
      !1 !== e && (n(r, o), t.requestAnimationFrame(i));
    }
    return {
      start: function () {
        !0 !== e && null !== n && (t.requestAnimationFrame(i), (e = !0));
      },
      stop: function () {
        e = !1;
      },
      setAnimationLoop: function (t) {
        n = t;
      },
      setContext: function (e) {
        t = e;
      },
    };
  }
  function Pn(t, e) {
    var n = e.isWebGL2,
      i = new WeakMap();
    return {
      get: function (t) {
        return t.isInterleavedBufferAttribute && (t = t.data), i.get(t);
      },
      remove: function (e) {
        e.isInterleavedBufferAttribute && (e = e.data);
        var n = i.get(e);
        n && (t.deleteBuffer(n.buffer), i.delete(e));
      },
      update: function (e, r) {
        e.isInterleavedBufferAttribute && (e = e.data);
        var o = i.get(e);
        void 0 === o
          ? i.set(
              e,
              (function (e, n) {
                var i = e.array,
                  r = e.usage,
                  o = t.createBuffer();
                t.bindBuffer(n, o), t.bufferData(n, i, r), e.onUploadCallback();
                var s = t.FLOAT;
                return (
                  i instanceof Float32Array
                    ? (s = t.FLOAT)
                    : i instanceof Float64Array
                    ? console.warn(
                        'THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.',
                      )
                    : i instanceof Uint16Array
                    ? (s = t.UNSIGNED_SHORT)
                    : i instanceof Int16Array
                    ? (s = t.SHORT)
                    : i instanceof Uint32Array
                    ? (s = t.UNSIGNED_INT)
                    : i instanceof Int32Array
                    ? (s = t.INT)
                    : i instanceof Int8Array
                    ? (s = t.BYTE)
                    : i instanceof Uint8Array && (s = t.UNSIGNED_BYTE),
                  {
                    buffer: o,
                    type: s,
                    bytesPerElement: i.BYTES_PER_ELEMENT,
                    version: e.version,
                  }
                );
              })(e, r),
            )
          : o.version < e.version &&
            (!(function (e, i, r) {
              var o = i.array,
                s = i.updateRange;
              t.bindBuffer(r, e),
                -1 === s.count
                  ? t.bufferSubData(r, 0, o)
                  : (n
                      ? t.bufferSubData(
                          r,
                          s.offset * o.BYTES_PER_ELEMENT,
                          o,
                          s.offset,
                          s.count,
                        )
                      : t.bufferSubData(
                          r,
                          s.offset * o.BYTES_PER_ELEMENT,
                          o.subarray(s.offset, s.offset + s.count),
                        ),
                    (s.count = -1));
            })(o.buffer, e, r),
            (o.version = e.version));
      },
    };
  }
  function Bn(t, e, n, i) {
    bn.call(this),
      (this.type = 'PlaneGeometry'),
      (this.parameters = {
        width: t,
        height: e,
        widthSegments: n,
        heightSegments: i,
      }),
      this.fromBufferGeometry(new On(t, e, n, i)),
      this.mergeVertices();
  }
  function On(t, e, n, i) {
    He.call(this),
      (this.type = 'PlaneBufferGeometry'),
      (this.parameters = {
        width: t,
        height: e,
        widthSegments: n,
        heightSegments: i,
      });
    var r,
      o,
      s = (t = t || 1) / 2,
      a = (e = e || 1) / 2,
      c = Math.floor(n) || 1,
      l = Math.floor(i) || 1,
      h = c + 1,
      u = l + 1,
      d = t / c,
      p = e / l,
      f = [],
      m = [],
      b = [],
      g = [];
    for (o = 0; o < u; o++) {
      var y = o * p - a;
      for (r = 0; r < h; r++) {
        var v = r * d - s;
        m.push(v, -y, 0), b.push(0, 0, 1), g.push(r / c), g.push(1 - o / l);
      }
    }
    for (o = 0; o < l; o++)
      for (r = 0; r < c; r++) {
        var _ = r + h * o,
          x = r + h * (o + 1),
          w = r + 1 + h * (o + 1),
          A = r + 1 + h * o;
        f.push(_, x, A), f.push(x, w, A);
      }
    this.setIndex(f),
      this.setAttribute('position', new Re(m, 3)),
      this.setAttribute('normal', new Re(b, 3)),
      this.setAttribute('uv', new Re(g, 2));
  }
  (Bn.prototype = Object.create(bn.prototype)),
    (Bn.prototype.constructor = Bn),
    (On.prototype = Object.create(He.prototype)),
    (On.prototype.constructor = On);
  var Vn = {
      alphamap_fragment:
        '\n#ifdef USE_ALPHAMAP\n\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n',
      alphamap_pars_fragment:
        '\n#ifdef USE_ALPHAMAP\n\n\tuniform sampler2D alphaMap;\n\n#endif\n',
      alphatest_fragment:
        '\n#ifdef ALPHATEST\n\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n\n#endif\n',
      aomap_fragment:
        '\n#ifdef USE_AOMAP\n\n\t// reads channel R, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\n\t#endif\n\n#endif\n',
      aomap_pars_fragment:
        '\n#ifdef USE_AOMAP\n\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n\n#endif\n',
      begin_vertex: '\nvec3 transformed = vec3( position );\n',
      beginnormal_vertex:
        '\n  vec3 objectNormal = vec3( normal );\n  if(isInstanceDrawing) {\n    mat3 normalMat = mat3(vec3(instanceMatrixR1), vec3(instanceMatrixR2), vec3(instanceMatrixR3));\n    objectNormal = normalize(normalMat * vec3( normal ));\n\n    vec3 xa = vec3(normalMat[0][0], normalMat[1][0], normalMat[2][0]);\n    vec3 ya = vec3(normalMat[0][1], normalMat[1][1], normalMat[2][1]);\n    vec3 za = vec3(normalMat[0][2], normalMat[1][2], normalMat[2][2]);\n    objectNormal *= dot(normalize(cross(xa, ya)), normalize(za));\n  }\n\n#ifdef USE_TANGENT\n\n\tvec3 objectTangent = vec3( tangent.xyz );\n\n#endif\n',
      bsdfs:
        '\n\n// Analytical approximation of the DFG LUT, one half of the\n// split-sum approximation used in indirect specular lighting.\n// via \'environmentBRDF\' from "Physically Based Shading on Mobile"\n// https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile\nvec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\n\tvec4 r = roughness * c0 + c1;\n\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n\n}\n\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\n\t// based upon Frostbite 3 Moving to Physically-based Rendering\n\t// page 32, equation 26: E[window1]\n\t// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\t// this is intended to be used on spot and point lights who are represented as luminous intensity\n\t// but who must be converted to luminous irradiance for surface lighting calculation\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\n\tif( cutoffDistance > 0.0 ) {\n\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\n\t}\n\n\treturn distanceFalloff;\n\n#else\n\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\n\t}\n\n\treturn 1.0;\n\n#endif\n\n}\n\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\n\treturn RECIPROCAL_PI * diffuseColor;\n\n} // validated\n\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\n\t// Original approximation by Christophe Schlick \'94\n\t// float fresnel = pow( 1.0 - dotLH, 5.0 );\n\n\t// Optimized variant (presented by Epic at SIGGRAPH \'13)\n\t// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n\n} // validated\n\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\n\t// See F_Schlick\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\n\treturn Fr * fresnel + F0;\n\n}\n\n\n// Microfacet Models for Refraction through Rough Surfaces - equation (34)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is "roughness squared" in Disney’s reparameterization\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\n\t// geometry term (normalized) = G(l)⋅G(v) / 4(n⋅l)(n⋅v)\n\t// also see #12151\n\n\tfloat a2 = pow2( alpha );\n\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\n\treturn 1.0 / ( gl * gv );\n\n} // validated\n\n// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2\n// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\n\tfloat a2 = pow2( alpha );\n\n\t// dotNL and dotNV are explicitly swapped. This is not a mistake.\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\n\treturn 0.5 / max( gv + gl, EPSILON );\n\n}\n\n// Microfacet Models for Refraction through Rough Surfaces - equation (33)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is "roughness squared" in Disney’s reparameterization\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\n\tfloat a2 = pow2( alpha );\n\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0; // avoid alpha = 0 with dotNH = 1\n\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n\n}\n\n// GGX Distribution, Schlick Fresnel, GGX-Smith Visibility\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\n\tfloat alpha = pow2( roughness ); // UE4\'s roughness\n\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\n\tfloat D = D_GGX( alpha, dotNH );\n\n\treturn F * ( G * D );\n\n} // validated\n\n// Rect Area Light\n\n// Real-Time Polygonal-Light Shading with Linearly Transformed Cosines\n// by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt\n// code: https://github.com/selfshadow/ltc_code/\n\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\n\tfloat dotNV = saturate( dot( N, V ) );\n\n\t// texture parameterized by sqrt( GGX alpha ) and sqrt( 1 - cos( theta ) )\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\n\treturn uv;\n\n}\n\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\n\t// Real-Time Area Lighting: a Journey from Research to Production (p.102)\n\t// An approximation of the form factor of a horizon-clipped rectangle.\n\n\tfloat l = length( f );\n\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n\n}\n\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\n\tfloat x = dot( v1, v2 );\n\n\tfloat y = abs( x );\n\n\t// rational polynomial approximation to theta / sin( theta ) / 2PI\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\n\treturn cross( v1, v2 ) * theta_sintheta;\n\n}\n\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\n\t// bail if point is on back side of plane of light\n\t// assumes ccw winding order of light vertices\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\n\t// construct orthonormal basis around N\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 ); // negated from paper; possibly due to a different handedness of world coordinate system\n\n\t// compute transform\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\n\t// transform rect\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\n\t// project rect onto sphere\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\n\t// calculate vector form factor\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\n\t// adjust for horizon clipping\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\n/*\n\t// alternate method of adjusting for horizon clipping (see referece)\n\t// refactoring required\n\tfloat len = length( vectorFormFactor );\n\tfloat z = vectorFormFactor.z / len;\n\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\n\t// tabulated horizon-clipped sphere, apparently...\n\tvec2 uv = vec2( z * 0.5 + 0.5, len );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\n\tfloat scale = texture2D( ltc_2, uv ).w;\n\n\tfloat result = len * scale;\n*/\n\n\treturn vec3( result );\n\n}\n\n// End Rect Area Light\n\n// ref: https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\n\treturn specularColor * brdf.x + brdf.y;\n\n} // validated\n\n// Fdez-Agüera\'s "Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting"\n// Approximates multiscattering in order to preserve energy.\n// http://www.jcgt.org/published/0008/01/03/\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619; // 1/21\n\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n\n}\n\nfloat G_BlinnPhong_Implicit( /* const in float dotNL, const in float dotNV */ ) {\n\n\t// geometry term is (n dot l)(n dot v) / 4(n dot l)(n dot v)\n\treturn 0.25;\n\n}\n\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n\n}\n\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\n\t//float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\t//float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\n\tfloat G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );\n\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\n\treturn F * ( G * D );\n\n} // validated\n\n// source: http://simonstechblog.blogspot.ca/2011/12/microfacet-brdf.html\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\n\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n\n#if defined( USE_SHEEN )\n\n// https://github.com/google/filament/blob/master/shaders/src/brdf.fs#L94\nfloat D_Charlie(float roughness, float NoH) {\n\t// Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF"\n\tfloat invAlpha  = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125); // 2^(-14/2), so sin2h^2 > 0 in fp16\n\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\n\n// https://github.com/google/filament/blob/master/shaders/src/brdf.fs#L136\nfloat V_Neubelt(float NoV, float NoL) {\n\t// Neubelt and Pettineo 2013, "Crafting a Next-gen Material Pipeline for The Order: 1886"\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\n\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n\n}\n\n#endif\n',
      bumpmap_pars_fragment:
        '\n#ifdef USE_BUMPMAP\n\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\n\t// Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen\n\t// http://api.unrealengine.com/attachments/Engine/Rendering/LightingAndShadows/BumpMappingWithoutTangentSpace/mm_sfgrad_bump.pdf\n\n\t// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n\tvec2 dHdxy_fwd() {\n\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n\t\treturn vec2( dBx, dBy );\n\n\t}\n\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n\t\t// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\n\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\t\t// normalized\n\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\n\t}\n\n#endif\n',
      clipping_planes_fragment:
        '\n#if NUM_CLIPPING_PLANES > 0\n\n\tvec4 plane;\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\n\t}\n\t#pragma unroll_loop_end\n\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\n\t\tbool clipped = true;\n\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\n\t\t}\n\t\t#pragma unroll_loop_end\n\n\t\tif ( clipped ) discard;\n\n\t#endif\n\n#endif\n',
      clipping_planes_pars_fragment:
        '\n#if NUM_CLIPPING_PLANES > 0\n\n\tvarying vec3 vClipPosition;\n\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n\n#endif\n',
      clipping_planes_pars_vertex:
        '\n#if NUM_CLIPPING_PLANES > 0\n\n\tvarying vec3 vClipPosition;\n\n#endif\n',
      clipping_planes_vertex:
        '\n#if NUM_CLIPPING_PLANES > 0\n\n\tvClipPosition = - mvPosition.xyz;\n\n#endif\n',
      color_fragment:
        '\n#ifdef USE_COLOR\n\n\tdiffuseColor.rgb *= vColor;\n\n#endif\n',
      color_pars_fragment:
        '\n#ifdef USE_COLOR\n\n\tvarying vec3 vColor;\n\n#endif\n',
      color_pars_vertex:
        '\n#ifdef USE_COLOR\n\n\tvarying vec3 vColor;\n\n#endif\n',
      color_vertex:
        '\n#ifdef USE_COLOR\n\n\tvColor.xyz = color.xyz;\n\n#endif\n',
      common:
        '\n#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n\n#ifndef saturate\n// <tonemapping_pars_fragment> may have defined saturate() already\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\n\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\n// expects values in the range of [0,1]x[0,1], returns values in the [0,1] range.\n// do not collapse into a single function per: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\n\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\n\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\n\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n}\n\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t// dir can be either a direction vector or a normal vector\n\t// upper-left 3x3 of matrix is assumed to be orthogonal\n\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n\n}\n\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\n\treturn - distance * planeNormal + point;\n\n}\n\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n\n}\n\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n\n}\n\nmat3 transposeMat3( const in mat3 m ) {\n\n\tmat3 tmp;\n\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\n\treturn tmp;\n\n}\n\n// https://en.wikipedia.org/wiki/Relative_luminance\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\n\treturn dot( weights, color.rgb );\n\n}\n\nbool isPerspectiveMatrix( mat4 m ) {\n\n  return m[ 2 ][ 3 ] == - 1.0;\n\n}\n',
      cube_uv_reflection_fragment:
        '\n#ifdef ENVMAP_TYPE_CUBE_UV\n\n#define cubeUV_maxMipLevel 8.0\n#define cubeUV_minMipLevel 4.0\n#define cubeUV_maxTileSize 256.0\n#define cubeUV_minTileSize 16.0\n\n// These shader functions convert between the UV coordinates of a single face of\n// a cubemap, the 0-5 integer index of a cube face, and the direction vector for\n// sampling a textureCube (not generally normalized).\n\nfloat getFace(vec3 direction) {\n    vec3 absDirection = abs(direction);\n    float face = -1.0;\n    if (absDirection.x > absDirection.z) {\n      if (absDirection.x > absDirection.y)\n        face = direction.x > 0.0 ? 0.0 : 3.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    } else {\n      if (absDirection.z > absDirection.y)\n        face = direction.z > 0.0 ? 2.0 : 5.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    }\n    return face;\n}\n\nvec2 getUV(vec3 direction, float face) {\n    vec2 uv;\n    if (face == 0.0) {\n      uv = vec2(-direction.z, direction.y) / abs(direction.x);\n    } else if (face == 1.0) {\n      uv = vec2(direction.x, -direction.z) / abs(direction.y);\n    } else if (face == 2.0) {\n      uv = direction.xy / abs(direction.z);\n    } else if (face == 3.0) {\n      uv = vec2(direction.z, direction.y) / abs(direction.x);\n    } else if (face == 4.0) {\n      uv = direction.xz / abs(direction.y);\n    } else {\n      uv = vec2(-direction.x, direction.y) / abs(direction.z);\n    }\n    return 0.5 * (uv + 1.0);\n}\n\nvec3 bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {\n  float face = getFace(direction);\n  float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);\n  mipInt = max(mipInt, cubeUV_minMipLevel);\n  float faceSize = exp2(mipInt);\n\n  float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\n\n  vec2 uv = getUV(direction, face) * (faceSize - 1.0);\n  vec2 f = fract(uv);\n  uv += 0.5 - f;\n  if (face > 2.0) {\n    uv.y += faceSize;\n    face -= 3.0;\n  }\n  uv.x += face * faceSize;\n  if(mipInt < cubeUV_maxMipLevel){\n    uv.y += 2.0 * cubeUV_maxTileSize;\n  }\n  uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n  uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\n  uv *= texelSize;\n\n  vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x += texelSize;\n  vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.y += texelSize;\n  vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x -= texelSize;\n  vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  vec3 tm = mix(tl, tr, f.x);\n  vec3 bm = mix(bl, br, f.x);\n  return mix(tm, bm, f.y);\n}\n\n// These defines must match with PMREMGenerator\n\n#define r0 1.0\n#define v0 0.339\n#define m0 -2.0\n#define r1 0.8\n#define v1 0.276\n#define m1 -1.0\n#define r4 0.4\n#define v4 0.046\n#define m4 2.0\n#define r5 0.305\n#define v5 0.016\n#define m5 3.0\n#define r6 0.21\n#define v6 0.0038\n#define m6 4.0\n\nfloat roughnessToMip(float roughness) {\n  float mip = 0.0;\n  if (roughness >= r1) {\n    mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;\n  } else if (roughness >= r4) {\n    mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;\n  } else if (roughness >= r5) {\n    mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;\n  } else if (roughness >= r6) {\n    mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;\n  } else {\n    mip = -2.0 * log2(1.16 * roughness);// 1.16 = 1.79^0.25\n  }\n  return mip;\n}\n\nvec4 textureCubeUV(sampler2D envMap, vec3 sampleDir, float roughness) {\n  float mip = clamp(roughnessToMip(roughness), m0, cubeUV_maxMipLevel);\n  float mipF = fract(mip);\n  float mipInt = floor(mip);\n\n  vec3 color0 = bilinearCubeUV(envMap, sampleDir, mipInt);\n  if (mipF == 0.0) {\n    return vec4(color0, 1.0);\n  } else {\n    vec3 color1 = bilinearCubeUV(envMap, sampleDir, mipInt + 1.0);\n    return vec4(mix(color0, color1, mipF), 1.0);\n  }\n}\n#endif\n',
      defaultnormal_vertex:
        '\nvec3 transformedNormal = objectNormal;\n\n#ifdef USE_INSTANCING\n\n\t// // this is in lieu of a per-instance normal-matrix\n\t// // shear transforms in the instance matrix are not supported\n\n\tmat3 m = mat3( instanceMatrix );\n\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\n\ttransformedNormal = m * transformedNormal;\n\n#endif\n\ntransformedNormal = normalMatrix * transformedNormal;\n\n#ifdef FLIP_SIDED\n\n\ttransformedNormal = - transformedNormal;\n\n#endif\n\n#ifdef USE_TANGENT\n\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\n\t#ifdef FLIP_SIDED\n\n\t\ttransformedTangent = - transformedTangent;\n\n\t#endif\n\n#endif\n',
      displacementmap_pars_vertex:
        '\n#ifdef USE_DISPLACEMENTMAP\n\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n\n#endif\n',
      displacementmap_vertex:
        '\n#ifdef USE_DISPLACEMENTMAP\n\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n\n#endif\n',
      emissivemap_fragment:
        '\n#ifdef USE_EMISSIVEMAP\n\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n\n#endif\n',
      emissivemap_pars_fragment:
        '\n#ifdef USE_EMISSIVEMAP\n\n\tuniform sampler2D emissiveMap;\n\n#endif\n',
      encodings_fragment:
        '\ngl_FragColor = linearToOutputTexel( gl_FragColor );\n',
      encodings_pars_fragment:
        '\n// For a discussion of what this is, please read this: http://lousodrome.net/blog/light/2013/05/26/gamma-correct-and-hdr-rendering-in-a-32-bits-buffer/\n\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\n\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\n\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\n\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\n\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\n\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\n\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n//  return vec4( value.brg, ( 3.0 + 128.0 ) / 256.0 );\n}\n\n// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\n\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\n\n// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\n\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\t// NOTE: The implementation with min causes the shader to not compile on\n\t// a common Alcatel A502DL in Chrome 78/Android 8.1. Some research suggests \n\t// that the chipset is Mediatek MT6739 w/ IMG PowerVR GE8100 GPU.\n\t// D = min( floor( D ) / 255.0, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\n\n// LogLuv reference: http://graphicrants.blogspot.ca/2009/04/rgbm-color-encoding.html\n\n// M matrix, for encoding\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\n\n// Inverse M matrix, for decoding\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}\n',
      envmap_fragment:
        '\n#ifdef USE_ENVMAP\n\n\t#ifdef ENV_WORLDPOS\n\n\t\tvec3 cameraToFrag;\n\t\t\n\t\tif ( isOrthographic ) {\n\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\n\t\t}  else {\n\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\n\t\t}\n\n\t\t// Transforming Normal Vectors with the Inverse Transformation\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\n\t\t#else\n\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\n\t\t#endif\n\n\t#else\n\n\t\tvec3 reflectVec = vReflect;\n\n\t#endif\n\n\t#ifdef ENVMAP_TYPE_CUBE\n\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\n\t\tvec2 sampleUV;\n\n\t\treflectVec = normalize( reflectVec );\n\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\n\t\treflectVec = normalize( reflectVec );\n\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\n\t#else\n\n\t\tvec4 envColor = vec4( 0.0 );\n\n\t#endif\n\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\n\t\tenvColor = envMapTexelToLinear( envColor );\n\n\t#endif\n\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\n\t#endif\n\n#endif\n',
      envmap_common_pars_fragment:
        '\n#ifdef USE_ENVMAP\n\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif\n',
      envmap_pars_fragment:
        '\n#ifdef USE_ENVMAP\n\n\tuniform float reflectivity;\n\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n\t\t#define ENV_WORLDPOS\n\n\t#endif\n\n\t#ifdef ENV_WORLDPOS\n\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n\n#endif\n',
      envmap_pars_vertex:
        '\n#ifdef USE_ENVMAP\n\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\n\t\t#define ENV_WORLDPOS\n\n\t#endif\n\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\n\t#else\n\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\n\t#endif\n\n#endif\n',
      envmap_physical_pars_fragment:
        '\n#if defined( USE_ENVMAP )\n\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\n\tvec3 getLightProbeIndirectIrradiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry, const in int maxMIPLevel ) {\n\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\n\t\t\t// TODO: replace with properly filtered cubemaps and access the irradiance LOD level, be it the last LOD level\n\t\t\t// of a specular cubemap, or just the default level of a specially created irradiance cubemap.\n\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\n\t\t\t#else\n\n\t\t\t\t// force the bias high to get the last LOD level as it is the most blurred.\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\n\t\t\t#endif\n\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\n\t\t#else\n\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\n\t\t#endif\n\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\n\t}\n\n\t// Trowbridge-Reitz distribution to Mip level, following the logic of http://casual-effects.blogspot.ca/2011/08/plausible-environment-lighting-in-two.html\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\n\t\t// clamp to allowable LOD ranges.\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\n\t}\n\n\tvec3 getLightProbeIndirectRadiance( /*const in SpecularLightProbe specularLightProbe,*/ const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\n\t\t  vec3 reflectVec = reflect( -viewDir, normal );\n\n\t\t  // Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.\n\t\t  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\n\t\t#else\n\n\t\t  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\n\t\t#endif\n\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\n\t\t\t#else\n\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\n\t\t\t#endif\n\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\n\t\t\t#else\n\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\n\t\t\t#endif\n\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\n\t\t\t#else\n\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\n\t\t\t#endif\n\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n\t\t#endif\n\n\t\treturn envMapColor.rgb * envMapIntensity;\n\n\t}\n\n#endif\n',
      envmap_vertex:
        '\n#ifdef USE_ENVMAP\n\n\t#ifdef ENV_WORLDPOS\n\n\t\tvWorldPosition = worldPosition.xyz;\n\n\t#else\n\n\t\tvec3 cameraToVertex;\n\n\t\tif ( isOrthographic ) { \n\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\n\t\t} else {\n\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n\t\t}\n\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\n\t\t#else\n\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n\t\t#endif\n\n\t#endif\n\n#endif\n',
      fog_vertex: '\n#ifdef USE_FOG\n\n\tfogDepth = -mvPosition.z;\n\n#endif\n',
      fog_pars_vertex:
        '\n#ifdef USE_FOG\n\n\tvarying float fogDepth;\n\n#endif\n',
      fog_fragment:
        '\n#ifdef USE_FOG\n\n\t#ifdef FOG_EXP2\n\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\n\t#else\n\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\n\t#endif\n\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n\n#endif\n',
      fog_pars_fragment:
        '\n#ifdef USE_FOG\n\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\n\t#ifdef FOG_EXP2\n\n\t\tuniform float fogDensity;\n\n\t#else\n\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\n\t#endif\n\n#endif\n',
      gradientmap_pars_fragment:
        '\n\n#ifdef USE_GRADIENTMAP\n\n\tuniform sampler2D gradientMap;\n\n#endif\n\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\n\t// dotNL will be from -1.0 to 1.0\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\n\t#ifdef USE_GRADIENTMAP\n\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\n\t#else\n\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\n\t#endif\n\n}\n\n',
      lightmap_fragment:
        '\n#ifdef USE_LIGHTMAP\n\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity; // factor of PI should not be present; included here to prevent breakage\n\n#endif\n',
      lightmap_pars_fragment:
        '\n#ifdef USE_LIGHTMAP\n\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n\n#endif\n',
      lights_lambert_vertex:
        '\nvec3 diffuse = vec3( 1.0 );\n\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\n\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\n\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\n\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n\n#if NUM_POINT_LIGHTS > 0\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\t#ifdef USE_SMOOTH_LIGHTING\n\t    dotNL = dotNL * 0.5 + 0.5;\n\t  #endif\n\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\n\t\t#endif\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if NUM_SPOT_LIGHTS > 0\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\t#ifdef USE_SMOOTH_LIGHTING\n\t    dotNL = dotNL * 0.5 + 0.5;\n\t  #endif\n\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n/*\n#if NUM_RECT_AREA_LIGHTS > 0\n\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\n\t\t// TODO (abelnation): implement\n\n\t}\n\n#endif\n*/\n\n#if NUM_DIR_LIGHTS > 0\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\t#ifdef USE_SMOOTH_LIGHTING\n\t    dotNL = dotNL * 0.5 + 0.5;\n\n\t  #endif\n\n\t  directLightColor_Diffuse = PI * directLight.color;\n\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\n\t\t#endif\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if NUM_HEMI_LIGHTS > 0\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\n\t\t#endif\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n',
      lights_pars_begin:
        "\nuniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\n\n// get the irradiance (radiance convolved with cosine lobe) at the point 'normal' on the unit sphere\n// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\n\t// normal is assumed to have unit length\n\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\n\t// band 0\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\n\t// band 1\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\n\t// band 2\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\n\treturn result;\n\n}\n\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\n\treturn irradiance;\n\n}\n\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\n\tvec3 irradiance = ambientLightColor;\n\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n\t\tirradiance *= PI;\n\n\t#endif\n\n\treturn irradiance;\n\n}\n\n#if NUM_DIR_LIGHTS > 0\n\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\n\t#endif\n\n\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\n\t}\n\n#endif\n\n\n#if NUM_POINT_LIGHTS > 0\n\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t// directLight is an out parameter as having it as a return value caused compiler errors on some devices\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\n\t\tfloat lightDistance = length( lVector );\n\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\n\t}\n\n#endif\n\n\n#if NUM_SPOT_LIGHTS > 0\n\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t// directLight is an out parameter as having it as a return value caused compiler errors on some devices\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\n\t\tif ( angleCos > spotLight.coneCos ) {\n\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\n\t\t} else {\n\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\n\t\t}\n\t}\n\n#endif\n\n\n#if NUM_RECT_AREA_LIGHTS > 0\n\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\n\t// Pre-computed values of LinearTransformedCosine approximation of BRDF\n\t// BRDF approximation Texture is 64x64\n\tuniform sampler2D ltc_1; // RGBA Float\n\tuniform sampler2D ltc_2; // RGBA Float\n\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n\n#endif\n\n\n#if NUM_HEMI_LIGHTS > 0\n\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n\t\t\tirradiance *= PI;\n\n\t\t#endif\n\n\t\treturn irradiance;\n\n\t}\n\n#endif\n",
      lights_toon_fragment:
        '\nToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n',
      lights_toon_pars_fragment:
        '\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n\nstruct ToonMaterial {\n\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n\n};\n\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n\t\tirradiance *= PI; // punctual light\n\n\t#endif\n\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n\n}\n\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n}\n\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n\n#define Material_LightProbeLOD( material )\t(0)\n',
      lights_phong_fragment:
        '\nBlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n',
      lights_phong_pars_fragment:
        '\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n\nstruct BlinnPhongMaterial {\n\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n\n};\n\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\n\tfloat dotNL = dot( geometry.normal, directLight.direction );\n\t#ifdef USE_SMOOTH_LIGHTING\n\t  dotNL = dotNL * 0.5 + 0.5;\n\t#endif\n\n\tdotNL = saturate(dotNL);\n\tvec3 irradiance = dotNL * directLight.color;\n\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n\t\tirradiance *= PI; // punctual light\n\n\t#endif\n\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n\n}\n\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n}\n\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n\n#define Material_LightProbeLOD( material )\t(0)\n',
      lights_physical_fragment:
        '\nPhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\n\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\n\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );// 0.0525 corresponds to the base mip of a 256 cubemap.\nmaterial.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n\n#ifdef REFLECTIVITY\n\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\n#else\n\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n\n#endif\n\n#ifdef CLEARCOAT\n\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\n\t#ifdef USE_CLEARCOATMAP\n\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\n\t#endif\n\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\n\t#endif\n\n\tmaterial.clearcoat = saturate( material.clearcoat ); // Burley clearcoat model\n\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n\n#endif\n\n#ifdef USE_SHEEN\n\n\tmaterial.sheenColor = sheen;\n\n#endif\n',
      lights_physical_pars_fragment:
        '\nstruct PhysicalMaterial {\n\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n\n};\n\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\n\n// Clear coat directional hemishperical reflectance (this approximation should be improved)\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n\n}\n\n#if NUM_RECT_AREA_LIGHTS > 0\n\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight; // counterclockwise; light shines in local neg z direction\n\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\n\t\t// LTC Fresnel Approximation by Stephen Hill\n\t\t// http://blog.selfshadow.com/publications/s2016-advances/s2016_ltc_fresnel.pdf\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\n\t}\n\n#endif\n\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\n\tvec3 irradiance = dotNL * directLight.color;\n\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n\t\tirradiance *= PI; // punctual light\n\n\t#endif\n\n\t#ifdef CLEARCOAT\n\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n\t\t\tccIrradiance *= PI; // punctual light\n\n\t\t#endif\n\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\n\t#else\n\n\t\tfloat clearcoatDHR = 0.0;\n\n\t#endif\n\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n}\n\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\n\t#ifdef CLEARCOAT\n\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\n\t#else\n\n\t\tfloat clearcoatDHR = 0.0;\n\n\t#endif\n\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\n\t// Both indirect specular and indirect diffuse light accumulate here\n\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n\n}\n\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n\n// ref: https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n\n}\n',
      lights_fragment_begin:
        '\n/**\n * This is a template that can be used to light a material, it uses pluggable\n * RenderEquations (RE)for specific lighting scenarios.\n *\n * Instructions for use:\n * - Ensure that both RE_Direct, RE_IndirectDiffuse and RE_IndirectSpecular are defined\n * - If you have defined an RE_IndirectSpecular, you need to also provide a Material_LightProbeLOD. <---- ???\n * - Create a material parameter that is to be passed as the third parameter to your lighting functions.\n *\n * TODO:\n * - Add area light support.\n * - Add sphere light support.\n * - Add diffuse light probe (irradiance cubemap) support.\n */\n\nGeometricContext geometry;\n\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n\n#ifdef CLEARCOAT\n\n\tgeometry.clearcoatNormal = clearcoatNormal;\n\n#endif\n\nIncidentLight directLight;\n\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n\t\tpointLight = pointLights[ i ];\n\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n\t\tspotLight = spotLights[ i ];\n\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\tdirectionalLight = directionalLights[ i ];\n\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\n\tRectAreaLight rectAreaLight;\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if defined( RE_IndirectDiffuse )\n\n\tvec3 iblIrradiance = vec3( 0.0 );\n\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\n\t\t}\n\t\t#pragma unroll_loop_end\n\n\t#endif\n\n#endif\n\n#if defined( RE_IndirectSpecular )\n\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n\n#endif\n',
      lights_fragment_maps:
        '\n#if defined( RE_IndirectDiffuse )\n\n\t#ifdef USE_LIGHTMAP\n\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n\t\t\tlightMapIrradiance *= PI; // factor of PI should not be present; included here to prevent breakage\n\n\t\t#endif\n\n\t\tirradiance += lightMapIrradiance;\n\n\t#endif\n\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( /*lightProbe,*/ geometry, maxMipLevel );\n\n\t#endif\n\n#endif\n\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\n\tradiance += getLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\n\t#ifdef CLEARCOAT\n\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\n\t#endif\n\n#endif\n',
      lights_fragment_end:
        '\n#if defined( RE_IndirectDiffuse )\n\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n\n#endif\n\n#if defined( RE_IndirectSpecular )\n\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n\n#endif\n',
      logdepthbuf_fragment:
        '\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\n\t// Doing a strict comparison with == 1.0 can cause noise artifacts\n\t// on some platforms. See issue #17623.\n\tif(vIsPerspective == 0.0) {\n\t  gl_FragDepthEXT = gl_FragCoord.z;\n\t} else {\n\t   float depth = log2( vFragDepth ) * logDepthBufFC * 0.5;\n\n\t   #ifdef USE_OFFSET_VERTEX_POSITION\n      float depth2 = log2( vFragDepthOffset ) * logDepthBufFC * 0.5;\n      float depthOffset = abs(depth2 - depth);\n      if(positionOffset < 0.0)\n        depth -= depthOffset;\n      else\n        depth += depthOffset;\n      #endif\n    gl_FragDepthEXT = depth;\n\t}\n\n#endif\n',
      logdepthbuf_pars_fragment:
        '\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n\n\t#ifdef USE_OFFSET_VERTEX_POSITION\n     uniform float positionOffset;\n     varying float vFragDepthOffset;\n  #endif\n\n#endif\n',
      logdepthbuf_pars_vertex:
        '\n#ifdef USE_LOGDEPTHBUF\n\n  #ifdef USE_OFFSET_VERTEX_POSITION\n    uniform float positionOffset;\n  #endif\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\n\t\t#ifdef USE_OFFSET_VERTEX_POSITION\n      varying float vFragDepthOffset;\n    #endif\n\n\t#else\n\n\t\tuniform float logDepthBufFC;\n\n\t#endif\n\n#endif\n',
      logdepthbuf_vertex:
        '\n#ifdef USE_LOGDEPTHBUF\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\n    #ifdef USE_OFFSET_VERTEX_POSITION\n      vec3 offsetDir = vec3(viewMatrix[0][2], viewMatrix[1][2], viewMatrix[2][2]);\n      vec4 projOffset = projectionMatrix * vec4( mvPosition.xyz + offsetDir * positionOffset, 1.0 );\n      vFragDepthOffset = 1.0 + projOffset.w;\n    #endif\n\n\t#else\n\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\n\t\t\tgl_Position.z *= gl_Position.w;\n\n\t\t}\n\n\t#endif\n\n#endif\n',
      map_fragment:
        '\n#ifdef USE_MAP\n\n\tvec4 texelColor = texture2D( map, vUv );\n\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n\n#endif\n',
      map_pars_fragment:
        '\n#ifdef USE_MAP\n\n\tuniform sampler2D map;\n\n#endif\n',
      map_particle_fragment:
        '\n#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\n#endif\n\n#ifdef USE_MAP\n\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n\n#endif\n\n#ifdef USE_ALPHAMAP\n\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n\n#endif\n',
      map_particle_pars_fragment:
        '\n#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\n\tuniform mat3 uvTransform;\n\n#endif\n\n#ifdef USE_MAP\n\n\tuniform sampler2D map;\n\n#endif\n\n#ifdef USE_ALPHAMAP\n\n\tuniform sampler2D alphaMap;\n\n#endif\n',
      metalnessmap_fragment:
        '\nfloat metalnessFactor = metalness;\n\n#ifdef USE_METALNESSMAP\n\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\n\t// reads channel B, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n\tmetalnessFactor *= texelMetalness.b;\n\n#endif\n',
      metalnessmap_pars_fragment:
        '\n#ifdef USE_METALNESSMAP\n\n\tuniform sampler2D metalnessMap;\n\n#endif\n',
      morphnormal_vertex:
        '\n#ifdef USE_MORPHNORMALS\n\n\t// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:\n\t// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in normal = sum((target - base) * influence)\n\t// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\n#endif\n',
      morphtarget_pars_vertex:
        '\n#ifdef USE_MORPHTARGETS\n\n\tuniform float morphTargetBaseInfluence;\n\n\t#ifndef USE_MORPHNORMALS\n\n\tuniform float morphTargetInfluences[ 8 ];\n\n\t#else\n\n\tuniform float morphTargetInfluences[ 4 ];\n\n\t#endif\n\n#endif\n',
      morphtarget_vertex:
        '\n#ifdef USE_MORPHTARGETS\n\n\t// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:\n\t// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in position = sum((target - base) * influence)\n\t// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\n\t#ifndef USE_MORPHNORMALS\n\n\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\n\t#endif\n\n#endif\n',
      normal_fragment_begin:
        '\n#ifdef FLAT_SHADED\n\n\t// Workaround for Adreno/Nexus5 not able able to do dFdx( vViewPosition ) ...\n\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n\n#else\n\n\tvec3 normal = normalize( vNormal );\n\n\t#ifdef DOUBLE_SIDED\n\n\t\t//normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n\t#endif\n\n\t#ifdef USE_TANGENT\n\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n\t\t#endif\n\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\n\t\t#endif\n\n\t#endif\n\n#endif\n\n// non perturbed normal for clearcoat among others\n\nvec3 geometryNormal = normal;\n\n',
      normal_fragment_maps:
        '\n\n#ifdef OBJECTSPACE_NORMALMAP\n\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0; // overrides both flatShading and attribute normals\n\n\t#ifdef FLIP_SIDED\n\n\t\tnormal = - normal;\n\n\t#endif\n\n\t#ifdef DOUBLE_SIDED\n\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n\t#endif\n\n\tnormal = normalize( normalMatrix * normal );\n\n#elif defined( TANGENTSPACE_NORMALMAP )\n\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\n\t#ifdef USE_TANGENT\n\n\t\tnormal = normalize( vTBN * mapN );\n\n\t#else\n\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\n\t#endif\n\n#elif defined( USE_BUMPMAP )\n\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n',
      normalmap_pars_fragment:
        '\n#ifdef USE_NORMALMAP\n\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\n#endif\n\n#ifdef OBJECTSPACE_NORMALMAP\n\n\tuniform mat3 normalMatrix;\n\n#endif\n\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\n\t// Per-Pixel Tangent Space Normal Mapping\n\t// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\n\t\t// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\n\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s ); // we do not care about the magnitude\n\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\n\t\tmat3 tsn = mat3( S, T, N );\n\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n\t\treturn normalize( tsn * mapN );\n\n\t}\n\n#endif\n',
      clearcoat_normal_fragment_begin:
        '\n#ifdef CLEARCOAT\n\n\tvec3 clearcoatNormal = geometryNormal;\n\n#endif\n',
      clearcoat_normal_fragment_maps:
        '\n#ifdef USE_CLEARCOAT_NORMALMAP\n\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\n\t#ifdef USE_TANGENT\n\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\n\t#else\n\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\n\t#endif\n\n#endif\n',
      clearcoat_pars_fragment:
        '\n\n#ifdef USE_CLEARCOATMAP\n\n\tuniform sampler2D clearcoatMap;\n\n#endif\n\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\n\tuniform sampler2D clearcoatRoughnessMap;\n\n#endif\n\n#ifdef USE_CLEARCOAT_NORMALMAP\n\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n\n#endif\n',
      packing:
        '\nvec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\n\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\n\nconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\nconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\n\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\n\nconst float ShiftRight8 = 1. / 256.;\n\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8; // tidy overflow\n\treturn r * PackUpscale;\n}\n\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\n\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\n\n// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\n\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\n\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n',
      premultiplied_alpha_fragment:
        '\n#ifdef PREMULTIPLIED_ALPHA\n\n\t// Get get normal blending with premultipled, use with CustomBlending, OneFactor, OneMinusSrcAlphaFactor, AddEquation.\n\tgl_FragColor.rgb *= gl_FragColor.a;\n\n#endif\n',
      project_vertex:
        '\nvec4 mvPosition = vec4( transformed, 1.0 );\n\n#ifdef USE_INSTANCING\n\n\tmvPosition = instanceMatrix * mvPosition;\n\n#endif\n\n  if(isInstanceDrawing) {\n    mat4 instanceMat = mat4(instanceMatrixR1, instanceMatrixR2, instanceMatrixR3, instanceMatrixR4);\n    mvPosition = modelViewMatrix * instanceMat * mvPosition;\n  } else {\n    mvPosition = modelViewMatrix * mvPosition;\n  }\n\ngl_Position = projectionMatrix * mvPosition;\n',
      dithering_fragment:
        '\n#ifdef DITHERING\n\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n\n#endif\n',
      dithering_pars_fragment:
        '\n#ifdef DITHERING\n\n\t// based on https://www.shadertoy.com/view/MslGR8\n\tvec3 dithering( vec3 color ) {\n\t\t//Calculate grid position\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\n\t\t//Shift the individual colors differently, thus making it even harder to see the dithering pattern\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\n\t\t//modify shift acording to grid position.\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\n\t\t//shift the color by dither_shift\n\t\treturn color + dither_shift_RGB;\n\t}\n\n#endif\n',
      roughnessmap_fragment:
        '\nfloat roughnessFactor = roughness;\n\n#ifdef USE_ROUGHNESSMAP\n\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\n\t// reads channel G, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n\troughnessFactor *= texelRoughness.g;\n\n#endif\n',
      roughnessmap_pars_fragment:
        '\n#ifdef USE_ROUGHNESSMAP\n\n\tuniform sampler2D roughnessMap;\n\n#endif\n',
      shadowmap_pars_fragment:
        '\n#ifdef USE_SHADOWMAP\n\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t/*\n\t#if NUM_RECT_AREA_LIGHTS > 0\n\n\t\t// TODO (abelnation): create uniforms for area light shadows\n\n\t#endif\n\t*/\n\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\n\t}\n\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\n\t}\n\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\n\t\tfloat occlusion = 1.0;\n\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\n\t\tfloat hard_shadow = step( compare , distribution.x ); // Hard Shadow\n\n\t\tif (hard_shadow != 1.0 ) {\n\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance ); // Chebeyshevs inequality\n\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 ); // 0.3 reduces light bleed\n\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\n\t\t}\n\t\treturn occlusion;\n\n\t}\n\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\n\t\tfloat shadow = 1.0;\n\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\n\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\n\t\t// if ( all( something, something ) ) using this instead\n\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n\t\tbool frustumTest = all( frustumTestVec );\n\n\t\tif ( frustumTest ) {\n\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n\t\t#else // no percentage-closer filtering:\n\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n\t\t#endif\n\n\t\t}\n\n\t\treturn shadow;\n\n\t}\n\n\t// cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D\n\t// vector suitable for 2D texture mapping. This code uses the following layout for the\n\t// 2D texture:\n\t//\n\t// xzXZ\n\t//  y Y\n\t//\n\t// Y - Positive y direction\n\t// y - Negative y direction\n\t// X - Positive x direction\n\t// x - Negative x direction\n\t// Z - Positive z direction\n\t// z - Negative z direction\n\t//\n\t// Source and test bed:\n\t// https://gist.github.com/tschw/da10c43c467ce8afd0c4\n\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\n\t\t// Number of texels to avoid at the edge of each square\n\n\t\tvec3 absV = abs( v );\n\n\t\t// Intersect unit cube\n\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\n\t\t// Apply scale to avoid seams\n\n\t\t// two texels less per square (one texel will do for NEAREST)\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\n\t\t// Unwrap\n\n\t\t// space: -1 ... 1 range for each square\n\t\t//\n\t\t// #X##\t\tdim    := ( 4 , 2 )\n\t\t//  # #\t\tcenter := ( 1 , 1 )\n\n\t\tvec2 planar = v.xy;\n\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\n\t\tif ( absV.z >= almostOne ) {\n\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\n\t\t} else if ( absV.x >= almostOne ) {\n\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\n\t\t} else if ( absV.y >= almostOne ) {\n\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\n\t\t}\n\n\t\t// Transform to UV space\n\n\t\t// scale := 0.5 / dim\n\t\t// translate := ( center + 0.5 ) / dim\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\n\t}\n\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\n\t\t// for point lights, the uniform @vShadowCoord is re-purposed to hold\n\t\t// the vector from the light to the world-space position of the fragment.\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\n\t\t// dp = normalized distance from light to fragment position\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?\n\t\tdp += shadowBias;\n\n\t\t// bd3D = base direction 3D\n\t\tvec3 bd3D = normalize( lightToPosition );\n\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\n\t\t#else // no percentage-closer filtering\n\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\n\t\t#endif\n\n\t}\n\n#endif\n',
      shadowmap_pars_vertex:
        '\n#ifdef USE_SHADOWMAP\n\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t/*\n\t#if NUM_RECT_AREA_LIGHTS > 0\n\n\t\t// TODO (abelnation): uniforms for area light shadows\n\n\t#endif\n\t*/\n\n#endif\n',
      shadowmap_vertex:
        '\n#ifdef USE_SHADOWMAP\n\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\n\t}\n\t#pragma unroll_loop_end\n\n\t#endif\n\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\n\t}\n\t#pragma unroll_loop_end\n\n\t#endif\n\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\n\t}\n\t#pragma unroll_loop_end\n\n\t#endif\n\n\t/*\n\t#if NUM_RECT_AREA_LIGHTS > 0\n\n\t\t// TODO (abelnation): update vAreaShadowCoord with area light info\n\n\t#endif\n\t*/\n\n#endif\n',
      shadowmask_pars_fragment:
        '\nfloat getShadowMask() {\n\n\tfloat shadow = 1.0;\n\n\t#ifdef USE_SHADOWMAP\n\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\n\tDirectionalLightShadow directionalLight;\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\n\t}\n\t#pragma unroll_loop_end\n\n\t#endif\n\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\n\tSpotLightShadow spotLight;\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\n\t}\n\t#pragma unroll_loop_end\n\n\t#endif\n\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\n\tPointLightShadow pointLight;\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\n\t}\n\t#pragma unroll_loop_end\n\n\t#endif\n\n\t/*\n\t#if NUM_RECT_AREA_LIGHTS > 0\n\n\t\t// TODO (abelnation): update shadow for Area light\n\n\t#endif\n\t*/\n\n\t#endif\n\n\treturn shadow;\n\n}\n',
      skinbase_vertex:
        '\n#ifdef USE_SKINNING\n\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif\n',
      skinning_pars_vertex:
        '\n#ifdef USE_SKINNING\n\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\n\t#ifdef BONE_TEXTURE\n\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\n\t\tmat4 getBoneMatrix( const in float i ) {\n\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\n\t\t\ty = dy * ( y + 0.5 );\n\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\n\t\t\treturn bone;\n\n\t\t}\n\n\t#else\n\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\n\t\tmat4 getBoneMatrix( const in float i ) {\n\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\n\t\t}\n\n\t#endif\n\n#endif\n',
      skinning_vertex:
        '\n#ifdef USE_SKINNING\n\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n\n#endif\n',
      skinnormal_vertex:
        '\n#ifdef USE_SKINNING\n\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\n\t#ifdef USE_TANGENT\n\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\n\t#endif\n\n#endif\n',
      specularmap_fragment:
        '\nfloat specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n\n#else\n\n\tspecularStrength = 1.0;\n\n#endif\n',
      specularmap_pars_fragment:
        '\n#ifdef USE_SPECULARMAP\n\n\tuniform sampler2D specularMap;\n\n#endif\n',
      tonemapping_fragment:
        '\n#if defined( TONE_MAPPING )\n\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n\n#endif\n',
      tonemapping_pars_fragment:
        "\n#ifndef saturate\n// <common> may have defined saturate() already\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\n\n// exposure only\nvec3 LinearToneMapping( vec3 color ) {\n\n\treturn toneMappingExposure * color;\n\n}\n\n// source: https://www.cs.utah.edu/~reinhard/cdrom/\nvec3 ReinhardToneMapping( vec3 color ) {\n\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n\n}\n\n// source: http://filmicgames.com/archives/75\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\n\t// John Hable's filmic operator from Uncharted 2 video game\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n\n}\n\n// source: http://filmicgames.com/archives/75\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\n\t// optimized filmic operator by Jim Hejl and Richard Burgess-Dawson\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n\n}\n\n// source: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n\n}\n",
      uv_pars_fragment:
        '\n#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\n\tvarying vec2 vUv;\n\n#endif\n',
      uv_pars_vertex:
        '\n#ifdef USE_UV\n\n\t#ifdef UVS_VERTEX_ONLY\n\n\t\tvec2 vUv;\n\n\t#else\n\n\t\tvarying vec2 vUv;\n\n\t#endif\n\n\tuniform mat3 uvTransform;\n\n#endif\n',
      uv_vertex:
        '\n#ifdef USE_UV\n\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\n#endif\n',
      uv2_pars_fragment:
        '\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n\tvarying vec2 vUv2;\n\n#endif\n',
      uv2_pars_vertex:
        '\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\n\tuniform mat3 uv2Transform;\n\n#endif\n',
      uv2_vertex:
        '\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n\n#endif\n',
      worldpos_vertex:
        '\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\n\t#ifdef USE_INSTANCING\n\n\t\tworldPosition = instanceMatrix * worldPosition;\n\n\t#endif\n\n\tworldPosition = modelMatrix * worldPosition;\n\n#endif\n',
      background_frag:
        '\nuniform sampler2D t2D;\n\nvarying vec2 vUv;\n\nvoid main() {\n\n\tvec4 texColor = texture2D( t2D, vUv );\n\n\tgl_FragColor = mapTexelToLinear( texColor );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\n}\n',
      background_vert:
        '\nvarying vec2 vUv;\nuniform mat3 uvTransform;\n\nvoid main() {\n\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n\n}\n',
      cube_frag:
        '\n\n#include <envmap_common_pars_fragment>\nuniform float opacity;\n\nvarying vec3 vWorldDirection;\n\n#include <cube_uv_reflection_fragment>\n\nvoid main() {\n\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\n}\n',
      cube_vert:
        '\nvarying vec3 vWorldDirection;\n\n#include <common>\n\nvoid main() {\n\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\n\tgl_Position.z = gl_Position.w; // set z to camera.far\n\n}\n',
      depth_frag:
        '\n#if DEPTH_PACKING == 3200\n\n\tuniform float opacity;\n\n#endif\n\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvarying vec2 vHighPrecisionZW;\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( 1.0 );\n\n\t#if DEPTH_PACKING == 3200\n\n\t\tdiffuseColor.a = opacity;\n\n\t#endif\n\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\n\t#include <logdepthbuf_fragment>\n\n\t// Higher precision equivalent of gl_FragCoord.z. This assumes depthRange has been left to its default values.\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\n\t#if DEPTH_PACKING == 3200\n\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\n\t#elif DEPTH_PACKING == 3201\n\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\n\t#endif\n\n}\n',
      depth_vert:
        '\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\n// This is used for computing an equivalent of gl_FragCoord.z that is as high precision as possible.\n// Some platforms compute gl_FragCoord at a lower precision which makes the manually computed value better for\n// depth-based postprocessing effects. Reproduced on iPad with A10 processor / iPadOS 13.3.1.\nvarying vec2 vHighPrecisionZW;\n\nvoid main() {\n\n\t#include <uv_vertex>\n\n\t#include <skinbase_vertex>\n\n\t#ifdef USE_DISPLACEMENTMAP\n\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\n\t#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvHighPrecisionZW = gl_Position.zw;\n\n}\n',
      distanceRGBA_frag:
        '\n#define DISTANCE\n\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main () {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( 1.0 );\n\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist ); // clamp to [ 0, 1 ]\n\n\tgl_FragColor = packDepthToRGBA( dist );\n\n}\n',
      distanceRGBA_vert:
        '\n#define DISTANCE\n\nvarying vec3 vWorldPosition;\n\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\n\t#include <skinbase_vertex>\n\n\t#ifdef USE_DISPLACEMENTMAP\n\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\n\t#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvWorldPosition = worldPosition.xyz;\n\n}\n',
      equirect_frag:
        '\nuniform sampler2D tEquirect;\n\nvarying vec3 vWorldDirection;\n\n#include <common>\n\nvoid main() {\n\n\tvec3 direction = normalize( vWorldDirection );\n\n\tvec2 sampleUV;\n\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\n\tgl_FragColor = mapTexelToLinear( texColor );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\n}\n',
      equirect_vert:
        '\nvarying vec3 vWorldDirection;\n\n#include <common>\n\nvoid main() {\n\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\n}\n',
      linedashed_frag:
        '\nuniform vec3 diffuse;\nuniform float opacity;\n\nuniform float dashSize;\nuniform float totalSize;\n\nvarying float vLineDistance;\n\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\n\t\tdiscard;\n\n\t}\n\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\n\toutgoingLight = diffuseColor.rgb; // simple shader\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\n}\n',
      linedashed_vert:
        '\nuniform float scale;\nattribute float lineDistance;\n\nvarying float vLineDistance;\n\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\tvLineDistance = scale * lineDistance;\n\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\n}\n',
      meshbasic_frag:
        '\nuniform vec3 diffuse;\nuniform float opacity;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\n\t// accumulation (baked indirect lighting only)\n\t#ifdef USE_LIGHTMAP\n\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\n\t#else\n\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\n\t#endif\n\n\t// modulation\n\t#include <aomap_fragment>\n\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\n\t#include <envmap_fragment>\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\n}\n',
      meshbasic_vert:
        '\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\n\t#ifdef USE_ENVMAP\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n\t#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n\n}\n',
      meshlambert_frag:
        '\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\n\t// accumulation\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\n\t#ifdef DOUBLE_SIDED\n\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\n\t#else\n\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\n\t#endif\n\n\t#include <lightmap_fragment>\n\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\n\t#ifdef DOUBLE_SIDED\n\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\n\t#else\n\n\t\treflectedLight.directDiffuse = vLightFront;\n\n\t#endif\n\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\n\t// modulation\n\t#include <aomap_fragment>\n\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\n\t#include <envmap_fragment>\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n',
      meshlambert_vert:
        '\n#define LAMBERT\n\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n',
      meshmatcap_frag:
        '\n#define MATCAP\n\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5; // 0.495 to remove artifacts caused by undersized matcap disks\n\n\t#ifdef USE_MATCAP\n\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\n\t#else\n\n\t\tvec4 matcapColor = vec4( 1.0 );\n\n\t#endif\n\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\n}\n',
      meshmatcap_vert:
        '\n#define MATCAP\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n\t#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n\t\tvNormal = normalize( transformedNormal );\n\n\t#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\n\tvViewPosition = - mvPosition.xyz;\n\n}\n',
      meshtoon_frag:
        '\n#define TOON\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\n\t// accumulation\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\n\t// modulation\n\t#include <aomap_fragment>\n\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n\n}\n',
      meshtoon_vert:
        '\n#define TOON\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n\tvNormal = normalize( transformedNormal );\n\n#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvViewPosition = - mvPosition.xyz;\n\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n\n}\n',
      meshphong_frag:
        '\n#define PHONG\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\n\t// accumulation\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\n\t// modulation\n\t#include <aomap_fragment>\n\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\n\t#include <envmap_fragment>\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n\n}\n',
      meshphong_vert:
        '\n#define PHONG\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n\tvNormal = normalize( transformedNormal );\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvViewPosition = - mvPosition.xyz;\n\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n\n\t{\n\t\tvec3 viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n\t\tfloat dotNV = dot(vNormal, viewDir);\n\t\tvNormal = (dotNV < 0.0)? -vNormal : vNormal;\n\t}\n\n\n}\n',
      meshphysical_frag:
        '\n#define STANDARD\n\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSPARENCY\n#endif\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n\n#ifdef TRANSPARENCY\n\tuniform float transparency;\n#endif\n\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n\t#ifdef USE_TANGENT\n\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\n\t#endif\n\n#endif\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\n\t// accumulation\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\n\t// modulation\n\t#include <aomap_fragment>\n\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\n\t// this is a stub for the transparency model\n\t#ifdef TRANSPARENCY\n\t\tdiffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n\t#endif\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n\n}\n',
      meshphysical_vert:
        '\n#define STANDARD\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n\t#ifdef USE_TANGENT\n\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\n\t#endif\n\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n\tvNormal = normalize( transformedNormal );\n\n\t#ifdef USE_TANGENT\n\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\n\t#endif\n\n#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvViewPosition = - mvPosition.xyz;\n\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n\n}\n',
      normal_frag:
        '\n#define NORMAL\n\nuniform float opacity;\n\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\n\tvarying vec3 vViewPosition;\n\n#endif\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n\t#ifdef USE_TANGENT\n\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\n\t#endif\n\n#endif\n\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\n}\n',
      normal_vert:
        '\n#define NORMAL\n\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\n\tvarying vec3 vViewPosition;\n\n#endif\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n\t#ifdef USE_TANGENT\n\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\n\t#endif\n\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n\tvNormal = normalize( transformedNormal );\n\n\t#ifdef USE_TANGENT\n\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\n\t#endif\n\n#endif\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\n\tvViewPosition = - mvPosition.xyz;\n\n#endif\n\n}\n',
      points_frag:
        '\nuniform vec3 diffuse;\nuniform float opacity;\n\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\n\toutgoingLight = diffuseColor.rgb;\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\n}\n',
      points_vert:
        '\nuniform float size;\nuniform float scale;\n\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\n\tgl_PointSize = size;\n\n\t#ifdef USE_SIZEATTENUATION\n\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\n\t#endif\n\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n\n}\n',
      shadow_frag:
        '\nuniform vec3 color;\nuniform float opacity;\n\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n\nvoid main() {\n\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\n}\n',
      shadow_vert:
        '\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n\nvoid main() {\n\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n\n}\n',
      sprite_frag:
        '\nuniform vec3 diffuse;\nuniform float opacity;\n\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\n\toutgoingLight = diffuseColor.rgb;\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\n}\n',
      sprite_vert:
        '\nuniform float rotation;\nuniform vec2 center;\n\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t#include <uv_vertex>\n\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\n\t#ifndef USE_SIZEATTENUATION\n\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\n\t#endif\n\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\n\tmvPosition.xy += rotatedPosition;\n\n\tgl_Position = projectionMatrix * mvPosition;\n\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\n}\n',
      centerlineCylinder_frag:
        '//#version 300 es\n// #define varying in\n// out highp vec4 pc_fragColor;\n// #define gl_FragColor pc_fragColor\n//#define webgl2\n\n#define SHADER_NAME CenterlineCylinderMaterial\n\nprecision highp float;\nprecision highp int;\n\nuniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\n\n\nuniform vec3 diffuse;\nuniform float opacity;\n\nstruct DirectionalLight {\n\tvec3 direction;\n\tvec3 color;\n};\nuniform DirectionalLight directionalLights[ 1 ];\nuniform vec3 ambientLightColor;\n\n\nvarying float lerpPos;\nvarying vec3 vNormal0;\nvarying vec3 vNormal1;\n\n\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#ifdef needOffsetZ\n\t\t//gl_FragColor = vec4( 1.0, 1.0, 0.0, 1.0 );\n\t\t//return;\n\t\t//discard;\n\t#endif\n\n\t#include <clipping_planes_fragment>\n\n\n\tDirectionalLight directionalLight = directionalLights[ 0 ];\n\tvec3 normal ;//= normalize(vNormal);\n\n\tfloat ler = lerpPos <0.0 ? lerpPos +1.0 : lerpPos;\n\tint ni = lerpPos <0.0 ? 0 : 1;\n\tvec3 normalarr[3];\n\tnormalarr[0] = vNormal0;\n\tnormalarr[1] = vNormal1;\n\tnormalarr[2] = -vNormal0;\n\n#ifdef webgl2\n\tnormal = mix(normalarr[ni], normalarr[ni +1], ler);\n#else\n\tvec3 normal1 = ni == 0 ? normalarr[0] : normalarr[1];\n\tvec3 normal2 = ni == 0 ? normalarr[1] : normalarr[2];\n\tnormal = mix(normal1, normal2, ler);\n#endif\n\n\n\tnormal = normalize(normal);\n\n\tfloat NDL = dot(directionalLight.direction, normal);\n\tNDL = clamp(NDL, 0.0, 1.0);\n\tvec3 lightColor = directionalLight.color * NDL + ambientLightColor*1.2;\n\tgl_FragColor = vec4( diffuse * lightColor, opacity );\n}\n',
      centerlineCylinder_vert:
        '//#version 300 es\n// #define attribute in\n// #define varying out\n// #define texture2D texture\n//#define webgl2\n\n#define SHADER_NAME CenterlineCylinder_vs\n\nprecision highp float;\nprecision highp int;\n\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nuniform bool isOrthographic;\nattribute vec4 position;\n//attribute vec3 normal;\n//attribute vec2 uv;\n//uniform bool isInstanceDrawing;\n\n#ifdef webgl2\n\tattribute vec3 CcyMatR1; //.xyz = rkNormal\n\tattribute vec3 CcyMatR2; //.xyz = pathDir\n#else\n\tattribute vec4 CcyMatR1; //.xyz = rkNormal .w= packed 端面标识  (圆精度index无法使用）\n\tattribute vec4 CcyMatR2; //.xyz = pathDir .w = 端面index\n#endif\n\n#include <clipping_planes_pars_vertex>\n\nvarying float lerpPos;\nvarying vec3 vNormal0;\nvarying vec3 vNormal1;\n\nvec4 getPlane(vec3 rkNormal, vec3 rkPoint)\n{\n\tfloat d = dot(-rkNormal, rkPoint);\n\treturn vec4(rkNormal, d);\n}\n\nvec3 getIntersection(vec4 plane, vec3 p1, vec3 p2)\n{\n\tvec3 dir = normalize(p2 - p1);\n\tfloat denom = dot(plane.xyz, dir);\n\tif (abs(denom) < 0.00001)\n\t{\n\t\treturn p1;\n\t}\n\tfloat nom = dot(plane.xyz, p1) + plane.w;\n\tfloat t = -(nom / denom);\n\treturn p1 + dir * t;\n}\n\nvoid main() {\n\tvec3 pathDir = CcyMatR2.xyz;\n\tvec3 rkNormal = CcyMatR1.xyz;\n\n#ifdef webgl2\n\tint packedR = floatBitsToInt(position.w);\n\n\tfloat radius0 = 0.001f * float(packedR & 0xFFFFF);\n\tint endPointFlag = (packedR >> 30) & 0x03;\n\tint cycleIndex = (packedR >> 28) & 0x03;\n\tint endPointIndex = (packedR >> 20) & 0xFF;\n#else\n\tfloat radius0 = position.w;\n\tint endPointFlag = int(CcyMatR1.w);\n\tint endPointIndex = int(CcyMatR2.w);\n#endif\n\n\tvec3 transformed = vec3( position.xyz );\n\tvec4 mvPosition = vec4( transformed, 1.0 );\n\tmvPosition = modelViewMatrix * mvPosition;\n\n\tfloat offset[2];\n\toffset[0] = radius0;\n\toffset[1] = -radius0;\n\n\n\tvec3 camDir =isOrthographic ? vec3(0, 0, 1) : normalize(cameraPosition - mvPosition.xyz);\n\n\tpathDir = normalize(normalMatrix * pathDir);\n\tvec3 viewBinomal = normalize(cross(camDir.xyz, pathDir));\n\tvec3 viewUp = normalize(cross(pathDir, viewBinomal));\n\n\tfloat lep[2]; lep[0] = -1.0; lep[1] = 1.0;\n\tvNormal0 = viewBinomal;\n\tvNormal1 = viewUp;\n\n\tif(endPointFlag == 0 )\n\t{\n\t\trkNormal = normalMatrix * rkNormal;\n\n\t#ifdef webgl2\n\t\tlerpPos = lep[endPointIndex];\n\t\tvec3 viewBinormal0 = viewBinomal * offset[endPointIndex];\n\t#else\n\t\tlerpPos = endPointIndex == 0 ? lep[0] : lep[1];\n\t\tvec3 viewBinormal0 = viewBinomal * (endPointIndex == 0 ? offset[0] : offset[1]);\n\t#endif\n\n\t\tvec3 p0 = mvPosition.xyz + viewBinormal0;\n\t\tvec4 plane0 = getPlane(rkNormal, mvPosition.xyz);\n\t\n\t\tpathDir *= vec3(100.0);\n\t\tmvPosition.xyz = getIntersection(plane0, p0 - pathDir , p0 + pathDir);\n\t}\n\telse\n\t{\n\t\t//标准圆(8段)\n\t\tint secCount[3]; secCount[0] = 24; secCount[1] = 16;  secCount[2] = 8;\n\t\tvec3 scePosition[48];\n\n\t\t//24段标准园\n\t\tscePosition[0 ] = vec3(1, 0, 0);\n\t\tscePosition[1 ] = vec3(0.965926, -0.25882, 0);\n\t\tscePosition[2 ] = vec3(0.965926, 0.258819, 0);\n\t\tscePosition[3 ] = vec3(0.866025, -0.500001, 0);\n\t\tscePosition[4 ] = vec3(0.866025, 0.5, 0);\n\t\tscePosition[5 ] = vec3(0.707106, -0.707107, 0);\n\t\tscePosition[6 ] = vec3(0.707107, 0.707107, 0);\n\t\tscePosition[7 ] = vec3(0.499999, -0.866026, 0);\n\t\tscePosition[8 ] = vec3(0.5, 0.866025, 0);\n\t\tscePosition[9 ] = vec3(0.258819, -0.965926, 0);\n\t\tscePosition[10] = vec3(0.258819, 0.965926, 0);\n\t\tscePosition[11] = vec3(-4.64912e-07, -1, 0);\n\t\tscePosition[12] = vec3(7.54979e-08, 1, 0);\n\t\tscePosition[13] = vec3(-0.258819, -0.965926, 0);\n\t\tscePosition[14] = vec3(-0.258819, 0.965926, 0);\n\t\tscePosition[15] = vec3(-0.5, -0.866025, 0);\n\t\tscePosition[16] = vec3(-0.5, 0.866026, 0);\n\t\tscePosition[17] = vec3(-0.707107, -0.707106, 0);\n\t\tscePosition[18] = vec3(-0.707107, 0.707107, 0);\n\t\tscePosition[19] = vec3(-0.866026, -0.5, 0);\n\t\tscePosition[20] = vec3(-0.866025, 0.5, 0);\n\t\tscePosition[21] = vec3(-0.965926, -0.258819, 0);\n\t\tscePosition[22] = vec3(-0.965926, 0.258819, 0);\n\t\tscePosition[23] = vec3(-1, 3.89414e-07, 0);\n\n\t\t//16段标准园\n\t\tscePosition[24+0 ] = vec3(1, 0, 0);\n\t\tscePosition[24+1 ] = vec3(0.92388, -0.382683, 0);\n\t\tscePosition[24+2 ] = vec3(0.92388, 0.382683, 0);\n\t\tscePosition[24+3 ] = vec3(0.707107, -0.707107, 0);\n\t\tscePosition[24+4 ] = vec3(0.707107, 0.707107, 0);\n\t\tscePosition[24+5 ] = vec3(0.382684, -0.923879, 0);\n\t\tscePosition[24+6 ] = vec3(0.382683, 0.92388, 0);\n\t\tscePosition[24+7 ] = vec3(1.19249e-08, -1, 0);\n\t\tscePosition[24+8 ] = vec3(-4.37114e-08, 1, 0);\n\t\tscePosition[24+9 ] = vec3(-0.382684, -0.92388, 0);\n\t\tscePosition[24+10] = vec3(-0.382684, 0.92388, 0);\n\t\tscePosition[24+11] = vec3(-0.707107, -0.707107, 0);\n\t\tscePosition[24+12] = vec3(-0.707107, 0.707107, 0);\n\t\tscePosition[24+13] = vec3(-0.92388, -0.382683, 0);\n\t\tscePosition[24+14] = vec3(-0.92388, 0.382683, 0);\n\t\tscePosition[24+15] = vec3(-1, 1.50996e-07, 0);\n\n\t\t//8段标准园\n\t\tscePosition[40+0] = vec3(1, 0, 0);\n\t\tscePosition[40+1] = vec3(0.707107, -0.707107, 0);\n\t\tscePosition[40+2] = vec3(0.707107, 0.707107, 0);\n\t\tscePosition[40+3] = vec3(1.19249e-08, -1, 0);\n\t\tscePosition[40+4] = vec3(-4.37114e-08, 1, 0);\n\t\tscePosition[40+5] = vec3(-0.707107, -0.707107, 0);\n\t\tscePosition[40+6] = vec3(-0.707107, 0.707107, 0);\n\t\tscePosition[40+7] = vec3(-1, 0, 0);\n\t\t\n\t\tmat3 rotmat = mat3(\n\t\t\tviewBinomal.x, -viewUp.x, pathDir.x,\n\t\t\tviewBinomal.y, -viewUp.y, pathDir.y,\n\t\t\tviewBinomal.z, -viewUp.z, pathDir.z);\n\n\t\tvec3 cycleNormal = endPointFlag == 1 ? -pathDir : pathDir;\n\t\tfloat dotNV = dot(cycleNormal, camDir);\n\t\t\t\n\n\t#ifdef webgl2\n\t\tint cycleIndex_start = 0;\n\t\tfor(int i=0; i<cycleIndex; ++i){cycleIndex_start +=secCount[i];}\n\t\tvec3 secPoint = scePosition[cycleIndex_start + endPointIndex];\n\t\tsecPoint.y = (dotNV < 0.0 && (endPointIndex & 0x01) == 0) ? 0.0 : secPoint.y;\n\t#else\n\t\tvec3 secPoint = endPointIndex == 0 ? scePosition[40] : \n\t\t\t\t\t\tendPointIndex == 1 ? scePosition[41] : \n\t\t\t\t\t\tendPointIndex == 2 ? scePosition[42] : \n\t\t\t\t\t\tendPointIndex == 3 ? scePosition[43] : \n\t\t\t\t\t\tendPointIndex == 4 ? scePosition[44] : \n\t\t\t\t\t\tendPointIndex == 5 ? scePosition[45] : \n\t\t\t\t\t\tendPointIndex == 6 ? scePosition[46] : scePosition[47];\n\t\tint mod = endPointIndex - (endPointIndex/2 * 2);\n\t\tsecPoint.y = (dotNV < 0.0 && mod == 0) ? 0.0 : secPoint.y;\n\t#endif\n\n\n\t\tif(dotNV < 0.0)\n\t\t{\n\t\t\tlerpPos = -secPoint.x;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvNormal0 = cycleNormal;\n\t\t\tvNormal1 = cycleNormal;\n\t\t\tlerpPos = -1.0;\n\t\t}\n\n\t\tsecPoint =( secPoint * rotmat) *radius0 ;\n\t\tmvPosition.xyz += secPoint;\n\n\t}\n\n\t#include <clipping_planes_vertex>\n\n\tgl_Position = projectionMatrix * mvPosition;\n\n\t#ifdef needOffsetZ\n\t\tgl_Position.z -= 0.0001 * gl_Position.w;\n\t#endif\n\n}\n',
    },
    Nn = {
      basic: {
        uniforms: _n([
          Rn.common,
          Rn.specularmap,
          Rn.envmap,
          Rn.aomap,
          Rn.lightmap,
          Rn.fog,
        ]),
        vertexShader: Vn.meshbasic_vert,
        fragmentShader: Vn.meshbasic_frag,
      },
      CenterLineCylinder: {
        uniforms: _n([Rn.common, Rn.lights]),
        vertexShader: Vn.centerlineCylinder_vert,
        fragmentShader: Vn.centerlineCylinder_frag,
      },
      lambert: {
        uniforms: _n([
          Rn.common,
          Rn.specularmap,
          Rn.envmap,
          Rn.aomap,
          Rn.lightmap,
          Rn.emissivemap,
          Rn.fog,
          Rn.lights,
          { emissive: { value: new fe(0) } },
        ]),
        vertexShader: Vn.meshlambert_vert,
        fragmentShader: Vn.meshlambert_frag,
      },
      phong: {
        uniforms: _n([
          Rn.common,
          Rn.specularmap,
          Rn.envmap,
          Rn.aomap,
          Rn.lightmap,
          Rn.emissivemap,
          Rn.bumpmap,
          Rn.normalmap,
          Rn.displacementmap,
          Rn.fog,
          Rn.lights,
          {
            emissive: { value: new fe(0) },
            specular: { value: new fe(1118481) },
            shininess: { value: 30 },
          },
        ]),
        vertexShader: Vn.meshphong_vert,
        fragmentShader: Vn.meshphong_frag,
      },
      standard: {
        uniforms: _n([
          Rn.common,
          Rn.envmap,
          Rn.aomap,
          Rn.lightmap,
          Rn.emissivemap,
          Rn.bumpmap,
          Rn.normalmap,
          Rn.displacementmap,
          Rn.roughnessmap,
          Rn.metalnessmap,
          Rn.fog,
          Rn.lights,
          {
            emissive: { value: new fe(0) },
            roughness: { value: 0.5 },
            metalness: { value: 0.5 },
            envMapIntensity: { value: 1 },
          },
        ]),
        vertexShader: Vn.meshphysical_vert,
        fragmentShader: Vn.meshphysical_frag,
      },
      toon: {
        uniforms: _n([
          Rn.common,
          Rn.specularmap,
          Rn.aomap,
          Rn.lightmap,
          Rn.emissivemap,
          Rn.bumpmap,
          Rn.normalmap,
          Rn.displacementmap,
          Rn.gradientmap,
          Rn.fog,
          Rn.lights,
          {
            emissive: { value: new fe(0) },
            specular: { value: new fe(1118481) },
            shininess: { value: 30 },
          },
        ]),
        vertexShader: Vn.meshtoon_vert,
        fragmentShader: Vn.meshtoon_frag,
      },
      matcap: {
        uniforms: _n([
          Rn.common,
          Rn.bumpmap,
          Rn.normalmap,
          Rn.displacementmap,
          Rn.fog,
          { matcap: { value: null } },
        ]),
        vertexShader: Vn.meshmatcap_vert,
        fragmentShader: Vn.meshmatcap_frag,
      },
      points: {
        uniforms: _n([Rn.points, Rn.fog]),
        vertexShader: Vn.points_vert,
        fragmentShader: Vn.points_frag,
      },
      dashed: {
        uniforms: _n([
          Rn.common,
          Rn.fog,
          {
            scale: { value: 1 },
            dashSize: { value: 1 },
            totalSize: { value: 2 },
          },
        ]),
        vertexShader: Vn.linedashed_vert,
        fragmentShader: Vn.linedashed_frag,
      },
      depth: {
        uniforms: _n([Rn.common, Rn.displacementmap]),
        vertexShader: Vn.depth_vert,
        fragmentShader: Vn.depth_frag,
      },
      normal: {
        uniforms: _n([
          Rn.common,
          Rn.bumpmap,
          Rn.normalmap,
          Rn.displacementmap,
          { opacity: { value: 1 } },
        ]),
        vertexShader: Vn.normal_vert,
        fragmentShader: Vn.normal_frag,
      },
      sprite: {
        uniforms: _n([Rn.sprite, Rn.fog]),
        vertexShader: Vn.sprite_vert,
        fragmentShader: Vn.sprite_frag,
      },
      background: {
        uniforms: { uvTransform: { value: new G() }, t2D: { value: null } },
        vertexShader: Vn.background_vert,
        fragmentShader: Vn.background_frag,
      },
      cube: {
        uniforms: _n([Rn.envmap, { opacity: { value: 1 } }]),
        vertexShader: Vn.cube_vert,
        fragmentShader: Vn.cube_frag,
      },
      equirect: {
        uniforms: { tEquirect: { value: null } },
        vertexShader: Vn.equirect_vert,
        fragmentShader: Vn.equirect_frag,
      },
      distanceRGBA: {
        uniforms: _n([
          Rn.common,
          Rn.displacementmap,
          {
            referencePosition: { value: new J() },
            nearDistance: { value: 1 },
            farDistance: { value: 1e3 },
          },
        ]),
        vertexShader: Vn.distanceRGBA_vert,
        fragmentShader: Vn.distanceRGBA_frag,
      },
      shadow: {
        uniforms: _n([
          Rn.lights,
          Rn.fog,
          { color: { value: new fe(0) }, opacity: { value: 1 } },
        ]),
        vertexShader: Vn.shadow_vert,
        fragmentShader: Vn.shadow_frag,
      },
    };
  function kn(t, e, n, i) {
    var o,
      s,
      a = new fe(0),
      c = 0,
      l = null,
      h = 0,
      u = null;
    function d(t, n) {
      e.buffers.color.setClear(t.r, t.g, t.b, n, i);
    }
    return {
      getClearColor: function () {
        return a;
      },
      setClearColor: function (t, e) {
        a.set(t), d(a, (c = void 0 !== e ? e : 1));
      },
      getClearAlpha: function () {
        return c;
      },
      setClearAlpha: function (t) {
        d(a, (c = t));
      },
      render: function (e, i, p, f) {
        var m = i.background;
        if (m) {
          var b = t.xr,
            g = b.getSession && b.getSession();
          if (
            (g && 'additive' === g.environmentBlendMode && (m = null),
            null === m ? d(a, c) : m && m.isColor && (d(m, 1), (f = !0)),
            (t.autoClear || f) &&
              t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
            m &&
              (m.isCubeTexture || m.isWebGLCubeRenderTarget || m.mapping === r))
          ) {
            void 0 === s &&
              ((s = new ln(
                new yn(1, 1, 1),
                new wn({
                  type: 'BackgroundCubeMaterial',
                  uniforms: vn(Nn.cube.uniforms),
                  vertexShader: Nn.cube.vertexShader,
                  fragmentShader: Nn.cube.fragmentShader,
                  side: 1,
                  depthTest: !1,
                  depthWrite: !1,
                  fog: !1,
                }),
              )).geometry.deleteAttribute('normal'),
              s.geometry.deleteAttribute('uv'),
              (s.onBeforeRender = function (t, e, n) {
                this.matrixWorld.copyPosition(n.matrixWorld);
              }),
              Object.defineProperty(s.material, 'envMap', {
                get: function () {
                  return this.uniforms.envMap.value;
                },
              }),
              n.update(s));
            var y = m.isWebGLCubeRenderTarget ? m.texture : m;
            (s.material.uniforms.envMap.value = y),
              (s.material.uniforms.flipEnvMap.value = y.isCubeTexture ? -1 : 1),
              (l === m && h === y.version && u === t.toneMapping) ||
                ((s.material.needsUpdate = !0),
                (l = m),
                (h = y.version),
                (u = t.toneMapping)),
              e.unshift(s, s.geometry, s.material, 0, 0, null);
          } else
            m &&
              m.isTexture &&
              (void 0 === o &&
                ((o = new ln(
                  new On(2, 2),
                  new wn({
                    type: 'BackgroundMaterial',
                    uniforms: vn(Nn.background.uniforms),
                    vertexShader: Nn.background.vertexShader,
                    fragmentShader: Nn.background.fragmentShader,
                    side: 0,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1,
                  }),
                )).geometry.deleteAttribute('normal'),
                Object.defineProperty(o.material, 'map', {
                  get: function () {
                    return this.uniforms.t2D.value;
                  },
                }),
                n.update(o)),
              (o.material.uniforms.t2D.value = m),
              !0 === m.matrixAutoUpdate && m.updateMatrix(),
              o.material.uniforms.uvTransform.value.copy(m.matrix),
              (l === m && h === m.version && u === t.toneMapping) ||
                ((o.material.needsUpdate = !0),
                (l = m),
                (h = m.version),
                (u = t.toneMapping)),
              e.unshift(o, o.geometry, o.material, 0, 0, null));
        }
      },
    };
  }
  function Un(t, e, n, i) {
    var r,
      o = i.isWebGL2;
    (this.setMode = function (t) {
      r = t;
    }),
      (this.render = function (e, i) {
        t.drawArrays(r, e, i), n.update(i, r);
      }),
      (this.renderInstances = function (i, s, a, c) {
        if (0 !== c) {
          var l, h;
          if (o) (l = t), (h = 'drawArraysInstanced');
          else if (
            ((h = 'drawArraysInstancedANGLE'),
            null === (l = e.get('ANGLE_instanced_arrays')))
          )
            return void console.error(
              'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.',
            );
          l[h](r, s, a, c), n.update(a, r, c);
        }
      });
  }
  function Gn(t, e, n) {
    var i;
    function r(e) {
      if ('highp' === e) {
        if (
          t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT).precision >
            0 &&
          t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT)
            .precision > 0
        )
          return 'highp';
        e = 'mediump';
      }
      return 'mediump' === e &&
        t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT).precision >
          0 &&
        t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT)
          .precision > 0
        ? 'mediump'
        : 'lowp';
    }
    var o =
        ('undefined' != typeof WebGL2RenderingContext &&
          t instanceof WebGL2RenderingContext) ||
        ('undefined' != typeof WebGL2ComputeRenderingContext &&
          t instanceof WebGL2ComputeRenderingContext),
      s = void 0 !== n.precision ? n.precision : 'highp',
      a = r(s);
    a !== s &&
      (console.warn(
        'THREE.WebGLRenderer:',
        s,
        'not supported, using',
        a,
        'instead.',
      ),
      (s = a));
    var c = !0 === n.logarithmicDepthBuffer,
      l = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),
      h = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
      u = t.getParameter(t.MAX_TEXTURE_SIZE),
      d = t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE),
      p = t.getParameter(t.MAX_VERTEX_ATTRIBS),
      f = t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS),
      m = t.getParameter(t.MAX_VARYING_VECTORS),
      b = t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS),
      g = h > 0,
      y = o || !!e.get('OES_texture_float');
    return {
      isWebGL2: o,
      getMaxAnisotropy: function () {
        if (void 0 !== i) return i;
        var n = e.get('EXT_texture_filter_anisotropic');
        return (i =
          null !== n ? t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0);
      },
      getMaxPrecision: r,
      precision: s,
      logarithmicDepthBuffer: c,
      maxTextures: l,
      maxVertexTextures: h,
      maxTextureSize: u,
      maxCubemapSize: d,
      maxAttributes: p,
      maxVertexUniforms: f,
      maxVaryings: m,
      maxFragmentUniforms: b,
      vertexTextures: g,
      floatFragmentTextures: y,
      floatVertexTextures: g && y,
      maxSamples: o ? t.getParameter(t.MAX_SAMPLES) : 0,
    };
  }
  function zn() {
    var t = this,
      e = null,
      n = 0,
      i = !1,
      r = !1,
      o = new Kt(),
      s = new G(),
      a = { value: null, needsUpdate: !1 };
    function c() {
      a.value !== e && ((a.value = e), (a.needsUpdate = n > 0)),
        (t.numPlanes = n),
        (t.numIntersection = 0);
    }
    function l(e, n, i, r) {
      var c = null !== e ? e.length : 0,
        l = null;
      if (0 !== c) {
        if (((l = a.value), !0 !== r || null === l)) {
          var h = i + 4 * c,
            u = n.matrixWorldInverse;
          s.getNormalMatrix(u),
            (null === l || l.length < h) && (l = new Float32Array(h));
          for (var d = 0, p = i; d !== c; ++d, p += 4)
            o.copy(e[d]).applyMatrix4(u, s),
              o.normal.toArray(l, p),
              (l[p + 3] = o.constant);
        }
        (a.value = l), (a.needsUpdate = !0);
      }
      return (t.numPlanes = c), (t.numIntersection = 0), l;
    }
    (this.uniform = a),
      (this.numPlanes = 0),
      (this.numIntersection = 0),
      (this.init = function (t, r, o) {
        var s = 0 !== t.length || r || 0 !== n || i;
        return (i = r), (e = l(t, o, 0)), (n = t.length), s;
      }),
      (this.beginShadows = function () {
        (r = !0), l(null);
      }),
      (this.endShadows = function () {
        (r = !1), c();
      }),
      (this.setState = function (t, o, s, h, u, d) {
        if (!i || null === t || 0 === t.length || (r && !s)) r ? l(null) : c();
        else {
          var p = r ? 0 : n,
            f = 4 * p,
            m = u.clippingState || null;
          (a.value = m), (m = l(t, h, f, d));
          for (var b = 0; b !== f; ++b) m[b] = e[b];
          (u.clippingState = m),
            (this.numIntersection = o ? this.numPlanes : 0),
            (this.numPlanes += p);
        }
      });
  }
  function jn(t) {
    var e = {};
    return {
      get: function (n) {
        if (void 0 !== e[n]) return e[n];
        var i;
        switch (n) {
          case 'WEBGL_depth_texture':
            i =
              t.getExtension('WEBGL_depth_texture') ||
              t.getExtension('MOZ_WEBGL_depth_texture') ||
              t.getExtension('WEBKIT_WEBGL_depth_texture');
            break;
          case 'EXT_texture_filter_anisotropic':
            i =
              t.getExtension('EXT_texture_filter_anisotropic') ||
              t.getExtension('MOZ_EXT_texture_filter_anisotropic') ||
              t.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
            break;
          case 'WEBGL_compressed_texture_s3tc':
            i =
              t.getExtension('WEBGL_compressed_texture_s3tc') ||
              t.getExtension('MOZ_WEBGL_compressed_texture_s3tc') ||
              t.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
            break;
          case 'WEBGL_compressed_texture_pvrtc':
            i =
              t.getExtension('WEBGL_compressed_texture_pvrtc') ||
              t.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
            break;
          default:
            i = t.getExtension(n);
        }
        return (
          null === i &&
            console.warn(
              'THREE.WebGLRenderer: ' + n + ' extension not supported.',
            ),
          (e[n] = i),
          i
        );
      },
    };
  }
  function Hn(t, e, n) {
    var i = new WeakMap(),
      r = new WeakMap();
    function o(t) {
      var s = t.target,
        a = i.get(s);
      for (var c in (null !== a.index && e.remove(a.index), a.attributes))
        e.remove(a.attributes[c]);
      s.removeEventListener('dispose', o), i.delete(s);
      var l = r.get(a);
      l && (e.remove(l), r.delete(a)), n.memory.geometries--;
    }
    function s(n) {
      var i = [],
        o = n.index,
        s = n.attributes.position,
        a = 0;
      if (null !== o) {
        var c = o.array;
        a = o.version;
        for (var l = 0, h = c.length; l < h; l += 3) {
          var u = c[l + 0],
            d = c[l + 1],
            p = c[l + 2];
          i.push(u, d, d, p, p, u);
        }
      } else {
        c = s.array;
        a = s.version;
        for (l = 0, h = c.length / 3 - 1; l < h; l += 3) {
          (u = l + 0), (d = l + 1), (p = l + 2);
          i.push(u, d, d, p, p, u);
        }
      }
      var f = new (Oe(i) > 65535 ? Te : De)(i, 1);
      (f.version = a), e.update(f, t.ELEMENT_ARRAY_BUFFER);
      var m = r.get(n);
      m && e.remove(m), r.set(n, f);
    }
    return {
      get: function (t, e) {
        var r = i.get(e);
        return (
          r ||
          (e.addEventListener('dispose', o),
          e.isBufferGeometry
            ? (r = e)
            : e.isGeometry &&
              (void 0 === e._bufferGeometry &&
                (e._bufferGeometry = new He().setFromObject(t)),
              (r = e._bufferGeometry)),
          i.set(e, r),
          n.memory.geometries++,
          r)
        );
      },
      update: function (n) {
        var i = n.index,
          r = n.attributes;
        for (var o in (null !== i && e.update(i, t.ELEMENT_ARRAY_BUFFER), r))
          e.update(r[o], t.ARRAY_BUFFER);
        var s = n.morphAttributes;
        for (var o in s)
          for (var a = s[o], c = 0, l = a.length; c < l; c++)
            e.update(a[c], t.ARRAY_BUFFER);
      },
      getWireframeAttribute: function (t) {
        var e = r.get(t);
        if (e) {
          var n = t.index;
          null !== n && e.version < n.version && s(t);
        } else s(t);
        return r.get(t);
      },
    };
  }
  function Wn(t, e, n, i) {
    var r,
      o,
      s,
      a = i.isWebGL2;
    (this.setMode = function (t) {
      r = t;
    }),
      (this.setIndex = function (t) {
        (o = t.type), (s = t.bytesPerElement);
      }),
      (this.render = function (e, i) {
        t.drawElements(r, i, o, e * s), n.update(i, r);
      }),
      (this.renderInstances = function (i, c, l, h) {
        if (0 !== h) {
          var u, d;
          if (a) (u = t), (d = 'drawElementsInstanced');
          else if (
            ((d = 'drawElementsInstancedANGLE'),
            null === (u = e.get('ANGLE_instanced_arrays')))
          )
            return void console.error(
              'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.',
            );
          u[d](r, l, o, c * s, h), n.update(l, r, h);
        }
      });
  }
  function Xn(t) {
    var e = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
    return {
      memory: { geometries: 0, textures: 0 },
      render: e,
      programs: null,
      autoReset: !0,
      reset: function () {
        e.frame++,
          (e.calls = 0),
          (e.triangles = 0),
          (e.points = 0),
          (e.lines = 0);
      },
      update: function (n, i, r) {
        switch (((r = r || 1), e.calls++, i)) {
          case t.TRIANGLES:
            e.triangles += r * (n / 3);
            break;
          case t.LINES:
            e.lines += r * (n / 2);
            break;
          case t.LINE_STRIP:
            e.lines += r * (n - 1);
            break;
          case t.LINE_LOOP:
            e.lines += r * n;
            break;
          case t.POINTS:
            e.points += r * n;
            break;
          case t.TRIANGLE_STRIP:
            e.triangles += r * (n - 3);
            break;
          default:
            console.error('THREE.WebGLInfo: Unknown draw mode:', i);
        }
      },
    };
  }
  function Zn(t, e) {
    return Math.abs(e[1]) - Math.abs(t[1]);
  }
  function Yn(t) {
    var e = {},
      n = new Float32Array(8);
    return {
      update: function (i, r, o, s) {
        var a = i.morphTargetInfluences,
          c = void 0 === a ? 0 : a.length,
          l = e[r.id];
        if (void 0 === l) {
          l = [];
          for (var h = 0; h < c; h++) l[h] = [h, 0];
          e[r.id] = l;
        }
        var u = o.morphTargets && r.morphAttributes.position,
          d = o.morphNormals && r.morphAttributes.normal;
        for (h = 0; h < c; h++) {
          0 !== (f = l[h])[1] &&
            (u && r.deleteAttribute('morphTarget' + h),
            d && r.deleteAttribute('morphNormal' + h));
        }
        for (h = 0; h < c; h++) {
          ((f = l[h])[0] = h), (f[1] = a[h]);
        }
        l.sort(Zn);
        var p = 0;
        for (h = 0; h < 8; h++) {
          var f;
          if ((f = l[h])) {
            var m = f[0],
              b = f[1];
            if (b) {
              u && r.setAttribute('morphTarget' + h, u[m]),
                d && r.setAttribute('morphNormal' + h, d[m]),
                (n[h] = b),
                (p += b);
              continue;
            }
          }
          n[h] = 0;
        }
        var g = r.morphTargetsRelative ? 1 : 1 - p;
        s.getUniforms().setValue(t, 'morphTargetBaseInfluence', g),
          s.getUniforms().setValue(t, 'morphTargetInfluences', n);
      },
    };
  }
  function qn(t, e, n, i) {
    var r = new WeakMap();
    return {
      update: function (o) {
        var s = i.render.frame,
          a = o.geometry,
          c = e.get(o, a);
        return (
          r.get(c) !== s &&
            (a.isGeometry && c.updateFromObject(o), e.update(c), r.set(c, s)),
          o.isInstancedMesh && n.update(o.instanceMatrix, t.ARRAY_BUFFER),
          c
        );
      },
      dispose: function () {
        r = new WeakMap();
      },
    };
  }
  function Qn(t, e, n, i, r, o, s, a, c, l) {
    (t = void 0 !== t ? t : []),
      (e = void 0 !== e ? e : 301),
      (s = void 0 !== s ? s : _),
      H.call(this, t, e, n, i, r, o, s, a, c, l),
      (this.flipY = !1);
  }
  function Jn(t, e, n, i) {
    H.call(this, null),
      (this.image = {
        data: t || null,
        width: e || 1,
        height: n || 1,
        depth: i || 1,
      }),
      (this.magFilter = c),
      (this.minFilter = c),
      (this.wrapR = s),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.needsUpdate = !0);
  }
  function $n(t, e, n, i) {
    H.call(this, null),
      (this.image = {
        data: t || null,
        width: e || 1,
        height: n || 1,
        depth: i || 1,
      }),
      (this.magFilter = c),
      (this.minFilter = c),
      (this.wrapR = s),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.needsUpdate = !0);
  }
  (Nn.physical = {
    uniforms: _n([
      Nn.standard.uniforms,
      {
        clearcoat: { value: 0 },
        clearcoatMap: { value: null },
        clearcoatRoughness: { value: 0 },
        clearcoatRoughnessMap: { value: null },
        clearcoatNormalScale: { value: new U(1, 1) },
        clearcoatNormalMap: { value: null },
        sheen: { value: new fe(0) },
        transparency: { value: 0 },
      },
    ]),
    vertexShader: Vn.meshphysical_vert,
    fragmentShader: Vn.meshphysical_frag,
  }),
    (Qn.prototype = Object.create(H.prototype)),
    (Qn.prototype.constructor = Qn),
    (Qn.prototype.isCubeTexture = !0),
    Object.defineProperty(Qn.prototype, 'images', {
      get: function () {
        return this.image;
      },
      set: function (t) {
        this.image = t;
      },
    }),
    (Jn.prototype = Object.create(H.prototype)),
    (Jn.prototype.constructor = Jn),
    (Jn.prototype.isDataTexture2DArray = !0),
    ($n.prototype = Object.create(H.prototype)),
    ($n.prototype.constructor = $n),
    ($n.prototype.isDataTexture3D = !0);
  var Kn = new H(),
    ti = new Jn(),
    ei = new $n(),
    ni = new Qn(),
    ii = [],
    ri = [],
    oi = new Float32Array(16),
    si = new Float32Array(9),
    ai = new Float32Array(4);
  function ci(t, e, n) {
    var i = t[0];
    if (i <= 0 || i > 0) return t;
    var r = e * n,
      o = ii[r];
    if ((void 0 === o && ((o = new Float32Array(r)), (ii[r] = o)), 0 !== e)) {
      i.toArray(o, 0);
      for (var s = 1, a = 0; s !== e; ++s) (a += n), t[s].toArray(o, a);
    }
    return o;
  }
  function li(t, e) {
    if (t.length !== e.length) return !1;
    for (var n = 0, i = t.length; n < i; n++) if (t[n] !== e[n]) return !1;
    return !0;
  }
  function hi(t, e) {
    for (var n = 0, i = e.length; n < i; n++) t[n] = e[n];
  }
  function ui(t, e) {
    var n = ri[e];
    void 0 === n && ((n = new Int32Array(e)), (ri[e] = n));
    for (var i = 0; i !== e; ++i) n[i] = t.allocateTextureUnit();
    return n;
  }
  function di(t, e) {
    var n = this.cache;
    n[0] !== e && (t.uniform1f(this.addr, e), (n[0] = e));
  }
  function pi(t, e) {
    var n = this.cache;
    if (void 0 !== e.x)
      (n[0] === e.x && n[1] === e.y) ||
        (t.uniform2f(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y));
    else {
      if (li(n, e)) return;
      t.uniform2fv(this.addr, e), hi(n, e);
    }
  }
  function fi(t, e) {
    var n = this.cache;
    if (void 0 !== e.x)
      (n[0] === e.x && n[1] === e.y && n[2] === e.z) ||
        (t.uniform3f(this.addr, e.x, e.y, e.z),
        (n[0] = e.x),
        (n[1] = e.y),
        (n[2] = e.z));
    else if (void 0 !== e.r)
      (n[0] === e.r && n[1] === e.g && n[2] === e.b) ||
        (t.uniform3f(this.addr, e.r, e.g, e.b),
        (n[0] = e.r),
        (n[1] = e.g),
        (n[2] = e.b));
    else {
      if (li(n, e)) return;
      t.uniform3fv(this.addr, e), hi(n, e);
    }
  }
  function mi(t, e) {
    var n = this.cache;
    if (void 0 !== e.x)
      (n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w) ||
        (t.uniform4f(this.addr, e.x, e.y, e.z, e.w),
        (n[0] = e.x),
        (n[1] = e.y),
        (n[2] = e.z),
        (n[3] = e.w));
    else {
      if (li(n, e)) return;
      t.uniform4fv(this.addr, e), hi(n, e);
    }
  }
  function bi(t, e) {
    var n = this.cache,
      i = e.elements;
    if (void 0 === i) {
      if (li(n, e)) return;
      t.uniformMatrix2fv(this.addr, !1, e), hi(n, e);
    } else {
      if (li(n, i)) return;
      ai.set(i), t.uniformMatrix2fv(this.addr, !1, ai), hi(n, i);
    }
  }
  function gi(t, e) {
    var n = this.cache,
      i = e.elements;
    if (void 0 === i) {
      if (li(n, e)) return;
      t.uniformMatrix3fv(this.addr, !1, e), hi(n, e);
    } else {
      if (li(n, i)) return;
      si.set(i), t.uniformMatrix3fv(this.addr, !1, si), hi(n, i);
    }
  }
  function yi(t, e) {
    var n = this.cache,
      i = e.elements;
    if (void 0 === i) {
      if (li(n, e)) return;
      t.uniformMatrix4fv(this.addr, !1, e), hi(n, e);
    } else {
      if (li(n, i)) return;
      oi.set(i), t.uniformMatrix4fv(this.addr, !1, oi), hi(n, i);
    }
  }
  function vi(t, e, n) {
    var i = this.cache,
      r = n.allocateTextureUnit();
    i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
      n.safeSetTexture2D(e || Kn, r);
  }
  function _i(t, e, n) {
    var i = this.cache,
      r = n.allocateTextureUnit();
    i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
      n.setTexture2DArray(e || ti, r);
  }
  function xi(t, e, n) {
    var i = this.cache,
      r = n.allocateTextureUnit();
    i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
      n.setTexture3D(e || ei, r);
  }
  function wi(t, e, n) {
    var i = this.cache,
      r = n.allocateTextureUnit();
    i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
      n.safeSetTextureCube(e || ni, r);
  }
  function Ai(t, e) {
    var n = this.cache;
    n[0] !== e && (t.uniform1i(this.addr, e), (n[0] = e));
  }
  function Mi(t, e) {
    var n = this.cache;
    li(n, e) || (t.uniform2iv(this.addr, e), hi(n, e));
  }
  function Si(t, e) {
    var n = this.cache;
    li(n, e) || (t.uniform3iv(this.addr, e), hi(n, e));
  }
  function Ii(t, e) {
    var n = this.cache;
    li(n, e) || (t.uniform4iv(this.addr, e), hi(n, e));
  }
  function Ei(t, e) {
    var n = this.cache;
    n[0] !== e && (t.uniform1ui(this.addr, e), (n[0] = e));
  }
  function Di(t, e) {
    t.uniform1fv(this.addr, e);
  }
  function Ci(t, e) {
    t.uniform1iv(this.addr, e);
  }
  function Ti(t, e) {
    t.uniform2iv(this.addr, e);
  }
  function Li(t, e) {
    t.uniform3iv(this.addr, e);
  }
  function Ri(t, e) {
    t.uniform4iv(this.addr, e);
  }
  function Fi(t, e) {
    var n = ci(e, this.size, 2);
    t.uniform2fv(this.addr, n);
  }
  function Pi(t, e) {
    var n = ci(e, this.size, 3);
    t.uniform3fv(this.addr, n);
  }
  function Bi(t, e) {
    var n = ci(e, this.size, 4);
    t.uniform4fv(this.addr, n);
  }
  function Oi(t, e) {
    var n = ci(e, this.size, 4);
    t.uniformMatrix2fv(this.addr, !1, n);
  }
  function Vi(t, e) {
    var n = ci(e, this.size, 9);
    t.uniformMatrix3fv(this.addr, !1, n);
  }
  function Ni(t, e) {
    var n = ci(e, this.size, 16);
    t.uniformMatrix4fv(this.addr, !1, n);
  }
  function ki(t, e, n) {
    var i = e.length,
      r = ui(n, i);
    t.uniform1iv(this.addr, r);
    for (var o = 0; o !== i; ++o) n.safeSetTexture2D(e[o] || Kn, r[o]);
  }
  function Ui(t, e, n) {
    var i = e.length,
      r = ui(n, i);
    t.uniform1iv(this.addr, r);
    for (var o = 0; o !== i; ++o) n.safeSetTextureCube(e[o] || ni, r[o]);
  }
  function Gi(t, e, n) {
    (this.id = t),
      (this.addr = n),
      (this.cache = []),
      (this.setValue = (function (t) {
        switch (t) {
          case 5126:
            return di;
          case 35664:
            return pi;
          case 35665:
            return fi;
          case 35666:
            return mi;
          case 35674:
            return bi;
          case 35675:
            return gi;
          case 35676:
            return yi;
          case 5124:
          case 35670:
            return Ai;
          case 35667:
          case 35671:
            return Mi;
          case 35668:
          case 35672:
            return Si;
          case 35669:
          case 35673:
            return Ii;
          case 5125:
            return Ei;
          case 35678:
          case 36198:
          case 36298:
          case 36306:
          case 35682:
            return vi;
          case 35679:
          case 36299:
          case 36307:
            return xi;
          case 35680:
          case 36300:
          case 36308:
          case 36293:
            return wi;
          case 36289:
          case 36303:
          case 36311:
          case 36292:
            return _i;
        }
      })(e.type));
  }
  function zi(t, e, n) {
    (this.id = t),
      (this.addr = n),
      (this.cache = []),
      (this.size = e.size),
      (this.setValue = (function (t) {
        switch (t) {
          case 5126:
            return Di;
          case 35664:
            return Fi;
          case 35665:
            return Pi;
          case 35666:
            return Bi;
          case 35674:
            return Oi;
          case 35675:
            return Vi;
          case 35676:
            return Ni;
          case 5124:
          case 35670:
            return Ci;
          case 35667:
          case 35671:
            return Ti;
          case 35668:
          case 35672:
            return Li;
          case 35669:
          case 35673:
            return Ri;
          case 35678:
          case 36198:
          case 36298:
          case 36306:
          case 35682:
            return ki;
          case 35680:
          case 36300:
          case 36308:
          case 36293:
            return Ui;
        }
      })(e.type));
  }
  function ji(t) {
    (this.id = t), (this.seq = []), (this.map = {});
  }
  (zi.prototype.updateCache = function (t) {
    var e = this.cache;
    t instanceof Float32Array &&
      e.length !== t.length &&
      (this.cache = new Float32Array(t.length)),
      hi(e, t);
  }),
    (ji.prototype.setValue = function (t, e, n) {
      for (var i = this.seq, r = 0, o = i.length; r !== o; ++r) {
        var s = i[r];
        s.setValue(t, e[s.id], n);
      }
    });
  var Hi = /([\w\d_]+)(\])?(\[|\.)?/g;
  function Wi(t, e) {
    t.seq.push(e), (t.map[e.id] = e);
  }
  function Xi(t, e, n) {
    var i = t.name,
      r = i.length;
    for (Hi.lastIndex = 0; ; ) {
      var o = Hi.exec(i),
        s = Hi.lastIndex,
        a = o[1],
        c = ']' === o[2],
        l = o[3];
      if ((c && (a |= 0), void 0 === l || ('[' === l && s + 2 === r))) {
        Wi(n, void 0 === l ? new Gi(a, t, e) : new zi(a, t, e));
        break;
      }
      var h = n.map[a];
      void 0 === h && Wi(n, (h = new ji(a))), (n = h);
    }
  }
  function Zi(t, e) {
    (this.seq = []), (this.map = {});
    for (
      var n = t.getProgramParameter(e, t.ACTIVE_UNIFORMS), i = 0;
      i < n;
      ++i
    ) {
      var r = t.getActiveUniform(e, i);
      Xi(r, t.getUniformLocation(e, r.name), this);
    }
  }
  function Yi(t, e, n) {
    var i = t.createShader(e);
    return t.shaderSource(i, n), t.compileShader(i), i;
  }
  (Zi.prototype.setValue = function (t, e, n, i) {
    var r = this.map[e];
    void 0 !== r && r.setValue(t, n, i);
  }),
    (Zi.prototype.setOptional = function (t, e, n) {
      var i = e[n];
      void 0 !== i && this.setValue(t, n, i);
    }),
    (Zi.upload = function (t, e, n, i) {
      for (var r = 0, o = e.length; r !== o; ++r) {
        var s = e[r],
          a = n[s.id];
        !1 !== a.needsUpdate && s.setValue(t, a.value, i);
      }
    }),
    (Zi.seqWithValue = function (t, e) {
      for (var n = [], i = 0, r = t.length; i !== r; ++i) {
        var o = t[i];
        o.id in e && n.push(o);
      }
      return n;
    });
  var qi = 0;
  function Qi(t) {
    switch (t) {
      case T:
        return ['Linear', '( value )'];
      case L:
        return ['sRGB', '( value )'];
      case 3002:
        return ['RGBE', '( value )'];
      case 3004:
        return ['RGBM', '( value, 7.0 )'];
      case 3005:
        return ['RGBM', '( value, 16.0 )'];
      case 3006:
        return ['RGBD', '( value, 256.0 )'];
      case 3007:
        return ['Gamma', '( value, float( GAMMA_FACTOR ) )'];
      case 3003:
        return ['LogLuv', '( value )'];
      default:
        throw new Error('unsupported encoding: ' + t);
    }
  }
  function Ji(t, e, n) {
    var i = t.getShaderParameter(e, t.COMPILE_STATUS),
      r = t.getShaderInfoLog(e).trim();
    return i && '' === r
      ? ''
      : 'THREE.WebGLShader: gl.getShaderInfoLog() ' +
          n +
          '\n' +
          r +
          (function (t) {
            for (var e = t.split('\n'), n = 0; n < e.length; n++)
              e[n] = n + 1 + ': ' + e[n];
            return e.join('\n');
          })(t.getShaderSource(e));
  }
  function $i(t, e) {
    var n = Qi(e);
    return (
      'vec4 ' +
      t +
      '( vec4 value ) { return ' +
      n[0] +
      'ToLinear' +
      n[1] +
      '; }'
    );
  }
  function Ki(t, e) {
    var n;
    switch (e) {
      case 1:
        n = 'Linear';
        break;
      case 2:
        n = 'Reinhard';
        break;
      case 3:
        n = 'Uncharted2';
        break;
      case 4:
        n = 'OptimizedCineon';
        break;
      case 5:
        n = 'ACESFilmic';
        break;
      default:
        throw new Error('unsupported toneMapping: ' + e);
    }
    return (
      'vec3 ' + t + '( vec3 color ) { return ' + n + 'ToneMapping( color ); }'
    );
  }
  function tr(t) {
    return '' !== t;
  }
  function er(t, e) {
    return t
      .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
      .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
      .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
      .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
      .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
      .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
      .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
      .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
  }
  function nr(t, e) {
    return t
      .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
      .replace(
        /UNION_CLIPPING_PLANES/g,
        e.numClippingPlanes - e.numClipIntersection,
      );
  }
  var ir = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function rr(t) {
    return t.replace(ir, or);
  }
  function or(t, e) {
    var n = Vn[e];
    if (void 0 === n) throw new Error('Can not resolve #include <' + e + '>');
    return rr(n);
  }
  var sr =
      /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
    ar =
      /#pragma unroll_loop_start[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}[\s]+?#pragma unroll_loop_end/g;
  function cr(t) {
    return t.replace(ar, hr).replace(sr, lr);
  }
  function lr(t, e, n, i) {
    return (
      console.warn(
        'WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.',
      ),
      hr(t, e, n, i)
    );
  }
  function hr(t, e, n, i) {
    for (var r = '', o = parseInt(e); o < parseInt(n); o++)
      r += i
        .replace(/\[ i \]/g, '[ ' + o + ' ]')
        .replace(/UNROLLED_LOOP_INDEX/g, o);
    return r;
  }
  function ur(t) {
    var e =
      'precision ' +
      t.precision +
      ' float;\nprecision ' +
      t.precision +
      ' int;';
    return (
      'highp' === t.precision
        ? (e += '\n#define HIGH_PRECISION')
        : 'mediump' === t.precision
        ? (e += '\n#define MEDIUM_PRECISION')
        : 'lowp' === t.precision && (e += '\n#define LOW_PRECISION'),
      e
    );
  }
  function dr(t, e, n) {
    var i,
      o,
      s,
      a,
      c,
      l = t.getContext(),
      h = n.defines,
      u = n.vertexShader,
      d = n.fragmentShader,
      p = (function (t) {
        var e = 'SHADOWMAP_TYPE_BASIC';
        return (
          1 === t.shadowMapType
            ? (e = 'SHADOWMAP_TYPE_PCF')
            : 2 === t.shadowMapType
            ? (e = 'SHADOWMAP_TYPE_PCF_SOFT')
            : 3 === t.shadowMapType && (e = 'SHADOWMAP_TYPE_VSM'),
          e
        );
      })(n),
      f = (function (t) {
        var e = 'ENVMAP_TYPE_CUBE';
        if (t.envMap)
          switch (t.envMapMode) {
            case 301:
            case 302:
              e = 'ENVMAP_TYPE_CUBE';
              break;
            case r:
            case 307:
              e = 'ENVMAP_TYPE_CUBE_UV';
              break;
            case 303:
            case 304:
              e = 'ENVMAP_TYPE_EQUIREC';
              break;
            case 305:
              e = 'ENVMAP_TYPE_SPHERE';
          }
        return e;
      })(n),
      m = (function (t) {
        var e = 'ENVMAP_MODE_REFLECTION';
        if (t.envMap)
          switch (t.envMapMode) {
            case 302:
            case 304:
              e = 'ENVMAP_MODE_REFRACTION';
          }
        return e;
      })(n),
      b = (function (t) {
        var e = 'ENVMAP_BLENDING_NONE';
        if (t.envMap)
          switch (t.combine) {
            case 0:
              e = 'ENVMAP_BLENDING_MULTIPLY';
              break;
            case 1:
              e = 'ENVMAP_BLENDING_MIX';
              break;
            case 2:
              e = 'ENVMAP_BLENDING_ADD';
          }
        return e;
      })(n),
      g = t.gammaFactor > 0 ? t.gammaFactor : 1,
      y = n.isWebGL2
        ? ''
        : (function (t) {
            return [
              t.extensionDerivatives ||
              t.envMapCubeUV ||
              t.bumpMap ||
              t.tangentSpaceNormalMap ||
              t.clearcoatNormalMap ||
              t.flatShading ||
              'physical' === t.shaderID
                ? '#extension GL_OES_standard_derivatives : enable'
                : '',
              (t.extensionFragDepth || t.logarithmicDepthBuffer) &&
              t.rendererExtensionFragDepth
                ? '#extension GL_EXT_frag_depth : enable'
                : '',
              t.extensionDrawBuffers && t.rendererExtensionDrawBuffers
                ? '#extension GL_EXT_draw_buffers : require'
                : '',
              (t.extensionShaderTextureLOD || t.envMap) &&
              t.rendererExtensionShaderTextureLod
                ? '#extension GL_EXT_shader_texture_lod : enable'
                : '',
            ]
              .filter(tr)
              .join('\n');
          })(n),
      v = (function (t) {
        var e = [];
        for (var n in t) {
          var i = t[n];
          !1 !== i && e.push('#define ' + n + ' ' + i);
        }
        return e.join('\n');
      })(h),
      _ = l.createProgram();
    if (
      (n.isRawShaderMaterial
        ? ((i = [v].filter(tr).join('\n')).length > 0 && (i += '\n'),
          (o = [y, v].filter(tr).join('\n')).length > 0 && (o += '\n'))
        : ((i = [
            ur(n),
            '#define SHADER_NAME ' + n.shaderName,
            v,
            n.instancing ? '#define USE_INSTANCING' : '',
            n.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',
            '#define GAMMA_FACTOR ' + g,
            '#define MAX_BONES ' + n.maxBones,
            n.useFog && n.fog ? '#define USE_FOG' : '',
            n.useFog && n.fogExp2 ? '#define FOG_EXP2' : '',
            n.map ? '#define USE_MAP' : '',
            n.envMap ? '#define USE_ENVMAP' : '',
            n.envMap ? '#define ' + m : '',
            n.lightMap ? '#define USE_LIGHTMAP' : '',
            n.aoMap ? '#define USE_AOMAP' : '',
            n.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
            n.bumpMap ? '#define USE_BUMPMAP' : '',
            n.normalMap ? '#define USE_NORMALMAP' : '',
            n.normalMap && n.objectSpaceNormalMap
              ? '#define OBJECTSPACE_NORMALMAP'
              : '',
            n.normalMap && n.tangentSpaceNormalMap
              ? '#define TANGENTSPACE_NORMALMAP'
              : '',
            n.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
            n.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
            n.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
            n.displacementMap && n.supportsVertexTextures
              ? '#define USE_DISPLACEMENTMAP'
              : '',
            n.specularMap ? '#define USE_SPECULARMAP' : '',
            n.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
            n.metalnessMap ? '#define USE_METALNESSMAP' : '',
            n.alphaMap ? '#define USE_ALPHAMAP' : '',
            n.vertexTangents ? '#define USE_TANGENT' : '',
            n.vertexColors ? '#define USE_COLOR' : '',
            n.vertexUvs ? '#define USE_UV' : '',
            n.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',
            n.flatShading ? '#define FLAT_SHADED' : '',
            n.skinning ? '#define USE_SKINNING' : '',
            n.useVertexTexture ? '#define BONE_TEXTURE' : '',
            n.morphTargets ? '#define USE_MORPHTARGETS' : '',
            n.morphNormals && !1 === n.flatShading
              ? '#define USE_MORPHNORMALS'
              : '',
            n.doubleSided ? '#define DOUBLE_SIDED' : '',
            n.flipSided ? '#define FLIP_SIDED' : '',
            n.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
            n.shadowMapEnabled ? '#define ' + p : '',
            n.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
            n.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
            n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
              ? '#define USE_LOGDEPTHBUF_EXT'
              : '',
            n.offsetVertexPosition ? '#define USE_OFFSET_VERTEX_POSITION' : '',
            n.smoothingLighting ? '#define USE_SMOOTH_LIGHTING' : '',
            'uniform mat4 modelMatrix;',
            'uniform mat4 modelViewMatrix;',
            'uniform mat4 projectionMatrix;',
            'uniform mat4 viewMatrix;',
            'uniform mat3 normalMatrix;',
            'uniform vec3 cameraPosition;',
            'uniform bool isOrthographic;',
            '#ifdef USE_INSTANCING',
            ' attribute mat4 instanceMatrix;',
            '#endif',
            'attribute vec3 position;',
            'attribute vec3 normal;',
            'attribute vec2 uv;',
            '#ifdef USE_TANGENT',
            '\tattribute vec4 tangent;',
            '#endif',
            '#ifdef USE_COLOR',
            '\tattribute vec3 color;',
            '#endif',
            '#ifdef USE_MORPHTARGETS',
            '\tattribute vec3 morphTarget0;',
            '\tattribute vec3 morphTarget1;',
            '\tattribute vec3 morphTarget2;',
            '\tattribute vec3 morphTarget3;',
            '\t#ifdef USE_MORPHNORMALS',
            '\t\tattribute vec3 morphNormal0;',
            '\t\tattribute vec3 morphNormal1;',
            '\t\tattribute vec3 morphNormal2;',
            '\t\tattribute vec3 morphNormal3;',
            '\t#else',
            '\t\tattribute vec3 morphTarget4;',
            '\t\tattribute vec3 morphTarget5;',
            '\t\tattribute vec3 morphTarget6;',
            '\t\tattribute vec3 morphTarget7;',
            '\t#endif',
            '#endif',
            '#ifdef USE_SKINNING',
            '\tattribute vec4 skinIndex;',
            '\tattribute vec4 skinWeight;',
            '#endif',
            'uniform bool isInstanceDrawing;',
            'attribute vec4 instanceMatrixR1;',
            'attribute vec4 instanceMatrixR2;',
            'attribute vec4 instanceMatrixR3;',
            'attribute vec4 instanceMatrixR4;',
            '\n',
          ]
            .filter(tr)
            .join('\n')),
          (o = [
            y,
            ur(n),
            '#define SHADER_NAME ' + n.shaderName,
            v,
            n.alphaTest
              ? '#define ALPHATEST ' +
                n.alphaTest +
                (n.alphaTest % 1 ? '' : '.0')
              : '',
            '#define GAMMA_FACTOR ' + g,
            n.useFog && n.fog ? '#define USE_FOG' : '',
            n.useFog && n.fogExp2 ? '#define FOG_EXP2' : '',
            n.map ? '#define USE_MAP' : '',
            n.matcap ? '#define USE_MATCAP' : '',
            n.envMap ? '#define USE_ENVMAP' : '',
            n.envMap ? '#define ' + f : '',
            n.envMap ? '#define ' + m : '',
            n.envMap ? '#define ' + b : '',
            n.lightMap ? '#define USE_LIGHTMAP' : '',
            n.aoMap ? '#define USE_AOMAP' : '',
            n.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
            n.bumpMap ? '#define USE_BUMPMAP' : '',
            n.normalMap ? '#define USE_NORMALMAP' : '',
            n.normalMap && n.objectSpaceNormalMap
              ? '#define OBJECTSPACE_NORMALMAP'
              : '',
            n.normalMap && n.tangentSpaceNormalMap
              ? '#define TANGENTSPACE_NORMALMAP'
              : '',
            n.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
            n.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
            n.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
            n.specularMap ? '#define USE_SPECULARMAP' : '',
            n.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
            n.metalnessMap ? '#define USE_METALNESSMAP' : '',
            n.alphaMap ? '#define USE_ALPHAMAP' : '',
            n.sheen ? '#define USE_SHEEN' : '',
            n.vertexTangents ? '#define USE_TANGENT' : '',
            n.vertexColors ? '#define USE_COLOR' : '',
            n.vertexUvs ? '#define USE_UV' : '',
            n.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',
            n.gradientMap ? '#define USE_GRADIENTMAP' : '',
            n.flatShading ? '#define FLAT_SHADED' : '',
            n.doubleSided ? '#define DOUBLE_SIDED' : '',
            n.flipSided ? '#define FLIP_SIDED' : '',
            n.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
            n.shadowMapEnabled ? '#define ' + p : '',
            n.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',
            n.physicallyCorrectLights
              ? '#define PHYSICALLY_CORRECT_LIGHTS'
              : '',
            n.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
            n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
              ? '#define USE_LOGDEPTHBUF_EXT'
              : '',
            (n.extensionShaderTextureLOD || n.envMap) &&
            n.rendererExtensionShaderTextureLod
              ? '#define TEXTURE_LOD_EXT'
              : '',
            'uniform mat4 viewMatrix;',
            'uniform vec3 cameraPosition;',
            'uniform bool isOrthographic;',
            0 !== n.toneMapping ? '#define TONE_MAPPING' : '',
            0 !== n.toneMapping ? Vn.tonemapping_pars_fragment : '',
            0 !== n.toneMapping ? Ki('toneMapping', n.toneMapping) : '',
            n.dithering ? '#define DITHERING' : '',
            n.outputEncoding ||
            n.mapEncoding ||
            n.matcapEncoding ||
            n.envMapEncoding ||
            n.emissiveMapEncoding ||
            n.lightMapEncoding
              ? Vn.encodings_pars_fragment
              : '',
            n.mapEncoding ? $i('mapTexelToLinear', n.mapEncoding) : '',
            n.matcapEncoding ? $i('matcapTexelToLinear', n.matcapEncoding) : '',
            n.envMapEncoding ? $i('envMapTexelToLinear', n.envMapEncoding) : '',
            n.emissiveMapEncoding
              ? $i('emissiveMapTexelToLinear', n.emissiveMapEncoding)
              : '',
            n.lightMapEncoding
              ? $i('lightMapTexelToLinear', n.lightMapEncoding)
              : '',
            n.outputEncoding
              ? ((s = 'linearToOutputTexel'),
                (a = n.outputEncoding),
                (c = Qi(a)),
                'vec4 ' +
                  s +
                  '( vec4 value ) { return LinearTo' +
                  c[0] +
                  c[1] +
                  '; }')
              : '',
            n.depthPacking ? '#define DEPTH_PACKING ' + n.depthPacking : '',
            n.offsetVertexPosition ? '#define USE_OFFSET_VERTEX_POSITION' : '',
            n.smoothingLighting ? '#define USE_SMOOTH_LIGHTING' : '',
            '\n',
          ]
            .filter(tr)
            .join('\n'))),
      (u = nr((u = er((u = rr(u)), n)), n)),
      (d = nr((d = er((d = rr(d)), n)), n)),
      (u = cr(u)),
      (d = cr(d)),
      'CenterLineCylinder' === n.shaderID)
    ) {
      let t = [],
        e = [];
      n.isWebGL2 &&
        ((t = [
          '#version 300 es\n',
          '#define attribute in',
          '#define varying out',
          '#define texture2D texture',
          '#define webgl2',
        ]),
        (e = [
          '#version 300 es\n',
          '#define varying in',
          'out highp vec4 pc_fragColor;',
          '#define gl_FragColor pc_fragColor',
          '#define webgl2',
        ])),
        n.needOffsetZ &&
          (t.push('#define needOffsetZ'), e.push('#define needOffsetZ')),
        (i = t.join('\n') + '\n' + i),
        (o = e.join('\n') + '\n' + o);
    } else if (n.isWebGL2 && !n.isRawShaderMaterial) {
      var x = !1,
        w = /^\s*#version\s+300\s+es\s*\n/;
      n.isShaderMaterial &&
        null !== u.match(w) &&
        null !== d.match(w) &&
        ((x = !0), (u = u.replace(w, '')), (d = d.replace(w, ''))),
        (i =
          [
            '#version 300 es\n',
            '#define attribute in',
            '#define varying out',
            '#define texture2D texture',
          ].join('\n') +
          '\n' +
          i),
        (o =
          [
            '#version 300 es\n',
            '#define varying in',
            x ? '' : 'out highp vec4 pc_fragColor;',
            x ? '' : '#define gl_FragColor pc_fragColor',
            '#define gl_FragDepthEXT gl_FragDepth',
            '#define texture2D texture',
            '#define textureCube texture',
            '#define texture2DProj textureProj',
            '#define texture2DLodEXT textureLod',
            '#define texture2DProjLodEXT textureProjLod',
            '#define textureCubeLodEXT textureLod',
            '#define texture2DGradEXT textureGrad',
            '#define texture2DProjGradEXT textureProjGrad',
            '#define textureCubeGradEXT textureGrad',
          ].join('\n') +
          '\n' +
          o);
    }
    var A,
      M,
      S = i + u,
      I = o + d,
      E = Yi(l, l.VERTEX_SHADER, S),
      D = Yi(l, l.FRAGMENT_SHADER, I);
    if (
      (l.attachShader(_, E),
      l.attachShader(_, D),
      void 0 !== n.index0AttributeName
        ? l.bindAttribLocation(_, 0, n.index0AttributeName)
        : !0 === n.morphTargets && l.bindAttribLocation(_, 0, 'position'),
      l.linkProgram(_),
      t.debug.checkShaderErrors)
    ) {
      var C = l.getProgramInfoLog(_).trim(),
        T = l.getShaderInfoLog(E).trim(),
        L = l.getShaderInfoLog(D).trim(),
        R = !0,
        F = !0;
      if (!1 === l.getProgramParameter(_, l.LINK_STATUS)) {
        R = !1;
        var P = Ji(l, E, 'vertex'),
          B = Ji(l, D, 'fragment');
        console.error(
          'THREE.WebGLProgram: shader error: ',
          l.getError(),
          'gl.VALIDATE_STATUS',
          l.getProgramParameter(_, l.VALIDATE_STATUS),
          'gl.getProgramInfoLog',
          C,
          P,
          B,
        );
      } else
        '' !== C
          ? console.warn('THREE.WebGLProgram: gl.getProgramInfoLog()', C)
          : ('' !== T && '' !== L) || (F = !1);
      F &&
        (this.diagnostics = {
          runnable: R,
          programLog: C,
          vertexShader: { log: T, prefix: i },
          fragmentShader: { log: L, prefix: o },
        });
    }
    return (
      l.detachShader(_, E),
      l.detachShader(_, D),
      l.deleteShader(E),
      l.deleteShader(D),
      (this.getUniforms = function () {
        return void 0 === A && (A = new Zi(l, _)), A;
      }),
      (this.getAttributes = function () {
        return (
          void 0 === M &&
            (M = (function (t, e) {
              for (
                var n = {},
                  i = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES),
                  r = 0;
                r < i;
                r++
              ) {
                var o = t.getActiveAttrib(e, r).name;
                n[o] = t.getAttribLocation(e, o);
              }
              return n;
            })(l, _)),
          M
        );
      }),
      (this.destroy = function () {
        l.deleteProgram(_), (this.program = void 0);
      }),
      (this.name = n.shaderName),
      (this.id = qi++),
      (this.cacheKey = e),
      (this.usedTimes = 1),
      (this.program = _),
      (this.vertexShader = E),
      (this.fragmentShader = D),
      this
    );
  }
  function pr(t, e, n) {
    var i = [],
      o = n.isWebGL2,
      s = n.logarithmicDepthBuffer,
      a = n.floatVertexTextures,
      c = n.precision,
      l = n.maxVertexUniforms,
      h = n.vertexTextures,
      u = {
        MeshDepthMaterial: 'depth',
        MeshDistanceMaterial: 'distanceRGBA',
        MeshNormalMaterial: 'normal',
        MeshBasicMaterial: 'basic',
        CenterLineCylinderMaterial: 'CenterLineCylinder',
        MeshLambertMaterial: 'lambert',
        MeshPhongMaterial: 'phong',
        MeshToonMaterial: 'toon',
        MeshStandardMaterial: 'physical',
        MeshPhysicalMaterial: 'physical',
        MeshMatcapMaterial: 'matcap',
        LineBasicMaterial: 'basic',
        LineDashedMaterial: 'dashed',
        PointsMaterial: 'points',
        ShadowMaterial: 'shadow',
        SpriteMaterial: 'sprite',
      },
      d = [
        'precision',
        'isWebGL2',
        'supportsVertexTextures',
        'outputEncoding',
        'instancing',
        'needOffsetZ',
        'map',
        'mapEncoding',
        'matcap',
        'matcapEncoding',
        'envMap',
        'envMapMode',
        'envMapEncoding',
        'envMapCubeUV',
        'lightMap',
        'lightMapEncoding',
        'aoMap',
        'emissiveMap',
        'emissiveMapEncoding',
        'bumpMap',
        'normalMap',
        'objectSpaceNormalMap',
        'tangentSpaceNormalMap',
        'clearcoatMap',
        'clearcoatRoughnessMap',
        'clearcoatNormalMap',
        'displacementMap',
        'specularMap',
        'roughnessMap',
        'metalnessMap',
        'gradientMap',
        'alphaMap',
        'combine',
        'vertexColors',
        'vertexTangents',
        'vertexUvs',
        'uvsVertexOnly',
        'fog',
        'useFog',
        'fogExp2',
        'flatShading',
        'sizeAttenuation',
        'logarithmicDepthBuffer',
        'skinning',
        'maxBones',
        'useVertexTexture',
        'morphTargets',
        'morphNormals',
        'maxMorphTargets',
        'maxMorphNormals',
        'premultipliedAlpha',
        'numDirLights',
        'numPointLights',
        'numSpotLights',
        'numHemiLights',
        'numRectAreaLights',
        'numDirLightShadows',
        'numPointLightShadows',
        'numSpotLightShadows',
        'shadowMapEnabled',
        'shadowMapType',
        'toneMapping',
        'physicallyCorrectLights',
        'alphaTest',
        'doubleSided',
        'flipSided',
        'numClippingPlanes',
        'numClipIntersection',
        'depthPacking',
        'dithering',
        'sheen',
        'offsetVertexPosition',
        'smoothingLighting',
      ];
    function p(t) {
      var e;
      return (
        t
          ? t.isTexture
            ? (e = t.encoding)
            : t.isWebGLRenderTarget &&
              (console.warn(
                "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.",
              ),
              (e = t.texture.encoding))
          : (e = T),
        e
      );
    }
    (this.getParameters = function (i, d, f, m, b, g, y) {
      var v = m.fog,
        _ = i.isMeshStandardMaterial ? m.environment : null,
        x = i.envMap || _,
        w = u[i.type],
        A = y.isSkinnedMesh
          ? (function (t) {
              var e = t.skeleton.bones;
              if (a) return 1024;
              var n = l,
                i = Math.floor((n - 20) / 4),
                r = Math.min(i, e.length);
              return r < e.length
                ? (console.warn(
                    'THREE.WebGLRenderer: Skeleton has ' +
                      e.length +
                      ' bones. This GPU supports ' +
                      r +
                      '.',
                  ),
                  0)
                : r;
            })(y)
          : 0;
      null !== i.precision &&
        (c = n.getMaxPrecision(i.precision)) !== i.precision &&
        console.warn(
          'THREE.WebGLProgram.getParameters:',
          i.precision,
          'not supported, using',
          c,
          'instead.',
        );
      var M = (function (t, e) {
        var n;
        if (e) {
          var i = Nn[e];
          n = {
            name: t.type,
            uniforms: xn.clone(i.uniforms),
            vertexShader: i.vertexShader,
            fragmentShader: i.fragmentShader,
          };
        } else
          n = {
            name: t.type,
            uniforms: t.uniforms,
            vertexShader: t.vertexShader,
            fragmentShader: t.fragmentShader,
          };
        return n;
      })(i, w);
      i.onBeforeCompile(M, t);
      var S = t.getRenderTarget();
      return {
        isWebGL2: o,
        shaderID: w,
        shaderName: M.name,
        needOffsetZ: i.needOffsetZ,
        uniforms: M.uniforms,
        vertexShader: M.vertexShader,
        fragmentShader: M.fragmentShader,
        defines: i.defines,
        isRawShaderMaterial: i.isRawShaderMaterial,
        isShaderMaterial: i.isShaderMaterial,
        precision: c,
        instancing: !0 === y.isInstancedMesh,
        supportsVertexTextures: h,
        outputEncoding: null !== S ? p(S.texture) : t.outputEncoding,
        map: !!i.map,
        mapEncoding: p(i.map),
        matcap: !!i.matcap,
        matcapEncoding: p(i.matcap),
        envMap: !!x,
        envMapMode: x && x.mapping,
        envMapEncoding: p(x),
        envMapCubeUV: !!x && (x.mapping === r || 307 === x.mapping),
        lightMap: !!i.lightMap,
        lightMapEncoding: p(i.lightMap),
        aoMap: !!i.aoMap,
        emissiveMap: !!i.emissiveMap,
        emissiveMapEncoding: p(i.emissiveMap),
        bumpMap: !!i.bumpMap,
        normalMap: !!i.normalMap,
        objectSpaceNormalMap: 1 === i.normalMapType,
        tangentSpaceNormalMap: 0 === i.normalMapType,
        clearcoatMap: !!i.clearcoatMap,
        clearcoatRoughnessMap: !!i.clearcoatRoughnessMap,
        clearcoatNormalMap: !!i.clearcoatNormalMap,
        displacementMap: !!i.displacementMap,
        roughnessMap: !!i.roughnessMap,
        metalnessMap: !!i.metalnessMap,
        specularMap: !!i.specularMap,
        alphaMap: !!i.alphaMap,
        gradientMap: !!i.gradientMap,
        sheen: !!i.sheen,
        combine: i.combine,
        vertexTangents: i.normalMap && i.vertexTangents,
        vertexColors: i.vertexColors,
        vertexUvs: !!(
          i.map ||
          i.bumpMap ||
          i.normalMap ||
          i.specularMap ||
          i.alphaMap ||
          i.emissiveMap ||
          i.roughnessMap ||
          i.metalnessMap ||
          i.clearcoatMap ||
          i.clearcoatRoughnessMap ||
          i.clearcoatNormalMap ||
          i.displacementMap
        ),
        uvsVertexOnly: !(
          i.map ||
          i.bumpMap ||
          i.normalMap ||
          i.specularMap ||
          i.alphaMap ||
          i.emissiveMap ||
          i.roughnessMap ||
          i.metalnessMap ||
          i.clearcoatNormalMap ||
          !i.displacementMap
        ),
        fog: !!v,
        useFog: i.fog,
        fogExp2: v && v.isFogExp2,
        flatShading: i.flatShading,
        sizeAttenuation: i.sizeAttenuation,
        logarithmicDepthBuffer: s,
        skinning: i.skinning && A > 0,
        maxBones: A,
        useVertexTexture: a,
        morphTargets: i.morphTargets,
        morphNormals: i.morphNormals,
        maxMorphTargets: t.maxMorphTargets,
        maxMorphNormals: t.maxMorphNormals,
        numDirLights: d.directional.length,
        numPointLights: d.point.length,
        numSpotLights: d.spot.length,
        numRectAreaLights: d.rectArea.length,
        numHemiLights: d.hemi.length,
        numDirLightShadows: d.directionalShadowMap.length,
        numPointLightShadows: d.pointShadowMap.length,
        numSpotLightShadows: d.spotShadowMap.length,
        numClippingPlanes: b,
        numClipIntersection: g,
        dithering: i.dithering,
        shadowMapEnabled: t.shadowMap.enabled && f.length > 0,
        shadowMapType: t.shadowMap.type,
        toneMapping: i.toneMapped ? t.toneMapping : 0,
        physicallyCorrectLights: t.physicallyCorrectLights,
        premultipliedAlpha: i.premultipliedAlpha,
        alphaTest: i.alphaTest,
        doubleSided: 2 === i.side,
        flipSided: 1 === i.side,
        depthPacking: void 0 !== i.depthPacking && i.depthPacking,
        index0AttributeName: i.index0AttributeName,
        extensionDerivatives: i.extensions && i.extensions.derivatives,
        extensionFragDepth: i.extensions && i.extensions.fragDepth,
        extensionDrawBuffers: i.extensions && i.extensions.drawBuffers,
        extensionShaderTextureLOD:
          i.extensions && i.extensions.shaderTextureLOD,
        rendererExtensionFragDepth: o || null !== e.get('EXT_frag_depth'),
        rendererExtensionDrawBuffers: o || null !== e.get('WEBGL_draw_buffers'),
        rendererExtensionShaderTextureLod:
          o || null !== e.get('EXT_shader_texture_lod'),
        offsetVertexPosition: !!i.vertexOffset,
        smoothingLighting: !!i.smoothLighting,
        onBeforeCompile: i.onBeforeCompile,
      };
    }),
      (this.getProgramCacheKey = function (e) {
        var n = [];
        if (
          (e.shaderID
            ? n.push(e.shaderID)
            : (n.push(e.fragmentShader), n.push(e.vertexShader)),
          void 0 !== e.defines)
        )
          for (var i in e.defines) n.push(i), n.push(e.defines[i]);
        for (var r = 0; r < d.length; r++) n.push(e[d[r]]);
        return (
          n.push(t.outputEncoding),
          n.push(t.gammaFactor),
          n.push(e.onBeforeCompile.toString()),
          n.join()
        );
      }),
      (this.acquireProgram = function (e, n) {
        for (var r, o = 0, s = i.length; o < s; o++) {
          var a = i[o];
          if (a.cacheKey === n) {
            ++(r = a).usedTimes;
            break;
          }
        }
        return void 0 === r && ((r = new dr(t, n, e)), i.push(r)), r;
      }),
      (this.releaseProgram = function (t) {
        if (0 == --t.usedTimes) {
          var e = i.indexOf(t);
          (i[e] = i[i.length - 1]), i.pop(), t.destroy();
        }
      }),
      (this.programs = i);
  }
  function fr() {
    var t = new WeakMap();
    return {
      get: function (e) {
        var n = t.get(e);
        return void 0 === n && ((n = {}), t.set(e, n)), n;
      },
      remove: function (e) {
        t.delete(e);
      },
      update: function (e, n, i) {
        t.get(e)[n] = i;
      },
      dispose: function () {
        t = new WeakMap();
      },
    };
  }
  function mr(t, e) {
    return t.groupOrder !== e.groupOrder
      ? t.groupOrder - e.groupOrder
      : t.renderOrder !== e.renderOrder
      ? t.renderOrder - e.renderOrder
      : t.program !== e.program
      ? t.program.id - e.program.id
      : t.material.id !== e.material.id
      ? t.material.id - e.material.id
      : t.z !== e.z
      ? t.z - e.z
      : t.id - e.id;
  }
  function br(t, e) {
    return t.groupOrder !== e.groupOrder
      ? t.groupOrder - e.groupOrder
      : t.renderOrder !== e.renderOrder
      ? t.renderOrder - e.renderOrder
      : t.z !== e.z
      ? e.z - t.z
      : t.id - e.id;
  }
  function gr() {
    var t = [],
      e = 0,
      n = [],
      i = [],
      r = { id: -1 };
    function o(n, i, o, s, a, c) {
      var l = t[e];
      return (
        void 0 === l
          ? ((l = {
              id: n.id,
              object: n,
              geometry: i,
              material: o,
              program: o.program || r,
              groupOrder: s,
              renderOrder: n.renderOrder,
              z: a,
              group: c,
            }),
            (t[e] = l))
          : ((l.id = n.id),
            (l.object = n),
            (l.geometry = i),
            (l.material = o),
            (l.program = o.program || r),
            (l.groupOrder = s),
            (l.renderOrder = n.renderOrder),
            (l.z = a),
            (l.group = c)),
        e++,
        l
      );
    }
    return {
      opaque: n,
      transparent: i,
      init: function () {
        (e = 0), (n.length = 0), (i.length = 0);
      },
      push: function (t, e, r, s, a, c) {
        var l = o(t, e, r, s, a, c);
        (!0 === r.transparent ? i : n).push(l);
      },
      unshift: function (t, e, r, s, a, c) {
        var l = o(t, e, r, s, a, c);
        (!0 === r.transparent ? i : n).unshift(l);
      },
      finish: function () {
        for (var n = e, i = t.length; n < i; n++) {
          var r = t[n];
          if (null === r.id) break;
          (r.id = null),
            (r.object = null),
            (r.geometry = null),
            (r.material = null),
            (r.program = null),
            (r.group = null);
        }
      },
      sort: function (t, e) {
        n.length > 1 && n.sort(t || mr), i.length > 1 && i.sort(e || br);
      },
    };
  }
  function yr() {
    var t = new WeakMap();
    function e(n) {
      var i = n.target;
      i.removeEventListener('dispose', e), t.delete(i);
    }
    return {
      get: function (n, i) {
        var r,
          o = t.get(n);
        return (
          void 0 === o
            ? ((r = new gr()),
              t.set(n, new WeakMap()),
              t.get(n).set(i, r),
              n.addEventListener('dispose', e))
            : void 0 === (r = o.get(i)) && ((r = new gr()), o.set(i, r)),
          r
        );
      },
      dispose: function () {
        t = new WeakMap();
      },
    };
  }
  function vr() {
    var t = {};
    return {
      get: function (e) {
        if (void 0 !== t[e.id]) return t[e.id];
        var n;
        switch (e.type) {
          case 'DirectionalLight':
            n = { direction: new J(), color: new fe() };
            break;
          case 'SpotLight':
            n = {
              position: new J(),
              direction: new J(),
              color: new fe(),
              distance: 0,
              coneCos: 0,
              penumbraCos: 0,
              decay: 0,
            };
            break;
          case 'PointLight':
            n = { position: new J(), color: new fe(), distance: 0, decay: 0 };
            break;
          case 'HemisphereLight':
            n = {
              direction: new J(),
              skyColor: new fe(),
              groundColor: new fe(),
            };
            break;
          case 'RectAreaLight':
            n = {
              color: new fe(),
              position: new J(),
              halfWidth: new J(),
              halfHeight: new J(),
            };
        }
        return (t[e.id] = n), n;
      },
    };
  }
  var _r = 0;
  function xr(t, e) {
    return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0);
  }
  function wr() {
    for (
      var t,
        e = new vr(),
        n =
          ((t = {}),
          {
            get: function (e) {
              if (void 0 !== t[e.id]) return t[e.id];
              var n;
              switch (e.type) {
                case 'DirectionalLight':
                case 'SpotLight':
                  n = {
                    shadowBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new U(),
                  };
                  break;
                case 'PointLight':
                  n = {
                    shadowBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new U(),
                    shadowCameraNear: 1,
                    shadowCameraFar: 1e3,
                  };
              }
              return (t[e.id] = n), n;
            },
          }),
        i = {
          version: 0,
          hash: {
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1,
          },
          ambient: [0, 0, 0],
          probe: [],
          directional: [],
          directionalShadow: [],
          directionalShadowMap: [],
          directionalShadowMatrix: [],
          spot: [],
          spotShadow: [],
          spotShadowMap: [],
          spotShadowMatrix: [],
          rectArea: [],
          point: [],
          pointShadow: [],
          pointShadowMap: [],
          pointShadowMatrix: [],
          hemi: [],
        },
        r = 0;
      r < 9;
      r++
    )
      i.probe.push(new J());
    var o = new J(),
      s = new ot(),
      a = new ot();
    return {
      setup: function (t, r, c) {
        for (var l = 0, h = 0, u = 0, d = 0; d < 9; d++)
          i.probe[d].set(0, 0, 0);
        var p = 0,
          f = 0,
          m = 0,
          b = 0,
          g = 0,
          y = 0,
          v = 0,
          _ = 0,
          x = c.matrixWorldInverse;
        t.sort(xr), (d = 0);
        for (var w = t.length; d < w; d++) {
          var A = t[d],
            M = A.color,
            S = A.intensity,
            I = A.distance,
            E = A.shadow && A.shadow.map ? A.shadow.map.texture : null;
          if (A.isAmbientLight) (l += M.r * S), (h += M.g * S), (u += M.b * S);
          else if (A.isLightProbe)
            for (var D = 0; D < 9; D++)
              i.probe[D].addScaledVector(A.sh.coefficients[D], S);
          else if (A.isDirectionalLight) {
            if (
              ((L = e.get(A)).color.copy(A.color).multiplyScalar(A.intensity),
              L.direction.setFromMatrixPosition(A.matrixWorld),
              o.setFromMatrixPosition(A.target.matrixWorld),
              L.direction.sub(o),
              L.direction.transformDirection(x),
              A.castShadow)
            ) {
              var C = A.shadow;
              ((T = n.get(A)).shadowBias = C.bias),
                (T.shadowRadius = C.radius),
                (T.shadowMapSize = C.mapSize),
                (i.directionalShadow[p] = T),
                (i.directionalShadowMap[p] = E),
                (i.directionalShadowMatrix[p] = A.shadow.matrix),
                y++;
            }
            (i.directional[p] = L), p++;
          } else if (A.isSpotLight) {
            if (
              ((L = e.get(A)).position.setFromMatrixPosition(A.matrixWorld),
              L.position.applyMatrix4(x),
              L.color.copy(M).multiplyScalar(S),
              (L.distance = I),
              L.direction.setFromMatrixPosition(A.matrixWorld),
              o.setFromMatrixPosition(A.target.matrixWorld),
              L.direction.sub(o),
              L.direction.transformDirection(x),
              (L.coneCos = Math.cos(A.angle)),
              (L.penumbraCos = Math.cos(A.angle * (1 - A.penumbra))),
              (L.decay = A.decay),
              A.castShadow)
            ) {
              C = A.shadow;
              ((T = n.get(A)).shadowBias = C.bias),
                (T.shadowRadius = C.radius),
                (T.shadowMapSize = C.mapSize),
                (i.spotShadow[m] = T),
                (i.spotShadowMap[m] = E),
                (i.spotShadowMatrix[m] = A.shadow.matrix),
                _++;
            }
            (i.spot[m] = L), m++;
          } else if (A.isRectAreaLight) {
            (L = e.get(A)).color.copy(M).multiplyScalar(S),
              L.position.setFromMatrixPosition(A.matrixWorld),
              L.position.applyMatrix4(x),
              a.identity(),
              s.copy(A.matrixWorld),
              s.premultiply(x),
              a.extractRotation(s),
              L.halfWidth.set(0.5 * A.width, 0, 0),
              L.halfHeight.set(0, 0.5 * A.height, 0),
              L.halfWidth.applyMatrix4(a),
              L.halfHeight.applyMatrix4(a),
              (i.rectArea[b] = L),
              b++;
          } else if (A.isPointLight) {
            if (
              ((L = e.get(A)).position.setFromMatrixPosition(A.matrixWorld),
              L.position.applyMatrix4(x),
              L.color.copy(A.color).multiplyScalar(A.intensity),
              (L.distance = A.distance),
              (L.decay = A.decay),
              A.castShadow)
            ) {
              var T;
              C = A.shadow;
              ((T = n.get(A)).shadowBias = C.bias),
                (T.shadowRadius = C.radius),
                (T.shadowMapSize = C.mapSize),
                (T.shadowCameraNear = C.camera.near),
                (T.shadowCameraFar = C.camera.far),
                (i.pointShadow[f] = T),
                (i.pointShadowMap[f] = E),
                (i.pointShadowMatrix[f] = A.shadow.matrix),
                v++;
            }
            (i.point[f] = L), f++;
          } else if (A.isHemisphereLight) {
            var L;
            (L = e.get(A)).direction.setFromMatrixPosition(A.matrixWorld),
              L.direction.transformDirection(x),
              L.direction.normalize(),
              L.skyColor.copy(A.color).multiplyScalar(S),
              L.groundColor.copy(A.groundColor).multiplyScalar(S),
              (i.hemi[g] = L),
              g++;
          }
        }
        (i.ambient[0] = l), (i.ambient[1] = h), (i.ambient[2] = u);
        var R = i.hash;
        (R.directionalLength === p &&
          R.pointLength === f &&
          R.spotLength === m &&
          R.rectAreaLength === b &&
          R.hemiLength === g &&
          R.numDirectionalShadows === y &&
          R.numPointShadows === v &&
          R.numSpotShadows === _) ||
          ((i.directional.length = p),
          (i.spot.length = m),
          (i.rectArea.length = b),
          (i.point.length = f),
          (i.hemi.length = g),
          (i.directionalShadow.length = y),
          (i.directionalShadowMap.length = y),
          (i.pointShadow.length = v),
          (i.pointShadowMap.length = v),
          (i.spotShadow.length = _),
          (i.spotShadowMap.length = _),
          (i.directionalShadowMatrix.length = y),
          (i.pointShadowMatrix.length = v),
          (i.spotShadowMatrix.length = _),
          (R.directionalLength = p),
          (R.pointLength = f),
          (R.spotLength = m),
          (R.rectAreaLength = b),
          (R.hemiLength = g),
          (R.numDirectionalShadows = y),
          (R.numPointShadows = v),
          (R.numSpotShadows = _),
          (i.version = _r++));
      },
      state: i,
    };
  }
  function Ar() {
    var t = new wr(),
      e = [],
      n = [];
    return {
      init: function () {
        (e.length = 0), (n.length = 0);
      },
      state: { lightsArray: e, shadowsArray: n, lights: t },
      setupLights: function (i) {
        t.setup(e, n, i);
      },
      pushLight: function (t) {
        e.push(t);
      },
      pushShadow: function (t) {
        n.push(t);
      },
    };
  }
  function Mr() {
    var t = new WeakMap();
    function e(n) {
      var i = n.target;
      i.removeEventListener('dispose', e), t.delete(i);
    }
    return {
      get: function (n, i) {
        var r;
        return (
          !1 === t.has(n)
            ? ((r = new Ar()),
              t.set(n, new WeakMap()),
              t.get(n).set(i, r),
              n.addEventListener('dispose', e))
            : !1 === t.get(n).has(i)
            ? ((r = new Ar()), t.get(n).set(i, r))
            : (r = t.get(n).get(i)),
          r
        );
      },
      dispose: function () {
        t = new WeakMap();
      },
    };
  }
  function Sr(t) {
    _e.call(this),
      (this.type = 'MeshDepthMaterial'),
      (this.depthPacking = 3200),
      (this.skinning = !1),
      (this.morphTargets = !1),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      this.setValues(t);
  }
  function Ir(t) {
    _e.call(this),
      (this.type = 'MeshDistanceMaterial'),
      (this.referencePosition = new J()),
      (this.nearDistance = 1),
      (this.farDistance = 1e3),
      (this.skinning = !1),
      (this.morphTargets = !1),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.fog = !1),
      this.setValues(t);
  }
  (Sr.prototype = Object.create(_e.prototype)),
    (Sr.prototype.constructor = Sr),
    (Sr.prototype.isMeshDepthMaterial = !0),
    (Sr.prototype.copy = function (t) {
      return (
        _e.prototype.copy.call(this, t),
        (this.depthPacking = t.depthPacking),
        (this.skinning = t.skinning),
        (this.morphTargets = t.morphTargets),
        (this.map = t.map),
        (this.alphaMap = t.alphaMap),
        (this.displacementMap = t.displacementMap),
        (this.displacementScale = t.displacementScale),
        (this.displacementBias = t.displacementBias),
        (this.wireframe = t.wireframe),
        (this.wireframeLinewidth = t.wireframeLinewidth),
        this
      );
    }),
    (Ir.prototype = Object.create(_e.prototype)),
    (Ir.prototype.constructor = Ir),
    (Ir.prototype.isMeshDistanceMaterial = !0),
    (Ir.prototype.copy = function (t) {
      return (
        _e.prototype.copy.call(this, t),
        this.referencePosition.copy(t.referencePosition),
        (this.nearDistance = t.nearDistance),
        (this.farDistance = t.farDistance),
        (this.skinning = t.skinning),
        (this.morphTargets = t.morphTargets),
        (this.map = t.map),
        (this.alphaMap = t.alphaMap),
        (this.displacementMap = t.displacementMap),
        (this.displacementScale = t.displacementScale),
        (this.displacementBias = t.displacementBias),
        this
      );
    });
  function Er(t, e, n) {
    var i = new Ln(),
      r = new U(),
      o = new U(),
      s = new W(),
      a = [],
      l = [],
      h = {},
      d = { 0: 1, 1: 0, 2: 2 },
      p = new wn({
        defines: { SAMPLE_RATE: 2 / 8, HALF_SAMPLE_RATE: 1 / 8 },
        uniforms: {
          shadow_pass: { value: null },
          resolution: { value: new U() },
          radius: { value: 4 },
        },
        vertexShader:
          '\n\nvoid main() {\n\n\tgl_Position = vec4( position, 1.0 );\n\n}\n\n',
        fragmentShader:
          "\nuniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n\n#include <packing>\n\nvoid main() {\n\n  float mean = 0.0;\n  float squared_mean = 0.0;\n\n\t// This seems totally useless but it's a crazy work around for a Adreno compiler bug\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );\n\n  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\n    #ifdef HORIZONAL_PASS\n\n      vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n      mean += distribution.x;\n      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\n    #else\n\n      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );\n      mean += depth;\n      squared_mean += depth * depth;\n\n    #endif\n\n  }\n\n  mean = mean * HALF_SAMPLE_RATE;\n  squared_mean = squared_mean * HALF_SAMPLE_RATE;\n\n  float std_dev = sqrt( squared_mean - mean * mean );\n\n  gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n\n}\n",
      }),
      f = p.clone();
    f.defines.HORIZONAL_PASS = 1;
    var m = new He();
    m.setAttribute(
      'position',
      new Ae(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3),
    );
    var b = new ln(m, p),
      g = this;
    function y(n, i) {
      var r = e.update(b);
      (p.uniforms.shadow_pass.value = n.map.texture),
        (p.uniforms.resolution.value = n.mapSize),
        (p.uniforms.radius.value = n.radius),
        t.setRenderTarget(n.mapPass),
        t.clear(),
        t.renderBufferDirect(i, null, r, p, b, null),
        (f.uniforms.shadow_pass.value = n.mapPass.texture),
        (f.uniforms.resolution.value = n.mapSize),
        (f.uniforms.radius.value = n.radius),
        t.setRenderTarget(n.map),
        t.clear(),
        t.renderBufferDirect(i, null, r, f, b, null);
    }
    function v(t, e, n) {
      var i = (t << 0) | (e << 1) | (n << 2),
        r = a[i];
      return (
        void 0 === r &&
          ((r = new Sr({ depthPacking: 3201, morphTargets: t, skinning: e })),
          (a[i] = r)),
        r
      );
    }
    function _(t, e, n) {
      var i = (t << 0) | (e << 1) | (n << 2),
        r = l[i];
      return (
        void 0 === r &&
          ((r = new Ir({ morphTargets: t, skinning: e })), (l[i] = r)),
        r
      );
    }
    function w(e, n, i, r, o, s) {
      var a = e.geometry,
        c = null,
        l = v,
        u = e.customDepthMaterial;
      if (
        (!0 === i.isPointLight && ((l = _), (u = e.customDistanceMaterial)),
        void 0 === u)
      ) {
        var p = !1;
        !0 === n.morphTargets &&
          (!0 === a.isBufferGeometry
            ? (p =
                a.morphAttributes &&
                a.morphAttributes.position &&
                a.morphAttributes.position.length > 0)
            : !0 === a.isGeometry &&
              (p = a.morphTargets && a.morphTargets.length > 0));
        var f = !1;
        !0 === e.isSkinnedMesh &&
          (!0 === n.skinning
            ? (f = !0)
            : console.warn(
                'THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:',
                e,
              )),
          (c = l(p, f, !0 === e.isInstancedMesh));
      } else c = u;
      if (
        t.localClippingEnabled &&
        !0 === n.clipShadows &&
        0 !== n.clippingPlanes.length
      ) {
        var m = c.uuid,
          b = n.uuid,
          g = h[m];
        void 0 === g && ((g = {}), (h[m] = g));
        var y = g[b];
        void 0 === y && ((y = c.clone()), (g[b] = y)), (c = y);
      }
      return (
        (c.visible = n.visible),
        (c.wireframe = n.wireframe),
        (c.side =
          3 === s
            ? null !== n.shadowSide
              ? n.shadowSide
              : n.side
            : null !== n.shadowSide
            ? n.shadowSide
            : d[n.side]),
        (c.clipShadows = n.clipShadows),
        (c.clippingPlanes = n.clippingPlanes),
        (c.clipIntersection = n.clipIntersection),
        (c.wireframeLinewidth = n.wireframeLinewidth),
        (c.linewidth = n.linewidth),
        !0 === i.isPointLight &&
          !0 === c.isMeshDistanceMaterial &&
          (c.referencePosition.setFromMatrixPosition(i.matrixWorld),
          (c.nearDistance = r),
          (c.farDistance = o)),
        c
      );
    }
    function A(n, r, o, s, a) {
      if (!1 !== n.visible) {
        if (
          n.layers.test(r.layers) &&
          (n.isMesh || n.isLine || n.isPoints) &&
          (n.castShadow || (n.receiveShadow && 3 === a)) &&
          (!n.frustumCulled || i.intersectsObject(n))
        ) {
          n.modelViewMatrix.multiplyMatrices(
            o.matrixWorldInverse,
            n.matrixWorld,
          );
          var c = e.update(n),
            l = n.material;
          if (Array.isArray(l))
            for (var h = c.groups, u = 0, d = h.length; u < d; u++) {
              var p = h[u],
                f = l[p.materialIndex];
              if (f && f.visible) {
                var m = w(n, f, s, o.near, o.far, a);
                t.renderBufferDirect(o, null, c, m, n, p);
              }
            }
          else if (l.visible) {
            m = w(n, l, s, o.near, o.far, a);
            t.renderBufferDirect(o, null, c, m, n, null);
          }
        }
        for (var b = n.children, g = 0, y = b.length; g < y; g++)
          A(b[g], r, o, s, a);
      }
    }
    (this.enabled = !1),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this.type = 1),
      (this.render = function (e, a, l) {
        if (
          !1 !== g.enabled &&
          (!1 !== g.autoUpdate || !1 !== g.needsUpdate) &&
          0 !== e.length
        ) {
          var h = t.getRenderTarget(),
            d = t.getActiveCubeFace(),
            p = t.getActiveMipmapLevel(),
            f = t.state;
          f.setBlending(0),
            f.buffers.color.setClear(1, 1, 1, 1),
            f.buffers.depth.setTest(!0),
            f.setScissorTest(!1);
          for (var m = 0, b = e.length; m < b; m++) {
            var v = e[m],
              _ = v.shadow;
            if (void 0 !== _) {
              r.copy(_.mapSize);
              var w = _.getFrameExtents();
              if (
                (r.multiply(w),
                o.copy(_.mapSize),
                (r.x > n || r.y > n) &&
                  (console.warn(
                    'THREE.WebGLShadowMap:',
                    v,
                    'has shadow exceeding max texture size, reducing',
                  ),
                  r.x > n &&
                    ((o.x = Math.floor(n / w.x)),
                    (r.x = o.x * w.x),
                    (_.mapSize.x = o.x)),
                  r.y > n &&
                    ((o.y = Math.floor(n / w.y)),
                    (r.y = o.y * w.y),
                    (_.mapSize.y = o.y))),
                null === _.map && !_.isPointLightShadow && 3 === this.type)
              ) {
                var M = { minFilter: u, magFilter: u, format: x };
                (_.map = new X(r.x, r.y, M)),
                  (_.map.texture.name = v.name + '.shadowMap'),
                  (_.mapPass = new X(r.x, r.y, M)),
                  _.camera.updateProjectionMatrix();
              }
              if (null === _.map) {
                M = { minFilter: c, magFilter: c, format: x };
                (_.map = new X(r.x, r.y, M)),
                  (_.map.texture.name = v.name + '.shadowMap'),
                  _.camera.updateProjectionMatrix();
              }
              t.setRenderTarget(_.map), t.clear();
              for (var S = _.getViewportCount(), I = 0; I < S; I++) {
                var E = _.getViewport(I);
                s.set(o.x * E.x, o.y * E.y, o.x * E.z, o.y * E.w),
                  f.viewport(s),
                  _.updateMatrices(v, I),
                  (i = _.getFrustum()),
                  A(a, l, _.camera, v, this.type);
              }
              _.isPointLightShadow || 3 !== this.type || y(_, l);
            } else console.warn('THREE.WebGLShadowMap:', v, 'has no shadow.');
          }
          (g.needsUpdate = !1), t.setRenderTarget(h, d, p);
        }
      });
  }
  function Dr(t, e, n) {
    var r = n.isWebGL2;
    var o = new (function () {
        var e = !1,
          n = new W(),
          i = null,
          r = new W(0, 0, 0, 0);
        return {
          setMask: function (n) {
            i === n || e || (t.colorMask(n, n, n, n), (i = n));
          },
          setLocked: function (t) {
            e = t;
          },
          setClear: function (e, i, o, s, a) {
            !0 === a && ((e *= s), (i *= s), (o *= s)),
              n.set(e, i, o, s),
              !1 === r.equals(n) && (t.clearColor(e, i, o, s), r.copy(n));
          },
          reset: function () {
            (e = !1), (i = null), r.set(-1, 0, 0, 0);
          },
        };
      })(),
      s = new (function () {
        var e = !1,
          n = null,
          i = null,
          r = null;
        return {
          setTest: function (e) {
            e ? U(t.DEPTH_TEST) : G(t.DEPTH_TEST);
          },
          setMask: function (i) {
            n === i || e || (t.depthMask(i), (n = i));
          },
          setFunc: function (e) {
            if (i !== e) {
              if (e)
                switch (e) {
                  case 0:
                    t.depthFunc(t.NEVER);
                    break;
                  case 1:
                    t.depthFunc(t.ALWAYS);
                    break;
                  case 2:
                    t.depthFunc(t.LESS);
                    break;
                  case 3:
                    t.depthFunc(t.LEQUAL);
                    break;
                  case 4:
                    t.depthFunc(t.EQUAL);
                    break;
                  case 5:
                    t.depthFunc(t.GEQUAL);
                    break;
                  case 6:
                    t.depthFunc(t.GREATER);
                    break;
                  case 7:
                    t.depthFunc(t.NOTEQUAL);
                    break;
                  default:
                    t.depthFunc(t.LEQUAL);
                }
              else t.depthFunc(t.LEQUAL);
              i = e;
            }
          },
          setLocked: function (t) {
            e = t;
          },
          setClear: function (e) {
            r !== e && (t.clearDepth(e), (r = e));
          },
          reset: function () {
            (e = !1), (n = null), (i = null), (r = null);
          },
        };
      })(),
      a = new (function () {
        var e = !1,
          n = null,
          i = null,
          r = null,
          o = null,
          s = null,
          a = null,
          c = null,
          l = null;
        return {
          setTest: function (n) {
            e || (n ? U(t.STENCIL_TEST) : G(t.STENCIL_TEST));
          },
          setMask: function (i) {
            n === i || e || (t.stencilMask(i), (n = i));
          },
          setFunc: function (e, n, s) {
            (i === e && r === n && o === s) ||
              (t.stencilFunc(e, n, s), (i = e), (r = n), (o = s));
          },
          setOp: function (e, n, i) {
            (s === e && a === n && c === i) ||
              (t.stencilOp(e, n, i), (s = e), (a = n), (c = i));
          },
          setLocked: function (t) {
            e = t;
          },
          setClear: function (e) {
            l !== e && (t.clearStencil(e), (l = e));
          },
          reset: function () {
            (e = !1),
              (n = null),
              (i = null),
              (r = null),
              (o = null),
              (s = null),
              (a = null),
              (c = null),
              (l = null);
          },
        };
      })(),
      c = t.getParameter(t.MAX_VERTEX_ATTRIBS),
      l = new Uint8Array(c),
      h = new Uint8Array(c),
      u = new Uint8Array(c),
      d = {},
      p = null,
      f = null,
      m = null,
      b = null,
      g = null,
      y = null,
      v = null,
      _ = null,
      x = null,
      w = !1,
      A = null,
      M = null,
      S = null,
      I = null,
      E = null,
      D = t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS),
      C = !1,
      T = 0,
      L = t.getParameter(t.VERSION);
    -1 !== L.indexOf('WebGL')
      ? ((T = parseFloat(/^WebGL\ ([0-9])/.exec(L)[1])), (C = T >= 1))
      : -1 !== L.indexOf('OpenGL ES') &&
        ((T = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(L)[1])), (C = T >= 2));
    var R = null,
      F = {},
      P = new W(),
      B = new W(),
      O = null;
    function V(e, n, i) {
      var r = new Uint8Array(4),
        o = t.createTexture();
      t.bindTexture(e, o),
        t.texParameteri(e, t.TEXTURE_MIN_FILTER, t.NEAREST),
        t.texParameteri(e, t.TEXTURE_MAG_FILTER, t.NEAREST);
      for (var s = 0; s < i; s++)
        t.texImage2D(n + s, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, r);
      return o;
    }
    var N = {};
    function k(n, i) {
      ((l[n] = 1),
      0 === h[n] && (t.enableVertexAttribArray(n), (h[n] = 1)),
      u[n] !== i) &&
        ((r ? t : e.get('ANGLE_instanced_arrays'))[
          r ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE'
        ](n, i),
        (u[n] = i));
    }
    function U(e) {
      !0 !== d[e] && (t.enable(e), (d[e] = !0));
    }
    function G(e) {
      !1 !== d[e] && (t.disable(e), (d[e] = !1));
    }
    (N[t.TEXTURE_2D] = V(t.TEXTURE_2D, t.TEXTURE_2D, 1)),
      (N[t.TEXTURE_CUBE_MAP] = V(
        t.TEXTURE_CUBE_MAP,
        t.TEXTURE_CUBE_MAP_POSITIVE_X,
        6,
      )),
      o.setClear(0, 0, 0, 1),
      s.setClear(1),
      a.setClear(0),
      U(t.DEPTH_TEST),
      s.setFunc(3),
      Z(!1),
      Y(1),
      U(t.CULL_FACE),
      X(0);
    var z = {
      [i]: t.FUNC_ADD,
      101: t.FUNC_SUBTRACT,
      102: t.FUNC_REVERSE_SUBTRACT,
    };
    if (r) (z[103] = t.MIN), (z[104] = t.MAX);
    else {
      var j = e.get('EXT_blend_minmax');
      null !== j && ((z[103] = j.MIN_EXT), (z[104] = j.MAX_EXT));
    }
    var H = {
      200: t.ZERO,
      201: t.ONE,
      202: t.SRC_COLOR,
      204: t.SRC_ALPHA,
      210: t.SRC_ALPHA_SATURATE,
      208: t.DST_COLOR,
      206: t.DST_ALPHA,
      203: t.ONE_MINUS_SRC_COLOR,
      205: t.ONE_MINUS_SRC_ALPHA,
      209: t.ONE_MINUS_DST_COLOR,
      207: t.ONE_MINUS_DST_ALPHA,
    };
    function X(e, n, r, o, s, a, c, l) {
      if (0 !== e) {
        if ((f || (U(t.BLEND), (f = !0)), 5 === e))
          (s = s || n),
            (a = a || r),
            (c = c || o),
            (n === b && s === v) ||
              (t.blendEquationSeparate(z[n], z[s]), (b = n), (v = s)),
            (r === g && o === y && a === _ && c === x) ||
              (t.blendFuncSeparate(H[r], H[o], H[a], H[c]),
              (g = r),
              (y = o),
              (_ = a),
              (x = c)),
            (m = e),
            (w = null);
        else if (e !== m || l !== w) {
          if (
            ((b === i && v === i) ||
              (t.blendEquation(t.FUNC_ADD), (b = i), (v = i)),
            l)
          )
            switch (e) {
              case 1:
                t.blendFuncSeparate(
                  t.ONE,
                  t.ONE_MINUS_SRC_ALPHA,
                  t.ONE,
                  t.ONE_MINUS_SRC_ALPHA,
                );
                break;
              case 2:
                t.blendFunc(t.ONE, t.ONE);
                break;
              case 3:
                t.blendFuncSeparate(
                  t.ZERO,
                  t.ZERO,
                  t.ONE_MINUS_SRC_COLOR,
                  t.ONE_MINUS_SRC_ALPHA,
                );
                break;
              case 4:
                t.blendFuncSeparate(t.ZERO, t.SRC_COLOR, t.ZERO, t.SRC_ALPHA);
                break;
              default:
                console.error('THREE.WebGLState: Invalid blending: ', e);
            }
          else
            switch (e) {
              case 1:
                t.blendFuncSeparate(
                  t.SRC_ALPHA,
                  t.ONE_MINUS_SRC_ALPHA,
                  t.ONE,
                  t.ONE_MINUS_SRC_ALPHA,
                );
                break;
              case 2:
                t.blendFunc(t.SRC_ALPHA, t.ONE);
                break;
              case 3:
                t.blendFunc(t.ZERO, t.ONE_MINUS_SRC_COLOR);
                break;
              case 4:
                t.blendFunc(t.ZERO, t.SRC_COLOR);
                break;
              default:
                console.error('THREE.WebGLState: Invalid blending: ', e);
            }
          (g = null), (y = null), (_ = null), (x = null), (m = e), (w = l);
        }
      } else f && (G(t.BLEND), (f = !1));
    }
    function Z(e) {
      A !== e && (e ? t.frontFace(t.CW) : t.frontFace(t.CCW), (A = e));
    }
    function Y(e) {
      0 !== e
        ? (U(t.CULL_FACE),
          e !== M &&
            (1 === e
              ? t.cullFace(t.BACK)
              : 2 === e
              ? t.cullFace(t.FRONT)
              : t.cullFace(t.FRONT_AND_BACK)))
        : G(t.CULL_FACE),
        (M = e);
    }
    function q(e, n, i) {
      e
        ? (U(t.POLYGON_OFFSET_FILL),
          (I === n && E === i) || (t.polygonOffset(n, i), (I = n), (E = i)))
        : G(t.POLYGON_OFFSET_FILL);
    }
    function Q(e) {
      void 0 === e && (e = t.TEXTURE0 + D - 1),
        R !== e && (t.activeTexture(e), (R = e));
    }
    return {
      buffers: { color: o, depth: s, stencil: a },
      initAttributes: function () {
        for (var t = 0, e = l.length; t < e; t++) l[t] = 0;
      },
      enableAttribute: function (t) {
        k(t, 0);
      },
      enableAttributeAndDivisor: k,
      disableUnusedAttributes: function () {
        for (var e = 0, n = h.length; e !== n; ++e)
          h[e] !== l[e] && (t.disableVertexAttribArray(e), (h[e] = 0));
      },
      enable: U,
      disable: G,
      useProgram: function (e) {
        return p !== e && (t.useProgram(e), (p = e), !0);
      },
      setBlending: X,
      setMaterial: function (e, n) {
        2 === e.side ? G(t.CULL_FACE) : U(t.CULL_FACE);
        var i = 1 === e.side;
        n && (i = !i),
          Z(i),
          1 === e.blending && !1 === e.transparent
            ? X(0)
            : X(
                e.blending,
                e.blendEquation,
                e.blendSrc,
                e.blendDst,
                e.blendEquationAlpha,
                e.blendSrcAlpha,
                e.blendDstAlpha,
                e.premultipliedAlpha,
              ),
          s.setFunc(e.depthFunc),
          s.setTest(e.depthTest),
          s.setMask(e.depthWrite),
          o.setMask(e.colorWrite);
        var r = e.stencilWrite;
        a.setTest(r),
          r &&
            (a.setMask(e.stencilWriteMask),
            a.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask),
            a.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)),
          q(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits),
          (function (e) {
            if (e === O) return;
            (O = e) && O.enable
              ? t.depthRange(O.minDepth, O.maxDepth)
              : t.depthRange(0, 1);
          })(e.depthRange);
      },
      setFlipSided: Z,
      setCullFace: Y,
      setLineWidth: function (e) {
        e !== S && (C && t.lineWidth(e), (S = e));
      },
      setPolygonOffset: q,
      setScissorTest: function (e) {
        e ? U(t.SCISSOR_TEST) : G(t.SCISSOR_TEST);
      },
      activeTexture: Q,
      bindTexture: function (e, n) {
        null === R && Q();
        var i = F[R];
        void 0 === i && ((i = { type: void 0, texture: void 0 }), (F[R] = i)),
          (i.type === e && i.texture === n) ||
            (t.bindTexture(e, n || N[e]), (i.type = e), (i.texture = n));
      },
      unbindTexture: function () {
        var e = F[R];
        void 0 !== e &&
          void 0 !== e.type &&
          (t.bindTexture(e.type, null),
          (e.type = void 0),
          (e.texture = void 0));
      },
      compressedTexImage2D: function () {
        try {
          t.compressedTexImage2D.apply(t, arguments);
        } catch (t) {
          console.error('THREE.WebGLState:', t);
        }
      },
      texImage2D: function () {
        try {
          t.texImage2D.apply(t, arguments);
        } catch (t) {
          console.error('THREE.WebGLState:', t);
        }
      },
      texImage3D: function () {
        try {
          t.texImage3D.apply(t, arguments);
        } catch (t) {
          console.error('THREE.WebGLState:', t);
        }
      },
      scissor: function (e) {
        !1 === P.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), P.copy(e));
      },
      viewport: function (e) {
        !1 === B.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), B.copy(e));
      },
      reset: function () {
        for (var e = 0; e < h.length; e++)
          1 === h[e] && (t.disableVertexAttribArray(e), (h[e] = 0));
        (d = {}),
          (R = null),
          (F = {}),
          (p = null),
          (m = null),
          (A = null),
          (M = null),
          o.reset(),
          s.reset(),
          a.reset();
      },
    };
  }
  function Cr(t, e, n, i, r, p, v) {
    var M,
      S = r.isWebGL2,
      I = r.maxTextures,
      E = r.maxCubemapSize,
      D = r.maxTextureSize,
      C = r.maxSamples,
      T = new WeakMap(),
      L = !1;
    try {
      L =
        'undefined' != typeof OffscreenCanvas &&
        null !== new OffscreenCanvas(1, 1).getContext('2d');
    } catch (t) {}
    function R(t, e) {
      return L
        ? new OffscreenCanvas(t, e)
        : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
    }
    function F(t, e, n, i) {
      var r = 1;
      if (
        ((t.width > i || t.height > i) && (r = i / Math.max(t.width, t.height)),
        r < 1 || !0 === e)
      ) {
        if (
          ('undefined' != typeof HTMLImageElement &&
            t instanceof HTMLImageElement) ||
          ('undefined' != typeof HTMLCanvasElement &&
            t instanceof HTMLCanvasElement) ||
          ('undefined' != typeof ImageBitmap && t instanceof ImageBitmap)
        ) {
          var o = e ? k.floorPowerOfTwo : Math.floor,
            s = o(r * t.width),
            a = o(r * t.height);
          void 0 === M && (M = R(s, a));
          var c = n ? R(s, a) : M;
          return (
            (c.width = s),
            (c.height = a),
            c.getContext('2d').drawImage(t, 0, 0, s, a),
            console.warn(
              'THREE.WebGLRenderer: Texture has been resized from (' +
                t.width +
                'x' +
                t.height +
                ') to (' +
                s +
                'x' +
                a +
                ').',
            ),
            c
          );
        }
        return (
          'data' in t &&
            console.warn(
              'THREE.WebGLRenderer: Image in DataTexture is too big (' +
                t.width +
                'x' +
                t.height +
                ').',
            ),
          t
        );
      }
      return t;
    }
    function P(t) {
      return k.isPowerOfTwo(t.width) && k.isPowerOfTwo(t.height);
    }
    function B(t, e) {
      return t.generateMipmaps && e && t.minFilter !== c && t.minFilter !== u;
    }
    function O(e, n, r, o) {
      t.generateMipmap(e),
        (i.get(n).__maxMipLevel = Math.log(Math.max(r, o)) * Math.LOG2E);
    }
    function V(n, i, r) {
      if (!1 === S) return i;
      if (null !== n) {
        if (void 0 !== t[n]) return t[n];
        console.warn(
          "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
            n +
            "'",
        );
      }
      var o = i;
      return (
        i === t.RED &&
          (r === t.FLOAT && (o = t.R32F),
          r === t.HALF_FLOAT && (o = t.R16F),
          r === t.UNSIGNED_BYTE && (o = t.R8)),
        i === t.RGB &&
          (r === t.FLOAT && (o = t.RGB32F),
          r === t.HALF_FLOAT && (o = t.RGB16F),
          r === t.UNSIGNED_BYTE && (o = t.RGB8)),
        i === t.RGBA &&
          (r === t.FLOAT && (o = t.RGBA32F),
          r === t.HALF_FLOAT && (o = t.RGBA16F),
          r === t.UNSIGNED_BYTE && (o = t.RGBA8)),
        (o !== t.R16F && o !== t.R32F && o !== t.RGBA16F && o !== t.RGBA32F) ||
          e.get('EXT_color_buffer_float'),
        o
      );
    }
    function N(e) {
      return e === c || e === l || e === h ? t.NEAREST : t.LINEAR;
    }
    function U(e) {
      var n = e.target;
      n.removeEventListener('dispose', U),
        (function (e) {
          var n = i.get(e);
          if (void 0 === n.__webglInit) return;
          t.deleteTexture(n.__webglTexture), i.remove(e);
        })(n),
        n.isVideoTexture && T.delete(n),
        v.memory.textures--;
    }
    function G(e) {
      var n = e.target;
      n.removeEventListener('dispose', G),
        (function (e) {
          var n = i.get(e),
            r = i.get(e.texture);
          if (!e) return;
          void 0 !== r.__webglTexture && t.deleteTexture(r.__webglTexture);
          e.depthTexture && e.depthTexture.dispose();
          if (e.isWebGLCubeRenderTarget)
            for (var o = 0; o < 6; o++)
              t.deleteFramebuffer(n.__webglFramebuffer[o]),
                n.__webglDepthbuffer &&
                  t.deleteRenderbuffer(n.__webglDepthbuffer[o]);
          else
            t.deleteFramebuffer(n.__webglFramebuffer),
              n.__webglDepthbuffer &&
                t.deleteRenderbuffer(n.__webglDepthbuffer),
              n.__webglMultisampledFramebuffer &&
                t.deleteFramebuffer(n.__webglMultisampledFramebuffer),
              n.__webglColorRenderbuffer &&
                t.deleteRenderbuffer(n.__webglColorRenderbuffer),
              n.__webglDepthRenderbuffer &&
                t.deleteRenderbuffer(n.__webglDepthRenderbuffer);
          i.remove(e.texture), i.remove(e);
        })(n),
        v.memory.textures--;
    }
    var z = 0;
    function j(e, r) {
      var o = i.get(e);
      if (
        (e.isVideoTexture &&
          (function (t) {
            var e = v.render.frame;
            T.get(t) !== e && (T.set(t, e), t.update());
          })(e),
        e.version > 0 && o.__version !== e.version)
      ) {
        var s = e.image;
        if (void 0 === s)
          console.warn(
            'THREE.WebGLRenderer: Texture marked for update but image is undefined',
          );
        else {
          if (!1 !== s.complete) return void Q(o, e, r);
          console.warn(
            'THREE.WebGLRenderer: Texture marked for update but image is incomplete',
          );
        }
      }
      n.activeTexture(t.TEXTURE0 + r),
        n.bindTexture(t.TEXTURE_2D, o.__webglTexture);
    }
    function H(e, r) {
      if (6 === e.image.length) {
        var o = i.get(e);
        if (e.version > 0 && o.__version !== e.version) {
          q(o, e),
            n.activeTexture(t.TEXTURE0 + r),
            n.bindTexture(t.TEXTURE_CUBE_MAP, o.__webglTexture),
            t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, e.flipY);
          for (
            var s =
                e && (e.isCompressedTexture || e.image[0].isCompressedTexture),
              a = e.image[0] && e.image[0].isDataTexture,
              c = [],
              l = 0;
            l < 6;
            l++
          )
            c[l] =
              s || a
                ? a
                  ? e.image[l].image
                  : e.image[l]
                : F(e.image[l], !1, !0, E);
          var h,
            u = c[0],
            d = P(u) || S,
            f = p.convert(e.format),
            m = p.convert(e.type),
            b = V(e.internalFormat, f, m);
          if ((Y(t.TEXTURE_CUBE_MAP, e, d), s)) {
            for (l = 0; l < 6; l++) {
              h = c[l].mipmaps;
              for (var g = 0; g < h.length; g++) {
                var y = h[g];
                e.format !== x && e.format !== _
                  ? null !== f
                    ? n.compressedTexImage2D(
                        t.TEXTURE_CUBE_MAP_POSITIVE_X + l,
                        g,
                        b,
                        y.width,
                        y.height,
                        0,
                        y.data,
                      )
                    : console.warn(
                        'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()',
                      )
                  : n.texImage2D(
                      t.TEXTURE_CUBE_MAP_POSITIVE_X + l,
                      g,
                      b,
                      y.width,
                      y.height,
                      0,
                      f,
                      m,
                      y.data,
                    );
              }
            }
            o.__maxMipLevel = h.length - 1;
          } else {
            h = e.mipmaps;
            for (l = 0; l < 6; l++)
              if (a) {
                n.texImage2D(
                  t.TEXTURE_CUBE_MAP_POSITIVE_X + l,
                  0,
                  b,
                  c[l].width,
                  c[l].height,
                  0,
                  f,
                  m,
                  c[l].data,
                );
                for (g = 0; g < h.length; g++) {
                  var v = (y = h[g]).image[l].image;
                  n.texImage2D(
                    t.TEXTURE_CUBE_MAP_POSITIVE_X + l,
                    g + 1,
                    b,
                    v.width,
                    v.height,
                    0,
                    f,
                    m,
                    v.data,
                  );
                }
              } else {
                n.texImage2D(
                  t.TEXTURE_CUBE_MAP_POSITIVE_X + l,
                  0,
                  b,
                  f,
                  m,
                  c[l],
                );
                for (g = 0; g < h.length; g++) {
                  y = h[g];
                  n.texImage2D(
                    t.TEXTURE_CUBE_MAP_POSITIVE_X + l,
                    g + 1,
                    b,
                    f,
                    m,
                    y.image[l],
                  );
                }
              }
            o.__maxMipLevel = h.length;
          }
          B(e, d) && O(t.TEXTURE_CUBE_MAP, e, u.width, u.height),
            (o.__version = e.version),
            e.onUpdate && e.onUpdate(e);
        } else
          n.activeTexture(t.TEXTURE0 + r),
            n.bindTexture(t.TEXTURE_CUBE_MAP, o.__webglTexture);
      }
    }
    function W(e, r) {
      n.activeTexture(t.TEXTURE0 + r),
        n.bindTexture(t.TEXTURE_CUBE_MAP, i.get(e).__webglTexture);
    }
    var X = { [o]: t.REPEAT, [s]: t.CLAMP_TO_EDGE, [a]: t.MIRRORED_REPEAT },
      Z = {
        [c]: t.NEAREST,
        [l]: t.NEAREST_MIPMAP_NEAREST,
        [h]: t.NEAREST_MIPMAP_LINEAR,
        [u]: t.LINEAR,
        1007: t.LINEAR_MIPMAP_NEAREST,
        [d]: t.LINEAR_MIPMAP_LINEAR,
      };
    function Y(n, o, a) {
      a
        ? (t.texParameteri(n, t.TEXTURE_WRAP_S, X[o.wrapS]),
          t.texParameteri(n, t.TEXTURE_WRAP_T, X[o.wrapT]),
          (n !== t.TEXTURE_3D && n !== t.TEXTURE_2D_ARRAY) ||
            t.texParameteri(n, t.TEXTURE_WRAP_R, X[o.wrapR]),
          t.texParameteri(n, t.TEXTURE_MAG_FILTER, Z[o.magFilter]),
          t.texParameteri(n, t.TEXTURE_MIN_FILTER, Z[o.minFilter]))
        : (t.texParameteri(n, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE),
          t.texParameteri(n, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE),
          (n !== t.TEXTURE_3D && n !== t.TEXTURE_2D_ARRAY) ||
            t.texParameteri(n, t.TEXTURE_WRAP_R, t.CLAMP_TO_EDGE),
          (o.wrapS === s && o.wrapT === s) ||
            console.warn(
              'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.',
            ),
          t.texParameteri(n, t.TEXTURE_MAG_FILTER, N(o.magFilter)),
          t.texParameteri(n, t.TEXTURE_MIN_FILTER, N(o.minFilter)),
          o.minFilter !== c &&
            o.minFilter !== u &&
            console.warn(
              'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.',
            ));
      var l = e.get('EXT_texture_filter_anisotropic');
      if (l) {
        if (o.type === b && null === e.get('OES_texture_float_linear')) return;
        if (
          o.type === g &&
          null === (S || e.get('OES_texture_half_float_linear'))
        )
          return;
        (o.anisotropy > 1 || i.get(o).__currentAnisotropy) &&
          (t.texParameterf(
            n,
            l.TEXTURE_MAX_ANISOTROPY_EXT,
            Math.min(o.anisotropy, r.getMaxAnisotropy()),
          ),
          (i.get(o).__currentAnisotropy = o.anisotropy));
      }
    }
    function q(e, n) {
      void 0 === e.__webglInit &&
        ((e.__webglInit = !0),
        n.addEventListener('dispose', U),
        (e.__webglTexture = t.createTexture()),
        v.memory.textures++);
    }
    function Q(e, i, r) {
      var o = t.TEXTURE_2D;
      i.isDataTexture2DArray && (o = t.TEXTURE_2D_ARRAY),
        i.isDataTexture3D && (o = t.TEXTURE_3D),
        q(e, i),
        n.activeTexture(t.TEXTURE0 + r),
        n.bindTexture(o, e.__webglTexture),
        t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, i.flipY),
        t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.premultiplyAlpha),
        t.pixelStorei(t.UNPACK_ALIGNMENT, i.unpackAlignment);
      var a =
          (function (t) {
            return (
              !S &&
              (t.wrapS !== s ||
                t.wrapT !== s ||
                (t.minFilter !== c && t.minFilter !== u))
            );
          })(i) && !1 === P(i.image),
        l = F(i.image, a, !1, D),
        h = P(l) || S,
        d = p.convert(i.format),
        g = p.convert(i.type),
        v = V(i.internalFormat, d, g);
      Y(o, i, h);
      var M,
        I = i.mipmaps;
      if (i.isDepthTexture)
        (v = t.DEPTH_COMPONENT),
          S
            ? (v =
                i.type === b
                  ? t.DEPTH_COMPONENT32F
                  : i.type === m
                  ? t.DEPTH_COMPONENT24
                  : i.type === y
                  ? t.DEPTH24_STENCIL8
                  : t.DEPTH_COMPONENT16)
            : i.type === b &&
              console.error(
                'WebGLRenderer: Floating point depth texture requires WebGL2.',
              ),
          i.format === w &&
            v === t.DEPTH_COMPONENT &&
            i.type !== f &&
            i.type !== m &&
            (console.warn(
              'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.',
            ),
            (i.type = f),
            (g = p.convert(i.type))),
          i.format === A &&
            v === t.DEPTH_COMPONENT &&
            ((v = t.DEPTH_STENCIL),
            i.type !== y &&
              (console.warn(
                'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.',
              ),
              (i.type = y),
              (g = p.convert(i.type)))),
          n.texImage2D(t.TEXTURE_2D, 0, v, l.width, l.height, 0, d, g, null);
      else if (i.isDataTexture)
        if (I.length > 0 && h) {
          for (var E = 0, C = I.length; E < C; E++)
            (M = I[E]),
              n.texImage2D(
                t.TEXTURE_2D,
                E,
                v,
                M.width,
                M.height,
                0,
                d,
                g,
                M.data,
              );
          (i.generateMipmaps = !1), (e.__maxMipLevel = I.length - 1);
        } else
          n.texImage2D(t.TEXTURE_2D, 0, v, l.width, l.height, 0, d, g, l.data),
            (e.__maxMipLevel = 0);
      else if (i.isCompressedTexture) {
        for (E = 0, C = I.length; E < C; E++)
          (M = I[E]),
            i.format !== x && i.format !== _
              ? null !== d
                ? n.compressedTexImage2D(
                    t.TEXTURE_2D,
                    E,
                    v,
                    M.width,
                    M.height,
                    0,
                    M.data,
                  )
                : console.warn(
                    'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()',
                  )
              : n.texImage2D(
                  t.TEXTURE_2D,
                  E,
                  v,
                  M.width,
                  M.height,
                  0,
                  d,
                  g,
                  M.data,
                );
        e.__maxMipLevel = I.length - 1;
      } else if (i.isDataTexture2DArray)
        n.texImage3D(
          t.TEXTURE_2D_ARRAY,
          0,
          v,
          l.width,
          l.height,
          l.depth,
          0,
          d,
          g,
          l.data,
        ),
          (e.__maxMipLevel = 0);
      else if (i.isDataTexture3D)
        n.texImage3D(
          t.TEXTURE_3D,
          0,
          v,
          l.width,
          l.height,
          l.depth,
          0,
          d,
          g,
          l.data,
        ),
          (e.__maxMipLevel = 0);
      else if (I.length > 0 && h) {
        for (E = 0, C = I.length; E < C; E++)
          (M = I[E]), n.texImage2D(t.TEXTURE_2D, E, v, d, g, M);
        (i.generateMipmaps = !1), (e.__maxMipLevel = I.length - 1);
      } else n.texImage2D(t.TEXTURE_2D, 0, v, d, g, l), (e.__maxMipLevel = 0);
      B(i, h) && O(o, i, l.width, l.height),
        (e.__version = i.version),
        i.onUpdate && i.onUpdate(i);
    }
    function J(e, r, o, s) {
      var a = p.convert(r.texture.format),
        c = p.convert(r.texture.type),
        l = V(r.texture.internalFormat, a, c);
      n.texImage2D(s, 0, l, r.width, r.height, 0, a, c, null),
        t.bindFramebuffer(t.FRAMEBUFFER, e),
        t.framebufferTexture2D(
          t.FRAMEBUFFER,
          o,
          s,
          i.get(r.texture).__webglTexture,
          0,
        ),
        t.bindFramebuffer(t.FRAMEBUFFER, null);
    }
    function $(e, n, i) {
      if (
        (t.bindRenderbuffer(t.RENDERBUFFER, e),
        n.depthBuffer && !n.stencilBuffer)
      ) {
        var r = t.DEPTH_COMPONENT16;
        if (i) {
          var o = n.depthTexture;
          o &&
            o.isDepthTexture &&
            (o.type === b
              ? (r = t.DEPTH_COMPONENT32F)
              : o.type === m && (r = t.DEPTH_COMPONENT24));
          var s = tt(n);
          t.renderbufferStorageMultisample(
            t.RENDERBUFFER,
            s,
            r,
            n.width,
            n.height,
          );
        } else t.renderbufferStorage(t.RENDERBUFFER, r, n.width, n.height);
        t.framebufferRenderbuffer(
          t.FRAMEBUFFER,
          t.DEPTH_ATTACHMENT,
          t.RENDERBUFFER,
          e,
        );
      } else if (n.depthBuffer && n.stencilBuffer) {
        if (i) {
          s = tt(n);
          t.renderbufferStorageMultisample(
            t.RENDERBUFFER,
            s,
            t.DEPTH24_STENCIL8,
            n.width,
            n.height,
          );
        } else
          t.renderbufferStorage(
            t.RENDERBUFFER,
            t.DEPTH_STENCIL,
            n.width,
            n.height,
          );
        t.framebufferRenderbuffer(
          t.FRAMEBUFFER,
          t.DEPTH_STENCIL_ATTACHMENT,
          t.RENDERBUFFER,
          e,
        );
      } else {
        var a = p.convert(n.texture.format),
          c = p.convert(n.texture.type);
        r = V(n.texture.internalFormat, a, c);
        if (i) {
          s = tt(n);
          t.renderbufferStorageMultisample(
            t.RENDERBUFFER,
            s,
            r,
            n.width,
            n.height,
          );
        } else t.renderbufferStorage(t.RENDERBUFFER, r, n.width, n.height);
      }
      t.bindRenderbuffer(t.RENDERBUFFER, null);
    }
    function K(e) {
      var n = i.get(e),
        r = !0 === e.isWebGLCubeRenderTarget;
      if (e.depthTexture) {
        if (r)
          throw new Error(
            'target.depthTexture not supported in Cube render targets',
          );
        !(function (e, n) {
          if (n && n.isWebGLCubeRenderTarget)
            throw new Error(
              'Depth Texture with cube render targets is not supported',
            );
          if (
            (t.bindFramebuffer(t.FRAMEBUFFER, e),
            !n.depthTexture || !n.depthTexture.isDepthTexture)
          )
            throw new Error(
              'renderTarget.depthTexture must be an instance of THREE.DepthTexture',
            );
          (i.get(n.depthTexture).__webglTexture &&
            n.depthTexture.image.width === n.width &&
            n.depthTexture.image.height === n.height) ||
            ((n.depthTexture.image.width = n.width),
            (n.depthTexture.image.height = n.height),
            (n.depthTexture.needsUpdate = !0)),
            j(n.depthTexture, 0);
          var r = i.get(n.depthTexture).__webglTexture;
          if (n.depthTexture.format === w)
            t.framebufferTexture2D(
              t.FRAMEBUFFER,
              t.DEPTH_ATTACHMENT,
              t.TEXTURE_2D,
              r,
              0,
            );
          else {
            if (n.depthTexture.format !== A)
              throw new Error('Unknown depthTexture format');
            t.framebufferTexture2D(
              t.FRAMEBUFFER,
              t.DEPTH_STENCIL_ATTACHMENT,
              t.TEXTURE_2D,
              r,
              0,
            );
          }
        })(n.__webglFramebuffer, e);
      } else if (r) {
        n.__webglDepthbuffer = [];
        for (var o = 0; o < 6; o++)
          t.bindFramebuffer(t.FRAMEBUFFER, n.__webglFramebuffer[o]),
            (n.__webglDepthbuffer[o] = t.createRenderbuffer()),
            $(n.__webglDepthbuffer[o], e, !1);
      } else
        t.bindFramebuffer(t.FRAMEBUFFER, n.__webglFramebuffer),
          (n.__webglDepthbuffer = t.createRenderbuffer()),
          $(n.__webglDepthbuffer, e, !1);
      t.bindFramebuffer(t.FRAMEBUFFER, null);
    }
    function tt(t) {
      return S && t.isWebGLMultisampleRenderTarget ? Math.min(C, t.samples) : 0;
    }
    var et = !1,
      nt = !1;
    (this.allocateTextureUnit = function () {
      var t = z;
      return (
        t >= I &&
          console.warn(
            'THREE.WebGLTextures: Trying to use ' +
              t +
              ' texture units while this GPU supports only ' +
              I,
          ),
        (z += 1),
        t
      );
    }),
      (this.resetTextureUnits = function () {
        z = 0;
      }),
      (this.setTexture2D = j),
      (this.setTexture2DArray = function (e, r) {
        var o = i.get(e);
        e.version > 0 && o.__version !== e.version
          ? Q(o, e, r)
          : (n.activeTexture(t.TEXTURE0 + r),
            n.bindTexture(t.TEXTURE_2D_ARRAY, o.__webglTexture));
      }),
      (this.setTexture3D = function (e, r) {
        var o = i.get(e);
        e.version > 0 && o.__version !== e.version
          ? Q(o, e, r)
          : (n.activeTexture(t.TEXTURE0 + r),
            n.bindTexture(t.TEXTURE_3D, o.__webglTexture));
      }),
      (this.setTextureCube = H),
      (this.setTextureCubeDynamic = W),
      (this.setupRenderTarget = function (e) {
        var r = i.get(e),
          o = i.get(e.texture);
        e.addEventListener('dispose', G),
          (o.__webglTexture = t.createTexture()),
          v.memory.textures++;
        var s = !0 === e.isWebGLCubeRenderTarget,
          a = !0 === e.isWebGLMultisampleRenderTarget,
          c = P(e) || S;
        if (
          (!S ||
            e.texture.format !== _ ||
            (e.texture.type !== b && e.texture.type !== g) ||
            ((e.texture.format = x),
            console.warn(
              'THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.',
            )),
          s)
        ) {
          r.__webglFramebuffer = [];
          for (var l = 0; l < 6; l++)
            r.__webglFramebuffer[l] = t.createFramebuffer();
        } else if (
          ((r.__webglFramebuffer = t.createFramebuffer()),
          e.setFrameBuffer(r.__webglFramebuffer),
          a)
        )
          if (S) {
            (r.__webglMultisampledFramebuffer = t.createFramebuffer()),
              e.setFrameBuffer(r.__webglMultisampledFramebuffer),
              (r.__webglColorRenderbuffer = t.createRenderbuffer()),
              t.bindRenderbuffer(t.RENDERBUFFER, r.__webglColorRenderbuffer);
            var h = p.convert(e.texture.format),
              u = p.convert(e.texture.type),
              d = V(e.texture.internalFormat, h, u),
              f = tt(e);
            t.renderbufferStorageMultisample(
              t.RENDERBUFFER,
              f,
              d,
              e.width,
              e.height,
            ),
              t.bindFramebuffer(
                t.FRAMEBUFFER,
                r.__webglMultisampledFramebuffer,
              ),
              t.framebufferRenderbuffer(
                t.FRAMEBUFFER,
                t.COLOR_ATTACHMENT0,
                t.RENDERBUFFER,
                r.__webglColorRenderbuffer,
              ),
              t.bindRenderbuffer(t.RENDERBUFFER, null),
              e.depthBuffer &&
                ((r.__webglDepthRenderbuffer = t.createRenderbuffer()),
                $(r.__webglDepthRenderbuffer, e, !0)),
              t.bindFramebuffer(t.FRAMEBUFFER, null);
          } else
            console.warn(
              'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.',
            );
        if (s) {
          n.bindTexture(t.TEXTURE_CUBE_MAP, o.__webglTexture),
            Y(t.TEXTURE_CUBE_MAP, e.texture, c);
          for (l = 0; l < 6; l++)
            J(
              r.__webglFramebuffer[l],
              e,
              t.COLOR_ATTACHMENT0,
              t.TEXTURE_CUBE_MAP_POSITIVE_X + l,
            );
          B(e.texture, c) &&
            O(t.TEXTURE_CUBE_MAP, e.texture, e.width, e.height),
            n.bindTexture(t.TEXTURE_CUBE_MAP, null);
        } else
          n.bindTexture(t.TEXTURE_2D, o.__webglTexture),
            Y(t.TEXTURE_2D, e.texture, c),
            J(r.__webglFramebuffer, e, t.COLOR_ATTACHMENT0, t.TEXTURE_2D),
            B(e.texture, c) && O(t.TEXTURE_2D, e.texture, e.width, e.height),
            n.bindTexture(t.TEXTURE_2D, null);
        e.depthBuffer && K(e);
      }),
      (this.updateRenderTargetMipmap = function (e) {
        var r = e.texture;
        if (B(r, P(e) || S)) {
          var o = e.isWebGLCubeRenderTarget ? t.TEXTURE_CUBE_MAP : t.TEXTURE_2D,
            s = i.get(r).__webglTexture;
          n.bindTexture(o, s),
            O(o, r, e.width, e.height),
            n.bindTexture(o, null);
        }
      }),
      (this.updateMultisampleRenderTarget = function (e) {
        if (e.isWebGLMultisampleRenderTarget)
          if (S) {
            var n = i.get(e);
            t.bindFramebuffer(
              t.READ_FRAMEBUFFER,
              n.__webglMultisampledFramebuffer,
            ),
              t.bindFramebuffer(t.DRAW_FRAMEBUFFER, n.__webglFramebuffer);
            var r = e.width,
              o = e.height,
              s = t.COLOR_BUFFER_BIT;
            e.depthBuffer && (s |= t.DEPTH_BUFFER_BIT),
              e.stencilBuffer && (s |= t.STENCIL_BUFFER_BIT),
              t.blitFramebuffer(0, 0, r, o, 0, 0, r, o, s, t.NEAREST),
              t.bindFramebuffer(
                t.FRAMEBUFFER,
                n.__webglMultisampledFramebuffer,
              );
          } else
            console.warn(
              'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.',
            );
      }),
      (this.safeSetTexture2D = function (t, e) {
        t &&
          t.isWebGLRenderTarget &&
          (!1 === et &&
            (console.warn(
              "THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead.",
            ),
            (et = !0)),
          (t = t.texture)),
          j(t, e);
      }),
      (this.safeSetTextureCube = function (t, e) {
        t &&
          t.isWebGLCubeRenderTarget &&
          (!1 === nt &&
            (console.warn(
              "THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead.",
            ),
            (nt = !0)),
          (t = t.texture)),
          (t && t.isCubeTexture) ||
          (Array.isArray(t.image) && 6 === t.image.length)
            ? H(t, e)
            : W(t, e);
      });
  }
  function Tr(t, e, n) {
    var i = n.isWebGL2;
    return {
      convert: function (n) {
        var r;
        if (n === p) return t.UNSIGNED_BYTE;
        if (1017 === n) return t.UNSIGNED_SHORT_4_4_4_4;
        if (1018 === n) return t.UNSIGNED_SHORT_5_5_5_1;
        if (1019 === n) return t.UNSIGNED_SHORT_5_6_5;
        if (1010 === n) return t.BYTE;
        if (1011 === n) return t.SHORT;
        if (n === f) return t.UNSIGNED_SHORT;
        if (1013 === n) return t.INT;
        if (n === m) return t.UNSIGNED_INT;
        if (n === b) return t.FLOAT;
        if (n === g)
          return i
            ? t.HALF_FLOAT
            : null !== (r = e.get('OES_texture_half_float'))
            ? r.HALF_FLOAT_OES
            : null;
        if (n === v) return t.ALPHA;
        if (n === _) return t.RGB;
        if (n === x) return t.RGBA;
        if (1024 === n) return t.LUMINANCE;
        if (1025 === n) return t.LUMINANCE_ALPHA;
        if (n === w) return t.DEPTH_COMPONENT;
        if (n === A) return t.DEPTH_STENCIL;
        if (1028 === n) return t.RED;
        if (1029 === n) return t.RED_INTEGER;
        if (1030 === n) return t.RG;
        if (1031 === n) return t.RG_INTEGER;
        if (1032 === n) return t.RGB_INTEGER;
        if (1033 === n) return t.RGBA_INTEGER;
        if (33776 === n || 33777 === n || 33778 === n || 33779 === n) {
          if (null === (r = e.get('WEBGL_compressed_texture_s3tc')))
            return null;
          if (33776 === n) return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
          if (33777 === n) return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
          if (33778 === n) return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
          if (33779 === n) return r.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        }
        if (35840 === n || 35841 === n || 35842 === n || 35843 === n) {
          if (null === (r = e.get('WEBGL_compressed_texture_pvrtc')))
            return null;
          if (35840 === n) return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
          if (35841 === n) return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
          if (35842 === n) return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
          if (35843 === n) return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
        }
        if (36196 === n)
          return null !== (r = e.get('WEBGL_compressed_texture_etc1'))
            ? r.COMPRESSED_RGB_ETC1_WEBGL
            : null;
        if (
          (37492 === n || 37496 === n) &&
          null !== (r = e.get('WEBGL_compressed_texture_etc'))
        ) {
          if (37492 === n) return r.COMPRESSED_RGB8_ETC2;
          if (37496 === n) return r.COMPRESSED_RGBA8_ETC2_EAC;
        }
        return 37808 === n ||
          37809 === n ||
          37810 === n ||
          37811 === n ||
          37812 === n ||
          37813 === n ||
          37814 === n ||
          37815 === n ||
          37816 === n ||
          37817 === n ||
          37818 === n ||
          37819 === n ||
          37820 === n ||
          37821 === n ||
          37840 === n ||
          37841 === n ||
          37842 === n ||
          37843 === n ||
          37844 === n ||
          37845 === n ||
          37846 === n ||
          37847 === n ||
          37848 === n ||
          37849 === n ||
          37850 === n ||
          37851 === n ||
          37852 === n ||
          37853 === n
          ? null !== (r = e.get('WEBGL_compressed_texture_astc'))
            ? n
            : null
          : 36492 === n
          ? null !== (r = e.get('EXT_texture_compression_bptc'))
            ? n
            : null
          : n === y
          ? i
            ? t.UNSIGNED_INT_24_8
            : null !== (r = e.get('WEBGL_depth_texture'))
            ? r.UNSIGNED_INT_24_8_WEBGL
            : null
          : void 0;
      },
    };
  }
  function Lr(t) {
    Mn.call(this), (this.cameras = t || []);
  }
  function Rr() {
    At.call(this), (this.type = 'Group');
  }
  function Fr(t, e) {
    var n = this,
      i = null,
      r = 1,
      o = null,
      s = 'local-floor',
      a = null,
      c = [],
      l = new Map(),
      h = new Mn();
    h.layers.enable(1), (h.viewport = new W());
    var u = new Mn();
    u.layers.enable(2), (u.viewport = new W());
    var d = new Lr([h, u]);
    d.layers.enable(1), d.layers.enable(2);
    var p = null,
      f = null;
    function m(t) {
      var e = l.get(t.inputSource);
      e &&
        (e.targetRay && e.targetRay.dispatchEvent({ type: t.type }),
        e.grip && e.grip.dispatchEvent({ type: t.type }));
    }
    function b() {
      l.forEach(function (t, e) {
        t.targetRay &&
          (t.targetRay.dispatchEvent({ type: 'disconnected', data: e }),
          (t.targetRay.visible = !1)),
          t.grip &&
            (t.grip.dispatchEvent({ type: 'disconnected', data: e }),
            (t.grip.visible = !1));
      }),
        l.clear(),
        t.setFramebuffer(null),
        t.setRenderTarget(t.getRenderTarget()),
        A.stop(),
        (n.isPresenting = !1),
        n.dispatchEvent({ type: 'sessionend' });
    }
    function g(t) {
      (o = t),
        A.setContext(i),
        A.start(),
        (n.isPresenting = !0),
        n.dispatchEvent({ type: 'sessionstart' });
    }
    function y(t) {
      for (var e = i.inputSources, n = 0; n < c.length; n++) l.set(e[n], c[n]);
      for (n = 0; n < t.removed.length; n++) {
        var r = t.removed[n];
        (o = l.get(r)) &&
          (o.targetRay &&
            o.targetRay.dispatchEvent({ type: 'disconnected', data: r }),
          o.grip && o.grip.dispatchEvent({ type: 'disconnected', data: r }),
          l.delete(r));
      }
      for (n = 0; n < t.added.length; n++) {
        var o;
        r = t.added[n];
        (o = l.get(r)) &&
          (o.targetRay &&
            o.targetRay.dispatchEvent({ type: 'connected', data: r }),
          o.grip && o.grip.dispatchEvent({ type: 'connected', data: r }));
      }
    }
    (this.enabled = !1),
      (this.isPresenting = !1),
      (this.getController = function (t) {
        var e = c[t];
        return (
          void 0 === e && ((e = {}), (c[t] = e)),
          void 0 === e.targetRay &&
            ((e.targetRay = new Rr()),
            (e.targetRay.matrixAutoUpdate = !1),
            (e.targetRay.visible = !1)),
          e.targetRay
        );
      }),
      (this.getControllerGrip = function (t) {
        var e = c[t];
        return (
          void 0 === e && ((e = {}), (c[t] = e)),
          void 0 === e.grip &&
            ((e.grip = new Rr()),
            (e.grip.matrixAutoUpdate = !1),
            (e.grip.visible = !1)),
          e.grip
        );
      }),
      (this.setFramebufferScaleFactor = function (t) {
        (r = t),
          1 == n.isPresenting &&
            console.warn(
              'WebXRManager: Cannot change framebuffer scale while presenting VR content',
            );
      }),
      (this.setReferenceSpaceType = function (t) {
        s = t;
      }),
      (this.getReferenceSpace = function () {
        return o;
      }),
      (this.getSession = function () {
        return i;
      }),
      (this.setSession = function (t) {
        if (null !== (i = t)) {
          i.addEventListener('select', m),
            i.addEventListener('selectstart', m),
            i.addEventListener('selectend', m),
            i.addEventListener('squeeze', m),
            i.addEventListener('squeezestart', m),
            i.addEventListener('squeezeend', m),
            i.addEventListener('end', b);
          var n = e.getContextAttributes(),
            o = {
              antialias: n.antialias,
              alpha: n.alpha,
              depth: n.depth,
              stencil: n.stencil,
              framebufferScaleFactor: r,
            },
            a = new XRWebGLLayer(i, e, o);
          i.updateRenderState({ baseLayer: a }),
            i.requestReferenceSpace(s).then(g),
            i.addEventListener('inputsourceschange', y);
        }
      });
    var v = new J(),
      _ = new J();
    function x(t, e) {
      null === e
        ? t.matrixWorld.copy(t.matrix)
        : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix),
        t.matrixWorldInverse.getInverse(t.matrixWorld);
    }
    this.getCamera = function (t) {
      (d.near = u.near = h.near = t.near),
        (d.far = u.far = h.far = t.far),
        (p === d.near && f === d.far) ||
          (i.updateRenderState({ depthNear: d.near, depthFar: d.far }),
          (p = d.near),
          (f = d.far));
      var e = t.parent,
        n = d.cameras;
      x(d, e);
      for (var r = 0; r < n.length; r++) x(n[r], e);
      t.matrixWorld.copy(d.matrixWorld);
      for (var o = t.children, s = ((r = 0), o.length); r < s; r++)
        o[r].updateMatrixWorld(!0);
      return (
        (function (t, e, n) {
          v.setFromMatrixPosition(e.matrixWorld),
            _.setFromMatrixPosition(n.matrixWorld);
          var i = v.distanceTo(_),
            r = e.projectionMatrix.elements,
            o = n.projectionMatrix.elements,
            s = r[14] / (r[10] - 1),
            a = r[14] / (r[10] + 1),
            c = (r[9] + 1) / r[5],
            l = (r[9] - 1) / r[5],
            h = (r[8] - 1) / r[0],
            u = (o[8] + 1) / o[0],
            d = s * h,
            p = s * u,
            f = i / (-h + u),
            m = f * -h;
          e.matrixWorld.decompose(t.position, t.quaternion, t.scale),
            t.translateX(m),
            t.translateZ(f),
            t.matrixWorld.compose(t.position, t.quaternion, t.scale),
            t.matrixWorldInverse.getInverse(t.matrixWorld);
          var b = s + f,
            g = a + f,
            y = d - m,
            x = p + (i - m),
            w = ((c * a) / g) * b,
            A = ((l * a) / g) * b;
          t.projectionMatrix.makePerspective(y, x, w, A, b, g);
        })(d, h, u),
        d
      );
    };
    var w = null;
    var A = new Fn();
    A.setAnimationLoop(function (e, n) {
      if (null !== (a = n.getViewerPose(o))) {
        var r = a.views,
          s = i.renderState.baseLayer;
        t.setFramebuffer(s.framebuffer);
        for (var l = 0; l < r.length; l++) {
          var h = r[l],
            u = s.getViewport(h),
            p = d.cameras[l];
          p.matrix.fromArray(h.transform.matrix),
            p.projectionMatrix.fromArray(h.projectionMatrix),
            p.viewport.set(u.x, u.y, u.width, u.height),
            0 === l && d.matrix.copy(p.matrix);
        }
      }
      var f = i.inputSources;
      for (l = 0; l < c.length; l++) {
        var m = c[l],
          b = f[l],
          g = null,
          y = null;
        b &&
          (m.targetRay &&
            null !== (g = n.getPose(b.targetRaySpace, o)) &&
            (m.targetRay.matrix.fromArray(g.transform.matrix),
            m.targetRay.matrix.decompose(
              m.targetRay.position,
              m.targetRay.rotation,
              m.targetRay.scale,
            )),
          m.grip &&
            b.gripSpace &&
            null !== (y = n.getPose(b.gripSpace, o)) &&
            (m.grip.matrix.fromArray(y.transform.matrix),
            m.grip.matrix.decompose(
              m.grip.position,
              m.grip.rotation,
              m.grip.scale,
            ))),
          m.targetRay && (m.targetRay.visible = null !== g),
          m.grip && (m.grip.visible = null !== y);
      }
      w && w(e, n);
    }),
      (this.setAnimationLoop = function (t) {
        w = t;
      }),
      (this.dispose = function () {});
  }
  function Pr(t) {
    var e =
      void 0 !== (t = t || {}).canvas
        ? t.canvas
        : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
    this.domElement = e;
    var n = {
        alpha: void 0 !== t.alpha && t.alpha,
        depth: void 0 === t.depth || t.depth,
        stencil: void 0 === t.stencil || t.stencil,
        antialias: void 0 !== t.antialias && t.antialias,
        premultipliedAlpha:
          void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
        preserveDrawingBuffer:
          void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
        powerPreference:
          void 0 !== t.powerPreference ? t.powerPreference : 'default',
        failIfMajorPerformanceCaveat:
          void 0 !== t.failIfMajorPerformanceCaveat &&
          t.failIfMajorPerformanceCaveat,
        xrCompatible: !0,
      },
      i = null;
    (this.debug = { checkShaderErrors: !0 }),
      (this.autoClear = !0),
      (this.autoClearColor = !0),
      (this.autoClearDepth = !0),
      (this.autoClearStencil = !0),
      (this.sortObjects = !0),
      (this.clippingPlanes = []),
      (this.localClippingEnabled = !1),
      (this.gammaFactor = 2),
      (this.outputEncoding = T),
      (this.physicallyCorrectLights = !1),
      (this.toneMapping = 1),
      (this.toneMappingExposure = 1),
      (this.toneMappingWhitePoint = 1),
      (this.maxMorphTargets = 8),
      (this.maxMorphNormals = 4),
      (this.frameTimeLimit = 1 / 0);
    var r,
      o,
      s,
      a,
      c,
      l,
      h,
      u,
      d,
      f,
      m,
      y,
      v,
      _,
      w,
      A,
      M,
      S,
      I = this,
      E = !1,
      D = null,
      C = 0,
      L = 0,
      R = null,
      F = null,
      P = -1,
      B = { geometry: null, program: null, wireframe: !1 },
      O = null,
      V = null,
      N = new W(),
      G = new W(),
      z = null,
      j = e.width,
      H = e.height,
      X = 1,
      Z = null,
      Y = null,
      q = new W(0, 0, j, H),
      Q = new W(0, 0, j, H),
      $ = !1,
      K = new Ln(),
      tt = new zn(),
      et = !1,
      nt = !1,
      it = new ot(),
      rt = new J();
    function st() {
      return null === R ? X : 1;
    }
    try {
      if (
        (e.addEventListener('webglcontextlost', ht, !1),
        e.addEventListener('webglcontextrestored', ut, !1),
        null ===
          (r =
            e.getContext('webgl2', n) ||
            e.getContext('webgl', n) ||
            e.getContext('experimental-webgl', n)))
      )
        throw null !== e.getContext('webgl')
          ? new Error(
              'Error creating WebGL context with your selected attributes.',
            )
          : new Error('Error creating WebGL context.');
      void 0 === r.getShaderPrecisionFormat &&
        (r.getShaderPrecisionFormat = function () {
          return { rangeMin: 1, rangeMax: 1, precision: 1 };
        });
    } catch (t) {
      throw (console.error('THREE.WebGLRenderer: ' + t.message), t);
    }
    function at() {
      (o = new jn(r)),
        !1 === (s = new Gn(r, o, t)).isWebGL2 &&
          (o.get('WEBGL_depth_texture'),
          o.get('OES_texture_float'),
          o.get('OES_texture_half_float'),
          o.get('OES_texture_half_float_linear'),
          o.get('OES_standard_derivatives'),
          o.get('OES_element_index_uint'),
          o.get('ANGLE_instanced_arrays')),
        o.get('OES_texture_float_linear'),
        (S = new Tr(r, o, s)),
        (a = new Dr(r, o, s)).scissor(G.copy(Q).multiplyScalar(X).floor()),
        a.viewport(N.copy(q).multiplyScalar(X).floor()),
        (c = new Xn(r)),
        (l = new fr()),
        (h = new Cr(r, o, a, l, s, S, c)),
        (u = new Pn(r, s)),
        (d = new Hn(r, u, c)),
        (f = new qn(r, d, u, c)),
        (w = new Yn(r)),
        (m = new pr(I, o, s)),
        (y = new yr()),
        (v = new Mr()),
        (_ = new kn(I, a, f, n.premultipliedAlpha)),
        (A = new Un(r, o, c, s)),
        (M = new Wn(r, o, c, s)),
        (c.programs = m.programs),
        (I.capabilities = s),
        (I.extensions = o),
        (I.properties = l),
        (I.renderLists = y),
        (I.state = a),
        (I.info = c);
    }
    at();
    var ct = new Fr(I, r);
    this.xr = ct;
    var lt = new Er(I, f, s.maxTextureSize);
    function ht(t) {
      t.preventDefault(),
        console.log('THREE.WebGLRenderer: Context Lost.'),
        (E = !0);
    }
    function ut() {
      console.log('THREE.WebGLRenderer: Context Restored.'), (E = !1), at();
    }
    function dt(t) {
      var e = t.target;
      e.removeEventListener('dispose', dt),
        (function (t) {
          pt(t), l.remove(t);
        })(e);
    }
    function pt(t) {
      var e = l.get(t).program;
      (t.program = void 0), void 0 !== e && m.releaseProgram(e);
    }
    (this.shadowMap = lt),
      (this.getContext = function () {
        return r;
      }),
      (this.getContextAttributes = function () {
        return r.getContextAttributes();
      }),
      (this.forceContextLoss = function () {
        var t = o.get('WEBGL_lose_context');
        t && t.loseContext();
      }),
      (this.forceContextRestore = function () {
        var t = o.get('WEBGL_lose_context');
        t && t.restoreContext();
      }),
      (this.getPixelRatio = function () {
        return X;
      }),
      (this.setPixelRatio = function (t) {
        void 0 !== t && ((X = t), this.setSize(j, H, !1));
      }),
      (this.getSize = function (t) {
        return (
          void 0 === t &&
            (console.warn(
              'WebGLRenderer: .getsize() now requires a Vector2 as an argument',
            ),
            (t = new U())),
          t.set(j, H)
        );
      }),
      (this.setSize = function (t, n, i) {
        ct.isPresenting
          ? console.warn(
              "THREE.WebGLRenderer: Can't change size while VR device is presenting.",
            )
          : ((j = t),
            (H = n),
            (e.width = Math.floor(t * X)),
            (e.height = Math.floor(n * X)),
            !1 !== i &&
              ((e.style.width = t + 'px'), (e.style.height = n + 'px')),
            this.setViewport(0, 0, t, n),
            this.setScissor(0, 0, t, n));
      }),
      (this.getDrawingBufferSize = function (t) {
        return (
          void 0 === t &&
            (console.warn(
              'WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument',
            ),
            (t = new U())),
          t.set(j * X, H * X).floor()
        );
      }),
      (this.setDrawingBufferSize = function (t, n, i) {
        (j = t),
          (H = n),
          (X = i),
          (e.width = Math.floor(t * i)),
          (e.height = Math.floor(n * i)),
          this.setViewport(0, 0, t, n);
      }),
      (this.getCurrentViewport = function (t) {
        return (
          void 0 === t &&
            (console.warn(
              'WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument',
            ),
            (t = new W())),
          t.copy(N)
        );
      }),
      (this.getViewport = function (t) {
        return t.copy(q);
      }),
      (this.setViewport = function (t, e, n, i) {
        t.isVector4 ? q.set(t.x, t.y, t.z, t.w) : q.set(t, e, n, i),
          a.viewport(N.copy(q).multiplyScalar(X).floor());
      }),
      (this.getScissor = function (t) {
        return t.copy(Q);
      }),
      (this.setScissor = function (t, e, n, i) {
        t.isVector4 ? Q.set(t.x, t.y, t.z, t.w) : Q.set(t, e, n, i),
          a.scissor(G.copy(Q).multiplyScalar(X).floor());
      }),
      (this.getScissorTest = function () {
        return $;
      }),
      (this.setScissorTest = function (t) {
        a.setScissorTest(($ = t));
      }),
      (this.setOpaqueSort = function (t) {
        Z = t;
      }),
      (this.setTransparentSort = function (t) {
        Y = t;
      }),
      (this.getClearColor = function () {
        return _.getClearColor();
      }),
      (this.setClearColor = function () {
        _.setClearColor.apply(_, arguments);
      }),
      (this.getClearAlpha = function () {
        return _.getClearAlpha();
      }),
      (this.setClearAlpha = function () {
        _.setClearAlpha.apply(_, arguments);
      }),
      (this.clear = function (t, e, n) {
        var i = 0;
        (void 0 === t || t) && (i |= r.COLOR_BUFFER_BIT),
          (void 0 === e || e) && (i |= r.DEPTH_BUFFER_BIT),
          (void 0 === n || n) && (i |= r.STENCIL_BUFFER_BIT),
          0 != i && r.clear(i);
      }),
      (this.clearColor = function () {
        this.clear(!0, !1, !1);
      }),
      (this.clearDepth = function () {
        this.clear(!1, !0, !1);
      }),
      (this.clearStencil = function () {
        this.clear(!1, !1, !0);
      }),
      (this.dispose = function () {
        e.removeEventListener('webglcontextlost', ht, !1),
          e.removeEventListener('webglcontextrestored', ut, !1),
          y.dispose(),
          v.dispose(),
          l.dispose(),
          f.dispose(),
          ct.dispose(),
          bt.stop(),
          this.forceContextLoss();
      }),
      (this.setFrameTimeLimit = function (t) {
        this.frameTimeLimit = void 0 === t ? 1 / 0 : t;
      }),
      (this.renderBufferImmediate = function (t, e) {
        a.initAttributes();
        var n = l.get(t);
        t.hasPositions && !n.position && (n.position = r.createBuffer()),
          t.hasNormals && !n.normal && (n.normal = r.createBuffer()),
          t.hasUvs && !n.uv && (n.uv = r.createBuffer()),
          t.hasColors && !n.color && (n.color = r.createBuffer());
        var i = e.getAttributes();
        t.hasPositions &&
          (r.bindBuffer(r.ARRAY_BUFFER, n.position),
          r.bufferData(r.ARRAY_BUFFER, t.positionArray, r.DYNAMIC_DRAW),
          a.enableAttribute(i.position),
          r.vertexAttribPointer(i.position, 3, r.FLOAT, !1, 0, 0)),
          t.hasNormals &&
            (r.bindBuffer(r.ARRAY_BUFFER, n.normal),
            r.bufferData(r.ARRAY_BUFFER, t.normalArray, r.DYNAMIC_DRAW),
            a.enableAttribute(i.normal),
            r.vertexAttribPointer(i.normal, 3, r.FLOAT, !1, 0, 0)),
          t.hasUvs &&
            (r.bindBuffer(r.ARRAY_BUFFER, n.uv),
            r.bufferData(r.ARRAY_BUFFER, t.uvArray, r.DYNAMIC_DRAW),
            a.enableAttribute(i.uv),
            r.vertexAttribPointer(i.uv, 2, r.FLOAT, !1, 0, 0)),
          t.hasColors &&
            (r.bindBuffer(r.ARRAY_BUFFER, n.color),
            r.bufferData(r.ARRAY_BUFFER, t.colorArray, r.DYNAMIC_DRAW),
            a.enableAttribute(i.color),
            r.vertexAttribPointer(i.color, 3, r.FLOAT, !1, 0, 0)),
          a.disableUnusedAttributes(),
          r.drawArrays(r.TRIANGLES, 0, t.count),
          (t.count = 0);
      });
    var ft = new Mt();
    (this.renderBufferDirect = function (t, e, n, i, c, l) {
      null === e && (e = ft);
      var h = c.isMesh && c.matrixWorld.determinant() < 0,
        p = xt(t, e, i, c);
      if ((a.setMaterial(i, h), c.isPMRenderObject)) c.draw(r, M, i, a, p);
      else {
        var f = !1;
        (B.geometry === n.id &&
          B.program === p.id &&
          B.wireframe === (!0 === i.wireframe)) ||
          ((B.geometry = n.id),
          (B.program = p.id),
          (B.wireframe = !0 === i.wireframe),
          (f = !0)),
          (i.morphTargets || i.morphNormals) &&
            (w.update(c, n, i, p), (f = !0));
        var m = n.index,
          b = n.attributes.position;
        if (null === m) {
          if (void 0 === b || 0 === b.count) return;
        } else if (0 === m.count) return;
        var g,
          y = 1;
        !0 === i.wireframe && ((m = d.getWireframeAttribute(n)), (y = 2));
        var v = A;
        null !== m && ((g = u.get(m)), (v = M).setIndex(g)),
          f &&
            (!(function (t, e, n, i) {
              if (
                !1 === s.isWebGL2 &&
                (t.isInstancedMesh || e.isInstancedBufferGeometry) &&
                null === o.get('ANGLE_instanced_arrays')
              )
                return;
              a.initAttributes();
              var c = e.attributes,
                l = i.getAttributes(),
                h = n.defaultAttributeValues;
              for (var d in l) {
                var p = l[d];
                if (p >= 0) {
                  var f = c[d];
                  if (void 0 !== f) {
                    var m = f.normalized,
                      b = f.itemSize;
                    if (void 0 === (A = u.get(f))) continue;
                    var g = A.buffer,
                      y = A.type,
                      v = A.bytesPerElement;
                    if (f.isInterleavedBufferAttribute) {
                      var _ = f.data,
                        x = _.stride,
                        w = f.offset;
                      _ && _.isInstancedInterleavedBuffer
                        ? (a.enableAttributeAndDivisor(p, _.meshPerAttribute),
                          void 0 === e.maxInstancedCount &&
                            (e.maxInstancedCount =
                              _.meshPerAttribute * _.count))
                        : a.enableAttribute(p),
                        r.bindBuffer(r.ARRAY_BUFFER, g),
                        r.vertexAttribPointer(p, b, y, m, x * v, w * v);
                    } else
                      f.isInstancedBufferAttribute
                        ? (a.enableAttributeAndDivisor(p, f.meshPerAttribute),
                          void 0 === e.maxInstancedCount &&
                            (e.maxInstancedCount =
                              f.meshPerAttribute * f.count))
                        : a.enableAttribute(p),
                        r.bindBuffer(r.ARRAY_BUFFER, g),
                        r.vertexAttribPointer(p, b, y, m, 0, 0);
                  } else if ('instanceMatrix' === d) {
                    var A;
                    if (void 0 === (A = u.get(t.instanceMatrix))) continue;
                    (g = A.buffer), (y = A.type);
                    a.enableAttributeAndDivisor(p + 0, 1),
                      a.enableAttributeAndDivisor(p + 1, 1),
                      a.enableAttributeAndDivisor(p + 2, 1),
                      a.enableAttributeAndDivisor(p + 3, 1),
                      r.bindBuffer(r.ARRAY_BUFFER, g),
                      r.vertexAttribPointer(p + 0, 4, y, !1, 64, 0),
                      r.vertexAttribPointer(p + 1, 4, y, !1, 64, 16),
                      r.vertexAttribPointer(p + 2, 4, y, !1, 64, 32),
                      r.vertexAttribPointer(p + 3, 4, y, !1, 64, 48);
                  } else if (void 0 !== h) {
                    var M = h[d];
                    if (void 0 !== M)
                      switch (M.length) {
                        case 2:
                          r.vertexAttrib2fv(p, M);
                          break;
                        case 3:
                          r.vertexAttrib3fv(p, M);
                          break;
                        case 4:
                          r.vertexAttrib4fv(p, M);
                          break;
                        default:
                          r.vertexAttrib1fv(p, M);
                      }
                  }
                }
              }
              a.disableUnusedAttributes();
            })(c, n, i, p),
            null !== m && r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, g.buffer));
        var _ = null !== m ? m.count : b.count,
          x = n.drawRange.start * y,
          S = n.drawRange.count * y,
          I = null !== l ? l.start * y : 0,
          E = null !== l ? l.count * y : 1 / 0,
          D = Math.max(x, I),
          C = Math.min(_, x + S, I + E) - 1,
          T = Math.max(0, C - D + 1);
        if (0 === T) return;
        if (c.isMesh)
          !0 === i.wireframe
            ? (a.setLineWidth(i.wireframeLinewidth * st()), v.setMode(r.LINES))
            : v.setMode(r.TRIANGLES);
        else if (c.isLine) {
          var L = i.linewidth;
          void 0 === L && (L = 1),
            a.setLineWidth(L * st()),
            c.isLineSegments
              ? v.setMode(r.LINES)
              : c.isLineLoop
              ? v.setMode(r.LINE_LOOP)
              : v.setMode(r.LINE_STRIP);
        } else
          c.isPoints
            ? v.setMode(r.POINTS)
            : c.isSprite && v.setMode(r.TRIANGLES);
        c.isInstancedMesh
          ? v.renderInstances(n, D, T, c.count)
          : n.isInstancedBufferGeometry
          ? v.renderInstances(n, D, T, n.maxInstancedCount)
          : v.render(D, T);
      }
    }),
      (this.compile = function (t, e) {
        (i = v.get(t, e)).init(),
          t.traverse(function (t) {
            t.isLight && (i.pushLight(t), t.castShadow && i.pushShadow(t));
          }),
          i.setupLights(e);
        var n = {};
        t.traverse(function (e) {
          if (e.material)
            if (Array.isArray(e.material))
              for (var i = 0; i < e.material.length; i++)
                e.material[i].uuid in n == !1 &&
                  (_t(e.material[i], t, e), (n[e.material[i].uuid] = !0));
            else
              e.material.uuid in n == !1 &&
                (_t(e.material, t, e), (n[e.material.uuid] = !0));
        });
      });
    var mt = null;
    var bt = new Fn();
    function gt(t, e, n, i, o, s) {
      if (!1 !== t.visible) {
        if (t.layers.test(e.layers))
          if (t.isGroup) n = t.renderOrder;
          else if (t.isLOD) !0 === t.autoUpdate && t.update(e);
          else if (t.isLight) s.pushLight(t), t.castShadow && s.pushShadow(t);
          else if (t.isSprite) {
            if (!t.frustumCulled || K.intersectsSprite(t)) {
              i && rt.setFromMatrixPosition(t.matrixWorld).applyMatrix4(it);
              var a = f.update(t);
              (l = t.material).visible && o.push(t, a, l, n, rt.z, null);
            }
          } else if (t.isImmediateRenderObject)
            i && rt.setFromMatrixPosition(t.matrixWorld).applyMatrix4(it),
              o.push(t, null, t.material, n, rt.z, null);
          else if (t.isMesh || t.isLine || t.isPoints) {
            if (
              (t.isSkinnedMesh &&
                t.skeleton.frame !== c.render.frame &&
                (t.skeleton.update(), (t.skeleton.frame = c.render.frame)),
              !t.frustumCulled || K.intersectsObject(t))
            ) {
              i && rt.setFromMatrixPosition(t.matrixWorld).applyMatrix4(it);
              a = f.update(t);
              var l = t.material;
              if (Array.isArray(l))
                for (var h = a.groups, u = 0, d = h.length; u < d; u++) {
                  var p = h[u],
                    m = l[p.materialIndex];
                  m && m.visible && o.push(t, a, m, n, rt.z, p);
                }
              else l.visible && o.push(t, a, l, n, rt.z, null);
            }
          } else if (t.isPMRenderObject) {
            (l = t.material) &&
              l.visible &&
              (t.update(r),
              t.validDraw && o.push(t, t.renderBuffer, l, n, rt.z, null));
          }
        var b = t.children;
        for (u = 0, d = b.length; u < d; u++) gt(b[u], e, n, i, o, s);
      }
    }
    function yt(t, e, n, i) {
      for (var r = 0, o = t.length; r < o; r++)
        I.drawRenderListItem(t[r], e, n, i);
    }
    function vt(t, e, n, r, o, s) {
      if (
        (t.onBeforeRender(I, e, n, r, o, s),
        (i = v.get(e, V || n)),
        t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld),
        t.normalMatrix.getNormalMatrix(t.modelViewMatrix),
        t.isImmediateRenderObject)
      ) {
        var c = xt(n, e, o, t);
        a.setMaterial(o),
          (B.geometry = null),
          (B.program = null),
          (B.wireframe = !1),
          (function (t, e) {
            t.render(function (t) {
              I.renderBufferImmediate(t, e);
            });
          })(t, c);
      } else I.renderBufferDirect(n, e, r, o, t, s);
      t.onAfterRender(I, e, n, r, o, s), (i = v.get(e, V || n));
    }
    function _t(t, e, n) {
      var r = l.get(t),
        o = i.state.lights,
        s = i.state.shadowsArray,
        a = o.state.version,
        c = m.getParameters(
          t,
          o.state,
          s,
          e,
          tt.numPlanes,
          tt.numIntersection,
          n,
        ),
        h = m.getProgramCacheKey(c),
        u = r.program,
        d = !0;
      if (void 0 === u) t.addEventListener('dispose', dt);
      else if (u.cacheKey !== h) pt(t);
      else if (r.lightsStateVersion !== a) (r.lightsStateVersion = a), (d = !1);
      else {
        if (void 0 !== c.shaderID) return;
        d = !1;
      }
      d &&
        ((u = m.acquireProgram(c, h)),
        (r.program = u),
        (r.uniforms = c.uniforms),
        (r.environment = t.isMeshStandardMaterial ? e.environment : null),
        (r.outputEncoding = I.outputEncoding),
        (t.program = u));
      var p = u.getAttributes();
      if (t.morphTargets) {
        t.numSupportedMorphTargets = 0;
        for (var f = 0; f < I.maxMorphTargets; f++)
          p['morphTarget' + f] >= 0 && t.numSupportedMorphTargets++;
      }
      if (t.morphNormals) {
        t.numSupportedMorphNormals = 0;
        for (f = 0; f < I.maxMorphNormals; f++)
          p['morphNormal' + f] >= 0 && t.numSupportedMorphNormals++;
      }
      var b = r.uniforms;
      ((t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping) ||
        ((r.numClippingPlanes = tt.numPlanes),
        (r.numIntersection = tt.numIntersection),
        (b.clippingPlanes = tt.uniform)),
        (r.fog = e.fog),
        (r.needsLights = (function (t) {
          return (
            t.isMeshLambertMaterial ||
            t.isMeshToonMaterial ||
            t.isMeshPhongMaterial ||
            t.isMeshStandardMaterial ||
            t.isShadowMaterial ||
            t.isCenterLineCylinderMaterial ||
            (t.isShaderMaterial && !0 === t.lights)
          );
        })(t)),
        (r.lightsStateVersion = a),
        r.needsLights &&
          ((b.ambientLightColor.value = o.state.ambient),
          (b.lightProbe.value = o.state.probe),
          (b.directionalLights.value = o.state.directional),
          (b.directionalLightShadows.value = o.state.directionalShadow),
          (b.spotLights.value = o.state.spot),
          (b.spotLightShadows.value = o.state.spotShadow),
          (b.rectAreaLights.value = o.state.rectArea),
          (b.pointLights.value = o.state.point),
          (b.pointLightShadows.value = o.state.pointShadow),
          (b.hemisphereLights.value = o.state.hemi),
          (b.directionalShadowMap.value = o.state.directionalShadowMap),
          (b.directionalShadowMatrix.value = o.state.directionalShadowMatrix),
          (b.spotShadowMap.value = o.state.spotShadowMap),
          (b.spotShadowMatrix.value = o.state.spotShadowMatrix),
          (b.pointShadowMap.value = o.state.pointShadowMap),
          (b.pointShadowMatrix.value = o.state.pointShadowMatrix));
      var g = r.program.getUniforms(),
        y = Zi.seqWithValue(g.seq, b);
      r.uniformsList = y;
    }
    function xt(t, e, n, o) {
      h.resetTextureUnits();
      var c = e.fog,
        u = n.isMeshStandardMaterial ? e.environment : null,
        d = l.get(n),
        p = i.state.lights;
      if (et && (nt || t !== O)) {
        var f = t === O && n.id === P;
        tt.setState(
          n.clippingPlanes,
          n.clipIntersection,
          n.clipShadows,
          t,
          d,
          f,
        );
      }
      n.version === d.__version
        ? void 0 === d.program ||
          (n.fog && d.fog !== c) ||
          d.environment !== u ||
          (d.needsLights && d.lightsStateVersion !== p.state.version)
          ? _t(n, e, o)
          : void 0 === d.numClippingPlanes ||
            (d.numClippingPlanes === tt.numPlanes &&
              d.numIntersection === tt.numIntersection)
          ? d.outputEncoding !== I.outputEncoding && _t(n, e, o)
          : _t(n, e, o)
        : (_t(n, e, o), (d.__version = n.version));
      var m,
        g,
        y = !1,
        v = !1,
        _ = !1,
        w = d.program,
        A = w.getUniforms(),
        M = d.uniforms;
      if (
        (a.useProgram(w.program) && ((y = !0), (v = !0), (_ = !0)),
        n.id !== P && ((P = n.id), (v = !0)),
        y || O !== t)
      ) {
        if (
          (A.setValue(r, 'projectionMatrix', t.projectionMatrix),
          s.logarithmicDepthBuffer &&
            A.setValue(
              r,
              'logDepthBufFC',
              2 / (Math.log(t.far + 1) / Math.LN2),
            ),
          O !== t && ((O = t), (v = !0), (_ = !0)),
          n.isShaderMaterial ||
            n.isMeshPhongMaterial ||
            n.isMeshToonMaterial ||
            n.isMeshStandardMaterial ||
            n.envMap)
        ) {
          var S = A.map.cameraPosition;
          void 0 !== S &&
            S.setValue(r, rt.setFromMatrixPosition(t.matrixWorld));
        }
        (n.isMeshPhongMaterial ||
          n.isMeshToonMaterial ||
          n.isMeshLambertMaterial ||
          n.isMeshBasicMaterial ||
          n.isMeshStandardMaterial ||
          n.isShaderMaterial) &&
          A.setValue(r, 'isOrthographic', !0 === t.isOrthographicCamera),
          (n.isMeshPhongMaterial ||
            n.isMeshToonMaterial ||
            n.isMeshLambertMaterial ||
            n.isMeshBasicMaterial ||
            n.isMeshStandardMaterial ||
            n.isShaderMaterial ||
            n.isLineBasicMaterial ||
            n.skinning) &&
            A.setValue(r, 'viewMatrix', t.matrixWorldInverse);
      }
      if (n.skinning) {
        A.setOptional(r, o, 'bindMatrix'),
          A.setOptional(r, o, 'bindMatrixInverse');
        var E = o.skeleton;
        if (E) {
          var D = E.bones;
          if (s.floatVertexTextures) {
            if (void 0 === E.boneTexture) {
              var C = Math.sqrt(4 * D.length);
              (C = k.ceilPowerOfTwo(C)), (C = Math.max(C, 4));
              var T = new Float32Array(C * C * 4);
              T.set(E.boneMatrices);
              var L = new Dn(T, C, C, x, b);
              (E.boneMatrices = T),
                (E.boneTexture = L),
                (E.boneTextureSize = C);
            }
            A.setValue(r, 'boneTexture', E.boneTexture, h),
              A.setValue(r, 'boneTextureSize', E.boneTextureSize);
          } else A.setOptional(r, E, 'boneMatrices');
        }
      }
      return (
        (v || d.receiveShadow !== o.receiveShadow) &&
          ((d.receiveShadow = o.receiveShadow),
          A.setValue(r, 'receiveShadow', o.receiveShadow)),
        v &&
          (A.setValue(r, 'toneMappingExposure', I.toneMappingExposure),
          A.setValue(r, 'toneMappingWhitePoint', I.toneMappingWhitePoint),
          d.needsLights &&
            ((g = _),
            ((m = M).ambientLightColor.needsUpdate = g),
            (m.lightProbe.needsUpdate = g),
            (m.directionalLights.needsUpdate = g),
            (m.directionalLightShadows.needsUpdate = g),
            (m.pointLights.needsUpdate = g),
            (m.pointLightShadows.needsUpdate = g),
            (m.spotLights.needsUpdate = g),
            (m.spotLightShadows.needsUpdate = g),
            (m.rectAreaLights.needsUpdate = g),
            (m.hemisphereLights.needsUpdate = g)),
          c &&
            n.fog &&
            (function (t, e) {
              t.fogColor.value.copy(e.color),
                e.isFog
                  ? ((t.fogNear.value = e.near), (t.fogFar.value = e.far))
                  : e.isFogExp2 && (t.fogDensity.value = e.density);
            })(M, c),
          n.isMeshBasicMaterial
            ? wt(M, n)
            : n.isMeshLambertMaterial
            ? (wt(M, n),
              (function (t, e) {
                e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
              })(M, n))
            : n.isMeshToonMaterial
            ? (wt(M, n),
              (function (t, e) {
                t.specular.value.copy(e.specular),
                  (t.shininess.value = Math.max(e.shininess, 1e-4)),
                  e.gradientMap && (t.gradientMap.value = e.gradientMap);
                e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
                e.bumpMap &&
                  ((t.bumpMap.value = e.bumpMap),
                  (t.bumpScale.value = e.bumpScale),
                  1 === e.side && (t.bumpScale.value *= -1));
                e.normalMap &&
                  ((t.normalMap.value = e.normalMap),
                  t.normalScale.value.copy(e.normalScale),
                  1 === e.side && t.normalScale.value.negate());
                e.displacementMap &&
                  ((t.displacementMap.value = e.displacementMap),
                  (t.displacementScale.value = e.displacementScale),
                  (t.displacementBias.value = e.displacementBias));
              })(M, n))
            : n.isMeshPhongMaterial
            ? (wt(M, n),
              (function (t, e) {
                t.specular.value.copy(e.specular),
                  (t.shininess.value = Math.max(e.shininess, 1e-4)),
                  e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
                e.bumpMap &&
                  ((t.bumpMap.value = e.bumpMap),
                  (t.bumpScale.value = e.bumpScale),
                  1 === e.side && (t.bumpScale.value *= -1));
                e.normalMap &&
                  ((t.normalMap.value = e.normalMap),
                  t.normalScale.value.copy(e.normalScale),
                  1 === e.side && t.normalScale.value.negate());
                e.displacementMap &&
                  ((t.displacementMap.value = e.displacementMap),
                  (t.displacementScale.value = e.displacementScale),
                  (t.displacementBias.value = e.displacementBias));
              })(M, n))
            : n.isMeshStandardMaterial
            ? (wt(M, n, u),
              n.isMeshPhysicalMaterial
                ? (function (t, e, n) {
                    At(t, e, n),
                      (t.reflectivity.value = e.reflectivity),
                      (t.clearcoat.value = e.clearcoat),
                      (t.clearcoatRoughness.value = e.clearcoatRoughness),
                      e.sheen && t.sheen.value.copy(e.sheen);
                    e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap);
                    e.clearcoatRoughnessMap &&
                      (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap);
                    e.clearcoatNormalMap &&
                      (t.clearcoatNormalScale.value.copy(
                        e.clearcoatNormalScale,
                      ),
                      (t.clearcoatNormalMap.value = e.clearcoatNormalMap),
                      1 === e.side && t.clearcoatNormalScale.value.negate());
                    t.transparency.value = e.transparency;
                  })(M, n, u)
                : At(M, n, u))
            : n.isMeshMatcapMaterial
            ? (wt(M, n),
              (function (t, e) {
                e.matcap && (t.matcap.value = e.matcap);
                e.bumpMap &&
                  ((t.bumpMap.value = e.bumpMap),
                  (t.bumpScale.value = e.bumpScale),
                  1 === e.side && (t.bumpScale.value *= -1));
                e.normalMap &&
                  ((t.normalMap.value = e.normalMap),
                  t.normalScale.value.copy(e.normalScale),
                  1 === e.side && t.normalScale.value.negate());
                e.displacementMap &&
                  ((t.displacementMap.value = e.displacementMap),
                  (t.displacementScale.value = e.displacementScale),
                  (t.displacementBias.value = e.displacementBias));
              })(M, n))
            : n.isMeshDepthMaterial
            ? (wt(M, n),
              (function (t, e) {
                e.displacementMap &&
                  ((t.displacementMap.value = e.displacementMap),
                  (t.displacementScale.value = e.displacementScale),
                  (t.displacementBias.value = e.displacementBias));
              })(M, n))
            : n.isMeshDistanceMaterial
            ? (wt(M, n),
              (function (t, e) {
                e.displacementMap &&
                  ((t.displacementMap.value = e.displacementMap),
                  (t.displacementScale.value = e.displacementScale),
                  (t.displacementBias.value = e.displacementBias));
                t.referencePosition.value.copy(e.referencePosition),
                  (t.nearDistance.value = e.nearDistance),
                  (t.farDistance.value = e.farDistance);
              })(M, n))
            : n.isMeshNormalMaterial
            ? (wt(M, n),
              (function (t, e) {
                e.bumpMap &&
                  ((t.bumpMap.value = e.bumpMap),
                  (t.bumpScale.value = e.bumpScale),
                  1 === e.side && (t.bumpScale.value *= -1));
                e.normalMap &&
                  ((t.normalMap.value = e.normalMap),
                  t.normalScale.value.copy(e.normalScale),
                  1 === e.side && t.normalScale.value.negate());
                e.displacementMap &&
                  ((t.displacementMap.value = e.displacementMap),
                  (t.displacementScale.value = e.displacementScale),
                  (t.displacementBias.value = e.displacementBias));
              })(M, n))
            : n.isLineBasicMaterial
            ? ((function (t, e) {
                t.diffuse.value.copy(e.color), (t.opacity.value = e.opacity);
              })(M, n),
              n.isLineDashedMaterial &&
                (function (t, e) {
                  (t.dashSize.value = e.dashSize),
                    (t.totalSize.value = e.dashSize + e.gapSize),
                    (t.scale.value = e.scale);
                })(M, n))
            : n.isPointsMaterial
            ? (function (t, e) {
                t.diffuse.value.copy(e.color),
                  (t.opacity.value = e.opacity),
                  (t.size.value = e.size * X),
                  (t.scale.value = 0.5 * H),
                  e.map && (t.map.value = e.map);
                e.alphaMap && (t.alphaMap.value = e.alphaMap);
                var n;
                e.map ? (n = e.map) : e.alphaMap && (n = e.alphaMap);
                void 0 !== n &&
                  (!0 === n.matrixAutoUpdate && n.updateMatrix(),
                  t.uvTransform.value.copy(n.matrix));
              })(M, n)
            : n.isSpriteMaterial
            ? (function (t, e) {
                t.diffuse.value.copy(e.color),
                  (t.opacity.value = e.opacity),
                  (t.rotation.value = e.rotation),
                  e.map && (t.map.value = e.map);
                e.alphaMap && (t.alphaMap.value = e.alphaMap);
                var n;
                e.map ? (n = e.map) : e.alphaMap && (n = e.alphaMap);
                void 0 !== n &&
                  (!0 === n.matrixAutoUpdate && n.updateMatrix(),
                  t.uvTransform.value.copy(n.matrix));
              })(M, n)
            : n.isShadowMaterial
            ? (M.color.value.copy(n.color), (M.opacity.value = n.opacity))
            : n.isCenterLineCylinderMaterial && M.diffuse.value.copy(n.color),
          void 0 !== M.ltc_1 && (M.ltc_1.value = Rn.LTC_1),
          void 0 !== M.ltc_2 && (M.ltc_2.value = Rn.LTC_2),
          Zi.upload(r, d.uniformsList, M, h),
          n.isShaderMaterial && (n.uniformsNeedUpdate = !1)),
        n.isShaderMaterial &&
          !0 === n.uniformsNeedUpdate &&
          (Zi.upload(r, d.uniformsList, M, h), (n.uniformsNeedUpdate = !1)),
        n.isSpriteMaterial && A.setValue(r, 'center', o.center),
        A.setValue(r, 'modelViewMatrix', o.modelViewMatrix),
        A.setValue(r, 'normalMatrix', o.normalMatrix),
        A.setValue(r, 'modelMatrix', o.matrixWorld),
        A.setValue(r, 'positionOffset', n.vertexOffset),
        A.setValue(r, 'isInstanceDrawing', o.instanceDrawing),
        w
      );
    }
    function wt(t, e, n) {
      (t.opacity.value = e.opacity),
        e.color && t.diffuse.value.copy(e.color),
        e.emissive &&
          t.emissive.value.copy(e.emissive).multiplyScalar(e.emissiveIntensity),
        e.map && (t.map.value = e.map),
        e.alphaMap && (t.alphaMap.value = e.alphaMap),
        e.specularMap && (t.specularMap.value = e.specularMap);
      var i,
        r,
        o = e.envMap || n;
      o &&
        ((t.envMap.value = o),
        (t.flipEnvMap.value = o.isCubeTexture ? -1 : 1),
        (t.reflectivity.value = e.reflectivity),
        (t.refractionRatio.value = e.refractionRatio),
        (t.maxMipLevel.value = l.get(o).__maxMipLevel)),
        e.lightMap &&
          ((t.lightMap.value = e.lightMap),
          (t.lightMapIntensity.value = e.lightMapIntensity)),
        e.aoMap &&
          ((t.aoMap.value = e.aoMap),
          (t.aoMapIntensity.value = e.aoMapIntensity)),
        e.map
          ? (i = e.map)
          : e.specularMap
          ? (i = e.specularMap)
          : e.displacementMap
          ? (i = e.displacementMap)
          : e.normalMap
          ? (i = e.normalMap)
          : e.bumpMap
          ? (i = e.bumpMap)
          : e.roughnessMap
          ? (i = e.roughnessMap)
          : e.metalnessMap
          ? (i = e.metalnessMap)
          : e.alphaMap
          ? (i = e.alphaMap)
          : e.emissiveMap && (i = e.emissiveMap),
        void 0 !== i &&
          (i.isWebGLRenderTarget && (i = i.texture),
          !0 === i.matrixAutoUpdate && i.updateMatrix(),
          t.uvTransform.value.copy(i.matrix)),
        e.aoMap ? (r = e.aoMap) : e.lightMap && (r = e.lightMap),
        void 0 !== r &&
          (r.isWebGLRenderTarget && (r = r.texture),
          !0 === r.matrixAutoUpdate && r.updateMatrix(),
          t.uv2Transform.value.copy(r.matrix));
    }
    function At(t, e, n) {
      (t.roughness.value = e.roughness),
        (t.metalness.value = e.metalness),
        e.roughnessMap && (t.roughnessMap.value = e.roughnessMap),
        e.metalnessMap && (t.metalnessMap.value = e.metalnessMap),
        e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
        e.bumpMap &&
          ((t.bumpMap.value = e.bumpMap),
          (t.bumpScale.value = e.bumpScale),
          1 === e.side && (t.bumpScale.value *= -1)),
        e.normalMap &&
          ((t.normalMap.value = e.normalMap),
          t.normalScale.value.copy(e.normalScale),
          1 === e.side && t.normalScale.value.negate()),
        e.displacementMap &&
          ((t.displacementMap.value = e.displacementMap),
          (t.displacementScale.value = e.displacementScale),
          (t.displacementBias.value = e.displacementBias)),
        (e.envMap || n) && (t.envMapIntensity.value = e.envMapIntensity);
    }
    bt.setAnimationLoop(function (t) {
      ct.isPresenting || (mt && mt(t));
    }),
      'undefined' != typeof window && bt.setContext(window),
      (this.setAnimationLoop = function (t) {
        (mt = t), ct.setAnimationLoop(t), bt.start();
      }),
      (this.getRenderListInternal = function (t, e) {
        return y.get(t, e);
      }),
      (this.getRenderStateInternal = function (t, e) {
        return v.get(t, e);
      }),
      (this.resetRenderingState = function (t, e) {
        (B.geometry = null),
          (B.program = null),
          (B.wireframe = !1),
          (P = -1),
          (O = null),
          (nt = this.localClippingEnabled),
          (et = tt.init(this.clippingPlanes, nt, e)),
          this.info.autoReset && this.info.reset(),
          !0 === t.autoUpdate && t.updateMatrixWorld(void 0, e),
          null === e.parent && e.updateMatrixWorld(),
          ct.enabled && ct.isPresenting && (e = ct.getCamera(e)),
          (i = v.get(t, e)).init(),
          t.onBeforeRender(I, t, e, R),
          it.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
          K.setFromProjectionMatrix(it);
      }),
      (this.clearRenderState = function (t, e) {
        t.onAfterRender(I, t, e),
          null !== R &&
            (h.updateRenderTargetMipmap(R), h.updateMultisampleRenderTarget(R)),
          a.buffers.depth.setTest(!0),
          a.buffers.depth.setMask(!0),
          a.buffers.color.setMask(!0),
          a.setPolygonOffset(!1),
          (i = null);
      }),
      (this.rebuildRenderList = function (t, e, n, i) {
        n || (n = this.getRenderListInternal(t, e)),
          i || (i = this.getRenderStateInternal(t, e)),
          n.init(),
          gt(t, e, 0, I.sortObjects, n, i),
          n.finish(),
          !0 === this.sortObjects && n.sort(Z, Y);
      }),
      (this.renderShadow = function (t, e) {
        et && tt.beginShadows();
        var n = i.state.shadowsArray;
        lt.render(n, t, e), i.setupLights(e), et && tt.endShadows();
      }),
      (this.drawRenderListItem = function (t, e, n, r) {
        var o = t.object,
          s = t.geometry,
          c = void 0 === r ? t.material : r,
          l = t.group;
        if (n.isArrayCamera) {
          V = n;
          for (var h = n.cameras, u = 0, d = h.length; u < d; u++) {
            var p = h[u];
            o.layers.test(p.layers) &&
              (a.viewport(N.copy(p.viewport)),
              i.setupLights(p),
              vt(o, e, p, s, c, l));
          }
        } else (V = null), vt(o, e, n, s, c, l);
      }),
      (this.render = function (t, e) {
        if (e && e.isCamera) {
          if (!E) {
            this.resetRenderingState(t, e);
            var n = this.getRenderListInternal(t, e),
              r = i || this.getRenderStateInternal(t, e);
            this.rebuildRenderList(t, e, n, r),
              this.renderShadow(t, e),
              _.render(n, t, e);
            var o = t.overrideMaterial ? t.overrideMaterial : void 0;
            yt(n.opaque, t, e, o),
              yt(n.transparent, t, e, o),
              this.clearRenderState(t, e);
          }
        } else
          console.error(
            'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.',
          );
      }),
      (this.setFramebuffer = function (t) {
        D !== t && null === R && r.bindFramebuffer(r.FRAMEBUFFER, t), (D = t);
      }),
      (this.getActiveCubeFace = function () {
        return C;
      }),
      (this.getActiveMipmapLevel = function () {
        return L;
      }),
      (this.getRenderTarget = function () {
        return R;
      }),
      (this.setRenderTarget = function (t, e, n) {
        (R = t),
          (C = e),
          (L = n),
          t && void 0 === l.get(t).__webglFramebuffer && h.setupRenderTarget(t);
        var i = D,
          o = !1;
        if (t) {
          var s = l.get(t).__webglFramebuffer;
          t.isWebGLCubeRenderTarget
            ? ((i = s[e || 0]), (o = !0))
            : (i = t.isWebGLMultisampleRenderTarget
                ? l.get(t).__webglMultisampledFramebuffer
                : s),
            N.copy(t.viewport),
            G.copy(t.scissor),
            (z = t.scissorTest);
        } else
          N.copy(q).multiplyScalar(X).floor(),
            G.copy(Q).multiplyScalar(X).floor(),
            (z = $);
        if (
          (F !== i && (r.bindFramebuffer(r.FRAMEBUFFER, i), (F = i)),
          a.viewport(N),
          a.scissor(G),
          a.setScissorTest(z),
          o)
        ) {
          var c = l.get(t.texture);
          r.framebufferTexture2D(
            r.FRAMEBUFFER,
            r.COLOR_ATTACHMENT0,
            r.TEXTURE_CUBE_MAP_POSITIVE_X + (e || 0),
            c.__webglTexture,
            n || 0,
          );
        }
      }),
      (this.readRenderTargetPixels = function (t, e, n, i, a, c, h) {
        if (t && t.isWebGLRenderTarget) {
          var u = l.get(t).__webglFramebuffer;
          if ((t.isWebGLCubeRenderTarget && void 0 !== h && (u = u[h]), u)) {
            var d = !1;
            u !== F && (r.bindFramebuffer(r.FRAMEBUFFER, u), (d = !0));
            try {
              var f = t.texture,
                m = f.format,
                y = f.type;
              if (
                m !== x &&
                S.convert(m) !==
                  r.getParameter(r.IMPLEMENTATION_COLOR_READ_FORMAT)
              )
                return void console.error(
                  'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.',
                );
              if (
                !(
                  y === p ||
                  S.convert(y) ===
                    r.getParameter(r.IMPLEMENTATION_COLOR_READ_TYPE) ||
                  (y === b &&
                    (s.isWebGL2 ||
                      o.get('OES_texture_float') ||
                      o.get('WEBGL_color_buffer_float'))) ||
                  (y === g &&
                    (s.isWebGL2
                      ? o.get('EXT_color_buffer_float')
                      : o.get('EXT_color_buffer_half_float')))
                )
              )
                return void console.error(
                  'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.',
                );
              r.checkFramebufferStatus(r.FRAMEBUFFER) === r.FRAMEBUFFER_COMPLETE
                ? e >= 0 &&
                  e <= t.width - i &&
                  n >= 0 &&
                  n <= t.height - a &&
                  r.readPixels(e, n, i, a, S.convert(m), S.convert(y), c)
                : console.error(
                    'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.',
                  );
            } finally {
              d && r.bindFramebuffer(r.FRAMEBUFFER, F);
            }
          }
        } else
          console.error(
            'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.',
          );
      }),
      (this.copyFramebufferToTexture = function (t, e, n) {
        void 0 === n && (n = 0);
        var i = Math.pow(2, -n),
          o = Math.floor(e.image.width * i),
          s = Math.floor(e.image.height * i),
          c = S.convert(e.format);
        h.setTexture2D(e, 0),
          r.copyTexImage2D(r.TEXTURE_2D, n, c, t.x, t.y, o, s, 0),
          a.unbindTexture();
      }),
      (this.copyTextureToTexture = function (t, e, n, i) {
        var o = e.image.width,
          s = e.image.height,
          c = S.convert(n.format),
          l = S.convert(n.type);
        h.setTexture2D(n, 0),
          e.isDataTexture
            ? r.texSubImage2D(
                r.TEXTURE_2D,
                i || 0,
                t.x,
                t.y,
                o,
                s,
                c,
                l,
                e.image.data,
              )
            : r.texSubImage2D(r.TEXTURE_2D, i || 0, t.x, t.y, c, l, e.image),
          a.unbindTexture();
      }),
      (this.initTexture = function (t) {
        h.setTexture2D(t, 0), a.unbindTexture();
      }),
      'undefined' != typeof __THREE_DEVTOOLS__ &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent('observe', { detail: this }),
        );
  }
  function Br(t, e) {
    (this.name = ''),
      (this.color = new fe(t)),
      (this.density = void 0 !== e ? e : 25e-5);
  }
  function Or(t, e, n) {
    (this.name = ''),
      (this.color = new fe(t)),
      (this.near = void 0 !== e ? e : 1),
      (this.far = void 0 !== n ? n : 1e3);
  }
  function Vr(t, e) {
    (this.array = t),
      (this.stride = e),
      (this.count = void 0 !== t ? t.length / e : 0),
      (this.usage = F),
      (this.updateRange = { offset: 0, count: -1 }),
      (this.version = 0);
  }
  (Lr.prototype = Object.assign(Object.create(Mn.prototype), {
    constructor: Lr,
    isArrayCamera: !0,
  })),
    (Rr.prototype = Object.assign(Object.create(At.prototype), {
      constructor: Rr,
      isGroup: !0,
    })),
    Object.assign(Fr.prototype, B.prototype),
    Object.assign(Br.prototype, {
      isFogExp2: !0,
      clone: function () {
        return new Br(this.color, this.density);
      },
      toJSON: function () {
        return {
          type: 'FogExp2',
          color: this.color.getHex(),
          density: this.density,
        };
      },
    }),
    Object.assign(Or.prototype, {
      isFog: !0,
      clone: function () {
        return new Or(this.color, this.near, this.far);
      },
      toJSON: function () {
        return {
          type: 'Fog',
          color: this.color.getHex(),
          near: this.near,
          far: this.far,
        };
      },
    }),
    Object.defineProperty(Vr.prototype, 'needsUpdate', {
      set: function (t) {
        !0 === t && this.version++;
      },
    }),
    Object.assign(Vr.prototype, {
      isInterleavedBuffer: !0,
      onUploadCallback: function () {},
      setUsage: function (t) {
        return (this.usage = t), this;
      },
      copy: function (t) {
        return (
          (this.array = new t.array.constructor(t.array)),
          (this.count = t.count),
          (this.stride = t.stride),
          (this.usage = t.usage),
          this
        );
      },
      copyAt: function (t, e, n) {
        (t *= this.stride), (n *= e.stride);
        for (var i = 0, r = this.stride; i < r; i++)
          this.array[t + i] = e.array[n + i];
        return this;
      },
      set: function (t, e) {
        return void 0 === e && (e = 0), this.array.set(t, e), this;
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      onUpload: function (t) {
        return (this.onUploadCallback = t), this;
      },
    });
  var Nr,
    kr = new J();
  function Ur(t, e, n, i) {
    (this.data = t),
      (this.itemSize = e),
      (this.offset = n),
      (this.normalized = !0 === i);
  }
  function Gr(t) {
    _e.call(this),
      (this.type = 'SpriteMaterial'),
      (this.color = new fe(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.rotation = 0),
      (this.sizeAttenuation = !0),
      (this.transparent = !0),
      this.setValues(t);
  }
  Object.defineProperties(Ur.prototype, {
    count: {
      get: function () {
        return this.data.count;
      },
    },
    array: {
      get: function () {
        return this.data.array;
      },
    },
  }),
    Object.assign(Ur.prototype, {
      isInterleavedBufferAttribute: !0,
      applyMatrix4: function (t) {
        for (var e = 0, n = this.data.count; e < n; e++)
          (kr.x = this.getX(e)),
            (kr.y = this.getY(e)),
            (kr.z = this.getZ(e)),
            kr.applyMatrix4(t),
            this.setXYZ(e, kr.x, kr.y, kr.z);
        return this;
      },
      setX: function (t, e) {
        return (this.data.array[t * this.data.stride + this.offset] = e), this;
      },
      setY: function (t, e) {
        return (
          (this.data.array[t * this.data.stride + this.offset + 1] = e), this
        );
      },
      setZ: function (t, e) {
        return (
          (this.data.array[t * this.data.stride + this.offset + 2] = e), this
        );
      },
      setW: function (t, e) {
        return (
          (this.data.array[t * this.data.stride + this.offset + 3] = e), this
        );
      },
      getX: function (t) {
        return this.data.array[t * this.data.stride + this.offset];
      },
      getY: function (t) {
        return this.data.array[t * this.data.stride + this.offset + 1];
      },
      getZ: function (t) {
        return this.data.array[t * this.data.stride + this.offset + 2];
      },
      getW: function (t) {
        return this.data.array[t * this.data.stride + this.offset + 3];
      },
      setXY: function (t, e, n) {
        return (
          (t = t * this.data.stride + this.offset),
          (this.data.array[t + 0] = e),
          (this.data.array[t + 1] = n),
          this
        );
      },
      setXYZ: function (t, e, n, i) {
        return (
          (t = t * this.data.stride + this.offset),
          (this.data.array[t + 0] = e),
          (this.data.array[t + 1] = n),
          (this.data.array[t + 2] = i),
          this
        );
      },
      setXYZW: function (t, e, n, i, r) {
        return (
          (t = t * this.data.stride + this.offset),
          (this.data.array[t + 0] = e),
          (this.data.array[t + 1] = n),
          (this.data.array[t + 2] = i),
          (this.data.array[t + 3] = r),
          this
        );
      },
    }),
    (Gr.prototype = Object.create(_e.prototype)),
    (Gr.prototype.constructor = Gr),
    (Gr.prototype.isSpriteMaterial = !0),
    (Gr.prototype.copy = function (t) {
      return (
        _e.prototype.copy.call(this, t),
        this.color.copy(t.color),
        (this.map = t.map),
        (this.alphaMap = t.alphaMap),
        (this.rotation = t.rotation),
        (this.sizeAttenuation = t.sizeAttenuation),
        this
      );
    });
  var zr = new J(),
    jr = new J(),
    Hr = new J(),
    Wr = new U(),
    Xr = new U(),
    Zr = new ot(),
    Yr = new J(),
    qr = new J(),
    Qr = new J(),
    Jr = new U(),
    $r = new U(),
    Kr = new U();
  function to(t) {
    if ((At.call(this), (this.type = 'Sprite'), void 0 === Nr)) {
      Nr = new He();
      var e = new Vr(
        new Float32Array([
          -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5,
          0, 0, 1,
        ]),
        5,
      );
      Nr.setIndex([0, 1, 2, 0, 2, 3]),
        Nr.setAttribute('position', new Ur(e, 3, 0, !1)),
        Nr.setAttribute('uv', new Ur(e, 2, 3, !1));
    }
    (this.geometry = Nr),
      (this.material = void 0 !== t ? t : new Gr()),
      (this.center = new U(0.5, 0.5));
  }
  function eo(t, e, n, i, r, o) {
    Wr.subVectors(t, n).addScalar(0.5).multiply(i),
      void 0 !== r
        ? ((Xr.x = o * Wr.x - r * Wr.y), (Xr.y = r * Wr.x + o * Wr.y))
        : Xr.copy(Wr),
      t.copy(e),
      (t.x += Xr.x),
      (t.y += Xr.y),
      t.applyMatrix4(Zr);
  }
  to.prototype = Object.assign(Object.create(At.prototype), {
    constructor: to,
    isSprite: !0,
    raycast: function (t, e) {
      null === t.camera &&
        console.error(
          'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.',
        ),
        jr.setFromMatrixScale(this.matrixWorld),
        Zr.copy(t.camera.matrixWorld),
        this.modelViewMatrix.multiplyMatrices(
          t.camera.matrixWorldInverse,
          this.matrixWorld,
        ),
        Hr.setFromMatrixPosition(this.modelViewMatrix),
        t.camera.isPerspectiveCamera &&
          !1 === this.material.sizeAttenuation &&
          jr.multiplyScalar(-Hr.z);
      var n,
        i,
        r = this.material.rotation;
      0 !== r && ((i = Math.cos(r)), (n = Math.sin(r)));
      var o = this.center;
      eo(Yr.set(-0.5, -0.5, 0), Hr, o, jr, n, i),
        eo(qr.set(0.5, -0.5, 0), Hr, o, jr, n, i),
        eo(Qr.set(0.5, 0.5, 0), Hr, o, jr, n, i),
        Jr.set(0, 0),
        $r.set(1, 0),
        Kr.set(1, 1);
      var s = t.ray.intersectTriangle(Yr, qr, Qr, !1, zr);
      if (
        null !== s ||
        (eo(qr.set(-0.5, 0.5, 0), Hr, o, jr, n, i),
        $r.set(0, 1),
        null !== (s = t.ray.intersectTriangle(Yr, Qr, qr, !1, zr)))
      ) {
        var a = t.ray.origin.distanceTo(zr);
        a < t.near ||
          a > t.far ||
          e.push({
            distance: a,
            point: zr.clone(),
            uv: he.getUV(zr, Yr, qr, Qr, Jr, $r, Kr, new U()),
            face: null,
            object: this,
          });
      }
    },
    clone: function () {
      return new this.constructor(this.material).copy(this);
    },
    copy: function (t) {
      return (
        At.prototype.copy.call(this, t),
        void 0 !== t.center && this.center.copy(t.center),
        this
      );
    },
  });
  var no = new J(),
    io = new J();
  function ro() {
    At.call(this),
      (this._currentLevel = 0),
      (this.type = 'LOD'),
      Object.defineProperties(this, { levels: { enumerable: !0, value: [] } }),
      (this.autoUpdate = !0);
  }
  function oo(t, e) {
    t &&
      t.isGeometry &&
      console.error(
        'THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.',
      ),
      ln.call(this, t, e),
      (this.type = 'SkinnedMesh'),
      (this.bindMode = 'attached'),
      (this.bindMatrix = new ot()),
      (this.bindMatrixInverse = new ot());
  }
  (ro.prototype = Object.assign(Object.create(At.prototype), {
    constructor: ro,
    isLOD: !0,
    copy: function (t) {
      At.prototype.copy.call(this, t, !1);
      for (var e = t.levels, n = 0, i = e.length; n < i; n++) {
        var r = e[n];
        this.addLevel(r.object.clone(), r.distance);
      }
      return (this.autoUpdate = t.autoUpdate), this;
    },
    addLevel: function (t, e) {
      void 0 === e && (e = 0), (e = Math.abs(e));
      for (
        var n = this.levels, i = 0;
        i < n.length && !(e < n[i].distance);
        i++
      );
      return n.splice(i, 0, { distance: e, object: t }), this.add(t), this;
    },
    getCurrentLevel: function () {
      return this._currentLevel;
    },
    getObjectForDistance: function (t) {
      var e = this.levels;
      if (e.length > 0) {
        for (var n = 1, i = e.length; n < i && !(t < e[n].distance); n++);
        return e[n - 1].object;
      }
      return null;
    },
    raycast: function (t, e) {
      if (this.levels.length > 0) {
        no.setFromMatrixPosition(this.matrixWorld);
        var n = t.ray.origin.distanceTo(no);
        this.getObjectForDistance(n).raycast(t, e);
      }
    },
    update: function (t) {
      var e = this.levels;
      if (e.length > 1) {
        no.setFromMatrixPosition(t.matrixWorld),
          io.setFromMatrixPosition(this.matrixWorld);
        var n = no.distanceTo(io) / t.zoom;
        e[0].object.visible = !0;
        for (var i = 1, r = e.length; i < r && n >= e[i].distance; i++)
          (e[i - 1].object.visible = !1), (e[i].object.visible = !0);
        for (this._currentLevel = i - 1; i < r; i++) e[i].object.visible = !1;
      }
    },
    toJSON: function (t) {
      var e = At.prototype.toJSON.call(this, t);
      !1 === this.autoUpdate && (e.object.autoUpdate = !1),
        (e.object.levels = []);
      for (var n = this.levels, i = 0, r = n.length; i < r; i++) {
        var o = n[i];
        e.object.levels.push({ object: o.object.uuid, distance: o.distance });
      }
      return e;
    },
  })),
    (oo.prototype = Object.assign(Object.create(ln.prototype), {
      constructor: oo,
      isSkinnedMesh: !0,
      bind: function (t, e) {
        (this.skeleton = t),
          void 0 === e &&
            (this.updateMatrixWorld(!0),
            this.skeleton.calculateInverses(),
            (e = this.matrixWorld)),
          this.bindMatrix.copy(e),
          this.bindMatrixInverse.getInverse(e);
      },
      pose: function () {
        this.skeleton.pose();
      },
      normalizeSkinWeights: function () {
        for (
          var t = new W(),
            e = this.geometry.attributes.skinWeight,
            n = 0,
            i = e.count;
          n < i;
          n++
        ) {
          (t.x = e.getX(n)),
            (t.y = e.getY(n)),
            (t.z = e.getZ(n)),
            (t.w = e.getW(n));
          var r = 1 / t.manhattanLength();
          r !== 1 / 0 ? t.multiplyScalar(r) : t.set(1, 0, 0, 0),
            e.setXYZW(n, t.x, t.y, t.z, t.w);
        }
      },
      updateMatrixWorld: function (t) {
        ln.prototype.updateMatrixWorld.call(this, t),
          'attached' === this.bindMode
            ? this.bindMatrixInverse.getInverse(this.matrixWorld)
            : 'detached' === this.bindMode
            ? this.bindMatrixInverse.getInverse(this.bindMatrix)
            : console.warn(
                'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode,
              );
      },
      clone: function () {
        return new this.constructor(this.geometry, this.material).copy(this);
      },
    }));
  var so = new ot(),
    ao = new ot();
  function co(t, e) {
    if (
      ((t = t || []),
      (this.bones = t.slice(0)),
      (this.boneMatrices = new Float32Array(16 * this.bones.length)),
      (this.frame = -1),
      void 0 === e)
    )
      this.calculateInverses();
    else if (this.bones.length === e.length) this.boneInverses = e.slice(0);
    else {
      console.warn('THREE.Skeleton boneInverses is the wrong length.'),
        (this.boneInverses = []);
      for (var n = 0, i = this.bones.length; n < i; n++)
        this.boneInverses.push(new ot());
    }
  }
  function lo() {
    At.call(this), (this.type = 'Bone');
  }
  Object.assign(co.prototype, {
    calculateInverses: function () {
      this.boneInverses = [];
      for (var t = 0, e = this.bones.length; t < e; t++) {
        var n = new ot();
        this.bones[t] && n.getInverse(this.bones[t].matrixWorld),
          this.boneInverses.push(n);
      }
    },
    pose: function () {
      var t, e, n;
      for (e = 0, n = this.bones.length; e < n; e++)
        (t = this.bones[e]) && t.matrixWorld.getInverse(this.boneInverses[e]);
      for (e = 0, n = this.bones.length; e < n; e++)
        (t = this.bones[e]) &&
          (t.parent && t.parent.isBone
            ? (t.matrix.getInverse(t.parent.matrixWorld),
              t.matrix.multiply(t.matrixWorld))
            : t.matrix.copy(t.matrixWorld),
          t.matrix.decompose(t.position, t.quaternion, t.scale));
    },
    update: function () {
      for (
        var t = this.bones,
          e = this.boneInverses,
          n = this.boneMatrices,
          i = this.boneTexture,
          r = 0,
          o = t.length;
        r < o;
        r++
      ) {
        var s = t[r] ? t[r].matrixWorld : ao;
        so.multiplyMatrices(s, e[r]), so.toArray(n, 16 * r);
      }
      void 0 !== i && (i.needsUpdate = !0);
    },
    clone: function () {
      return new co(this.bones, this.boneInverses);
    },
    getBoneByName: function (t) {
      for (var e = 0, n = this.bones.length; e < n; e++) {
        var i = this.bones[e];
        if (i.name === t) return i;
      }
    },
    dispose: function () {
      this.boneTexture &&
        (this.boneTexture.dispose(), (this.boneTexture = void 0));
    },
  }),
    (lo.prototype = Object.assign(Object.create(At.prototype), {
      constructor: lo,
      isBone: !0,
    }));
  var ho = new ot(),
    uo = new ot(),
    po = [],
    fo = new ln();
  function mo(t, e, n) {
    ln.call(this, t, e),
      (this.instanceMatrix = new Ae(new Float32Array(16 * n), 16)),
      (this.count = n),
      (this.frustumCulled = !1);
  }
  function bo(t) {
    _e.call(this),
      (this.type = 'LineBasicMaterial'),
      (this.color = new fe(16777215)),
      (this.linewidth = 1),
      (this.linecap = 'round'),
      (this.linejoin = 'round'),
      this.setValues(t);
  }
  (mo.prototype = Object.assign(Object.create(ln.prototype), {
    constructor: mo,
    isInstancedMesh: !0,
    getMatrixAt: function (t, e) {
      e.fromArray(this.instanceMatrix.array, 16 * t);
    },
    raycast: function (t, e) {
      var n = this.matrixWorld,
        i = this.count;
      if (
        ((fo.geometry = this.geometry),
        (fo.material = this.material),
        void 0 !== fo.material)
      )
        for (var r = 0; r < i; r++)
          this.getMatrixAt(r, ho),
            uo.multiplyMatrices(n, ho),
            (fo.matrixWorld = uo),
            fo.raycast(t, po),
            po.length > 0 &&
              ((po[0].instanceId = r),
              (po[0].object = this),
              e.push(po[0]),
              (po.length = 0));
    },
    setMatrixAt: function (t, e) {
      e.toArray(this.instanceMatrix.array, 16 * t);
    },
    updateMorphTargets: function () {},
  })),
    (bo.prototype = Object.create(_e.prototype)),
    (bo.prototype.constructor = bo),
    (bo.prototype.isLineBasicMaterial = !0),
    (bo.prototype.copy = function (t) {
      return (
        _e.prototype.copy.call(this, t),
        this.color.copy(t.color),
        (this.linewidth = t.linewidth),
        (this.linecap = t.linecap),
        (this.linejoin = t.linejoin),
        this
      );
    });
  var go = new J(),
    yo = new J(),
    vo = new ot(),
    _o = new qt(),
    xo = new Gt();
  function wo(t, e, n) {
    1 === n &&
      console.error(
        'THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.',
      ),
      At.call(this),
      (this.type = 'Line'),
      (this.geometry = void 0 !== t ? t : new He()),
      (this.material = void 0 !== e ? e : new bo());
  }
  wo.prototype = Object.assign(Object.create(At.prototype), {
    constructor: wo,
    isLine: !0,
    computeLineDistances: function () {
      var t = this.geometry;
      if (t.isBufferGeometry)
        if (null === t.index) {
          for (
            var e = t.attributes.position, n = [0], i = 1, r = e.count;
            i < r;
            i++
          )
            go.fromBufferAttribute(e, i - 1),
              yo.fromBufferAttribute(e, i),
              (n[i] = n[i - 1]),
              (n[i] += go.distanceTo(yo));
          t.setAttribute('lineDistance', new Re(n, 1));
        } else
          console.warn(
            'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.',
          );
      else if (t.isGeometry) {
        var o = t.vertices;
        (n = t.lineDistances)[0] = 0;
        for (i = 1, r = o.length; i < r; i++)
          (n[i] = n[i - 1]), (n[i] += o[i - 1].distanceTo(o[i]));
      }
      return this;
    },
    raycast: function (t, e) {
      var n = this.geometry,
        i = this.matrixWorld,
        r = t.params.Line.threshold;
      if (
        (null === n.boundingSphere && n.computeBoundingSphere(),
        xo.copy(n.boundingSphere),
        xo.applyMatrix4(i),
        (xo.radius += r),
        !1 !== t.ray.intersectsSphere(xo))
      ) {
        vo.getInverse(i), _o.copy(t.ray).applyMatrix4(vo);
        var o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
          s = o * o,
          a = new J(),
          c = new J(),
          l = new J(),
          h = new J(),
          u = this && this.isLineSegments ? 2 : 1;
        if (n.isBufferGeometry) {
          var d = n.index,
            p = n.attributes.position.array;
          if (null !== d)
            for (var f = d.array, m = 0, b = f.length - 1; m < b; m += u) {
              var g = f[m],
                y = f[m + 1];
              if (
                (a.fromArray(p, 3 * g),
                c.fromArray(p, 3 * y),
                !(_o.distanceSqToSegment(a, c, h, l) > s))
              )
                h.applyMatrix4(this.matrixWorld),
                  (x = t.ray.origin.distanceTo(h)) < t.near ||
                    x > t.far ||
                    e.push({
                      distance: x,
                      point: l.clone().applyMatrix4(this.matrixWorld),
                      index: m,
                      face: null,
                      faceIndex: null,
                      object: this,
                    });
            }
          else
            for (m = 0, b = p.length / 3 - 1; m < b; m += u) {
              if (
                (a.fromArray(p, 3 * m),
                c.fromArray(p, 3 * m + 3),
                !(_o.distanceSqToSegment(a, c, h, l) > s))
              )
                h.applyMatrix4(this.matrixWorld),
                  (x = t.ray.origin.distanceTo(h)) < t.near ||
                    x > t.far ||
                    e.push({
                      distance: x,
                      point: l.clone().applyMatrix4(this.matrixWorld),
                      index: m,
                      face: null,
                      faceIndex: null,
                      object: this,
                    });
            }
        } else if (n.isGeometry) {
          var v = n.vertices,
            _ = v.length;
          for (m = 0; m < _ - 1; m += u) {
            var x;
            if (!(_o.distanceSqToSegment(v[m], v[m + 1], h, l) > s))
              h.applyMatrix4(this.matrixWorld),
                (x = t.ray.origin.distanceTo(h)) < t.near ||
                  x > t.far ||
                  e.push({
                    distance: x,
                    point: l.clone().applyMatrix4(this.matrixWorld),
                    index: m,
                    face: null,
                    faceIndex: null,
                    object: this,
                  });
          }
        }
      }
    },
    clone: function () {
      return new this.constructor(this.geometry, this.material).copy(this);
    },
  });
  var Ao = new J(),
    Mo = new J();
  function So(t, e) {
    wo.call(this, t, e), (this.type = 'LineSegments');
  }
  function Io(t, e) {
    wo.call(this, t, e), (this.type = 'LineLoop');
  }
  function Eo(t) {
    _e.call(this),
      (this.type = 'PointsMaterial'),
      (this.color = new fe(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.size = 1),
      (this.sizeAttenuation = !0),
      (this.morphTargets = !1),
      this.setValues(t);
  }
  (So.prototype = Object.assign(Object.create(wo.prototype), {
    constructor: So,
    isLineSegments: !0,
    computeLineDistances: function () {
      var t = this.geometry;
      if (t.isBufferGeometry)
        if (null === t.index) {
          for (
            var e = t.attributes.position, n = [], i = 0, r = e.count;
            i < r;
            i += 2
          )
            Ao.fromBufferAttribute(e, i),
              Mo.fromBufferAttribute(e, i + 1),
              (n[i] = 0 === i ? 0 : n[i - 1]),
              (n[i + 1] = n[i] + Ao.distanceTo(Mo));
          t.setAttribute('lineDistance', new Re(n, 1));
        } else
          console.warn(
            'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.',
          );
      else if (t.isGeometry) {
        var o = t.vertices;
        for (n = t.lineDistances, i = 0, r = o.length; i < r; i += 2)
          Ao.copy(o[i]),
            Mo.copy(o[i + 1]),
            (n[i] = 0 === i ? 0 : n[i - 1]),
            (n[i + 1] = n[i] + Ao.distanceTo(Mo));
      }
      return this;
    },
  })),
    (Io.prototype = Object.assign(Object.create(wo.prototype), {
      constructor: Io,
      isLineLoop: !0,
    })),
    (Eo.prototype = Object.create(_e.prototype)),
    (Eo.prototype.constructor = Eo),
    (Eo.prototype.isPointsMaterial = !0),
    (Eo.prototype.copy = function (t) {
      return (
        _e.prototype.copy.call(this, t),
        this.color.copy(t.color),
        (this.map = t.map),
        (this.alphaMap = t.alphaMap),
        (this.size = t.size),
        (this.sizeAttenuation = t.sizeAttenuation),
        (this.morphTargets = t.morphTargets),
        this
      );
    });
  var Do = new ot(),
    Co = new qt(),
    To = new Gt(),
    Lo = new J();
  function Ro(t, e) {
    At.call(this),
      (this.type = 'Points'),
      (this.geometry = void 0 !== t ? t : new He()),
      (this.material = void 0 !== e ? e : new Eo()),
      this.updateMorphTargets();
  }
  function Fo(t, e, n, i, r, o, s) {
    var a = Co.distanceSqToPoint(t);
    if (a < n) {
      var c = new J();
      Co.closestPointToPoint(t, c), c.applyMatrix4(i);
      var l = r.ray.origin.distanceTo(c);
      if (l < r.near || l > r.far) return;
      o.push({
        distance: l,
        distanceToRay: Math.sqrt(a),
        point: c,
        index: e,
        face: null,
        object: s,
      });
    }
  }
  function Po(t, e, n, i, r, o, s, a, c) {
    H.call(this, t, e, n, i, r, o, s, a, c),
      (this.format = void 0 !== s ? s : _),
      (this.minFilter = void 0 !== o ? o : u),
      (this.magFilter = void 0 !== r ? r : u),
      (this.generateMipmaps = !1);
  }
  function Bo(t, e, n, i, r, o, s, a, c, l, h, u) {
    H.call(this, null, o, s, a, c, l, i, r, h, u),
      (this.image = { width: e, height: n }),
      (this.mipmaps = t),
      (this.flipY = !1),
      (this.generateMipmaps = !1);
  }
  function Oo(t, e, n, i, r, o, s, a, c) {
    H.call(this, t, e, n, i, r, o, s, a, c), (this.needsUpdate = !0);
  }
  function Vo(t, e, n, i, r, o, s, a, l, h) {
    if ((h = void 0 !== h ? h : w) !== w && h !== A)
      throw new Error(
        'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat',
      );
    void 0 === n && h === w && (n = f),
      void 0 === n && h === A && (n = y),
      H.call(this, null, i, r, o, s, a, h, n, l),
      (this.image = { width: t, height: e }),
      (this.magFilter = void 0 !== s ? s : c),
      (this.minFilter = void 0 !== a ? a : c),
      (this.flipY = !1),
      (this.generateMipmaps = !1);
  }
  function No(t) {
    He.call(this), (this.type = 'WireframeGeometry');
    var e,
      n,
      i,
      r,
      o,
      s,
      a,
      c,
      l,
      h,
      u = [],
      d = [0, 0],
      p = {},
      f = ['a', 'b', 'c'];
    if (t && t.isGeometry) {
      var m = t.faces;
      for (e = 0, i = m.length; e < i; e++) {
        var b = m[e];
        for (n = 0; n < 3; n++)
          (a = b[f[n]]),
            (c = b[f[(n + 1) % 3]]),
            (d[0] = Math.min(a, c)),
            (d[1] = Math.max(a, c)),
            void 0 === p[(l = d[0] + ',' + d[1])] &&
              (p[l] = { index1: d[0], index2: d[1] });
      }
      for (l in p)
        (s = p[l]),
          (h = t.vertices[s.index1]),
          u.push(h.x, h.y, h.z),
          (h = t.vertices[s.index2]),
          u.push(h.x, h.y, h.z);
    } else if (t && t.isBufferGeometry) {
      var g, y, v, _, x, w, A;
      if (((h = new J()), null !== t.index)) {
        for (
          g = t.attributes.position,
            y = t.index,
            0 === (v = t.groups).length &&
              (v = [{ start: 0, count: y.count, materialIndex: 0 }]),
            r = 0,
            o = v.length;
          r < o;
          ++r
        )
          for (e = x = (_ = v[r]).start, i = x + _.count; e < i; e += 3)
            for (n = 0; n < 3; n++)
              (a = y.getX(e + n)),
                (c = y.getX(e + ((n + 1) % 3))),
                (d[0] = Math.min(a, c)),
                (d[1] = Math.max(a, c)),
                void 0 === p[(l = d[0] + ',' + d[1])] &&
                  (p[l] = { index1: d[0], index2: d[1] });
        for (l in p)
          (s = p[l]),
            h.fromBufferAttribute(g, s.index1),
            u.push(h.x, h.y, h.z),
            h.fromBufferAttribute(g, s.index2),
            u.push(h.x, h.y, h.z);
      } else
        for (e = 0, i = (g = t.attributes.position).count / 3; e < i; e++)
          for (n = 0; n < 3; n++)
            (w = 3 * e + n),
              h.fromBufferAttribute(g, w),
              u.push(h.x, h.y, h.z),
              (A = 3 * e + ((n + 1) % 3)),
              h.fromBufferAttribute(g, A),
              u.push(h.x, h.y, h.z);
    }
    this.setAttribute('position', new Re(u, 3));
  }
  function ko(t, e, n) {
    bn.call(this),
      (this.type = 'ParametricGeometry'),
      (this.parameters = { func: t, slices: e, stacks: n }),
      this.fromBufferGeometry(new Uo(t, e, n)),
      this.mergeVertices();
  }
  function Uo(t, e, n) {
    He.call(this),
      (this.type = 'ParametricBufferGeometry'),
      (this.parameters = { func: t, slices: e, stacks: n });
    var i,
      r,
      o = [],
      s = [],
      a = [],
      c = [],
      l = 1e-5,
      h = new J(),
      u = new J(),
      d = new J(),
      p = new J(),
      f = new J();
    t.length < 3 &&
      console.error(
        'THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.',
      );
    var m = e + 1;
    for (i = 0; i <= n; i++) {
      var b = i / n;
      for (r = 0; r <= e; r++) {
        var g = r / e;
        t(g, b, u),
          s.push(u.x, u.y, u.z),
          g - l >= 0
            ? (t(g - l, b, d), p.subVectors(u, d))
            : (t(g + l, b, d), p.subVectors(d, u)),
          b - l >= 0
            ? (t(g, b - l, d), f.subVectors(u, d))
            : (t(g, b + l, d), f.subVectors(d, u)),
          h.crossVectors(p, f).normalize(),
          a.push(h.x, h.y, h.z),
          c.push(g, b);
      }
    }
    for (i = 0; i < n; i++)
      for (r = 0; r < e; r++) {
        var y = i * m + r,
          v = i * m + r + 1,
          _ = (i + 1) * m + r + 1,
          x = (i + 1) * m + r;
        o.push(y, v, x), o.push(v, _, x);
      }
    this.setIndex(o),
      this.setAttribute('position', new Re(s, 3)),
      this.setAttribute('normal', new Re(a, 3)),
      this.setAttribute('uv', new Re(c, 2));
  }
  function Go(t, e, n, i) {
    bn.call(this),
      (this.type = 'PolyhedronGeometry'),
      (this.parameters = { vertices: t, indices: e, radius: n, detail: i }),
      this.fromBufferGeometry(new zo(t, e, n, i)),
      this.mergeVertices();
  }
  function zo(t, e, n, i) {
    He.call(this),
      (this.type = 'PolyhedronBufferGeometry'),
      (this.parameters = { vertices: t, indices: e, radius: n, detail: i }),
      (n = n || 1);
    var r = [],
      o = [];
    function s(t, e, n, i) {
      var r,
        o,
        s = Math.pow(2, i),
        c = [];
      for (r = 0; r <= s; r++) {
        c[r] = [];
        var l = t.clone().lerp(n, r / s),
          h = e.clone().lerp(n, r / s),
          u = s - r;
        for (o = 0; o <= u; o++)
          c[r][o] = 0 === o && r === s ? l : l.clone().lerp(h, o / u);
      }
      for (r = 0; r < s; r++)
        for (o = 0; o < 2 * (s - r) - 1; o++) {
          var d = Math.floor(o / 2);
          o % 2 == 0
            ? (a(c[r][d + 1]), a(c[r + 1][d]), a(c[r][d]))
            : (a(c[r][d + 1]), a(c[r + 1][d + 1]), a(c[r + 1][d]));
        }
    }
    function a(t) {
      r.push(t.x, t.y, t.z);
    }
    function c(e, n) {
      var i = 3 * e;
      (n.x = t[i + 0]), (n.y = t[i + 1]), (n.z = t[i + 2]);
    }
    function l(t, e, n, i) {
      i < 0 && 1 === t.x && (o[e] = t.x - 1),
        0 === n.x && 0 === n.z && (o[e] = i / 2 / Math.PI + 0.5);
    }
    function h(t) {
      return Math.atan2(t.z, -t.x);
    }
    !(function (t) {
      for (
        var n = new J(), i = new J(), r = new J(), o = 0;
        o < e.length;
        o += 3
      )
        c(e[o + 0], n), c(e[o + 1], i), c(e[o + 2], r), s(n, i, r, t);
    })((i = i || 0)),
      (function (t) {
        for (var e = new J(), n = 0; n < r.length; n += 3)
          (e.x = r[n + 0]),
            (e.y = r[n + 1]),
            (e.z = r[n + 2]),
            e.normalize().multiplyScalar(t),
            (r[n + 0] = e.x),
            (r[n + 1] = e.y),
            (r[n + 2] = e.z);
      })(n),
      (function () {
        for (var t = new J(), e = 0; e < r.length; e += 3) {
          (t.x = r[e + 0]), (t.y = r[e + 1]), (t.z = r[e + 2]);
          var n = h(t) / 2 / Math.PI + 0.5,
            i =
              ((s = t),
              Math.atan2(-s.y, Math.sqrt(s.x * s.x + s.z * s.z)) / Math.PI +
                0.5);
          o.push(n, 1 - i);
        }
        var s;
        (function () {
          for (
            var t = new J(),
              e = new J(),
              n = new J(),
              i = new J(),
              s = new U(),
              a = new U(),
              c = new U(),
              u = 0,
              d = 0;
            u < r.length;
            u += 9, d += 6
          ) {
            t.set(r[u + 0], r[u + 1], r[u + 2]),
              e.set(r[u + 3], r[u + 4], r[u + 5]),
              n.set(r[u + 6], r[u + 7], r[u + 8]),
              s.set(o[d + 0], o[d + 1]),
              a.set(o[d + 2], o[d + 3]),
              c.set(o[d + 4], o[d + 5]),
              i.copy(t).add(e).add(n).divideScalar(3);
            var p = h(i);
            l(s, d + 0, t, p), l(a, d + 2, e, p), l(c, d + 4, n, p);
          }
        })(),
          (function () {
            for (var t = 0; t < o.length; t += 6) {
              var e = o[t + 0],
                n = o[t + 2],
                i = o[t + 4],
                r = Math.max(e, n, i),
                s = Math.min(e, n, i);
              r > 0.9 &&
                s < 0.1 &&
                (e < 0.2 && (o[t + 0] += 1),
                n < 0.2 && (o[t + 2] += 1),
                i < 0.2 && (o[t + 4] += 1));
            }
          })();
      })(),
      this.setAttribute('position', new Re(r, 3)),
      this.setAttribute('normal', new Re(r.slice(), 3)),
      this.setAttribute('uv', new Re(o, 2)),
      0 === i ? this.computeVertexNormals() : this.normalizeNormals();
  }
  function jo(t, e) {
    bn.call(this),
      (this.type = 'TetrahedronGeometry'),
      (this.parameters = { radius: t, detail: e }),
      this.fromBufferGeometry(new Ho(t, e)),
      this.mergeVertices();
  }
  function Ho(t, e) {
    zo.call(
      this,
      [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
      [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1],
      t,
      e,
    ),
      (this.type = 'TetrahedronBufferGeometry'),
      (this.parameters = { radius: t, detail: e });
  }
  function Wo(t, e) {
    bn.call(this),
      (this.type = 'OctahedronGeometry'),
      (this.parameters = { radius: t, detail: e }),
      this.fromBufferGeometry(new Xo(t, e)),
      this.mergeVertices();
  }
  function Xo(t, e) {
    zo.call(
      this,
      [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
      [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2],
      t,
      e,
    ),
      (this.type = 'OctahedronBufferGeometry'),
      (this.parameters = { radius: t, detail: e });
  }
  function Zo(t, e) {
    bn.call(this),
      (this.type = 'IcosahedronGeometry'),
      (this.parameters = { radius: t, detail: e }),
      this.fromBufferGeometry(new Yo(t, e)),
      this.mergeVertices();
  }
  function Yo(t, e) {
    var n = (1 + Math.sqrt(5)) / 2,
      i = [
        -1,
        n,
        0,
        1,
        n,
        0,
        -1,
        -n,
        0,
        1,
        -n,
        0,
        0,
        -1,
        n,
        0,
        1,
        n,
        0,
        -1,
        -n,
        0,
        1,
        -n,
        n,
        0,
        -1,
        n,
        0,
        1,
        -n,
        0,
        -1,
        -n,
        0,
        1,
      ];
    zo.call(
      this,
      i,
      [
        0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11,
        10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9,
        4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
      ],
      t,
      e,
    ),
      (this.type = 'IcosahedronBufferGeometry'),
      (this.parameters = { radius: t, detail: e });
  }
  function qo(t, e) {
    bn.call(this),
      (this.type = 'DodecahedronGeometry'),
      (this.parameters = { radius: t, detail: e }),
      this.fromBufferGeometry(new Qo(t, e)),
      this.mergeVertices();
  }
  function Qo(t, e) {
    var n = (1 + Math.sqrt(5)) / 2,
      i = 1 / n,
      r = [
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        -1,
        1,
        1,
        1,
        -1,
        -1,
        1,
        -1,
        1,
        1,
        1,
        -1,
        1,
        1,
        1,
        0,
        -i,
        -n,
        0,
        -i,
        n,
        0,
        i,
        -n,
        0,
        i,
        n,
        -i,
        -n,
        0,
        -i,
        n,
        0,
        i,
        -n,
        0,
        i,
        n,
        0,
        -n,
        0,
        -i,
        n,
        0,
        -i,
        -n,
        0,
        i,
        n,
        0,
        i,
      ];
    zo.call(
      this,
      r,
      [
        3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8,
        17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18,
        0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13,
        18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5,
        11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14,
        5, 1, 5, 9,
      ],
      t,
      e,
    ),
      (this.type = 'DodecahedronBufferGeometry'),
      (this.parameters = { radius: t, detail: e });
  }
  function Jo(t, e, n, i, r, o) {
    bn.call(this),
      (this.type = 'TubeGeometry'),
      (this.parameters = {
        path: t,
        tubularSegments: e,
        radius: n,
        radialSegments: i,
        closed: r,
      }),
      void 0 !== o &&
        console.warn('THREE.TubeGeometry: taper has been removed.');
    var s = new $o(t, e, n, i, r);
    (this.tangents = s.tangents),
      (this.normals = s.normals),
      (this.binormals = s.binormals),
      this.fromBufferGeometry(s),
      this.mergeVertices();
  }
  function $o(t, e, n, i, r) {
    He.call(this),
      (this.type = 'TubeBufferGeometry'),
      (this.parameters = {
        path: t,
        tubularSegments: e,
        radius: n,
        radialSegments: i,
        closed: r,
      }),
      (e = e || 64),
      (n = n || 1),
      (i = i || 8),
      (r = r || !1);
    var o = t.computeFrenetFrames(e, r);
    (this.tangents = o.tangents),
      (this.normals = o.normals),
      (this.binormals = o.binormals);
    var s,
      a,
      c = new J(),
      l = new J(),
      h = new U(),
      u = new J(),
      d = [],
      p = [],
      f = [],
      m = [];
    function b(r) {
      u = t.getPointAt(r / e, u);
      var s = o.normals[r],
        h = o.binormals[r];
      for (a = 0; a <= i; a++) {
        var f = (a / i) * Math.PI * 2,
          m = Math.sin(f),
          b = -Math.cos(f);
        (l.x = b * s.x + m * h.x),
          (l.y = b * s.y + m * h.y),
          (l.z = b * s.z + m * h.z),
          l.normalize(),
          p.push(l.x, l.y, l.z),
          (c.x = u.x + n * l.x),
          (c.y = u.y + n * l.y),
          (c.z = u.z + n * l.z),
          d.push(c.x, c.y, c.z);
      }
    }
    !(function () {
      for (s = 0; s < e; s++) b(s);
      b(!1 === r ? e : 0),
        (function () {
          for (s = 0; s <= e; s++)
            for (a = 0; a <= i; a++)
              (h.x = s / e), (h.y = a / i), f.push(h.x, h.y);
        })(),
        (function () {
          for (a = 1; a <= e; a++)
            for (s = 1; s <= i; s++) {
              var t = (i + 1) * (a - 1) + (s - 1),
                n = (i + 1) * a + (s - 1),
                r = (i + 1) * a + s,
                o = (i + 1) * (a - 1) + s;
              m.push(t, n, o), m.push(n, r, o);
            }
        })();
    })(),
      this.setIndex(m),
      this.setAttribute('position', new Re(d, 3)),
      this.setAttribute('normal', new Re(p, 3)),
      this.setAttribute('uv', new Re(f, 2));
  }
  function Ko(t, e, n, i, r, o, s) {
    bn.call(this),
      (this.type = 'TorusKnotGeometry'),
      (this.parameters = {
        radius: t,
        tube: e,
        tubularSegments: n,
        radialSegments: i,
        p: r,
        q: o,
      }),
      void 0 !== s &&
        console.warn(
          'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.',
        ),
      this.fromBufferGeometry(new ts(t, e, n, i, r, o)),
      this.mergeVertices();
  }
  function ts(t, e, n, i, r, o) {
    He.call(this),
      (this.type = 'TorusKnotBufferGeometry'),
      (this.parameters = {
        radius: t,
        tube: e,
        tubularSegments: n,
        radialSegments: i,
        p: r,
        q: o,
      }),
      (t = t || 1),
      (e = e || 0.4),
      (n = Math.floor(n) || 64),
      (i = Math.floor(i) || 8),
      (r = r || 2),
      (o = o || 3);
    var s,
      a,
      c = [],
      l = [],
      h = [],
      u = [],
      d = new J(),
      p = new J(),
      f = new J(),
      m = new J(),
      b = new J(),
      g = new J(),
      y = new J();
    for (s = 0; s <= n; ++s) {
      var v = (s / n) * r * Math.PI * 2;
      for (
        E(v, r, o, t, f),
          E(v + 0.01, r, o, t, m),
          g.subVectors(m, f),
          y.addVectors(m, f),
          b.crossVectors(g, y),
          y.crossVectors(b, g),
          b.normalize(),
          y.normalize(),
          a = 0;
        a <= i;
        ++a
      ) {
        var _ = (a / i) * Math.PI * 2,
          x = -e * Math.cos(_),
          w = e * Math.sin(_);
        (d.x = f.x + (x * y.x + w * b.x)),
          (d.y = f.y + (x * y.y + w * b.y)),
          (d.z = f.z + (x * y.z + w * b.z)),
          l.push(d.x, d.y, d.z),
          p.subVectors(d, f).normalize(),
          h.push(p.x, p.y, p.z),
          u.push(s / n),
          u.push(a / i);
      }
    }
    for (a = 1; a <= n; a++)
      for (s = 1; s <= i; s++) {
        var A = (i + 1) * (a - 1) + (s - 1),
          M = (i + 1) * a + (s - 1),
          S = (i + 1) * a + s,
          I = (i + 1) * (a - 1) + s;
        c.push(A, M, I), c.push(M, S, I);
      }
    function E(t, e, n, i, r) {
      var o = Math.cos(t),
        s = Math.sin(t),
        a = (n / e) * t,
        c = Math.cos(a);
      (r.x = i * (2 + c) * 0.5 * o),
        (r.y = i * (2 + c) * s * 0.5),
        (r.z = i * Math.sin(a) * 0.5);
    }
    this.setIndex(c),
      this.setAttribute('position', new Re(l, 3)),
      this.setAttribute('normal', new Re(h, 3)),
      this.setAttribute('uv', new Re(u, 2));
  }
  function es(t, e, n, i, r) {
    bn.call(this),
      (this.type = 'TorusGeometry'),
      (this.parameters = {
        radius: t,
        tube: e,
        radialSegments: n,
        tubularSegments: i,
        arc: r,
      }),
      this.fromBufferGeometry(new ns(t, e, n, i, r)),
      this.mergeVertices();
  }
  function ns(t, e, n, i, r) {
    He.call(this),
      (this.type = 'TorusBufferGeometry'),
      (this.parameters = {
        radius: t,
        tube: e,
        radialSegments: n,
        tubularSegments: i,
        arc: r,
      }),
      (t = t || 1),
      (e = e || 0.4),
      (n = Math.floor(n) || 8),
      (i = Math.floor(i) || 6),
      (r = r || 2 * Math.PI);
    var o,
      s,
      a = [],
      c = [],
      l = [],
      h = [],
      u = new J(),
      d = new J(),
      p = new J();
    for (o = 0; o <= n; o++)
      for (s = 0; s <= i; s++) {
        var f = (s / i) * r,
          m = (o / n) * Math.PI * 2;
        (d.x = (t + e * Math.cos(m)) * Math.cos(f)),
          (d.y = (t + e * Math.cos(m)) * Math.sin(f)),
          (d.z = e * Math.sin(m)),
          c.push(d.x, d.y, d.z),
          (u.x = t * Math.cos(f)),
          (u.y = t * Math.sin(f)),
          p.subVectors(d, u).normalize(),
          l.push(p.x, p.y, p.z),
          h.push(s / i),
          h.push(o / n);
      }
    for (o = 1; o <= n; o++)
      for (s = 1; s <= i; s++) {
        var b = (i + 1) * o + s - 1,
          g = (i + 1) * (o - 1) + s - 1,
          y = (i + 1) * (o - 1) + s,
          v = (i + 1) * o + s;
        a.push(b, g, v), a.push(g, y, v);
      }
    this.setIndex(a),
      this.setAttribute('position', new Re(c, 3)),
      this.setAttribute('normal', new Re(l, 3)),
      this.setAttribute('uv', new Re(h, 2));
  }
  (Ro.prototype = Object.assign(Object.create(At.prototype), {
    constructor: Ro,
    isPoints: !0,
    raycast: function (t, e) {
      var n = this.geometry,
        i = this.matrixWorld,
        r = t.params.Points.threshold;
      if (
        (null === n.boundingSphere && n.computeBoundingSphere(),
        To.copy(n.boundingSphere),
        To.applyMatrix4(i),
        (To.radius += r),
        !1 !== t.ray.intersectsSphere(To))
      ) {
        Do.getInverse(i), Co.copy(t.ray).applyMatrix4(Do);
        var o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
          s = o * o;
        if (n.isBufferGeometry) {
          var a = n.index,
            c = n.attributes.position.array;
          if (null !== a)
            for (var l = a.array, h = 0, u = l.length; h < u; h++) {
              var d = l[h];
              Lo.fromArray(c, 3 * d), Fo(Lo, d, s, i, t, e, this);
            }
          else {
            h = 0;
            for (var p = c.length / 3; h < p; h++)
              Lo.fromArray(c, 3 * h), Fo(Lo, h, s, i, t, e, this);
          }
        } else {
          var f = n.vertices;
          for (h = 0, p = f.length; h < p; h++) Fo(f[h], h, s, i, t, e, this);
        }
      }
    },
    updateMorphTargets: function () {
      var t,
        e,
        n,
        i = this.geometry;
      if (i.isBufferGeometry) {
        var r = i.morphAttributes,
          o = Object.keys(r);
        if (o.length > 0) {
          var s = r[o[0]];
          if (void 0 !== s)
            for (
              this.morphTargetInfluences = [],
                this.morphTargetDictionary = {},
                t = 0,
                e = s.length;
              t < e;
              t++
            )
              (n = s[t].name || String(t)),
                this.morphTargetInfluences.push(0),
                (this.morphTargetDictionary[n] = t);
        }
      } else {
        var a = i.morphTargets;
        void 0 !== a &&
          a.length > 0 &&
          console.error(
            'THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.',
          );
      }
    },
    clone: function () {
      return new this.constructor(this.geometry, this.material).copy(this);
    },
  })),
    (Po.prototype = Object.assign(Object.create(H.prototype), {
      constructor: Po,
      isVideoTexture: !0,
      update: function () {
        var t = this.image;
        t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
      },
    })),
    (Bo.prototype = Object.create(H.prototype)),
    (Bo.prototype.constructor = Bo),
    (Bo.prototype.isCompressedTexture = !0),
    (Oo.prototype = Object.create(H.prototype)),
    (Oo.prototype.constructor = Oo),
    (Oo.prototype.isCanvasTexture = !0),
    (Vo.prototype = Object.create(H.prototype)),
    (Vo.prototype.constructor = Vo),
    (Vo.prototype.isDepthTexture = !0),
    (No.prototype = Object.create(He.prototype)),
    (No.prototype.constructor = No),
    (ko.prototype = Object.create(bn.prototype)),
    (ko.prototype.constructor = ko),
    (Uo.prototype = Object.create(He.prototype)),
    (Uo.prototype.constructor = Uo),
    (Go.prototype = Object.create(bn.prototype)),
    (Go.prototype.constructor = Go),
    (zo.prototype = Object.create(He.prototype)),
    (zo.prototype.constructor = zo),
    (jo.prototype = Object.create(bn.prototype)),
    (jo.prototype.constructor = jo),
    (Ho.prototype = Object.create(zo.prototype)),
    (Ho.prototype.constructor = Ho),
    (Wo.prototype = Object.create(bn.prototype)),
    (Wo.prototype.constructor = Wo),
    (Xo.prototype = Object.create(zo.prototype)),
    (Xo.prototype.constructor = Xo),
    (Zo.prototype = Object.create(bn.prototype)),
    (Zo.prototype.constructor = Zo),
    (Yo.prototype = Object.create(zo.prototype)),
    (Yo.prototype.constructor = Yo),
    (qo.prototype = Object.create(bn.prototype)),
    (qo.prototype.constructor = qo),
    (Qo.prototype = Object.create(zo.prototype)),
    (Qo.prototype.constructor = Qo),
    (Jo.prototype = Object.create(bn.prototype)),
    (Jo.prototype.constructor = Jo),
    ($o.prototype = Object.create(He.prototype)),
    ($o.prototype.constructor = $o),
    ($o.prototype.toJSON = function () {
      var t = He.prototype.toJSON.call(this);
      return (t.path = this.parameters.path.toJSON()), t;
    }),
    (Ko.prototype = Object.create(bn.prototype)),
    (Ko.prototype.constructor = Ko),
    (ts.prototype = Object.create(He.prototype)),
    (ts.prototype.constructor = ts),
    (es.prototype = Object.create(bn.prototype)),
    (es.prototype.constructor = es),
    (ns.prototype = Object.create(He.prototype)),
    (ns.prototype.constructor = ns);
  var is = function (t, e, n) {
    n = n || 2;
    var i,
      r,
      o,
      s,
      a,
      c,
      l,
      h = e && e.length,
      u = h ? e[0] * n : t.length,
      d = rs(t, 0, u, n, !0),
      p = [];
    if (!d || d.next === d.prev) return p;
    if (
      (h &&
        (d = (function (t, e, n, i) {
          var r,
            o,
            s,
            a = [];
          for (r = 0, o = e.length; r < o; r++)
            (s = rs(
              t,
              e[r] * i,
              r < o - 1 ? e[r + 1] * i : t.length,
              i,
              !1,
            )) === s.next && (s.steiner = !0),
              a.push(fs(s));
          for (a.sort(us), r = 0; r < a.length; r++)
            ds(a[r], n), (n = os(n, n.next));
          return n;
        })(t, e, d, n)),
      t.length > 80 * n)
    ) {
      (i = o = t[0]), (r = s = t[1]);
      for (var f = n; f < u; f += n)
        (a = t[f]) < i && (i = a),
          (c = t[f + 1]) < r && (r = c),
          a > o && (o = a),
          c > s && (s = c);
      l = 0 !== (l = Math.max(o - i, s - r)) ? 1 / l : 0;
    }
    return ss(d, p, n, i, r, l), p;
  };
  function rs(t, e, n, i, r) {
    var o, s;
    if (
      r ===
      (function (t, e, n, i) {
        for (var r = 0, o = e, s = n - i; o < n; o += i)
          (r += (t[s] - t[o]) * (t[o + 1] + t[s + 1])), (s = o);
        return r;
      })(t, e, n, i) >
        0
    )
      for (o = e; o < n; o += i) s = ws(o, t[o], t[o + 1], s);
    else for (o = n - i; o >= e; o -= i) s = ws(o, t[o], t[o + 1], s);
    return s && ys(s, s.next) && (As(s), (s = s.next)), s;
  }
  function os(t, e) {
    if (!t) return t;
    e || (e = t);
    var n,
      i = t;
    do {
      if (
        ((n = !1), i.steiner || (!ys(i, i.next) && 0 !== gs(i.prev, i, i.next)))
      )
        i = i.next;
      else {
        if ((As(i), (i = e = i.prev) === i.next)) break;
        n = !0;
      }
    } while (n || i !== e);
    return e;
  }
  function ss(t, e, n, i, r, o, s) {
    if (t) {
      !s &&
        o &&
        (function (t, e, n, i) {
          var r = t;
          do {
            null === r.z && (r.z = ps(r.x, r.y, e, n, i)),
              (r.prevZ = r.prev),
              (r.nextZ = r.next),
              (r = r.next);
          } while (r !== t);
          (r.prevZ.nextZ = null),
            (r.prevZ = null),
            (function (t) {
              var e,
                n,
                i,
                r,
                o,
                s,
                a,
                c,
                l = 1;
              do {
                for (n = t, t = null, o = null, s = 0; n; ) {
                  for (
                    s++, i = n, a = 0, e = 0;
                    e < l && (a++, (i = i.nextZ));
                    e++
                  );
                  for (c = l; a > 0 || (c > 0 && i); )
                    0 !== a && (0 === c || !i || n.z <= i.z)
                      ? ((r = n), (n = n.nextZ), a--)
                      : ((r = i), (i = i.nextZ), c--),
                      o ? (o.nextZ = r) : (t = r),
                      (r.prevZ = o),
                      (o = r);
                  n = i;
                }
                (o.nextZ = null), (l *= 2);
              } while (s > 1);
            })(r);
        })(t, i, r, o);
      for (var a, c, l = t; t.prev !== t.next; )
        if (((a = t.prev), (c = t.next), o ? cs(t, i, r, o) : as(t)))
          e.push(a.i / n),
            e.push(t.i / n),
            e.push(c.i / n),
            As(t),
            (t = c.next),
            (l = c.next);
        else if ((t = c) === l) {
          s
            ? 1 === s
              ? ss((t = ls(t, e, n)), e, n, i, r, o, 2)
              : 2 === s && hs(t, e, n, i, r, o)
            : ss(os(t), e, n, i, r, o, 1);
          break;
        }
    }
  }
  function as(t) {
    var e = t.prev,
      n = t,
      i = t.next;
    if (gs(e, n, i) >= 0) return !1;
    for (var r = t.next.next; r !== t.prev; ) {
      if (
        ms(e.x, e.y, n.x, n.y, i.x, i.y, r.x, r.y) &&
        gs(r.prev, r, r.next) >= 0
      )
        return !1;
      r = r.next;
    }
    return !0;
  }
  function cs(t, e, n, i) {
    var r = t.prev,
      o = t,
      s = t.next;
    if (gs(r, o, s) >= 0) return !1;
    for (
      var a = r.x < o.x ? (r.x < s.x ? r.x : s.x) : o.x < s.x ? o.x : s.x,
        c = r.y < o.y ? (r.y < s.y ? r.y : s.y) : o.y < s.y ? o.y : s.y,
        l = r.x > o.x ? (r.x > s.x ? r.x : s.x) : o.x > s.x ? o.x : s.x,
        h = r.y > o.y ? (r.y > s.y ? r.y : s.y) : o.y > s.y ? o.y : s.y,
        u = ps(a, c, e, n, i),
        d = ps(l, h, e, n, i),
        p = t.prevZ,
        f = t.nextZ;
      p && p.z >= u && f && f.z <= d;

    ) {
      if (
        p !== t.prev &&
        p !== t.next &&
        ms(r.x, r.y, o.x, o.y, s.x, s.y, p.x, p.y) &&
        gs(p.prev, p, p.next) >= 0
      )
        return !1;
      if (
        ((p = p.prevZ),
        f !== t.prev &&
          f !== t.next &&
          ms(r.x, r.y, o.x, o.y, s.x, s.y, f.x, f.y) &&
          gs(f.prev, f, f.next) >= 0)
      )
        return !1;
      f = f.nextZ;
    }
    for (; p && p.z >= u; ) {
      if (
        p !== t.prev &&
        p !== t.next &&
        ms(r.x, r.y, o.x, o.y, s.x, s.y, p.x, p.y) &&
        gs(p.prev, p, p.next) >= 0
      )
        return !1;
      p = p.prevZ;
    }
    for (; f && f.z <= d; ) {
      if (
        f !== t.prev &&
        f !== t.next &&
        ms(r.x, r.y, o.x, o.y, s.x, s.y, f.x, f.y) &&
        gs(f.prev, f, f.next) >= 0
      )
        return !1;
      f = f.nextZ;
    }
    return !0;
  }
  function ls(t, e, n) {
    var i = t;
    do {
      var r = i.prev,
        o = i.next.next;
      !ys(r, o) &&
        vs(r, i, i.next, o) &&
        _s(r, o) &&
        _s(o, r) &&
        (e.push(r.i / n),
        e.push(i.i / n),
        e.push(o.i / n),
        As(i),
        As(i.next),
        (i = t = o)),
        (i = i.next);
    } while (i !== t);
    return i;
  }
  function hs(t, e, n, i, r, o) {
    var s = t;
    do {
      for (var a = s.next.next; a !== s.prev; ) {
        if (s.i !== a.i && bs(s, a)) {
          var c = xs(s, a);
          return (
            (s = os(s, s.next)),
            (c = os(c, c.next)),
            ss(s, e, n, i, r, o),
            void ss(c, e, n, i, r, o)
          );
        }
        a = a.next;
      }
      s = s.next;
    } while (s !== t);
  }
  function us(t, e) {
    return t.x - e.x;
  }
  function ds(t, e) {
    if (
      (e = (function (t, e) {
        var n,
          i = e,
          r = t.x,
          o = t.y,
          s = -1 / 0;
        do {
          if (o <= i.y && o >= i.next.y && i.next.y !== i.y) {
            var a = i.x + ((o - i.y) * (i.next.x - i.x)) / (i.next.y - i.y);
            if (a <= r && a > s) {
              if (((s = a), a === r)) {
                if (o === i.y) return i;
                if (o === i.next.y) return i.next;
              }
              n = i.x < i.next.x ? i : i.next;
            }
          }
          i = i.next;
        } while (i !== e);
        if (!n) return null;
        if (r === s) return n.prev;
        var c,
          l = n,
          h = n.x,
          u = n.y,
          d = 1 / 0;
        i = n.next;
        for (; i !== l; )
          r >= i.x &&
            i.x >= h &&
            r !== i.x &&
            ms(o < u ? r : s, o, h, u, o < u ? s : r, o, i.x, i.y) &&
            ((c = Math.abs(o - i.y) / (r - i.x)) < d ||
              (c === d && i.x > n.x)) &&
            _s(i, t) &&
            ((n = i), (d = c)),
            (i = i.next);
        return n;
      })(t, e))
    ) {
      var n = xs(e, t);
      os(n, n.next);
    }
  }
  function ps(t, e, n, i, r) {
    return (
      (t =
        1431655765 &
        ((t =
          858993459 &
          ((t =
            252645135 &
            ((t = 16711935 & ((t = 32767 * (t - n) * r) | (t << 8))) |
              (t << 4))) |
            (t << 2))) |
          (t << 1))) |
      ((e =
        1431655765 &
        ((e =
          858993459 &
          ((e =
            252645135 &
            ((e = 16711935 & ((e = 32767 * (e - i) * r) | (e << 8))) |
              (e << 4))) |
            (e << 2))) |
          (e << 1))) <<
        1)
    );
  }
  function fs(t) {
    var e = t,
      n = t;
    do {
      (e.x < n.x || (e.x === n.x && e.y < n.y)) && (n = e), (e = e.next);
    } while (e !== t);
    return n;
  }
  function ms(t, e, n, i, r, o, s, a) {
    return (
      (r - s) * (e - a) - (t - s) * (o - a) >= 0 &&
      (t - s) * (i - a) - (n - s) * (e - a) >= 0 &&
      (n - s) * (o - a) - (r - s) * (i - a) >= 0
    );
  }
  function bs(t, e) {
    return (
      t.next.i !== e.i &&
      t.prev.i !== e.i &&
      !(function (t, e) {
        var n = t;
        do {
          if (
            n.i !== t.i &&
            n.next.i !== t.i &&
            n.i !== e.i &&
            n.next.i !== e.i &&
            vs(n, n.next, t, e)
          )
            return !0;
          n = n.next;
        } while (n !== t);
        return !1;
      })(t, e) &&
      _s(t, e) &&
      _s(e, t) &&
      (function (t, e) {
        var n = t,
          i = !1,
          r = (t.x + e.x) / 2,
          o = (t.y + e.y) / 2;
        do {
          n.y > o != n.next.y > o &&
            n.next.y !== n.y &&
            r < ((n.next.x - n.x) * (o - n.y)) / (n.next.y - n.y) + n.x &&
            (i = !i),
            (n = n.next);
        } while (n !== t);
        return i;
      })(t, e)
    );
  }
  function gs(t, e, n) {
    return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y);
  }
  function ys(t, e) {
    return t.x === e.x && t.y === e.y;
  }
  function vs(t, e, n, i) {
    return (
      !!((ys(t, n) && ys(e, i)) || (ys(t, i) && ys(n, e))) ||
      (gs(t, e, n) > 0 != gs(t, e, i) > 0 && gs(n, i, t) > 0 != gs(n, i, e) > 0)
    );
  }
  function _s(t, e) {
    return gs(t.prev, t, t.next) < 0
      ? gs(t, e, t.next) >= 0 && gs(t, t.prev, e) >= 0
      : gs(t, e, t.prev) < 0 || gs(t, t.next, e) < 0;
  }
  function xs(t, e) {
    var n = new Ms(t.i, t.x, t.y),
      i = new Ms(e.i, e.x, e.y),
      r = t.next,
      o = e.prev;
    return (
      (t.next = e),
      (e.prev = t),
      (n.next = r),
      (r.prev = n),
      (i.next = n),
      (n.prev = i),
      (o.next = i),
      (i.prev = o),
      i
    );
  }
  function ws(t, e, n, i) {
    var r = new Ms(t, e, n);
    return (
      i
        ? ((r.next = i.next), (r.prev = i), (i.next.prev = r), (i.next = r))
        : ((r.prev = r), (r.next = r)),
      r
    );
  }
  function As(t) {
    (t.next.prev = t.prev),
      (t.prev.next = t.next),
      t.prevZ && (t.prevZ.nextZ = t.nextZ),
      t.nextZ && (t.nextZ.prevZ = t.prevZ);
  }
  function Ms(t, e, n) {
    (this.i = t),
      (this.x = e),
      (this.y = n),
      (this.prev = null),
      (this.next = null),
      (this.z = null),
      (this.prevZ = null),
      (this.nextZ = null),
      (this.steiner = !1);
  }
  var Ss = {
    area: function (t) {
      for (var e = t.length, n = 0, i = e - 1, r = 0; r < e; i = r++)
        n += t[i].x * t[r].y - t[r].x * t[i].y;
      return 0.5 * n;
    },
    isClockWise: function (t) {
      return Ss.area(t) < 0;
    },
    triangulateShape: function (t, e) {
      var n = [],
        i = [],
        r = [];
      Is(t), Es(n, t);
      var o = t.length;
      e.forEach(Is);
      for (var s = 0; s < e.length; s++)
        i.push(o), (o += e[s].length), Es(n, e[s]);
      var a = is(n, i);
      for (s = 0; s < a.length; s += 3) r.push(a.slice(s, s + 3));
      return r;
    },
  };
  function Is(t) {
    var e = t.length;
    e > 2 && t[e - 1].equals(t[0]) && t.pop();
  }
  function Es(t, e) {
    for (var n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y);
  }
  function Ds(t, e) {
    bn.call(this),
      (this.type = 'ExtrudeGeometry'),
      (this.parameters = { shapes: t, options: e }),
      this.fromBufferGeometry(new Cs(t, e)),
      this.mergeVertices();
  }
  function Cs(t, e) {
    He.call(this),
      (this.type = 'ExtrudeBufferGeometry'),
      (this.parameters = { shapes: t, options: e }),
      (t = Array.isArray(t) ? t : [t]);
    for (var n = this, i = [], r = [], o = 0, s = t.length; o < s; o++) {
      a(t[o]);
    }
    function a(t) {
      var o = [],
        s = void 0 !== e.curveSegments ? e.curveSegments : 12,
        a = void 0 !== e.steps ? e.steps : 1,
        c = void 0 !== e.depth ? e.depth : 100,
        l = void 0 === e.bevelEnabled || e.bevelEnabled,
        h = void 0 !== e.bevelThickness ? e.bevelThickness : 6,
        u = void 0 !== e.bevelSize ? e.bevelSize : h - 2,
        d = void 0 !== e.bevelOffset ? e.bevelOffset : 0,
        p = void 0 !== e.bevelSegments ? e.bevelSegments : 3,
        f = e.extrudePath,
        m = void 0 !== e.UVGenerator ? e.UVGenerator : Ts;
      void 0 !== e.amount &&
        (console.warn(
          'THREE.ExtrudeBufferGeometry: amount has been renamed to depth.',
        ),
        (c = e.amount));
      var b,
        g,
        y,
        v,
        _,
        x,
        w,
        A,
        M = !1;
      f &&
        ((b = f.getSpacedPoints(a)),
        (M = !0),
        (l = !1),
        (g = f.computeFrenetFrames(a, !1)),
        (y = new J()),
        (v = new J()),
        (_ = new J())),
        l || ((p = 0), (h = 0), (u = 0), (d = 0));
      var S = t.extractPoints(s),
        I = S.shape,
        E = S.holes;
      if (!Ss.isClockWise(I))
        for (I = I.reverse(), w = 0, A = E.length; w < A; w++)
          (x = E[w]), Ss.isClockWise(x) && (E[w] = x.reverse());
      var D = Ss.triangulateShape(I, E),
        C = I;
      for (w = 0, A = E.length; w < A; w++) (x = E[w]), (I = I.concat(x));
      function T(t, e, n) {
        return (
          e || console.error('THREE.ExtrudeGeometry: vec does not exist'),
          e.clone().multiplyScalar(n).add(t)
        );
      }
      var L,
        R,
        F,
        P,
        B,
        O,
        V = I.length,
        N = D.length;
      function k(t, e, n) {
        var i,
          r,
          o,
          s = t.x - e.x,
          a = t.y - e.y,
          c = n.x - t.x,
          l = n.y - t.y,
          h = s * s + a * a,
          u = s * l - a * c;
        if (Math.abs(u) > Number.EPSILON) {
          var d = Math.sqrt(h),
            p = Math.sqrt(c * c + l * l),
            f = e.x - a / d,
            m = e.y + s / d,
            b =
              ((n.x - l / p - f) * l - (n.y + c / p - m) * c) / (s * l - a * c),
            g = (i = f + s * b - t.x) * i + (r = m + a * b - t.y) * r;
          if (g <= 2) return new U(i, r);
          o = Math.sqrt(g / 2);
        } else {
          var y = !1;
          s > Number.EPSILON
            ? c > Number.EPSILON && (y = !0)
            : s < -Number.EPSILON
            ? c < -Number.EPSILON && (y = !0)
            : Math.sign(a) === Math.sign(l) && (y = !0),
            y
              ? ((i = -a), (r = s), (o = Math.sqrt(h)))
              : ((i = s), (r = a), (o = Math.sqrt(h / 2)));
        }
        return new U(i / o, r / o);
      }
      for (
        var G = [], z = 0, j = C.length, H = j - 1, W = z + 1;
        z < j;
        z++, H++, W++
      )
        H === j && (H = 0), W === j && (W = 0), (G[z] = k(C[z], C[H], C[W]));
      var X,
        Z,
        Y = [],
        q = G.concat();
      for (w = 0, A = E.length; w < A; w++) {
        for (
          x = E[w], X = [], z = 0, H = (j = x.length) - 1, W = z + 1;
          z < j;
          z++, H++, W++
        )
          H === j && (H = 0), W === j && (W = 0), (X[z] = k(x[z], x[H], x[W]));
        Y.push(X), (q = q.concat(X));
      }
      for (L = 0; L < p; L++) {
        for (
          F = L / p,
            P = h * Math.cos((F * Math.PI) / 2),
            R = u * Math.sin((F * Math.PI) / 2) + d,
            z = 0,
            j = C.length;
          z < j;
          z++
        )
          $((B = T(C[z], G[z], R)).x, B.y, -P);
        for (w = 0, A = E.length; w < A; w++)
          for (x = E[w], X = Y[w], z = 0, j = x.length; z < j; z++)
            $((B = T(x[z], X[z], R)).x, B.y, -P);
      }
      for (R = u + d, z = 0; z < V; z++)
        (B = l ? T(I[z], q[z], R) : I[z]),
          M
            ? (v.copy(g.normals[0]).multiplyScalar(B.x),
              y.copy(g.binormals[0]).multiplyScalar(B.y),
              _.copy(b[0]).add(v).add(y),
              $(_.x, _.y, _.z))
            : $(B.x, B.y, 0);
      for (Z = 1; Z <= a; Z++)
        for (z = 0; z < V; z++)
          (B = l ? T(I[z], q[z], R) : I[z]),
            M
              ? (v.copy(g.normals[Z]).multiplyScalar(B.x),
                y.copy(g.binormals[Z]).multiplyScalar(B.y),
                _.copy(b[Z]).add(v).add(y),
                $(_.x, _.y, _.z))
              : $(B.x, B.y, (c / a) * Z);
      for (L = p - 1; L >= 0; L--) {
        for (
          F = L / p,
            P = h * Math.cos((F * Math.PI) / 2),
            R = u * Math.sin((F * Math.PI) / 2) + d,
            z = 0,
            j = C.length;
          z < j;
          z++
        )
          $((B = T(C[z], G[z], R)).x, B.y, c + P);
        for (w = 0, A = E.length; w < A; w++)
          for (x = E[w], X = Y[w], z = 0, j = x.length; z < j; z++)
            (B = T(x[z], X[z], R)),
              M ? $(B.x, B.y + b[a - 1].y, b[a - 1].x + P) : $(B.x, B.y, c + P);
      }
      function Q(t, e) {
        var n, i;
        for (z = t.length; --z >= 0; ) {
          (n = z), (i = z - 1) < 0 && (i = t.length - 1);
          var r = 0,
            o = a + 2 * p;
          for (r = 0; r < o; r++) {
            var s = V * r,
              c = V * (r + 1);
            tt(e + n + s, e + i + s, e + i + c, e + n + c);
          }
        }
      }
      function $(t, e, n) {
        o.push(t), o.push(e), o.push(n);
      }
      function K(t, e, r) {
        et(t), et(e), et(r);
        var o = i.length / 3,
          s = m.generateTopUV(n, i, o - 3, o - 2, o - 1);
        nt(s[0]), nt(s[1]), nt(s[2]);
      }
      function tt(t, e, r, o) {
        et(t), et(e), et(o), et(e), et(r), et(o);
        var s = i.length / 3,
          a = m.generateSideWallUV(n, i, s - 6, s - 3, s - 2, s - 1);
        nt(a[0]), nt(a[1]), nt(a[3]), nt(a[1]), nt(a[2]), nt(a[3]);
      }
      function et(t) {
        i.push(o[3 * t + 0]), i.push(o[3 * t + 1]), i.push(o[3 * t + 2]);
      }
      function nt(t) {
        r.push(t.x), r.push(t.y);
      }
      !(function () {
        var t = i.length / 3;
        if (l) {
          var e = 0,
            r = V * e;
          for (z = 0; z < N; z++) K((O = D[z])[2] + r, O[1] + r, O[0] + r);
          for (r = V * (e = a + 2 * p), z = 0; z < N; z++)
            K((O = D[z])[0] + r, O[1] + r, O[2] + r);
        } else {
          for (z = 0; z < N; z++) K((O = D[z])[2], O[1], O[0]);
          for (z = 0; z < N; z++)
            K((O = D[z])[0] + V * a, O[1] + V * a, O[2] + V * a);
        }
        n.addGroup(t, i.length / 3 - t, 0);
      })(),
        (function () {
          var t = i.length / 3,
            e = 0;
          for (Q(C, e), e += C.length, w = 0, A = E.length; w < A; w++)
            Q((x = E[w]), e), (e += x.length);
          n.addGroup(t, i.length / 3 - t, 1);
        })();
    }
    this.setAttribute('position', new Re(i, 3)),
      this.setAttribute('uv', new Re(r, 2)),
      this.computeVertexNormals();
  }
  (Ds.prototype = Object.create(bn.prototype)),
    (Ds.prototype.constructor = Ds),
    (Ds.prototype.toJSON = function () {
      var t = bn.prototype.toJSON.call(this);
      return Ls(this.parameters.shapes, this.parameters.options, t);
    }),
    (Cs.prototype = Object.create(He.prototype)),
    (Cs.prototype.constructor = Cs),
    (Cs.prototype.toJSON = function () {
      var t = He.prototype.toJSON.call(this);
      return Ls(this.parameters.shapes, this.parameters.options, t);
    });
  var Ts = {
    generateTopUV: function (t, e, n, i, r) {
      var o = e[3 * n],
        s = e[3 * n + 1],
        a = e[3 * i],
        c = e[3 * i + 1],
        l = e[3 * r],
        h = e[3 * r + 1];
      return [new U(o, s), new U(a, c), new U(l, h)];
    },
    generateSideWallUV: function (t, e, n, i, r, o) {
      var s = e[3 * n],
        a = e[3 * n + 1],
        c = e[3 * n + 2],
        l = e[3 * i],
        h = e[3 * i + 1],
        u = e[3 * i + 2],
        d = e[3 * r],
        p = e[3 * r + 1],
        f = e[3 * r + 2],
        m = e[3 * o],
        b = e[3 * o + 1],
        g = e[3 * o + 2];
      return Math.abs(a - h) < 0.01
        ? [new U(s, 1 - c), new U(l, 1 - u), new U(d, 1 - f), new U(m, 1 - g)]
        : [new U(a, 1 - c), new U(h, 1 - u), new U(p, 1 - f), new U(b, 1 - g)];
    },
  };
  function Ls(t, e, n) {
    if (((n.shapes = []), Array.isArray(t)))
      for (var i = 0, r = t.length; i < r; i++) {
        var o = t[i];
        n.shapes.push(o.uuid);
      }
    else n.shapes.push(t.uuid);
    return (
      void 0 !== e.extrudePath &&
        (n.options.extrudePath = e.extrudePath.toJSON()),
      n
    );
  }
  function Rs(t, e) {
    bn.call(this),
      (this.type = 'TextGeometry'),
      (this.parameters = { text: t, parameters: e }),
      this.fromBufferGeometry(new Fs(t, e)),
      this.mergeVertices();
  }
  function Fs(t, e) {
    var n = (e = e || {}).font;
    if (!n || !n.isFont)
      return (
        console.error(
          'THREE.TextGeometry: font parameter is not an instance of THREE.Font.',
        ),
        new bn()
      );
    var i = n.generateShapes(t, e.size);
    (e.depth = void 0 !== e.height ? e.height : 50),
      void 0 === e.bevelThickness && (e.bevelThickness = 10),
      void 0 === e.bevelSize && (e.bevelSize = 8),
      void 0 === e.bevelEnabled && (e.bevelEnabled = !1),
      Cs.call(this, i, e),
      (this.type = 'TextBufferGeometry');
  }
  function Ps(t, e, n, i, r, o, s) {
    bn.call(this),
      (this.type = 'SphereGeometry'),
      (this.parameters = {
        radius: t,
        widthSegments: e,
        heightSegments: n,
        phiStart: i,
        phiLength: r,
        thetaStart: o,
        thetaLength: s,
      }),
      this.fromBufferGeometry(new Bs(t, e, n, i, r, o, s)),
      this.mergeVertices();
  }
  function Bs(t, e, n, i, r, o, s) {
    He.call(this),
      (this.type = 'SphereBufferGeometry'),
      (this.parameters = {
        radius: t,
        widthSegments: e,
        heightSegments: n,
        phiStart: i,
        phiLength: r,
        thetaStart: o,
        thetaLength: s,
      }),
      (t = t || 1),
      (e = Math.max(3, Math.floor(e) || 8)),
      (n = Math.max(2, Math.floor(n) || 6)),
      (i = void 0 !== i ? i : 0),
      (r = void 0 !== r ? r : 2 * Math.PI),
      (o = void 0 !== o ? o : 0),
      (s = void 0 !== s ? s : Math.PI);
    var a,
      c,
      l = Math.min(o + s, Math.PI),
      h = 0,
      u = [],
      d = new J(),
      p = new J(),
      f = [],
      m = [],
      b = [],
      g = [];
    for (c = 0; c <= n; c++) {
      var y = [],
        v = c / n,
        _ = 0;
      for (
        0 == c && 0 == o
          ? (_ = 0.5 / e)
          : c == n && l == Math.PI && (_ = -0.5 / e),
          a = 0;
        a <= e;
        a++
      ) {
        var x = a / e;
        (d.x = -t * Math.cos(i + x * r) * Math.sin(o + v * s)),
          (d.y = t * Math.cos(o + v * s)),
          (d.z = t * Math.sin(i + x * r) * Math.sin(o + v * s)),
          m.push(d.x, d.y, d.z),
          p.copy(d).normalize(),
          b.push(p.x, p.y, p.z),
          g.push(x + _, 1 - v),
          y.push(h++);
      }
      u.push(y);
    }
    for (c = 0; c < n; c++)
      for (a = 0; a < e; a++) {
        var w = u[c][a + 1],
          A = u[c][a],
          M = u[c + 1][a],
          S = u[c + 1][a + 1];
        (0 !== c || o > 0) && f.push(w, A, S),
          (c !== n - 1 || l < Math.PI) && f.push(A, M, S);
      }
    this.setIndex(f),
      this.setAttribute('position', new Re(m, 3)),
      this.setAttribute('normal', new Re(b, 3)),
      this.setAttribute('uv', new Re(g, 2));
  }
  function Os(t, e, n, i, r, o) {
    bn.call(this),
      (this.type = 'RingGeometry'),
      (this.parameters = {
        innerRadius: t,
        outerRadius: e,
        thetaSegments: n,
        phiSegments: i,
        thetaStart: r,
        thetaLength: o,
      }),
      this.fromBufferGeometry(new Vs(t, e, n, i, r, o)),
      this.mergeVertices();
  }
  function Vs(t, e, n, i, r, o) {
    He.call(this),
      (this.type = 'RingBufferGeometry'),
      (this.parameters = {
        innerRadius: t,
        outerRadius: e,
        thetaSegments: n,
        phiSegments: i,
        thetaStart: r,
        thetaLength: o,
      }),
      (t = t || 0.5),
      (e = e || 1),
      (r = void 0 !== r ? r : 0),
      (o = void 0 !== o ? o : 2 * Math.PI),
      (n = void 0 !== n ? Math.max(3, n) : 8);
    var s,
      a,
      c,
      l = [],
      h = [],
      u = [],
      d = [],
      p = t,
      f = (e - t) / (i = void 0 !== i ? Math.max(1, i) : 1),
      m = new J(),
      b = new U();
    for (a = 0; a <= i; a++) {
      for (c = 0; c <= n; c++)
        (s = r + (c / n) * o),
          (m.x = p * Math.cos(s)),
          (m.y = p * Math.sin(s)),
          h.push(m.x, m.y, m.z),
          u.push(0, 0, 1),
          (b.x = (m.x / e + 1) / 2),
          (b.y = (m.y / e + 1) / 2),
          d.push(b.x, b.y);
      p += f;
    }
    for (a = 0; a < i; a++) {
      var g = a * (n + 1);
      for (c = 0; c < n; c++) {
        var y = (s = c + g),
          v = s + n + 1,
          _ = s + n + 2,
          x = s + 1;
        l.push(y, v, x), l.push(v, _, x);
      }
    }
    this.setIndex(l),
      this.setAttribute('position', new Re(h, 3)),
      this.setAttribute('normal', new Re(u, 3)),
      this.setAttribute('uv', new Re(d, 2));
  }
  function Ns(t, e, n, i) {
    bn.call(this),
      (this.type = 'LatheGeometry'),
      (this.parameters = { points: t, segments: e, phiStart: n, phiLength: i }),
      this.fromBufferGeometry(new ks(t, e, n, i)),
      this.mergeVertices();
  }
  function ks(t, e, n, i) {
    He.call(this),
      (this.type = 'LatheBufferGeometry'),
      (this.parameters = { points: t, segments: e, phiStart: n, phiLength: i }),
      (e = Math.floor(e) || 12),
      (n = n || 0),
      (i = i || 2 * Math.PI),
      (i = k.clamp(i, 0, 2 * Math.PI));
    var r,
      o,
      s,
      a = [],
      c = [],
      l = [],
      h = 1 / e,
      u = new J(),
      d = new U();
    for (o = 0; o <= e; o++) {
      var p = n + o * h * i,
        f = Math.sin(p),
        m = Math.cos(p);
      for (s = 0; s <= t.length - 1; s++)
        (u.x = t[s].x * f),
          (u.y = t[s].y),
          (u.z = t[s].x * m),
          c.push(u.x, u.y, u.z),
          (d.x = o / e),
          (d.y = s / (t.length - 1)),
          l.push(d.x, d.y);
    }
    for (o = 0; o < e; o++)
      for (s = 0; s < t.length - 1; s++) {
        var b = (r = s + o * t.length),
          g = r + t.length,
          y = r + t.length + 1,
          v = r + 1;
        a.push(b, g, v), a.push(g, y, v);
      }
    if (
      (this.setIndex(a),
      this.setAttribute('position', new Re(c, 3)),
      this.setAttribute('uv', new Re(l, 2)),
      this.computeVertexNormals(),
      i === 2 * Math.PI)
    ) {
      var _ = this.attributes.normal.array,
        x = new J(),
        w = new J(),
        A = new J();
      for (r = e * t.length * 3, o = 0, s = 0; o < t.length; o++, s += 3)
        (x.x = _[s + 0]),
          (x.y = _[s + 1]),
          (x.z = _[s + 2]),
          (w.x = _[r + s + 0]),
          (w.y = _[r + s + 1]),
          (w.z = _[r + s + 2]),
          A.addVectors(x, w).normalize(),
          (_[s + 0] = _[r + s + 0] = A.x),
          (_[s + 1] = _[r + s + 1] = A.y),
          (_[s + 2] = _[r + s + 2] = A.z);
    }
  }
  function Us(t, e) {
    bn.call(this),
      (this.type = 'ShapeGeometry'),
      'object' == typeof e &&
        (console.warn(
          'THREE.ShapeGeometry: Options parameter has been removed.',
        ),
        (e = e.curveSegments)),
      (this.parameters = { shapes: t, curveSegments: e }),
      this.fromBufferGeometry(new Gs(t, e)),
      this.mergeVertices();
  }
  function Gs(t, e) {
    He.call(this),
      (this.type = 'ShapeBufferGeometry'),
      (this.parameters = { shapes: t, curveSegments: e }),
      (e = e || 12);
    var n = [],
      i = [],
      r = [],
      o = [],
      s = 0,
      a = 0;
    if (!1 === Array.isArray(t)) l(t);
    else
      for (var c = 0; c < t.length; c++)
        l(t[c]), this.addGroup(s, a, c), (s += a), (a = 0);
    function l(t) {
      var s,
        c,
        l,
        h = i.length / 3,
        u = t.extractPoints(e),
        d = u.shape,
        p = u.holes;
      for (
        !1 === Ss.isClockWise(d) && (d = d.reverse()), s = 0, c = p.length;
        s < c;
        s++
      )
        (l = p[s]), !0 === Ss.isClockWise(l) && (p[s] = l.reverse());
      var f = Ss.triangulateShape(d, p);
      for (s = 0, c = p.length; s < c; s++) (l = p[s]), (d = d.concat(l));
      for (s = 0, c = d.length; s < c; s++) {
        var m = d[s];
        i.push(m.x, m.y, 0), r.push(0, 0, 1), o.push(m.x, m.y);
      }
      for (s = 0, c = f.length; s < c; s++) {
        var b = f[s],
          g = b[0] + h,
          y = b[1] + h,
          v = b[2] + h;
        n.push(g, y, v), (a += 3);
      }
    }
    this.setIndex(n),
      this.setAttribute('position', new Re(i, 3)),
      this.setAttribute('normal', new Re(r, 3)),
      this.setAttribute('uv', new Re(o, 2));
  }
  function zs(t, e) {
    if (((e.shapes = []), Array.isArray(t)))
      for (var n = 0, i = t.length; n < i; n++) {
        var r = t[n];
        e.shapes.push(r.uuid);
      }
    else e.shapes.push(t.uuid);
    return e;
  }
  function js(t, e) {
    He.call(this),
      (this.type = 'EdgesGeometry'),
      (this.parameters = { thresholdAngle: e }),
      (e = void 0 !== e ? e : 1);
    var n,
      i,
      r,
      o,
      s = [],
      a = Math.cos(k.DEG2RAD * e),
      c = [0, 0],
      l = {},
      h = ['a', 'b', 'c'];
    t.isBufferGeometry ? (o = new bn()).fromBufferGeometry(t) : (o = t.clone()),
      o.mergeVertices(),
      o.computeFaceNormals();
    for (var u = o.vertices, d = o.faces, p = 0, f = d.length; p < f; p++)
      for (var m = d[p], b = 0; b < 3; b++)
        (n = m[h[b]]),
          (i = m[h[(b + 1) % 3]]),
          (c[0] = Math.min(n, i)),
          (c[1] = Math.max(n, i)),
          void 0 === l[(r = c[0] + ',' + c[1])]
            ? (l[r] = { index1: c[0], index2: c[1], face1: p, face2: void 0 })
            : (l[r].face2 = p);
    for (r in l) {
      var g = l[r];
      if (void 0 === g.face2 || d[g.face1].normal.dot(d[g.face2].normal) <= a) {
        var y = u[g.index1];
        s.push(y.x, y.y, y.z), (y = u[g.index2]), s.push(y.x, y.y, y.z);
      }
    }
    this.setAttribute('position', new Re(s, 3));
  }
  function Hs(t, e, n, i, r, o, s, a) {
    bn.call(this),
      (this.type = 'CylinderGeometry'),
      (this.parameters = {
        radiusTop: t,
        radiusBottom: e,
        height: n,
        radialSegments: i,
        heightSegments: r,
        openEnded: o,
        thetaStart: s,
        thetaLength: a,
      }),
      this.fromBufferGeometry(new Ws(t, e, n, i, r, o, s, a)),
      this.mergeVertices();
  }
  function Ws(t, e, n, i, r, o, s, a) {
    He.call(this),
      (this.type = 'CylinderBufferGeometry'),
      (this.parameters = {
        radiusTop: t,
        radiusBottom: e,
        height: n,
        radialSegments: i,
        heightSegments: r,
        openEnded: o,
        thetaStart: s,
        thetaLength: a,
      });
    var c = this;
    (t = void 0 !== t ? t : 1),
      (e = void 0 !== e ? e : 1),
      (n = n || 1),
      (i = Math.floor(i) || 8),
      (r = Math.floor(r) || 1),
      (o = void 0 !== o && o),
      (s = void 0 !== s ? s : 0),
      (a = void 0 !== a ? a : 2 * Math.PI);
    var l = [],
      h = [],
      u = [],
      d = [],
      p = 0,
      f = [],
      m = n / 2,
      b = 0;
    function g(n) {
      var r,
        o,
        f,
        g = new U(),
        y = new J(),
        v = 0,
        _ = !0 === n ? t : e,
        x = !0 === n ? 1 : -1;
      for (o = p, r = 1; r <= i; r++)
        h.push(0, m * x, 0), u.push(0, x, 0), d.push(0.5, 0.5), p++;
      for (f = p, r = 0; r <= i; r++) {
        var w = (r / i) * a + s,
          A = Math.cos(w),
          M = Math.sin(w);
        (y.x = _ * M),
          (y.y = m * x),
          (y.z = _ * A),
          h.push(y.x, y.y, y.z),
          u.push(0, x, 0),
          (g.x = 0.5 * A + 0.5),
          (g.y = 0.5 * M * x + 0.5),
          d.push(g.x, g.y),
          p++;
      }
      for (r = 0; r < i; r++) {
        var S = o + r,
          I = f + r;
        !0 === n ? l.push(I, I + 1, S) : l.push(I + 1, I, S), (v += 3);
      }
      c.addGroup(b, v, !0 === n ? 1 : 2), (b += v);
    }
    !(function () {
      var o,
        g,
        y = new J(),
        v = new J(),
        _ = 0,
        x = (e - t) / n;
      for (g = 0; g <= r; g++) {
        var w = [],
          A = g / r,
          M = A * (e - t) + t;
        for (o = 0; o <= i; o++) {
          var S = o / i,
            I = S * a + s,
            E = Math.sin(I),
            D = Math.cos(I);
          (v.x = M * E),
            (v.y = -A * n + m),
            (v.z = M * D),
            h.push(v.x, v.y, v.z),
            y.set(E, x, D).normalize(),
            u.push(y.x, y.y, y.z),
            d.push(S, 1 - A),
            w.push(p++);
        }
        f.push(w);
      }
      for (o = 0; o < i; o++)
        for (g = 0; g < r; g++) {
          var C = f[g][o],
            T = f[g + 1][o],
            L = f[g + 1][o + 1],
            R = f[g][o + 1];
          l.push(C, T, R), l.push(T, L, R), (_ += 6);
        }
      c.addGroup(b, _, 0), (b += _);
    })(),
      !1 === o && (t > 0 && g(!0), e > 0 && g(!1)),
      this.setIndex(l),
      this.setAttribute('position', new Re(h, 3)),
      this.setAttribute('normal', new Re(u, 3)),
      this.setAttribute('uv', new Re(d, 2));
  }
  function Xs(t, e, n, i, r, o, s) {
    Hs.call(this, 0, t, e, n, i, r, o, s),
      (this.type = 'ConeGeometry'),
      (this.parameters = {
        radius: t,
        height: e,
        radialSegments: n,
        heightSegments: i,
        openEnded: r,
        thetaStart: o,
        thetaLength: s,
      });
  }
  function Zs(t, e, n, i, r, o, s) {
    Ws.call(this, 0, t, e, n, i, r, o, s),
      (this.type = 'ConeBufferGeometry'),
      (this.parameters = {
        radius: t,
        height: e,
        radialSegments: n,
        heightSegments: i,
        openEnded: r,
        thetaStart: o,
        thetaLength: s,
      });
  }
  function Ys(t, e, n, i) {
    bn.call(this),
      (this.type = 'CircleGeometry'),
      (this.parameters = {
        radius: t,
        segments: e,
        thetaStart: n,
        thetaLength: i,
      }),
      this.fromBufferGeometry(new qs(t, e, n, i)),
      this.mergeVertices();
  }
  function qs(t, e, n, i) {
    He.call(this),
      (this.type = 'CircleBufferGeometry'),
      (this.parameters = {
        radius: t,
        segments: e,
        thetaStart: n,
        thetaLength: i,
      }),
      (t = t || 1),
      (e = void 0 !== e ? Math.max(3, e) : 8),
      (n = void 0 !== n ? n : 0),
      (i = void 0 !== i ? i : 2 * Math.PI);
    var r,
      o,
      s = [],
      a = [],
      c = [],
      l = [],
      h = new J(),
      u = new U();
    for (
      a.push(0, 0, 0), c.push(0, 0, 1), l.push(0.5, 0.5), o = 0, r = 3;
      o <= e;
      o++, r += 3
    ) {
      var d = n + (o / e) * i;
      (h.x = t * Math.cos(d)),
        (h.y = t * Math.sin(d)),
        a.push(h.x, h.y, h.z),
        c.push(0, 0, 1),
        (u.x = (a[r] / t + 1) / 2),
        (u.y = (a[r + 1] / t + 1) / 2),
        l.push(u.x, u.y);
    }
    for (r = 1; r <= e; r++) s.push(r, r + 1, 0);
    this.setIndex(s),
      this.setAttribute('position', new Re(a, 3)),
      this.setAttribute('normal', new Re(c, 3)),
      this.setAttribute('uv', new Re(l, 2));
  }
  (Rs.prototype = Object.create(bn.prototype)),
    (Rs.prototype.constructor = Rs),
    (Fs.prototype = Object.create(Cs.prototype)),
    (Fs.prototype.constructor = Fs),
    (Ps.prototype = Object.create(bn.prototype)),
    (Ps.prototype.constructor = Ps),
    (Bs.prototype = Object.create(He.prototype)),
    (Bs.prototype.constructor = Bs),
    (Os.prototype = Object.create(bn.prototype)),
    (Os.prototype.constructor = Os),
    (Vs.prototype = Object.create(He.prototype)),
    (Vs.prototype.constructor = Vs),
    (Ns.prototype = Object.create(bn.prototype)),
    (Ns.prototype.constructor = Ns),
    (ks.prototype = Object.create(He.prototype)),
    (ks.prototype.constructor = ks),
    (Us.prototype = Object.create(bn.prototype)),
    (Us.prototype.constructor = Us),
    (Us.prototype.toJSON = function () {
      var t = bn.prototype.toJSON.call(this);
      return zs(this.parameters.shapes, t);
    }),
    (Gs.prototype = Object.create(He.prototype)),
    (Gs.prototype.constructor = Gs),
    (Gs.prototype.toJSON = function () {
      var t = He.prototype.toJSON.call(this);
      return zs(this.parameters.shapes, t);
    }),
    (js.prototype = Object.create(He.prototype)),
    (js.prototype.constructor = js),
    (Hs.prototype = Object.create(bn.prototype)),
    (Hs.prototype.constructor = Hs),
    (Ws.prototype = Object.create(He.prototype)),
    (Ws.prototype.constructor = Ws),
    (Xs.prototype = Object.create(Hs.prototype)),
    (Xs.prototype.constructor = Xs),
    (Zs.prototype = Object.create(Ws.prototype)),
    (Zs.prototype.constructor = Zs),
    (Ys.prototype = Object.create(bn.prototype)),
    (Ys.prototype.constructor = Ys),
    (qs.prototype = Object.create(He.prototype)),
    (qs.prototype.constructor = qs);
  var Qs = Object.freeze({
    __proto__: null,
    WireframeGeometry: No,
    ParametricGeometry: ko,
    ParametricBufferGeometry: Uo,
    TetrahedronGeometry: jo,
    TetrahedronBufferGeometry: Ho,
    OctahedronGeometry: Wo,
    OctahedronBufferGeometry: Xo,
    IcosahedronGeometry: Zo,
    IcosahedronBufferGeometry: Yo,
    DodecahedronGeometry: qo,
    DodecahedronBufferGeometry: Qo,
    PolyhedronGeometry: Go,
    PolyhedronBufferGeometry: zo,
    TubeGeometry: Jo,
    TubeBufferGeometry: $o,
    TorusKnotGeometry: Ko,
    TorusKnotBufferGeometry: ts,
    TorusGeometry: es,
    TorusBufferGeometry: ns,
    TextGeometry: Rs,
    TextBufferGeometry: Fs,
    SphereGeometry: Ps,
    SphereBufferGeometry: Bs,
    RingGeometry: Os,
    RingBufferGeometry: Vs,
    PlaneGeometry: Bn,
    PlaneBufferGeometry: On,
    LatheGeometry: Ns,
    LatheBufferGeometry: ks,
    ShapeGeometry: Us,
    ShapeBufferGeometry: Gs,
    ExtrudeGeometry: Ds,
    ExtrudeBufferGeometry: Cs,
    EdgesGeometry: js,
    ConeGeometry: Xs,
    ConeBufferGeometry: Zs,
    CylinderGeometry: Hs,
    CylinderBufferGeometry: Ws,
    CircleGeometry: Ys,
    CircleBufferGeometry: qs,
    BoxGeometry: gn,
    BoxBufferGeometry: yn,
  });
  function Js(t) {
    _e.call(this),
      (this.type = 'ShadowMaterial'),
      (this.color = new fe(0)),
      (this.transparent = !0),
      this.setValues(t);
  }
  function $s(t) {
    wn.call(this, t), (this.type = 'RawShaderMaterial');
  }
  function Ks(t) {
    _e.call(this),
      (this.defines = { STANDARD: '' }),
      (this.type = 'MeshStandardMaterial'),
      (this.color = new fe(16777215)),
      (this.roughness = 1),
      (this.metalness = 0),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new fe(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = 0),
      (this.normalScale = new U(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.roughnessMap = null),
      (this.metalnessMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapIntensity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = 'round'),
      (this.wireframeLinejoin = 'round'),
      (this.skinning = !1),
      (this.morphTargets = !1),
      (this.morphNormals = !1),
      (this.vertexTangents = !1),
      this.setValues(t);
  }
  function ta(t) {
    Ks.call(this),
      (this.defines = { STANDARD: '', PHYSICAL: '' }),
      (this.type = 'MeshPhysicalMaterial'),
      (this.clearcoat = 0),
      (this.clearcoatMap = null),
      (this.clearcoatRoughness = 0),
      (this.clearcoatRoughnessMap = null),
      (this.clearcoatNormalScale = new U(1, 1)),
      (this.clearcoatNormalMap = null),
      (this.reflectivity = 0.5),
      (this.sheen = null),
      (this.transparency = 0),
      this.setValues(t);
  }
  function ea(t) {
    _e.call(this),
      (this.type = 'MeshPhongMaterial'),
      (this.color = new fe(16777215)),
      (this.specular = new fe(1118481)),
      (this.shininess = 30),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new fe(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = 0),
      (this.normalScale = new U(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = 0),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = 'round'),
      (this.wireframeLinejoin = 'round'),
      (this.skinning = !1),
      (this.morphTargets = !1),
      (this.morphNormals = !1),
      this.setValues(t);
  }
  function na(t) {
    _e.call(this),
      (this.defines = { TOON: '' }),
      (this.type = 'MeshToonMaterial'),
      (this.color = new fe(16777215)),
      (this.specular = new fe(1118481)),
      (this.shininess = 30),
      (this.map = null),
      (this.gradientMap = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new fe(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = 0),
      (this.normalScale = new U(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = 'round'),
      (this.wireframeLinejoin = 'round'),
      (this.skinning = !1),
      (this.morphTargets = !1),
      (this.morphNormals = !1),
      this.setValues(t);
  }
  function ia(t) {
    _e.call(this),
      (this.type = 'MeshNormalMaterial'),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = 0),
      (this.normalScale = new U(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.skinning = !1),
      (this.morphTargets = !1),
      (this.morphNormals = !1),
      this.setValues(t);
  }
  function ra(t) {
    _e.call(this),
      (this.type = 'MeshLambertMaterial'),
      (this.color = new fe(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new fe(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = 0),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = 'round'),
      (this.wireframeLinejoin = 'round'),
      (this.skinning = !1),
      (this.morphTargets = !1),
      (this.morphNormals = !1),
      this.setValues(t);
  }
  function oa(t) {
    _e.call(this),
      (this.type = 'CenterLineCylinderMaterial'),
      (this.color = new fe(16777215)),
      (this.combine = 0),
      (this.clipping = !0),
      (this.needOffsetZ = !1),
      this.setValues(t);
  }
  function sa(t) {
    _e.call(this),
      (this.defines = { MATCAP: '' }),
      (this.type = 'MeshMatcapMaterial'),
      (this.color = new fe(16777215)),
      (this.matcap = null),
      (this.map = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = 0),
      (this.normalScale = new U(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.skinning = !1),
      (this.morphTargets = !1),
      (this.morphNormals = !1),
      this.setValues(t);
  }
  function aa(t) {
    bo.call(this),
      (this.type = 'LineDashedMaterial'),
      (this.scale = 1),
      (this.dashSize = 3),
      (this.gapSize = 1),
      this.setValues(t);
  }
  (Js.prototype = Object.create(_e.prototype)),
    (Js.prototype.constructor = Js),
    (Js.prototype.isShadowMaterial = !0),
    (Js.prototype.copy = function (t) {
      return _e.prototype.copy.call(this, t), this.color.copy(t.color), this;
    }),
    ($s.prototype = Object.create(wn.prototype)),
    ($s.prototype.constructor = $s),
    ($s.prototype.isRawShaderMaterial = !0),
    (Ks.prototype = Object.create(_e.prototype)),
    (Ks.prototype.constructor = Ks),
    (Ks.prototype.isMeshStandardMaterial = !0),
    (Ks.prototype.copy = function (t) {
      return (
        _e.prototype.copy.call(this, t),
        (this.defines = { STANDARD: '' }),
        this.color.copy(t.color),
        (this.roughness = t.roughness),
        (this.metalness = t.metalness),
        (this.map = t.map),
        (this.lightMap = t.lightMap),
        (this.lightMapIntensity = t.lightMapIntensity),
        (this.aoMap = t.aoMap),
        (this.aoMapIntensity = t.aoMapIntensity),
        this.emissive.copy(t.emissive),
        (this.emissiveMap = t.emissiveMap),
        (this.emissiveIntensity = t.emissiveIntensity),
        (this.bumpMap = t.bumpMap),
        (this.bumpScale = t.bumpScale),
        (this.normalMap = t.normalMap),
        (this.normalMapType = t.normalMapType),
        this.normalScale.copy(t.normalScale),
        (this.displacementMap = t.displacementMap),
        (this.displacementScale = t.displacementScale),
        (this.displacementBias = t.displacementBias),
        (this.roughnessMap = t.roughnessMap),
        (this.metalnessMap = t.metalnessMap),
        (this.alphaMap = t.alphaMap),
        (this.envMap = t.envMap),
        (this.envMapIntensity = t.envMapIntensity),
        (this.refractionRatio = t.refractionRatio),
        (this.wireframe = t.wireframe),
        (this.wireframeLinewidth = t.wireframeLinewidth),
        (this.wireframeLinecap = t.wireframeLinecap),
        (this.wireframeLinejoin = t.wireframeLinejoin),
        (this.skinning = t.skinning),
        (this.morphTargets = t.morphTargets),
        (this.morphNormals = t.morphNormals),
        (this.vertexTangents = t.vertexTangents),
        this
      );
    }),
    (ta.prototype = Object.create(Ks.prototype)),
    (ta.prototype.constructor = ta),
    (ta.prototype.isMeshPhysicalMaterial = !0),
    (ta.prototype.copy = function (t) {
      return (
        Ks.prototype.copy.call(this, t),
        (this.defines = { STANDARD: '', PHYSICAL: '' }),
        (this.clearcoat = t.clearcoat),
        (this.clearcoatMap = t.clearcoatMap),
        (this.clearcoatRoughness = t.clearcoatRoughness),
        (this.clearcoatRoughnessMap = t.clearcoatRoughnessMap),
        (this.clearcoatNormalMap = t.clearcoatNormalMap),
        this.clearcoatNormalScale.copy(t.clearcoatNormalScale),
        (this.reflectivity = t.reflectivity),
        t.sheen
          ? (this.sheen = (this.sheen || new fe()).copy(t.sheen))
          : (this.sheen = null),
        (this.transparency = t.transparency),
        this
      );
    }),
    (ea.prototype = Object.create(_e.prototype)),
    (ea.prototype.constructor = ea),
    (ea.prototype.isMeshPhongMaterial = !0),
    (ea.prototype.copy = function (t) {
      return (
        _e.prototype.copy.call(this, t),
        this.color.copy(t.color),
        this.specular.copy(t.specular),
        (this.shininess = t.shininess),
        (this.map = t.map),
        (this.lightMap = t.lightMap),
        (this.lightMapIntensity = t.lightMapIntensity),
        (this.aoMap = t.aoMap),
        (this.aoMapIntensity = t.aoMapIntensity),
        this.emissive.copy(t.emissive),
        (this.emissiveMap = t.emissiveMap),
        (this.emissiveIntensity = t.emissiveIntensity),
        (this.bumpMap = t.bumpMap),
        (this.bumpScale = t.bumpScale),
        (this.normalMap = t.normalMap),
        (this.normalMapType = t.normalMapType),
        this.normalScale.copy(t.normalScale),
        (this.displacementMap = t.displacementMap),
        (this.displacementScale = t.displacementScale),
        (this.displacementBias = t.displacementBias),
        (this.specularMap = t.specularMap),
        (this.alphaMap = t.alphaMap),
        (this.envMap = t.envMap),
        (this.combine = t.combine),
        (this.reflectivity = t.reflectivity),
        (this.refractionRatio = t.refractionRatio),
        (this.wireframe = t.wireframe),
        (this.wireframeLinewidth = t.wireframeLinewidth),
        (this.wireframeLinecap = t.wireframeLinecap),
        (this.wireframeLinejoin = t.wireframeLinejoin),
        (this.skinning = t.skinning),
        (this.morphTargets = t.morphTargets),
        (this.morphNormals = t.morphNormals),
        this
      );
    }),
    (na.prototype = Object.create(_e.prototype)),
    (na.prototype.constructor = na),
    (na.prototype.isMeshToonMaterial = !0),
    (na.prototype.copy = function (t) {
      return (
        _e.prototype.copy.call(this, t),
        this.color.copy(t.color),
        this.specular.copy(t.specular),
        (this.shininess = t.shininess),
        (this.map = t.map),
        (this.gradientMap = t.gradientMap),
        (this.lightMap = t.lightMap),
        (this.lightMapIntensity = t.lightMapIntensity),
        (this.aoMap = t.aoMap),
        (this.aoMapIntensity = t.aoMapIntensity),
        this.emissive.copy(t.emissive),
        (this.emissiveMap = t.emissiveMap),
        (this.emissiveIntensity = t.emissiveIntensity),
        (this.bumpMap = t.bumpMap),
        (this.bumpScale = t.bumpScale),
        (this.normalMap = t.normalMap),
        (this.normalMapType = t.normalMapType),
        this.normalScale.copy(t.normalScale),
        (this.displacementMap = t.displacementMap),
        (this.displacementScale = t.displacementScale),
        (this.displacementBias = t.displacementBias),
        (this.specularMap = t.specularMap),
        (this.alphaMap = t.alphaMap),
        (this.wireframe = t.wireframe),
        (this.wireframeLinewidth = t.wireframeLinewidth),
        (this.wireframeLinecap = t.wireframeLinecap),
        (this.wireframeLinejoin = t.wireframeLinejoin),
        (this.skinning = t.skinning),
        (this.morphTargets = t.morphTargets),
        (this.morphNormals = t.morphNormals),
        this
      );
    }),
    (ia.prototype = Object.create(_e.prototype)),
    (ia.prototype.constructor = ia),
    (ia.prototype.isMeshNormalMaterial = !0),
    (ia.prototype.copy = function (t) {
      return (
        _e.prototype.copy.call(this, t),
        (this.bumpMap = t.bumpMap),
        (this.bumpScale = t.bumpScale),
        (this.normalMap = t.normalMap),
        (this.normalMapType = t.normalMapType),
        this.normalScale.copy(t.normalScale),
        (this.displacementMap = t.displacementMap),
        (this.displacementScale = t.displacementScale),
        (this.displacementBias = t.displacementBias),
        (this.wireframe = t.wireframe),
        (this.wireframeLinewidth = t.wireframeLinewidth),
        (this.skinning = t.skinning),
        (this.morphTargets = t.morphTargets),
        (this.morphNormals = t.morphNormals),
        this
      );
    }),
    (ra.prototype = Object.create(_e.prototype)),
    (ra.prototype.constructor = ra),
    (ra.prototype.isMeshLambertMaterial = !0),
    (ra.prototype.copy = function (t) {
      return (
        _e.prototype.copy.call(this, t),
        this.color.copy(t.color),
        (this.map = t.map),
        (this.lightMap = t.lightMap),
        (this.lightMapIntensity = t.lightMapIntensity),
        (this.aoMap = t.aoMap),
        (this.aoMapIntensity = t.aoMapIntensity),
        this.emissive.copy(t.emissive),
        (this.emissiveMap = t.emissiveMap),
        (this.emissiveIntensity = t.emissiveIntensity),
        (this.specularMap = t.specularMap),
        (this.alphaMap = t.alphaMap),
        (this.envMap = t.envMap),
        (this.combine = t.combine),
        (this.reflectivity = t.reflectivity),
        (this.refractionRatio = t.refractionRatio),
        (this.wireframe = t.wireframe),
        (this.wireframeLinewidth = t.wireframeLinewidth),
        (this.wireframeLinecap = t.wireframeLinecap),
        (this.wireframeLinejoin = t.wireframeLinejoin),
        (this.skinning = t.skinning),
        (this.morphTargets = t.morphTargets),
        (this.morphNormals = t.morphNormals),
        this
      );
    }),
    (oa.prototype = Object.assign(Object.create(_e.prototype), {
      constructor: oa,
      isCenterLineCylinderMaterial: !0,
      isRawShaderMaterial: !0,
      copy: function (t) {
        return (
          _e.prototype.copy.call(this, t),
          this.color.copy(t.color),
          (this.combine = t.combine),
          this
        );
      },
    })),
    (sa.prototype = Object.create(_e.prototype)),
    (sa.prototype.constructor = sa),
    (sa.prototype.isMeshMatcapMaterial = !0),
    (sa.prototype.copy = function (t) {
      return (
        _e.prototype.copy.call(this, t),
        (this.defines = { MATCAP: '' }),
        this.color.copy(t.color),
        (this.matcap = t.matcap),
        (this.map = t.map),
        (this.bumpMap = t.bumpMap),
        (this.bumpScale = t.bumpScale),
        (this.normalMap = t.normalMap),
        (this.normalMapType = t.normalMapType),
        this.normalScale.copy(t.normalScale),
        (this.displacementMap = t.displacementMap),
        (this.displacementScale = t.displacementScale),
        (this.displacementBias = t.displacementBias),
        (this.alphaMap = t.alphaMap),
        (this.skinning = t.skinning),
        (this.morphTargets = t.morphTargets),
        (this.morphNormals = t.morphNormals),
        this
      );
    }),
    (aa.prototype = Object.create(bo.prototype)),
    (aa.prototype.constructor = aa),
    (aa.prototype.isLineDashedMaterial = !0),
    (aa.prototype.copy = function (t) {
      return (
        bo.prototype.copy.call(this, t),
        (this.scale = t.scale),
        (this.dashSize = t.dashSize),
        (this.gapSize = t.gapSize),
        this
      );
    });
  var ca = Object.freeze({
      __proto__: null,
      ShadowMaterial: Js,
      SpriteMaterial: Gr,
      RawShaderMaterial: $s,
      ShaderMaterial: wn,
      PointsMaterial: Eo,
      MeshPhysicalMaterial: ta,
      MeshStandardMaterial: Ks,
      MeshPhongMaterial: ea,
      MeshToonMaterial: na,
      MeshNormalMaterial: ia,
      MeshLambertMaterial: ra,
      MeshDepthMaterial: Sr,
      MeshDistanceMaterial: Ir,
      MeshBasicMaterial: xe,
      CenterLineCylinderMaterial: oa,
      MeshMatcapMaterial: sa,
      LineDashedMaterial: aa,
      LineBasicMaterial: bo,
      Material: _e,
    }),
    la = {
      arraySlice: function (t, e, n) {
        return la.isTypedArray(t)
          ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length))
          : t.slice(e, n);
      },
      convertArray: function (t, e, n) {
        return !t || (!n && t.constructor === e)
          ? t
          : 'number' == typeof e.BYTES_PER_ELEMENT
          ? new e(t)
          : Array.prototype.slice.call(t);
      },
      isTypedArray: function (t) {
        return ArrayBuffer.isView(t) && !(t instanceof DataView);
      },
      getKeyframeOrder: function (t) {
        for (var e = t.length, n = new Array(e), i = 0; i !== e; ++i) n[i] = i;
        return (
          n.sort(function (e, n) {
            return t[e] - t[n];
          }),
          n
        );
      },
      sortedArray: function (t, e, n) {
        for (
          var i = t.length, r = new t.constructor(i), o = 0, s = 0;
          s !== i;
          ++o
        )
          for (var a = n[o] * e, c = 0; c !== e; ++c) r[s++] = t[a + c];
        return r;
      },
      flattenJSON: function (t, e, n, i) {
        for (var r = 1, o = t[0]; void 0 !== o && void 0 === o[i]; ) o = t[r++];
        if (void 0 !== o) {
          var s = o[i];
          if (void 0 !== s)
            if (Array.isArray(s))
              do {
                void 0 !== (s = o[i]) && (e.push(o.time), n.push.apply(n, s)),
                  (o = t[r++]);
              } while (void 0 !== o);
            else if (void 0 !== s.toArray)
              do {
                void 0 !== (s = o[i]) &&
                  (e.push(o.time), s.toArray(n, n.length)),
                  (o = t[r++]);
              } while (void 0 !== o);
            else
              do {
                void 0 !== (s = o[i]) && (e.push(o.time), n.push(s)),
                  (o = t[r++]);
              } while (void 0 !== o);
        }
      },
      subclip: function (t, e, n, i, r) {
        r = r || 30;
        var o = t.clone();
        o.name = e;
        for (var s = [], a = 0; a < o.tracks.length; ++a) {
          for (
            var c = o.tracks[a], l = c.getValueSize(), h = [], u = [], d = 0;
            d < c.times.length;
            ++d
          ) {
            var p = c.times[d] * r;
            if (!(p < n || p >= i)) {
              h.push(c.times[d]);
              for (var f = 0; f < l; ++f) u.push(c.values[d * l + f]);
            }
          }
          0 !== h.length &&
            ((c.times = la.convertArray(h, c.times.constructor)),
            (c.values = la.convertArray(u, c.values.constructor)),
            s.push(c));
        }
        o.tracks = s;
        var m = 1 / 0;
        for (a = 0; a < o.tracks.length; ++a)
          m > o.tracks[a].times[0] && (m = o.tracks[a].times[0]);
        for (a = 0; a < o.tracks.length; ++a) o.tracks[a].shift(-1 * m);
        return o.resetDuration(), o;
      },
    };
  function ha(t, e, n, i) {
    (this.parameterPositions = t),
      (this._cachedIndex = 0),
      (this.resultBuffer = void 0 !== i ? i : new e.constructor(n)),
      (this.sampleValues = e),
      (this.valueSize = n);
  }
  function ua(t, e, n, i) {
    ha.call(this, t, e, n, i),
      (this._weightPrev = -0),
      (this._offsetPrev = -0),
      (this._weightNext = -0),
      (this._offsetNext = -0);
  }
  function da(t, e, n, i) {
    ha.call(this, t, e, n, i);
  }
  function pa(t, e, n, i) {
    ha.call(this, t, e, n, i);
  }
  function fa(t, e, n, i) {
    if (void 0 === t)
      throw new Error('THREE.KeyframeTrack: track name is undefined');
    if (void 0 === e || 0 === e.length)
      throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + t);
    (this.name = t),
      (this.times = la.convertArray(e, this.TimeBufferType)),
      (this.values = la.convertArray(n, this.ValueBufferType)),
      this.setInterpolation(i || this.DefaultInterpolation);
  }
  function ma(t, e, n) {
    fa.call(this, t, e, n);
  }
  function ba(t, e, n, i) {
    fa.call(this, t, e, n, i);
  }
  function ga(t, e, n, i) {
    fa.call(this, t, e, n, i);
  }
  function ya(t, e, n, i) {
    ha.call(this, t, e, n, i);
  }
  function va(t, e, n, i) {
    fa.call(this, t, e, n, i);
  }
  function _a(t, e, n, i) {
    fa.call(this, t, e, n, i);
  }
  function xa(t, e, n, i) {
    fa.call(this, t, e, n, i);
  }
  function wa(t, e, n) {
    (this.name = t),
      (this.tracks = n),
      (this.duration = void 0 !== e ? e : -1),
      (this.uuid = k.generateUUID()),
      this.duration < 0 && this.resetDuration();
  }
  function Aa(t) {
    if (void 0 === t.type)
      throw new Error(
        'THREE.KeyframeTrack: track type undefined, can not parse',
      );
    var e = (function (t) {
      switch (t.toLowerCase()) {
        case 'scalar':
        case 'double':
        case 'float':
        case 'number':
        case 'integer':
          return ga;
        case 'vector':
        case 'vector2':
        case 'vector3':
        case 'vector4':
          return xa;
        case 'color':
          return ba;
        case 'quaternion':
          return va;
        case 'bool':
        case 'boolean':
          return ma;
        case 'string':
          return _a;
      }
      throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + t);
    })(t.type);
    if (void 0 === t.times) {
      var n = [],
        i = [];
      la.flattenJSON(t.keys, n, i, 'value'), (t.times = n), (t.values = i);
    }
    return void 0 !== e.parse
      ? e.parse(t)
      : new e(t.name, t.times, t.values, t.interpolation);
  }
  Object.assign(ha.prototype, {
    evaluate: function (t) {
      var e = this.parameterPositions,
        n = this._cachedIndex,
        i = e[n],
        r = e[n - 1];
      t: {
        e: {
          var o;
          n: {
            i: if (!(t < i)) {
              for (var s = n + 2; ; ) {
                if (void 0 === i) {
                  if (t < r) break i;
                  return (
                    (n = e.length),
                    (this._cachedIndex = n),
                    this.afterEnd_(n - 1, t, r)
                  );
                }
                if (n === s) break;
                if (((r = i), t < (i = e[++n]))) break e;
              }
              o = e.length;
              break n;
            }
            if (t >= r) break t;
            var a = e[1];
            t < a && ((n = 2), (r = a));
            for (s = n - 2; ; ) {
              if (void 0 === r)
                return (this._cachedIndex = 0), this.beforeStart_(0, t, i);
              if (n === s) break;
              if (((i = r), t >= (r = e[--n - 1]))) break e;
            }
            (o = n), (n = 0);
          }
          for (; n < o; ) {
            var c = (n + o) >>> 1;
            t < e[c] ? (o = c) : (n = c + 1);
          }
          if (((i = e[n]), void 0 === (r = e[n - 1])))
            return (this._cachedIndex = 0), this.beforeStart_(0, t, i);
          if (void 0 === i)
            return (
              (n = e.length),
              (this._cachedIndex = n),
              this.afterEnd_(n - 1, r, t)
            );
        }
        (this._cachedIndex = n), this.intervalChanged_(n, r, i);
      }
      return this.interpolate_(n, r, t, i);
    },
    settings: null,
    DefaultSettings_: {},
    getSettings_: function () {
      return this.settings || this.DefaultSettings_;
    },
    copySampleValue_: function (t) {
      for (
        var e = this.resultBuffer,
          n = this.sampleValues,
          i = this.valueSize,
          r = t * i,
          o = 0;
        o !== i;
        ++o
      )
        e[o] = n[r + o];
      return e;
    },
    interpolate_: function () {
      throw new Error('call to abstract method');
    },
    intervalChanged_: function () {},
  }),
    Object.assign(ha.prototype, {
      beforeStart_: ha.prototype.copySampleValue_,
      afterEnd_: ha.prototype.copySampleValue_,
    }),
    (ua.prototype = Object.assign(Object.create(ha.prototype), {
      constructor: ua,
      DefaultSettings_: { endingStart: E, endingEnd: E },
      intervalChanged_: function (t, e, n) {
        var i = this.parameterPositions,
          r = t - 2,
          o = t + 1,
          s = i[r],
          a = i[o];
        if (void 0 === s)
          switch (this.getSettings_().endingStart) {
            case D:
              (r = t), (s = 2 * e - n);
              break;
            case C:
              s = e + i[(r = i.length - 2)] - i[r + 1];
              break;
            default:
              (r = t), (s = n);
          }
        if (void 0 === a)
          switch (this.getSettings_().endingEnd) {
            case D:
              (o = t), (a = 2 * n - e);
              break;
            case C:
              (o = 1), (a = n + i[1] - i[0]);
              break;
            default:
              (o = t - 1), (a = e);
          }
        var c = 0.5 * (n - e),
          l = this.valueSize;
        (this._weightPrev = c / (e - s)),
          (this._weightNext = c / (a - n)),
          (this._offsetPrev = r * l),
          (this._offsetNext = o * l);
      },
      interpolate_: function (t, e, n, i) {
        for (
          var r = this.resultBuffer,
            o = this.sampleValues,
            s = this.valueSize,
            a = t * s,
            c = a - s,
            l = this._offsetPrev,
            h = this._offsetNext,
            u = this._weightPrev,
            d = this._weightNext,
            p = (n - e) / (i - e),
            f = p * p,
            m = f * p,
            b = -u * m + 2 * u * f - u * p,
            g = (1 + u) * m + (-1.5 - 2 * u) * f + (-0.5 + u) * p + 1,
            y = (-1 - d) * m + (1.5 + d) * f + 0.5 * p,
            v = d * m - d * f,
            _ = 0;
          _ !== s;
          ++_
        )
          r[_] = b * o[l + _] + g * o[c + _] + y * o[a + _] + v * o[h + _];
        return r;
      },
    })),
    (da.prototype = Object.assign(Object.create(ha.prototype), {
      constructor: da,
      interpolate_: function (t, e, n, i) {
        for (
          var r = this.resultBuffer,
            o = this.sampleValues,
            s = this.valueSize,
            a = t * s,
            c = a - s,
            l = (n - e) / (i - e),
            h = 1 - l,
            u = 0;
          u !== s;
          ++u
        )
          r[u] = o[c + u] * h + o[a + u] * l;
        return r;
      },
    })),
    (pa.prototype = Object.assign(Object.create(ha.prototype), {
      constructor: pa,
      interpolate_: function (t) {
        return this.copySampleValue_(t - 1);
      },
    })),
    Object.assign(fa, {
      toJSON: function (t) {
        var e,
          n = t.constructor;
        if (void 0 !== n.toJSON) e = n.toJSON(t);
        else {
          e = {
            name: t.name,
            times: la.convertArray(t.times, Array),
            values: la.convertArray(t.values, Array),
          };
          var i = t.getInterpolation();
          i !== t.DefaultInterpolation && (e.interpolation = i);
        }
        return (e.type = t.ValueTypeName), e;
      },
    }),
    Object.assign(fa.prototype, {
      constructor: fa,
      TimeBufferType: Float32Array,
      ValueBufferType: Float32Array,
      DefaultInterpolation: S,
      InterpolantFactoryMethodDiscrete: function (t) {
        return new pa(this.times, this.values, this.getValueSize(), t);
      },
      InterpolantFactoryMethodLinear: function (t) {
        return new da(this.times, this.values, this.getValueSize(), t);
      },
      InterpolantFactoryMethodSmooth: function (t) {
        return new ua(this.times, this.values, this.getValueSize(), t);
      },
      setInterpolation: function (t) {
        var e;
        switch (t) {
          case M:
            e = this.InterpolantFactoryMethodDiscrete;
            break;
          case S:
            e = this.InterpolantFactoryMethodLinear;
            break;
          case I:
            e = this.InterpolantFactoryMethodSmooth;
        }
        if (void 0 === e) {
          var n =
            'unsupported interpolation for ' +
            this.ValueTypeName +
            ' keyframe track named ' +
            this.name;
          if (void 0 === this.createInterpolant) {
            if (t === this.DefaultInterpolation) throw new Error(n);
            this.setInterpolation(this.DefaultInterpolation);
          }
          return console.warn('THREE.KeyframeTrack:', n), this;
        }
        return (this.createInterpolant = e), this;
      },
      getInterpolation: function () {
        switch (this.createInterpolant) {
          case this.InterpolantFactoryMethodDiscrete:
            return M;
          case this.InterpolantFactoryMethodLinear:
            return S;
          case this.InterpolantFactoryMethodSmooth:
            return I;
        }
      },
      getValueSize: function () {
        return this.values.length / this.times.length;
      },
      shift: function (t) {
        if (0 !== t)
          for (var e = this.times, n = 0, i = e.length; n !== i; ++n) e[n] += t;
        return this;
      },
      scale: function (t) {
        if (1 !== t)
          for (var e = this.times, n = 0, i = e.length; n !== i; ++n) e[n] *= t;
        return this;
      },
      trim: function (t, e) {
        for (
          var n = this.times, i = n.length, r = 0, o = i - 1;
          r !== i && n[r] < t;

        )
          ++r;
        for (; -1 !== o && n[o] > e; ) --o;
        if ((++o, 0 !== r || o !== i)) {
          r >= o && (r = (o = Math.max(o, 1)) - 1);
          var s = this.getValueSize();
          (this.times = la.arraySlice(n, r, o)),
            (this.values = la.arraySlice(this.values, r * s, o * s));
        }
        return this;
      },
      validate: function () {
        var t = !0,
          e = this.getValueSize();
        e - Math.floor(e) != 0 &&
          (console.error(
            'THREE.KeyframeTrack: Invalid value size in track.',
            this,
          ),
          (t = !1));
        var n = this.times,
          i = this.values,
          r = n.length;
        0 === r &&
          (console.error('THREE.KeyframeTrack: Track is empty.', this),
          (t = !1));
        for (var o = null, s = 0; s !== r; s++) {
          var a = n[s];
          if ('number' == typeof a && isNaN(a)) {
            console.error(
              'THREE.KeyframeTrack: Time is not a valid number.',
              this,
              s,
              a,
            ),
              (t = !1);
            break;
          }
          if (null !== o && o > a) {
            console.error(
              'THREE.KeyframeTrack: Out of order keys.',
              this,
              s,
              a,
              o,
            ),
              (t = !1);
            break;
          }
          o = a;
        }
        if (void 0 !== i && la.isTypedArray(i)) {
          s = 0;
          for (var c = i.length; s !== c; ++s) {
            var l = i[s];
            if (isNaN(l)) {
              console.error(
                'THREE.KeyframeTrack: Value is not a valid number.',
                this,
                s,
                l,
              ),
                (t = !1);
              break;
            }
          }
        }
        return t;
      },
      optimize: function () {
        for (
          var t = la.arraySlice(this.times),
            e = la.arraySlice(this.values),
            n = this.getValueSize(),
            i = this.getInterpolation() === I,
            r = 1,
            o = t.length - 1,
            s = 1;
          s < o;
          ++s
        ) {
          var a = !1,
            c = t[s];
          if (c !== t[s + 1] && (1 !== s || c !== c[0]))
            if (i) a = !0;
            else
              for (var l = s * n, h = l - n, u = l + n, d = 0; d !== n; ++d) {
                var p = e[l + d];
                if (p !== e[h + d] || p !== e[u + d]) {
                  a = !0;
                  break;
                }
              }
          if (a) {
            if (s !== r) {
              t[r] = t[s];
              var f = s * n,
                m = r * n;
              for (d = 0; d !== n; ++d) e[m + d] = e[f + d];
            }
            ++r;
          }
        }
        if (o > 0) {
          t[r] = t[o];
          for (f = o * n, m = r * n, d = 0; d !== n; ++d) e[m + d] = e[f + d];
          ++r;
        }
        return (
          r !== t.length
            ? ((this.times = la.arraySlice(t, 0, r)),
              (this.values = la.arraySlice(e, 0, r * n)))
            : ((this.times = t), (this.values = e)),
          this
        );
      },
      clone: function () {
        var t = la.arraySlice(this.times, 0),
          e = la.arraySlice(this.values, 0),
          n = new (0, this.constructor)(this.name, t, e);
        return (n.createInterpolant = this.createInterpolant), n;
      },
    }),
    (ma.prototype = Object.assign(Object.create(fa.prototype), {
      constructor: ma,
      ValueTypeName: 'bool',
      ValueBufferType: Array,
      DefaultInterpolation: M,
      InterpolantFactoryMethodLinear: void 0,
      InterpolantFactoryMethodSmooth: void 0,
    })),
    (ba.prototype = Object.assign(Object.create(fa.prototype), {
      constructor: ba,
      ValueTypeName: 'color',
    })),
    (ga.prototype = Object.assign(Object.create(fa.prototype), {
      constructor: ga,
      ValueTypeName: 'number',
    })),
    (ya.prototype = Object.assign(Object.create(ha.prototype), {
      constructor: ya,
      interpolate_: function (t, e, n, i) {
        for (
          var r = this.resultBuffer,
            o = this.sampleValues,
            s = this.valueSize,
            a = t * s,
            c = (n - e) / (i - e),
            l = a + s;
          a !== l;
          a += 4
        )
          Y.slerpFlat(r, 0, o, a - s, o, a, c);
        return r;
      },
    })),
    (va.prototype = Object.assign(Object.create(fa.prototype), {
      constructor: va,
      ValueTypeName: 'quaternion',
      DefaultInterpolation: S,
      InterpolantFactoryMethodLinear: function (t) {
        return new ya(this.times, this.values, this.getValueSize(), t);
      },
      InterpolantFactoryMethodSmooth: void 0,
    })),
    (_a.prototype = Object.assign(Object.create(fa.prototype), {
      constructor: _a,
      ValueTypeName: 'string',
      ValueBufferType: Array,
      DefaultInterpolation: M,
      InterpolantFactoryMethodLinear: void 0,
      InterpolantFactoryMethodSmooth: void 0,
    })),
    (xa.prototype = Object.assign(Object.create(fa.prototype), {
      constructor: xa,
      ValueTypeName: 'vector',
    })),
    Object.assign(wa, {
      parse: function (t) {
        for (
          var e = [], n = t.tracks, i = 1 / (t.fps || 1), r = 0, o = n.length;
          r !== o;
          ++r
        )
          e.push(Aa(n[r]).scale(i));
        return new wa(t.name, t.duration, e);
      },
      toJSON: function (t) {
        for (
          var e = [],
            n = t.tracks,
            i = { name: t.name, duration: t.duration, tracks: e, uuid: t.uuid },
            r = 0,
            o = n.length;
          r !== o;
          ++r
        )
          e.push(fa.toJSON(n[r]));
        return i;
      },
      CreateFromMorphTargetSequence: function (t, e, n, i) {
        for (var r = e.length, o = [], s = 0; s < r; s++) {
          var a = [],
            c = [];
          a.push((s + r - 1) % r, s, (s + 1) % r), c.push(0, 1, 0);
          var l = la.getKeyframeOrder(a);
          (a = la.sortedArray(a, 1, l)),
            (c = la.sortedArray(c, 1, l)),
            i || 0 !== a[0] || (a.push(r), c.push(c[0])),
            o.push(
              new ga('.morphTargetInfluences[' + e[s].name + ']', a, c).scale(
                1 / n,
              ),
            );
        }
        return new wa(t, -1, o);
      },
      findByName: function (t, e) {
        var n = t;
        if (!Array.isArray(t)) {
          var i = t;
          n = (i.geometry && i.geometry.animations) || i.animations;
        }
        for (var r = 0; r < n.length; r++) if (n[r].name === e) return n[r];
        return null;
      },
      CreateClipsFromMorphTargetSequences: function (t, e, n) {
        for (
          var i = {}, r = /^([\w-]*?)([\d]+)$/, o = 0, s = t.length;
          o < s;
          o++
        ) {
          var a = t[o],
            c = a.name.match(r);
          if (c && c.length > 1) {
            var l = i[(u = c[1])];
            l || (i[u] = l = []), l.push(a);
          }
        }
        var h = [];
        for (var u in i)
          h.push(wa.CreateFromMorphTargetSequence(u, i[u], e, n));
        return h;
      },
      parseAnimation: function (t, e) {
        if (!t)
          return (
            console.error(
              'THREE.AnimationClip: No animation in JSONLoader data.',
            ),
            null
          );
        for (
          var n = function (t, e, n, i, r) {
              if (0 !== n.length) {
                var o = [],
                  s = [];
                la.flattenJSON(n, o, s, i),
                  0 !== o.length && r.push(new t(e, o, s));
              }
            },
            i = [],
            r = t.name || 'default',
            o = t.length || -1,
            s = t.fps || 30,
            a = t.hierarchy || [],
            c = 0;
          c < a.length;
          c++
        ) {
          var l = a[c].keys;
          if (l && 0 !== l.length)
            if (l[0].morphTargets) {
              for (var h = {}, u = 0; u < l.length; u++)
                if (l[u].morphTargets)
                  for (var d = 0; d < l[u].morphTargets.length; d++)
                    h[l[u].morphTargets[d]] = -1;
              for (var p in h) {
                var f = [],
                  m = [];
                for (d = 0; d !== l[u].morphTargets.length; ++d) {
                  var b = l[u];
                  f.push(b.time), m.push(b.morphTarget === p ? 1 : 0);
                }
                i.push(new ga('.morphTargetInfluence[' + p + ']', f, m));
              }
              o = h.length * (s || 1);
            } else {
              var g = '.bones[' + e[c].name + ']';
              n(xa, g + '.position', l, 'pos', i),
                n(va, g + '.quaternion', l, 'rot', i),
                n(xa, g + '.scale', l, 'scl', i);
            }
        }
        return 0 === i.length ? null : new wa(r, o, i);
      },
    }),
    Object.assign(wa.prototype, {
      resetDuration: function () {
        for (var t = 0, e = 0, n = this.tracks.length; e !== n; ++e) {
          var i = this.tracks[e];
          t = Math.max(t, i.times[i.times.length - 1]);
        }
        return (this.duration = t), this;
      },
      trim: function () {
        for (var t = 0; t < this.tracks.length; t++)
          this.tracks[t].trim(0, this.duration);
        return this;
      },
      validate: function () {
        for (var t = !0, e = 0; e < this.tracks.length; e++)
          t = t && this.tracks[e].validate();
        return t;
      },
      optimize: function () {
        for (var t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
        return this;
      },
      clone: function () {
        for (var t = [], e = 0; e < this.tracks.length; e++)
          t.push(this.tracks[e].clone());
        return new wa(this.name, this.duration, t);
      },
    });
  var Ma = {
    enabled: !1,
    files: {},
    add: function (t, e) {
      !1 !== this.enabled && (this.files[t] = e);
    },
    get: function (t) {
      if (!1 !== this.enabled) return this.files[t];
    },
    remove: function (t) {
      delete this.files[t];
    },
    clear: function () {
      this.files = {};
    },
  };
  function Sa(t, e, n) {
    var i = this,
      r = !1,
      o = 0,
      s = 0,
      a = void 0,
      c = [];
    (this.onStart = void 0),
      (this.onLoad = t),
      (this.onProgress = e),
      (this.onError = n),
      (this.itemStart = function (t) {
        s++, !1 === r && void 0 !== i.onStart && i.onStart(t, o, s), (r = !0);
      }),
      (this.itemEnd = function (t) {
        o++,
          void 0 !== i.onProgress && i.onProgress(t, o, s),
          o === s && ((r = !1), void 0 !== i.onLoad && i.onLoad());
      }),
      (this.itemError = function (t) {
        void 0 !== i.onError && i.onError(t);
      }),
      (this.resolveURL = function (t) {
        return a ? a(t) : t;
      }),
      (this.setURLModifier = function (t) {
        return (a = t), this;
      }),
      (this.addHandler = function (t, e) {
        return c.push(t, e), this;
      }),
      (this.removeHandler = function (t) {
        var e = c.indexOf(t);
        return -1 !== e && c.splice(e, 2), this;
      }),
      (this.getHandler = function (t) {
        for (var e = 0, n = c.length; e < n; e += 2) {
          var i = c[e],
            r = c[e + 1];
          if ((i.global && (i.lastIndex = 0), i.test(t))) return r;
        }
        return null;
      });
  }
  var Ia = new Sa();
  function Ea(t) {
    (this.manager = void 0 !== t ? t : Ia),
      (this.crossOrigin = 'anonymous'),
      (this.path = ''),
      (this.resourcePath = '');
  }
  Object.assign(Ea.prototype, {
    load: function () {},
    parse: function () {},
    setCrossOrigin: function (t) {
      return (this.crossOrigin = t), this;
    },
    setPath: function (t) {
      return (this.path = t), this;
    },
    setResourcePath: function (t) {
      return (this.resourcePath = t), this;
    },
  });
  var Da = {};
  function Ca(t) {
    Ea.call(this, t);
  }
  function Ta(t) {
    Ea.call(this, t);
  }
  function La(t) {
    Ea.call(this, t);
  }
  function Ra(t) {
    Ea.call(this, t);
  }
  function Fa(t) {
    Ea.call(this, t);
  }
  function Pa(t) {
    Ea.call(this, t);
  }
  function Ba(t) {
    Ea.call(this, t);
  }
  function Oa() {
    (this.type = 'Curve'), (this.arcLengthDivisions = 200);
  }
  function Va(t, e, n, i, r, o, s, a) {
    Oa.call(this),
      (this.type = 'EllipseCurve'),
      (this.aX = t || 0),
      (this.aY = e || 0),
      (this.xRadius = n || 1),
      (this.yRadius = i || 1),
      (this.aStartAngle = r || 0),
      (this.aEndAngle = o || 2 * Math.PI),
      (this.aClockwise = s || !1),
      (this.aRotation = a || 0);
  }
  function Na(t, e, n, i, r, o) {
    Va.call(this, t, e, n, n, i, r, o), (this.type = 'ArcCurve');
  }
  function ka() {
    var t = 0,
      e = 0,
      n = 0,
      i = 0;
    function r(r, o, s, a) {
      (t = r),
        (e = s),
        (n = -3 * r + 3 * o - 2 * s - a),
        (i = 2 * r - 2 * o + s + a);
    }
    return {
      initCatmullRom: function (t, e, n, i, o) {
        r(e, n, o * (n - t), o * (i - e));
      },
      initNonuniformCatmullRom: function (t, e, n, i, o, s, a) {
        var c = (e - t) / o - (n - t) / (o + s) + (n - e) / s,
          l = (n - e) / s - (i - e) / (s + a) + (i - n) / a;
        r(e, n, (c *= s), (l *= s));
      },
      calc: function (r) {
        var o = r * r;
        return t + e * r + n * o + i * (o * r);
      },
    };
  }
  (Ca.prototype = Object.assign(Object.create(Ea.prototype), {
    constructor: Ca,
    load: function (t, e, n, i) {
      void 0 === t && (t = ''),
        void 0 !== this.path && (t = this.path + t),
        (t = this.manager.resolveURL(t));
      var r = this,
        o = Ma.get(t);
      if (void 0 !== o)
        return (
          r.manager.itemStart(t),
          setTimeout(function () {
            e && e(o), r.manager.itemEnd(t);
          }, 0),
          o
        );
      if (void 0 === Da[t]) {
        var s = t.match(/^data:(.*?)(;base64)?,(.*)$/);
        if (s) {
          var a = s[1],
            c = !!s[2],
            l = s[3];
          (l = decodeURIComponent(l)), c && (l = atob(l));
          try {
            var h,
              u = (this.responseType || '').toLowerCase();
            switch (u) {
              case 'arraybuffer':
              case 'blob':
                for (var d = new Uint8Array(l.length), p = 0; p < l.length; p++)
                  d[p] = l.charCodeAt(p);
                h = 'blob' === u ? new Blob([d.buffer], { type: a }) : d.buffer;
                break;
              case 'document':
                var f = new DOMParser();
                h = f.parseFromString(l, a);
                break;
              case 'json':
                h = JSON.parse(l);
                break;
              default:
                h = l;
            }
            setTimeout(function () {
              e && e(h), r.manager.itemEnd(t);
            }, 0);
          } catch (e) {
            setTimeout(function () {
              i && i(e), r.manager.itemError(t), r.manager.itemEnd(t);
            }, 0);
          }
        } else {
          (Da[t] = []), Da[t].push({ onLoad: e, onProgress: n, onError: i });
          var m = new XMLHttpRequest();
          for (var b in (m.open('GET', t, !0),
          m.addEventListener(
            'load',
            function (e) {
              var n = this.response,
                i = Da[t];
              if ((delete Da[t], 200 === this.status || 0 === this.status)) {
                0 === this.status &&
                  console.warn('THREE.FileLoader: HTTP Status 0 received.'),
                  Ma.add(t, n);
                for (var o = 0, s = i.length; o < s; o++) {
                  (a = i[o]).onLoad && a.onLoad(n);
                }
                r.manager.itemEnd(t);
              } else {
                for (o = 0, s = i.length; o < s; o++) {
                  var a;
                  (a = i[o]).onError && a.onError(e);
                }
                r.manager.itemError(t), r.manager.itemEnd(t);
              }
            },
            !1,
          ),
          m.addEventListener(
            'progress',
            function (e) {
              for (var n = Da[t], i = 0, r = n.length; i < r; i++) {
                var o = n[i];
                o.onProgress && o.onProgress(e);
              }
            },
            !1,
          ),
          m.addEventListener(
            'error',
            function (e) {
              var n = Da[t];
              delete Da[t];
              for (var i = 0, o = n.length; i < o; i++) {
                var s = n[i];
                s.onError && s.onError(e);
              }
              r.manager.itemError(t), r.manager.itemEnd(t);
            },
            !1,
          ),
          m.addEventListener(
            'abort',
            function (e) {
              var n = Da[t];
              delete Da[t];
              for (var i = 0, o = n.length; i < o; i++) {
                var s = n[i];
                s.onError && s.onError(e);
              }
              r.manager.itemError(t), r.manager.itemEnd(t);
            },
            !1,
          ),
          void 0 !== this.responseType && (m.responseType = this.responseType),
          void 0 !== this.withCredentials &&
            (m.withCredentials = this.withCredentials),
          m.overrideMimeType &&
            m.overrideMimeType(
              void 0 !== this.mimeType ? this.mimeType : 'text/plain',
            ),
          this.requestHeader))
            m.setRequestHeader(b, this.requestHeader[b]);
          m.send(null);
        }
        return r.manager.itemStart(t), m;
      }
      Da[t].push({ onLoad: e, onProgress: n, onError: i });
    },
    setResponseType: function (t) {
      return (this.responseType = t), this;
    },
    setWithCredentials: function (t) {
      return (this.withCredentials = t), this;
    },
    setMimeType: function (t) {
      return (this.mimeType = t), this;
    },
    setRequestHeader: function (t) {
      return (this.requestHeader = t), this;
    },
  })),
    (Ta.prototype = Object.assign(Object.create(Ea.prototype), {
      constructor: Ta,
      load: function (t, e, n, i) {
        var r = this,
          o = new Ca(r.manager);
        o.setPath(r.path),
          o.load(
            t,
            function (t) {
              e(r.parse(JSON.parse(t)));
            },
            n,
            i,
          );
      },
      parse: function (t) {
        for (var e = [], n = 0; n < t.length; n++) {
          var i = wa.parse(t[n]);
          e.push(i);
        }
        return e;
      },
    })),
    (La.prototype = Object.assign(Object.create(Ea.prototype), {
      constructor: La,
      load: function (t, e, n, i) {
        var r = this,
          o = [],
          s = new Bo();
        s.image = o;
        var a = new Ca(this.manager);
        function c(c) {
          a.load(
            t[c],
            function (t) {
              var n = r.parse(t, !0);
              (o[c] = {
                width: n.width,
                height: n.height,
                format: n.format,
                mipmaps: n.mipmaps,
              }),
                6 === (l += 1) &&
                  (1 === n.mipmapCount && (s.minFilter = u),
                  (s.format = n.format),
                  (s.needsUpdate = !0),
                  e && e(s));
            },
            n,
            i,
          );
        }
        if (
          (a.setPath(this.path),
          a.setResponseType('arraybuffer'),
          Array.isArray(t))
        )
          for (var l = 0, h = 0, d = t.length; h < d; ++h) c(h);
        else
          a.load(
            t,
            function (t) {
              var n = r.parse(t, !0);
              if (n.isCubemap)
                for (
                  var i = n.mipmaps.length / n.mipmapCount, a = 0;
                  a < i;
                  a++
                ) {
                  o[a] = { mipmaps: [] };
                  for (var c = 0; c < n.mipmapCount; c++)
                    o[a].mipmaps.push(n.mipmaps[a * n.mipmapCount + c]),
                      (o[a].format = n.format),
                      (o[a].width = n.width),
                      (o[a].height = n.height);
                }
              else
                (s.image.width = n.width),
                  (s.image.height = n.height),
                  (s.mipmaps = n.mipmaps);
              1 === n.mipmapCount && (s.minFilter = u),
                (s.format = n.format),
                (s.needsUpdate = !0),
                e && e(s);
            },
            n,
            i,
          );
        return s;
      },
    })),
    (Ra.prototype = Object.assign(Object.create(Ea.prototype), {
      constructor: Ra,
      load: function (t, e, n, i) {
        var r = this,
          o = new Dn(),
          a = new Ca(this.manager);
        return (
          a.setResponseType('arraybuffer'),
          a.setPath(this.path),
          a.load(
            t,
            function (t) {
              var n = r.parse(t);
              n &&
                (void 0 !== n.image
                  ? (o.image = n.image)
                  : void 0 !== n.data &&
                    ((o.image.width = n.width),
                    (o.image.height = n.height),
                    (o.image.data = n.data)),
                (o.wrapS = void 0 !== n.wrapS ? n.wrapS : s),
                (o.wrapT = void 0 !== n.wrapT ? n.wrapT : s),
                (o.magFilter = void 0 !== n.magFilter ? n.magFilter : u),
                (o.minFilter = void 0 !== n.minFilter ? n.minFilter : u),
                (o.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1),
                void 0 !== n.format && (o.format = n.format),
                void 0 !== n.type && (o.type = n.type),
                void 0 !== n.mipmaps &&
                  ((o.mipmaps = n.mipmaps), (o.minFilter = d)),
                1 === n.mipmapCount && (o.minFilter = u),
                (o.needsUpdate = !0),
                e && e(o, n));
            },
            n,
            i,
          ),
          o
        );
      },
    })),
    (Fa.prototype = Object.assign(Object.create(Ea.prototype), {
      constructor: Fa,
      load: function (t, e, n, i) {
        void 0 !== this.path && (t = this.path + t),
          (t = this.manager.resolveURL(t));
        var r = this,
          o = Ma.get(t);
        if (void 0 !== o)
          return (
            r.manager.itemStart(t),
            setTimeout(function () {
              e && e(o), r.manager.itemEnd(t);
            }, 0),
            o
          );
        var s = document.createElementNS('http://www.w3.org/1999/xhtml', 'img');
        function a() {
          s.removeEventListener('load', a, !1),
            s.removeEventListener('error', c, !1),
            Ma.add(t, this),
            e && e(this),
            r.manager.itemEnd(t);
        }
        function c(e) {
          s.removeEventListener('load', a, !1),
            s.removeEventListener('error', c, !1),
            i && i(e),
            r.manager.itemError(t),
            r.manager.itemEnd(t);
        }
        return (
          s.addEventListener('load', a, !1),
          s.addEventListener('error', c, !1),
          'data:' !== t.substr(0, 5) &&
            void 0 !== this.crossOrigin &&
            (s.crossOrigin = this.crossOrigin),
          r.manager.itemStart(t),
          (s.src = t),
          s
        );
      },
    })),
    (Pa.prototype = Object.assign(Object.create(Ea.prototype), {
      constructor: Pa,
      load: function (t, e, n, i) {
        var r = new Qn(),
          o = new Fa(this.manager);
        o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
        var s = 0;
        function a(n) {
          o.load(
            t[n],
            function (t) {
              (r.images[n] = t), 6 === ++s && ((r.needsUpdate = !0), e && e(r));
            },
            void 0,
            i,
          );
        }
        for (var c = 0; c < t.length; ++c) a(c);
        return r;
      },
    })),
    (Ba.prototype = Object.assign(Object.create(Ea.prototype), {
      constructor: Ba,
      load: function (t, e, n, i) {
        var r = new H(),
          o = new Fa(this.manager);
        return (
          o.setCrossOrigin(this.crossOrigin),
          o.setPath(this.path),
          o.load(
            t,
            function (n) {
              r.image = n;
              var i =
                t.search(/\.jpe?g($|\?)/i) > 0 ||
                0 === t.search(/^data\:image\/jpeg/);
              (r.format = i ? _ : x),
                (r.needsUpdate = !0),
                void 0 !== e && e(r);
            },
            n,
            i,
          ),
          r
        );
      },
    })),
    Object.assign(Oa.prototype, {
      getPoint: function () {
        return console.warn('THREE.Curve: .getPoint() not implemented.'), null;
      },
      getPointAt: function (t, e) {
        var n = this.getUtoTmapping(t);
        return this.getPoint(n, e);
      },
      getPoints: function (t) {
        void 0 === t && (t = 5);
        for (var e = [], n = 0; n <= t; n++) e.push(this.getPoint(n / t));
        return e;
      },
      getSpacedPoints: function (t) {
        void 0 === t && (t = 5);
        for (var e = [], n = 0; n <= t; n++) e.push(this.getPointAt(n / t));
        return e;
      },
      getLength: function () {
        var t = this.getLengths();
        return t[t.length - 1];
      },
      getLengths: function (t) {
        if (
          (void 0 === t && (t = this.arcLengthDivisions),
          this.cacheArcLengths &&
            this.cacheArcLengths.length === t + 1 &&
            !this.needsUpdate)
        )
          return this.cacheArcLengths;
        this.needsUpdate = !1;
        var e,
          n,
          i = [],
          r = this.getPoint(0),
          o = 0;
        for (i.push(0), n = 1; n <= t; n++)
          (o += (e = this.getPoint(n / t)).distanceTo(r)), i.push(o), (r = e);
        return (this.cacheArcLengths = i), i;
      },
      updateArcLengths: function () {
        (this.needsUpdate = !0), this.getLengths();
      },
      getUtoTmapping: function (t, e) {
        var n,
          i = this.getLengths(),
          r = 0,
          o = i.length;
        n = e || t * i[o - 1];
        for (var s, a = 0, c = o - 1; a <= c; )
          if ((s = i[(r = Math.floor(a + (c - a) / 2))] - n) < 0) a = r + 1;
          else {
            if (!(s > 0)) {
              c = r;
              break;
            }
            c = r - 1;
          }
        if (i[(r = c)] === n) return r / (o - 1);
        var l = i[r];
        return (r + (n - l) / (i[r + 1] - l)) / (o - 1);
      },
      getTangent: function (t) {
        var e = 1e-4,
          n = t - e,
          i = t + e;
        n < 0 && (n = 0), i > 1 && (i = 1);
        var r = this.getPoint(n);
        return this.getPoint(i).clone().sub(r).normalize();
      },
      getTangentAt: function (t) {
        var e = this.getUtoTmapping(t);
        return this.getTangent(e);
      },
      computeFrenetFrames: function (t, e) {
        var n,
          i,
          r,
          o = new J(),
          s = [],
          a = [],
          c = [],
          l = new J(),
          h = new ot();
        for (n = 0; n <= t; n++)
          (i = n / t), (s[n] = this.getTangentAt(i)), s[n].normalize();
        (a[0] = new J()), (c[0] = new J());
        var u = Number.MAX_VALUE,
          d = Math.abs(s[0].x),
          p = Math.abs(s[0].y),
          f = Math.abs(s[0].z);
        for (
          d <= u && ((u = d), o.set(1, 0, 0)),
            p <= u && ((u = p), o.set(0, 1, 0)),
            f <= u && o.set(0, 0, 1),
            l.crossVectors(s[0], o).normalize(),
            a[0].crossVectors(s[0], l),
            c[0].crossVectors(s[0], a[0]),
            n = 1;
          n <= t;
          n++
        )
          (a[n] = a[n - 1].clone()),
            (c[n] = c[n - 1].clone()),
            l.crossVectors(s[n - 1], s[n]),
            l.length() > Number.EPSILON &&
              (l.normalize(),
              (r = Math.acos(k.clamp(s[n - 1].dot(s[n]), -1, 1))),
              a[n].applyMatrix4(h.makeRotationAxis(l, r))),
            c[n].crossVectors(s[n], a[n]);
        if (!0 === e)
          for (
            r = Math.acos(k.clamp(a[0].dot(a[t]), -1, 1)),
              r /= t,
              s[0].dot(l.crossVectors(a[0], a[t])) > 0 && (r = -r),
              n = 1;
            n <= t;
            n++
          )
            a[n].applyMatrix4(h.makeRotationAxis(s[n], r * n)),
              c[n].crossVectors(s[n], a[n]);
        return { tangents: s, normals: a, binormals: c };
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (t) {
        return (this.arcLengthDivisions = t.arcLengthDivisions), this;
      },
      toJSON: function () {
        var t = {
          metadata: { version: 4.5, type: 'Curve', generator: 'Curve.toJSON' },
        };
        return (
          (t.arcLengthDivisions = this.arcLengthDivisions),
          (t.type = this.type),
          t
        );
      },
      fromJSON: function (t) {
        return (this.arcLengthDivisions = t.arcLengthDivisions), this;
      },
    }),
    (Va.prototype = Object.create(Oa.prototype)),
    (Va.prototype.constructor = Va),
    (Va.prototype.isEllipseCurve = !0),
    (Va.prototype.getPoint = function (t, e) {
      for (
        var n = e || new U(),
          i = 2 * Math.PI,
          r = this.aEndAngle - this.aStartAngle,
          o = Math.abs(r) < Number.EPSILON;
        r < 0;

      )
        r += i;
      for (; r > i; ) r -= i;
      r < Number.EPSILON && (r = o ? 0 : i),
        !0 !== this.aClockwise || o || (r === i ? (r = -i) : (r -= i));
      var s = this.aStartAngle + t * r,
        a = this.aX + this.xRadius * Math.cos(s),
        c = this.aY + this.yRadius * Math.sin(s);
      if (0 !== this.aRotation) {
        var l = Math.cos(this.aRotation),
          h = Math.sin(this.aRotation),
          u = a - this.aX,
          d = c - this.aY;
        (a = u * l - d * h + this.aX), (c = u * h + d * l + this.aY);
      }
      return n.set(a, c);
    }),
    (Va.prototype.copy = function (t) {
      return (
        Oa.prototype.copy.call(this, t),
        (this.aX = t.aX),
        (this.aY = t.aY),
        (this.xRadius = t.xRadius),
        (this.yRadius = t.yRadius),
        (this.aStartAngle = t.aStartAngle),
        (this.aEndAngle = t.aEndAngle),
        (this.aClockwise = t.aClockwise),
        (this.aRotation = t.aRotation),
        this
      );
    }),
    (Va.prototype.toJSON = function () {
      var t = Oa.prototype.toJSON.call(this);
      return (
        (t.aX = this.aX),
        (t.aY = this.aY),
        (t.xRadius = this.xRadius),
        (t.yRadius = this.yRadius),
        (t.aStartAngle = this.aStartAngle),
        (t.aEndAngle = this.aEndAngle),
        (t.aClockwise = this.aClockwise),
        (t.aRotation = this.aRotation),
        t
      );
    }),
    (Va.prototype.fromJSON = function (t) {
      return (
        Oa.prototype.fromJSON.call(this, t),
        (this.aX = t.aX),
        (this.aY = t.aY),
        (this.xRadius = t.xRadius),
        (this.yRadius = t.yRadius),
        (this.aStartAngle = t.aStartAngle),
        (this.aEndAngle = t.aEndAngle),
        (this.aClockwise = t.aClockwise),
        (this.aRotation = t.aRotation),
        this
      );
    }),
    (Na.prototype = Object.create(Va.prototype)),
    (Na.prototype.constructor = Na),
    (Na.prototype.isArcCurve = !0);
  var Ua = new J(),
    Ga = new ka(),
    za = new ka(),
    ja = new ka();
  function Ha(t, e, n, i) {
    Oa.call(this),
      (this.type = 'CatmullRomCurve3'),
      (this.points = t || []),
      (this.closed = e || !1),
      (this.curveType = n || 'centripetal'),
      (this.tension = i || 0.5);
  }
  function Wa(t, e, n, i, r) {
    var o = 0.5 * (i - e),
      s = 0.5 * (r - n),
      a = t * t;
    return (
      (2 * n - 2 * i + o + s) * (t * a) +
      (-3 * n + 3 * i - 2 * o - s) * a +
      o * t +
      n
    );
  }
  function Xa(t, e, n, i) {
    return (
      (function (t, e) {
        var n = 1 - t;
        return n * n * e;
      })(t, e) +
      (function (t, e) {
        return 2 * (1 - t) * t * e;
      })(t, n) +
      (function (t, e) {
        return t * t * e;
      })(t, i)
    );
  }
  function Za(t, e, n, i, r) {
    return (
      (function (t, e) {
        var n = 1 - t;
        return n * n * n * e;
      })(t, e) +
      (function (t, e) {
        var n = 1 - t;
        return 3 * n * n * t * e;
      })(t, n) +
      (function (t, e) {
        return 3 * (1 - t) * t * t * e;
      })(t, i) +
      (function (t, e) {
        return t * t * t * e;
      })(t, r)
    );
  }
  function Ya(t, e, n, i) {
    Oa.call(this),
      (this.type = 'CubicBezierCurve'),
      (this.v0 = t || new U()),
      (this.v1 = e || new U()),
      (this.v2 = n || new U()),
      (this.v3 = i || new U());
  }
  function qa(t, e, n, i) {
    Oa.call(this),
      (this.type = 'CubicBezierCurve3'),
      (this.v0 = t || new J()),
      (this.v1 = e || new J()),
      (this.v2 = n || new J()),
      (this.v3 = i || new J());
  }
  function Qa(t, e) {
    Oa.call(this),
      (this.type = 'LineCurve'),
      (this.v1 = t || new U()),
      (this.v2 = e || new U());
  }
  function Ja(t, e) {
    Oa.call(this),
      (this.type = 'LineCurve3'),
      (this.v1 = t || new J()),
      (this.v2 = e || new J());
  }
  function $a(t, e, n) {
    Oa.call(this),
      (this.type = 'QuadraticBezierCurve'),
      (this.v0 = t || new U()),
      (this.v1 = e || new U()),
      (this.v2 = n || new U());
  }
  function Ka(t, e, n) {
    Oa.call(this),
      (this.type = 'QuadraticBezierCurve3'),
      (this.v0 = t || new J()),
      (this.v1 = e || new J()),
      (this.v2 = n || new J());
  }
  function tc(t) {
    Oa.call(this), (this.type = 'SplineCurve'), (this.points = t || []);
  }
  (Ha.prototype = Object.create(Oa.prototype)),
    (Ha.prototype.constructor = Ha),
    (Ha.prototype.isCatmullRomCurve3 = !0),
    (Ha.prototype.getPoint = function (t, e) {
      var n,
        i,
        r,
        o,
        s = e || new J(),
        a = this.points,
        c = a.length,
        l = (c - (this.closed ? 0 : 1)) * t,
        h = Math.floor(l),
        u = l - h;
      if (
        (this.closed
          ? (h += h > 0 ? 0 : (Math.floor(Math.abs(h) / c) + 1) * c)
          : 0 === u && h === c - 1 && ((h = c - 2), (u = 1)),
        this.closed || h > 0
          ? (n = a[(h - 1) % c])
          : (Ua.subVectors(a[0], a[1]).add(a[0]), (n = Ua)),
        (i = a[h % c]),
        (r = a[(h + 1) % c]),
        this.closed || h + 2 < c
          ? (o = a[(h + 2) % c])
          : (Ua.subVectors(a[c - 1], a[c - 2]).add(a[c - 1]), (o = Ua)),
        'centripetal' === this.curveType || 'chordal' === this.curveType)
      ) {
        var d = 'chordal' === this.curveType ? 0.5 : 0.25,
          p = Math.pow(n.distanceToSquared(i), d),
          f = Math.pow(i.distanceToSquared(r), d),
          m = Math.pow(r.distanceToSquared(o), d);
        f < 1e-4 && (f = 1),
          p < 1e-4 && (p = f),
          m < 1e-4 && (m = f),
          Ga.initNonuniformCatmullRom(n.x, i.x, r.x, o.x, p, f, m),
          za.initNonuniformCatmullRom(n.y, i.y, r.y, o.y, p, f, m),
          ja.initNonuniformCatmullRom(n.z, i.z, r.z, o.z, p, f, m);
      } else
        'catmullrom' === this.curveType &&
          (Ga.initCatmullRom(n.x, i.x, r.x, o.x, this.tension),
          za.initCatmullRom(n.y, i.y, r.y, o.y, this.tension),
          ja.initCatmullRom(n.z, i.z, r.z, o.z, this.tension));
      return s.set(Ga.calc(u), za.calc(u), ja.calc(u)), s;
    }),
    (Ha.prototype.copy = function (t) {
      Oa.prototype.copy.call(this, t), (this.points = []);
      for (var e = 0, n = t.points.length; e < n; e++) {
        var i = t.points[e];
        this.points.push(i.clone());
      }
      return (
        (this.closed = t.closed),
        (this.curveType = t.curveType),
        (this.tension = t.tension),
        this
      );
    }),
    (Ha.prototype.toJSON = function () {
      var t = Oa.prototype.toJSON.call(this);
      t.points = [];
      for (var e = 0, n = this.points.length; e < n; e++) {
        var i = this.points[e];
        t.points.push(i.toArray());
      }
      return (
        (t.closed = this.closed),
        (t.curveType = this.curveType),
        (t.tension = this.tension),
        t
      );
    }),
    (Ha.prototype.fromJSON = function (t) {
      Oa.prototype.fromJSON.call(this, t), (this.points = []);
      for (var e = 0, n = t.points.length; e < n; e++) {
        var i = t.points[e];
        this.points.push(new J().fromArray(i));
      }
      return (
        (this.closed = t.closed),
        (this.curveType = t.curveType),
        (this.tension = t.tension),
        this
      );
    }),
    (Ya.prototype = Object.create(Oa.prototype)),
    (Ya.prototype.constructor = Ya),
    (Ya.prototype.isCubicBezierCurve = !0),
    (Ya.prototype.getPoint = function (t, e) {
      var n = e || new U(),
        i = this.v0,
        r = this.v1,
        o = this.v2,
        s = this.v3;
      return n.set(Za(t, i.x, r.x, o.x, s.x), Za(t, i.y, r.y, o.y, s.y)), n;
    }),
    (Ya.prototype.copy = function (t) {
      return (
        Oa.prototype.copy.call(this, t),
        this.v0.copy(t.v0),
        this.v1.copy(t.v1),
        this.v2.copy(t.v2),
        this.v3.copy(t.v3),
        this
      );
    }),
    (Ya.prototype.toJSON = function () {
      var t = Oa.prototype.toJSON.call(this);
      return (
        (t.v0 = this.v0.toArray()),
        (t.v1 = this.v1.toArray()),
        (t.v2 = this.v2.toArray()),
        (t.v3 = this.v3.toArray()),
        t
      );
    }),
    (Ya.prototype.fromJSON = function (t) {
      return (
        Oa.prototype.fromJSON.call(this, t),
        this.v0.fromArray(t.v0),
        this.v1.fromArray(t.v1),
        this.v2.fromArray(t.v2),
        this.v3.fromArray(t.v3),
        this
      );
    }),
    (qa.prototype = Object.create(Oa.prototype)),
    (qa.prototype.constructor = qa),
    (qa.prototype.isCubicBezierCurve3 = !0),
    (qa.prototype.getPoint = function (t, e) {
      var n = e || new J(),
        i = this.v0,
        r = this.v1,
        o = this.v2,
        s = this.v3;
      return (
        n.set(
          Za(t, i.x, r.x, o.x, s.x),
          Za(t, i.y, r.y, o.y, s.y),
          Za(t, i.z, r.z, o.z, s.z),
        ),
        n
      );
    }),
    (qa.prototype.copy = function (t) {
      return (
        Oa.prototype.copy.call(this, t),
        this.v0.copy(t.v0),
        this.v1.copy(t.v1),
        this.v2.copy(t.v2),
        this.v3.copy(t.v3),
        this
      );
    }),
    (qa.prototype.toJSON = function () {
      var t = Oa.prototype.toJSON.call(this);
      return (
        (t.v0 = this.v0.toArray()),
        (t.v1 = this.v1.toArray()),
        (t.v2 = this.v2.toArray()),
        (t.v3 = this.v3.toArray()),
        t
      );
    }),
    (qa.prototype.fromJSON = function (t) {
      return (
        Oa.prototype.fromJSON.call(this, t),
        this.v0.fromArray(t.v0),
        this.v1.fromArray(t.v1),
        this.v2.fromArray(t.v2),
        this.v3.fromArray(t.v3),
        this
      );
    }),
    (Qa.prototype = Object.create(Oa.prototype)),
    (Qa.prototype.constructor = Qa),
    (Qa.prototype.isLineCurve = !0),
    (Qa.prototype.getPoint = function (t, e) {
      var n = e || new U();
      return (
        1 === t
          ? n.copy(this.v2)
          : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)),
        n
      );
    }),
    (Qa.prototype.getPointAt = function (t, e) {
      return this.getPoint(t, e);
    }),
    (Qa.prototype.getTangent = function () {
      return this.v2.clone().sub(this.v1).normalize();
    }),
    (Qa.prototype.copy = function (t) {
      return (
        Oa.prototype.copy.call(this, t),
        this.v1.copy(t.v1),
        this.v2.copy(t.v2),
        this
      );
    }),
    (Qa.prototype.toJSON = function () {
      var t = Oa.prototype.toJSON.call(this);
      return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
    }),
    (Qa.prototype.fromJSON = function (t) {
      return (
        Oa.prototype.fromJSON.call(this, t),
        this.v1.fromArray(t.v1),
        this.v2.fromArray(t.v2),
        this
      );
    }),
    (Ja.prototype = Object.create(Oa.prototype)),
    (Ja.prototype.constructor = Ja),
    (Ja.prototype.isLineCurve3 = !0),
    (Ja.prototype.getPoint = function (t, e) {
      var n = e || new J();
      return (
        1 === t
          ? n.copy(this.v2)
          : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)),
        n
      );
    }),
    (Ja.prototype.getPointAt = function (t, e) {
      return this.getPoint(t, e);
    }),
    (Ja.prototype.copy = function (t) {
      return (
        Oa.prototype.copy.call(this, t),
        this.v1.copy(t.v1),
        this.v2.copy(t.v2),
        this
      );
    }),
    (Ja.prototype.toJSON = function () {
      var t = Oa.prototype.toJSON.call(this);
      return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
    }),
    (Ja.prototype.fromJSON = function (t) {
      return (
        Oa.prototype.fromJSON.call(this, t),
        this.v1.fromArray(t.v1),
        this.v2.fromArray(t.v2),
        this
      );
    }),
    ($a.prototype = Object.create(Oa.prototype)),
    ($a.prototype.constructor = $a),
    ($a.prototype.isQuadraticBezierCurve = !0),
    ($a.prototype.getPoint = function (t, e) {
      var n = e || new U(),
        i = this.v0,
        r = this.v1,
        o = this.v2;
      return n.set(Xa(t, i.x, r.x, o.x), Xa(t, i.y, r.y, o.y)), n;
    }),
    ($a.prototype.copy = function (t) {
      return (
        Oa.prototype.copy.call(this, t),
        this.v0.copy(t.v0),
        this.v1.copy(t.v1),
        this.v2.copy(t.v2),
        this
      );
    }),
    ($a.prototype.toJSON = function () {
      var t = Oa.prototype.toJSON.call(this);
      return (
        (t.v0 = this.v0.toArray()),
        (t.v1 = this.v1.toArray()),
        (t.v2 = this.v2.toArray()),
        t
      );
    }),
    ($a.prototype.fromJSON = function (t) {
      return (
        Oa.prototype.fromJSON.call(this, t),
        this.v0.fromArray(t.v0),
        this.v1.fromArray(t.v1),
        this.v2.fromArray(t.v2),
        this
      );
    }),
    (Ka.prototype = Object.create(Oa.prototype)),
    (Ka.prototype.constructor = Ka),
    (Ka.prototype.isQuadraticBezierCurve3 = !0),
    (Ka.prototype.getPoint = function (t, e) {
      var n = e || new J(),
        i = this.v0,
        r = this.v1,
        o = this.v2;
      return (
        n.set(Xa(t, i.x, r.x, o.x), Xa(t, i.y, r.y, o.y), Xa(t, i.z, r.z, o.z)),
        n
      );
    }),
    (Ka.prototype.copy = function (t) {
      return (
        Oa.prototype.copy.call(this, t),
        this.v0.copy(t.v0),
        this.v1.copy(t.v1),
        this.v2.copy(t.v2),
        this
      );
    }),
    (Ka.prototype.toJSON = function () {
      var t = Oa.prototype.toJSON.call(this);
      return (
        (t.v0 = this.v0.toArray()),
        (t.v1 = this.v1.toArray()),
        (t.v2 = this.v2.toArray()),
        t
      );
    }),
    (Ka.prototype.fromJSON = function (t) {
      return (
        Oa.prototype.fromJSON.call(this, t),
        this.v0.fromArray(t.v0),
        this.v1.fromArray(t.v1),
        this.v2.fromArray(t.v2),
        this
      );
    }),
    (tc.prototype = Object.create(Oa.prototype)),
    (tc.prototype.constructor = tc),
    (tc.prototype.isSplineCurve = !0),
    (tc.prototype.getPoint = function (t, e) {
      var n = e || new U(),
        i = this.points,
        r = (i.length - 1) * t,
        o = Math.floor(r),
        s = r - o,
        a = i[0 === o ? o : o - 1],
        c = i[o],
        l = i[o > i.length - 2 ? i.length - 1 : o + 1],
        h = i[o > i.length - 3 ? i.length - 1 : o + 2];
      return n.set(Wa(s, a.x, c.x, l.x, h.x), Wa(s, a.y, c.y, l.y, h.y)), n;
    }),
    (tc.prototype.copy = function (t) {
      Oa.prototype.copy.call(this, t), (this.points = []);
      for (var e = 0, n = t.points.length; e < n; e++) {
        var i = t.points[e];
        this.points.push(i.clone());
      }
      return this;
    }),
    (tc.prototype.toJSON = function () {
      var t = Oa.prototype.toJSON.call(this);
      t.points = [];
      for (var e = 0, n = this.points.length; e < n; e++) {
        var i = this.points[e];
        t.points.push(i.toArray());
      }
      return t;
    }),
    (tc.prototype.fromJSON = function (t) {
      Oa.prototype.fromJSON.call(this, t), (this.points = []);
      for (var e = 0, n = t.points.length; e < n; e++) {
        var i = t.points[e];
        this.points.push(new U().fromArray(i));
      }
      return this;
    });
  var ec = Object.freeze({
    __proto__: null,
    ArcCurve: Na,
    CatmullRomCurve3: Ha,
    CubicBezierCurve: Ya,
    CubicBezierCurve3: qa,
    EllipseCurve: Va,
    LineCurve: Qa,
    LineCurve3: Ja,
    QuadraticBezierCurve: $a,
    QuadraticBezierCurve3: Ka,
    SplineCurve: tc,
  });
  function nc() {
    Oa.call(this),
      (this.type = 'CurvePath'),
      (this.curves = []),
      (this.autoClose = !1);
  }
  function ic(t) {
    nc.call(this),
      (this.type = 'Path'),
      (this.currentPoint = new U()),
      t && this.setFromPoints(t);
  }
  function rc(t) {
    ic.call(this, t),
      (this.uuid = k.generateUUID()),
      (this.type = 'Shape'),
      (this.holes = []);
  }
  function oc(t, e) {
    At.call(this),
      (this.type = 'Light'),
      (this.color = new fe(t)),
      (this.intensity = void 0 !== e ? e : 1),
      (this.receiveShadow = void 0);
  }
  function sc(t, e, n) {
    oc.call(this, t, n),
      (this.type = 'HemisphereLight'),
      (this.castShadow = void 0),
      this.position.copy(At.DefaultUp),
      this.updateMatrix(),
      (this.groundColor = new fe(e));
  }
  function ac(t) {
    (this.camera = t),
      (this.bias = 0),
      (this.radius = 1),
      (this.mapSize = new U(512, 512)),
      (this.map = null),
      (this.mapPass = null),
      (this.matrix = new ot()),
      (this._frustum = new Ln()),
      (this._frameExtents = new U(1, 1)),
      (this._viewportCount = 1),
      (this._viewports = [new W(0, 0, 1, 1)]);
  }
  function cc() {
    ac.call(this, new Mn(50, 1, 0.5, 500));
  }
  function lc(t, e, n, i, r, o) {
    oc.call(this, t, e),
      (this.type = 'SpotLight'),
      this.position.copy(At.DefaultUp),
      this.updateMatrix(),
      (this.target = new At()),
      Object.defineProperty(this, 'power', {
        get: function () {
          return this.intensity * Math.PI;
        },
        set: function (t) {
          this.intensity = t / Math.PI;
        },
      }),
      (this.distance = void 0 !== n ? n : 0),
      (this.angle = void 0 !== i ? i : Math.PI / 3),
      (this.penumbra = void 0 !== r ? r : 0),
      (this.decay = void 0 !== o ? o : 1),
      (this.shadow = new cc());
  }
  function hc() {
    ac.call(this, new Mn(90, 1, 0.5, 500)),
      (this._frameExtents = new U(4, 2)),
      (this._viewportCount = 6),
      (this._viewports = [
        new W(2, 1, 1, 1),
        new W(0, 1, 1, 1),
        new W(3, 1, 1, 1),
        new W(1, 1, 1, 1),
        new W(3, 0, 1, 1),
        new W(1, 0, 1, 1),
      ]),
      (this._cubeDirections = [
        new J(1, 0, 0),
        new J(-1, 0, 0),
        new J(0, 0, 1),
        new J(0, 0, -1),
        new J(0, 1, 0),
        new J(0, -1, 0),
      ]),
      (this._cubeUps = [
        new J(0, 1, 0),
        new J(0, 1, 0),
        new J(0, 1, 0),
        new J(0, 1, 0),
        new J(0, 0, 1),
        new J(0, 0, -1),
      ]);
  }
  function uc(t, e, n, i) {
    oc.call(this, t, e),
      (this.type = 'PointLight'),
      Object.defineProperty(this, 'power', {
        get: function () {
          return 4 * this.intensity * Math.PI;
        },
        set: function (t) {
          this.intensity = t / (4 * Math.PI);
        },
      }),
      (this.distance = void 0 !== n ? n : 0),
      (this.decay = void 0 !== i ? i : 1),
      (this.shadow = new hc());
  }
  function dc(t, e, n, i, r, o) {
    An.call(this),
      (this.type = 'OrthographicCamera'),
      (this.zoom = 1),
      (this.view = null),
      (this.left = void 0 !== t ? t : -1),
      (this.right = void 0 !== e ? e : 1),
      (this.top = void 0 !== n ? n : 1),
      (this.bottom = void 0 !== i ? i : -1),
      (this.near = void 0 !== r ? r : 0.1),
      (this.far = void 0 !== o ? o : 2e3),
      this.updateProjectionMatrix();
  }
  function pc() {
    ac.call(this, new dc(-5, 5, 5, -5, 0.5, 500));
  }
  function fc(t, e) {
    oc.call(this, t, e),
      (this.type = 'DirectionalLight'),
      this.position.copy(At.DefaultUp),
      this.updateMatrix(),
      (this.target = new At()),
      (this.shadow = new pc());
  }
  function mc(t, e) {
    oc.call(this, t, e),
      (this.type = 'AmbientLight'),
      (this.castShadow = void 0);
  }
  function bc(t, e, n, i) {
    oc.call(this, t, e),
      (this.type = 'RectAreaLight'),
      (this.width = void 0 !== n ? n : 10),
      (this.height = void 0 !== i ? i : 10);
  }
  function gc(t) {
    Ea.call(this, t), (this.textures = {});
  }
  (nc.prototype = Object.assign(Object.create(Oa.prototype), {
    constructor: nc,
    add: function (t) {
      this.curves.push(t);
    },
    closePath: function () {
      var t = this.curves[0].getPoint(0),
        e = this.curves[this.curves.length - 1].getPoint(1);
      t.equals(e) || this.curves.push(new Qa(e, t));
    },
    getPoint: function (t) {
      for (
        var e = t * this.getLength(), n = this.getCurveLengths(), i = 0;
        i < n.length;

      ) {
        if (n[i] >= e) {
          var r = n[i] - e,
            o = this.curves[i],
            s = o.getLength(),
            a = 0 === s ? 0 : 1 - r / s;
          return o.getPointAt(a);
        }
        i++;
      }
      return null;
    },
    getLength: function () {
      var t = this.getCurveLengths();
      return t[t.length - 1];
    },
    updateArcLengths: function () {
      (this.needsUpdate = !0),
        (this.cacheLengths = null),
        this.getCurveLengths();
    },
    getCurveLengths: function () {
      if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
        return this.cacheLengths;
      for (var t = [], e = 0, n = 0, i = this.curves.length; n < i; n++)
        (e += this.curves[n].getLength()), t.push(e);
      return (this.cacheLengths = t), t;
    },
    getSpacedPoints: function (t) {
      void 0 === t && (t = 40);
      for (var e = [], n = 0; n <= t; n++) e.push(this.getPoint(n / t));
      return this.autoClose && e.push(e[0]), e;
    },
    getPoints: function (t) {
      t = t || 12;
      for (var e, n = [], i = 0, r = this.curves; i < r.length; i++)
        for (
          var o = r[i],
            s =
              o && o.isEllipseCurve
                ? 2 * t
                : o && (o.isLineCurve || o.isLineCurve3)
                ? 1
                : o && o.isSplineCurve
                ? t * o.points.length
                : t,
            a = o.getPoints(s),
            c = 0;
          c < a.length;
          c++
        ) {
          var l = a[c];
          (e && e.equals(l)) || (n.push(l), (e = l));
        }
      return (
        this.autoClose &&
          n.length > 1 &&
          !n[n.length - 1].equals(n[0]) &&
          n.push(n[0]),
        n
      );
    },
    copy: function (t) {
      Oa.prototype.copy.call(this, t), (this.curves = []);
      for (var e = 0, n = t.curves.length; e < n; e++) {
        var i = t.curves[e];
        this.curves.push(i.clone());
      }
      return (this.autoClose = t.autoClose), this;
    },
    toJSON: function () {
      var t = Oa.prototype.toJSON.call(this);
      (t.autoClose = this.autoClose), (t.curves = []);
      for (var e = 0, n = this.curves.length; e < n; e++) {
        var i = this.curves[e];
        t.curves.push(i.toJSON());
      }
      return t;
    },
    fromJSON: function (t) {
      Oa.prototype.fromJSON.call(this, t),
        (this.autoClose = t.autoClose),
        (this.curves = []);
      for (var e = 0, n = t.curves.length; e < n; e++) {
        var i = t.curves[e];
        this.curves.push(new ec[i.type]().fromJSON(i));
      }
      return this;
    },
  })),
    (ic.prototype = Object.assign(Object.create(nc.prototype), {
      constructor: ic,
      setFromPoints: function (t) {
        this.moveTo(t[0].x, t[0].y);
        for (var e = 1, n = t.length; e < n; e++) this.lineTo(t[e].x, t[e].y);
        return this;
      },
      moveTo: function (t, e) {
        return this.currentPoint.set(t, e), this;
      },
      lineTo: function (t, e) {
        var n = new Qa(this.currentPoint.clone(), new U(t, e));
        return this.curves.push(n), this.currentPoint.set(t, e), this;
      },
      quadraticCurveTo: function (t, e, n, i) {
        var r = new $a(this.currentPoint.clone(), new U(t, e), new U(n, i));
        return this.curves.push(r), this.currentPoint.set(n, i), this;
      },
      bezierCurveTo: function (t, e, n, i, r, o) {
        var s = new Ya(
          this.currentPoint.clone(),
          new U(t, e),
          new U(n, i),
          new U(r, o),
        );
        return this.curves.push(s), this.currentPoint.set(r, o), this;
      },
      splineThru: function (t) {
        var e = new tc([this.currentPoint.clone()].concat(t));
        return (
          this.curves.push(e), this.currentPoint.copy(t[t.length - 1]), this
        );
      },
      arc: function (t, e, n, i, r, o) {
        var s = this.currentPoint.x,
          a = this.currentPoint.y;
        return this.absarc(t + s, e + a, n, i, r, o), this;
      },
      absarc: function (t, e, n, i, r, o) {
        return this.absellipse(t, e, n, n, i, r, o), this;
      },
      ellipse: function (t, e, n, i, r, o, s, a) {
        var c = this.currentPoint.x,
          l = this.currentPoint.y;
        return this.absellipse(t + c, e + l, n, i, r, o, s, a), this;
      },
      absellipse: function (t, e, n, i, r, o, s, a) {
        var c = new Va(t, e, n, i, r, o, s, a);
        if (this.curves.length > 0) {
          var l = c.getPoint(0);
          l.equals(this.currentPoint) || this.lineTo(l.x, l.y);
        }
        this.curves.push(c);
        var h = c.getPoint(1);
        return this.currentPoint.copy(h), this;
      },
      copy: function (t) {
        return (
          nc.prototype.copy.call(this, t),
          this.currentPoint.copy(t.currentPoint),
          this
        );
      },
      toJSON: function () {
        var t = nc.prototype.toJSON.call(this);
        return (t.currentPoint = this.currentPoint.toArray()), t;
      },
      fromJSON: function (t) {
        return (
          nc.prototype.fromJSON.call(this, t),
          this.currentPoint.fromArray(t.currentPoint),
          this
        );
      },
    })),
    (rc.prototype = Object.assign(Object.create(ic.prototype), {
      constructor: rc,
      getPointsHoles: function (t) {
        for (var e = [], n = 0, i = this.holes.length; n < i; n++)
          e[n] = this.holes[n].getPoints(t);
        return e;
      },
      extractPoints: function (t) {
        return { shape: this.getPoints(t), holes: this.getPointsHoles(t) };
      },
      copy: function (t) {
        ic.prototype.copy.call(this, t), (this.holes = []);
        for (var e = 0, n = t.holes.length; e < n; e++) {
          var i = t.holes[e];
          this.holes.push(i.clone());
        }
        return this;
      },
      toJSON: function () {
        var t = ic.prototype.toJSON.call(this);
        (t.uuid = this.uuid), (t.holes = []);
        for (var e = 0, n = this.holes.length; e < n; e++) {
          var i = this.holes[e];
          t.holes.push(i.toJSON());
        }
        return t;
      },
      fromJSON: function (t) {
        ic.prototype.fromJSON.call(this, t),
          (this.uuid = t.uuid),
          (this.holes = []);
        for (var e = 0, n = t.holes.length; e < n; e++) {
          var i = t.holes[e];
          this.holes.push(new ic().fromJSON(i));
        }
        return this;
      },
    })),
    (oc.prototype = Object.assign(Object.create(At.prototype), {
      constructor: oc,
      isLight: !0,
      copy: function (t) {
        return (
          At.prototype.copy.call(this, t),
          this.color.copy(t.color),
          (this.intensity = t.intensity),
          this
        );
      },
      toJSON: function (t) {
        var e = At.prototype.toJSON.call(this, t);
        return (
          (e.object.color = this.color.getHex()),
          (e.object.intensity = this.intensity),
          void 0 !== this.groundColor &&
            (e.object.groundColor = this.groundColor.getHex()),
          void 0 !== this.distance && (e.object.distance = this.distance),
          void 0 !== this.angle && (e.object.angle = this.angle),
          void 0 !== this.decay && (e.object.decay = this.decay),
          void 0 !== this.penumbra && (e.object.penumbra = this.penumbra),
          void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()),
          e
        );
      },
    })),
    (sc.prototype = Object.assign(Object.create(oc.prototype), {
      constructor: sc,
      isHemisphereLight: !0,
      copy: function (t) {
        return (
          oc.prototype.copy.call(this, t),
          this.groundColor.copy(t.groundColor),
          this
        );
      },
    })),
    Object.assign(ac.prototype, {
      _projScreenMatrix: new ot(),
      _lightPositionWorld: new J(),
      _lookTarget: new J(),
      getViewportCount: function () {
        return this._viewportCount;
      },
      getFrustum: function () {
        return this._frustum;
      },
      updateMatrices: function (t) {
        var e = this.camera,
          n = this.matrix,
          i = this._projScreenMatrix,
          r = this._lookTarget,
          o = this._lightPositionWorld;
        o.setFromMatrixPosition(t.matrixWorld),
          e.position.copy(o),
          r.setFromMatrixPosition(t.target.matrixWorld),
          e.lookAt(r),
          e.updateMatrixWorld(),
          i.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
          this._frustum.setFromProjectionMatrix(i),
          n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
          n.multiply(e.projectionMatrix),
          n.multiply(e.matrixWorldInverse);
      },
      getViewport: function (t) {
        return this._viewports[t];
      },
      getFrameExtents: function () {
        return this._frameExtents;
      },
      copy: function (t) {
        return (
          (this.camera = t.camera.clone()),
          (this.bias = t.bias),
          (this.radius = t.radius),
          this.mapSize.copy(t.mapSize),
          this
        );
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      toJSON: function () {
        var t = {};
        return (
          0 !== this.bias && (t.bias = this.bias),
          1 !== this.radius && (t.radius = this.radius),
          (512 === this.mapSize.x && 512 === this.mapSize.y) ||
            (t.mapSize = this.mapSize.toArray()),
          (t.camera = this.camera.toJSON(!1).object),
          delete t.camera.matrix,
          t
        );
      },
    }),
    (cc.prototype = Object.assign(Object.create(ac.prototype), {
      constructor: cc,
      isSpotLightShadow: !0,
      updateMatrices: function (t) {
        var e = this.camera,
          n = 2 * k.RAD2DEG * t.angle,
          i = this.mapSize.width / this.mapSize.height,
          r = t.distance || e.far;
        (n === e.fov && i === e.aspect && r === e.far) ||
          ((e.fov = n),
          (e.aspect = i),
          (e.far = r),
          e.updateProjectionMatrix()),
          ac.prototype.updateMatrices.call(this, t);
      },
    })),
    (lc.prototype = Object.assign(Object.create(oc.prototype), {
      constructor: lc,
      isSpotLight: !0,
      copy: function (t) {
        return (
          oc.prototype.copy.call(this, t),
          (this.distance = t.distance),
          (this.angle = t.angle),
          (this.penumbra = t.penumbra),
          (this.decay = t.decay),
          (this.target = t.target.clone()),
          (this.shadow = t.shadow.clone()),
          this
        );
      },
    })),
    (hc.prototype = Object.assign(Object.create(ac.prototype), {
      constructor: hc,
      isPointLightShadow: !0,
      updateMatrices: function (t, e) {
        void 0 === e && (e = 0);
        var n = this.camera,
          i = this.matrix,
          r = this._lightPositionWorld,
          o = this._lookTarget,
          s = this._projScreenMatrix;
        r.setFromMatrixPosition(t.matrixWorld),
          n.position.copy(r),
          o.copy(n.position),
          o.add(this._cubeDirections[e]),
          n.up.copy(this._cubeUps[e]),
          n.lookAt(o),
          n.updateMatrixWorld(),
          i.makeTranslation(-r.x, -r.y, -r.z),
          s.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
          this._frustum.setFromProjectionMatrix(s);
      },
    })),
    (uc.prototype = Object.assign(Object.create(oc.prototype), {
      constructor: uc,
      isPointLight: !0,
      copy: function (t) {
        return (
          oc.prototype.copy.call(this, t),
          (this.distance = t.distance),
          (this.decay = t.decay),
          (this.shadow = t.shadow.clone()),
          this
        );
      },
    })),
    (dc.prototype = Object.assign(Object.create(An.prototype), {
      constructor: dc,
      isOrthographicCamera: !0,
      copy: function (t, e) {
        return (
          An.prototype.copy.call(this, t, e),
          (this.left = t.left),
          (this.right = t.right),
          (this.top = t.top),
          (this.bottom = t.bottom),
          (this.near = t.near),
          (this.far = t.far),
          (this.zoom = t.zoom),
          (this.view = null === t.view ? null : Object.assign({}, t.view)),
          this
        );
      },
      setViewOffset: function (t, e, n, i, r, o) {
        null === this.view &&
          (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1,
          }),
          (this.view.enabled = !0),
          (this.view.fullWidth = t),
          (this.view.fullHeight = e),
          (this.view.offsetX = n),
          (this.view.offsetY = i),
          (this.view.width = r),
          (this.view.height = o),
          this.updateProjectionMatrix();
      },
      clearViewOffset: function () {
        null !== this.view && (this.view.enabled = !1),
          this.updateProjectionMatrix();
      },
      updateProjectionMatrix: function () {
        var t = (this.right - this.left) / (2 * this.zoom),
          e = (this.top - this.bottom) / (2 * this.zoom),
          n = (this.right + this.left) / 2,
          i = (this.top + this.bottom) / 2,
          r = n - t,
          o = n + t,
          s = i + e,
          a = i - e;
        if (null !== this.view && this.view.enabled) {
          var c = (this.right - this.left) / this.view.fullWidth / this.zoom,
            l = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
          (o = (r += c * this.view.offsetX) + c * this.view.width),
            (a = (s -= l * this.view.offsetY) - l * this.view.height);
        }
        this.projectionMatrix.makeOrthographic(r, o, s, a, this.near, this.far),
          this.projectionMatrixInverse.getInverse(this.projectionMatrix);
      },
      toJSON: function (t) {
        var e = At.prototype.toJSON.call(this, t);
        return (
          (e.object.zoom = this.zoom),
          (e.object.left = this.left),
          (e.object.right = this.right),
          (e.object.top = this.top),
          (e.object.bottom = this.bottom),
          (e.object.near = this.near),
          (e.object.far = this.far),
          null !== this.view && (e.object.view = Object.assign({}, this.view)),
          e
        );
      },
    })),
    (pc.prototype = Object.assign(Object.create(ac.prototype), {
      constructor: pc,
      isDirectionalLightShadow: !0,
      updateMatrices: function (t) {
        ac.prototype.updateMatrices.call(this, t);
      },
    })),
    (fc.prototype = Object.assign(Object.create(oc.prototype), {
      constructor: fc,
      isDirectionalLight: !0,
      copy: function (t) {
        return (
          oc.prototype.copy.call(this, t),
          (this.target = t.target.clone()),
          (this.shadow = t.shadow.clone()),
          this
        );
      },
    })),
    (mc.prototype = Object.assign(Object.create(oc.prototype), {
      constructor: mc,
      isAmbientLight: !0,
    })),
    (bc.prototype = Object.assign(Object.create(oc.prototype), {
      constructor: bc,
      isRectAreaLight: !0,
      copy: function (t) {
        return (
          oc.prototype.copy.call(this, t),
          (this.width = t.width),
          (this.height = t.height),
          this
        );
      },
      toJSON: function (t) {
        var e = oc.prototype.toJSON.call(this, t);
        return (
          (e.object.width = this.width), (e.object.height = this.height), e
        );
      },
    })),
    (gc.prototype = Object.assign(Object.create(Ea.prototype), {
      constructor: gc,
      load: function (t, e, n, i) {
        var r = this,
          o = new Ca(r.manager);
        o.setPath(r.path),
          o.load(
            t,
            function (t) {
              e(r.parse(JSON.parse(t)));
            },
            n,
            i,
          );
      },
      parse: function (t) {
        var e = this.textures;
        function n(t) {
          return (
            void 0 === e[t] &&
              console.warn('THREE.MaterialLoader: Undefined texture', t),
            e[t]
          );
        }
        var i = new ca[t.type]();
        if (
          (void 0 !== t.uuid && (i.uuid = t.uuid),
          void 0 !== t.name && (i.name = t.name),
          void 0 !== t.color && i.color.setHex(t.color),
          void 0 !== t.roughness && (i.roughness = t.roughness),
          void 0 !== t.metalness && (i.metalness = t.metalness),
          void 0 !== t.sheen && (i.sheen = new fe().setHex(t.sheen)),
          void 0 !== t.emissive && i.emissive.setHex(t.emissive),
          void 0 !== t.specular && i.specular.setHex(t.specular),
          void 0 !== t.shininess && (i.shininess = t.shininess),
          void 0 !== t.clearcoat && (i.clearcoat = t.clearcoat),
          void 0 !== t.clearcoatRoughness &&
            (i.clearcoatRoughness = t.clearcoatRoughness),
          void 0 !== t.fog && (i.fog = t.fog),
          void 0 !== t.flatShading && (i.flatShading = t.flatShading),
          void 0 !== t.blending && (i.blending = t.blending),
          void 0 !== t.combine && (i.combine = t.combine),
          void 0 !== t.side && (i.side = t.side),
          void 0 !== t.opacity && (i.opacity = t.opacity),
          void 0 !== t.transparent && (i.transparent = t.transparent),
          void 0 !== t.alphaTest && (i.alphaTest = t.alphaTest),
          void 0 !== t.depthTest && (i.depthTest = t.depthTest),
          void 0 !== t.depthWrite && (i.depthWrite = t.depthWrite),
          void 0 !== t.colorWrite && (i.colorWrite = t.colorWrite),
          void 0 !== t.stencilWrite && (i.stencilWrite = t.stencilWrite),
          void 0 !== t.stencilWriteMask &&
            (i.stencilWriteMask = t.stencilWriteMask),
          void 0 !== t.stencilFunc && (i.stencilFunc = t.stencilFunc),
          void 0 !== t.stencilRef && (i.stencilRef = t.stencilRef),
          void 0 !== t.stencilFuncMask &&
            (i.stencilFuncMask = t.stencilFuncMask),
          void 0 !== t.stencilFail && (i.stencilFail = t.stencilFail),
          void 0 !== t.stencilZFail && (i.stencilZFail = t.stencilZFail),
          void 0 !== t.stencilZPass && (i.stencilZPass = t.stencilZPass),
          void 0 !== t.wireframe && (i.wireframe = t.wireframe),
          void 0 !== t.wireframeLinewidth &&
            (i.wireframeLinewidth = t.wireframeLinewidth),
          void 0 !== t.wireframeLinecap &&
            (i.wireframeLinecap = t.wireframeLinecap),
          void 0 !== t.wireframeLinejoin &&
            (i.wireframeLinejoin = t.wireframeLinejoin),
          void 0 !== t.rotation && (i.rotation = t.rotation),
          1 !== t.linewidth && (i.linewidth = t.linewidth),
          void 0 !== t.dashSize && (i.dashSize = t.dashSize),
          void 0 !== t.gapSize && (i.gapSize = t.gapSize),
          void 0 !== t.scale && (i.scale = t.scale),
          void 0 !== t.polygonOffset && (i.polygonOffset = t.polygonOffset),
          void 0 !== t.polygonOffsetFactor &&
            (i.polygonOffsetFactor = t.polygonOffsetFactor),
          void 0 !== t.polygonOffsetUnits &&
            (i.polygonOffsetUnits = t.polygonOffsetUnits),
          void 0 !== t.skinning && (i.skinning = t.skinning),
          void 0 !== t.morphTargets && (i.morphTargets = t.morphTargets),
          void 0 !== t.morphNormals && (i.morphNormals = t.morphNormals),
          void 0 !== t.dithering && (i.dithering = t.dithering),
          void 0 !== t.vertexTangents && (i.vertexTangents = t.vertexTangents),
          void 0 !== t.visible && (i.visible = t.visible),
          void 0 !== t.toneMapped && (i.toneMapped = t.toneMapped),
          void 0 !== t.userData && (i.userData = t.userData),
          void 0 !== t.vertexColors &&
            ('number' == typeof t.vertexColors
              ? (i.vertexColors = t.vertexColors > 0)
              : (i.vertexColors = t.vertexColors)),
          void 0 !== t.uniforms)
        )
          for (var r in t.uniforms) {
            var o = t.uniforms[r];
            switch (((i.uniforms[r] = {}), o.type)) {
              case 't':
                i.uniforms[r].value = n(o.value);
                break;
              case 'c':
                i.uniforms[r].value = new fe().setHex(o.value);
                break;
              case 'v2':
                i.uniforms[r].value = new U().fromArray(o.value);
                break;
              case 'v3':
                i.uniforms[r].value = new J().fromArray(o.value);
                break;
              case 'v4':
                i.uniforms[r].value = new W().fromArray(o.value);
                break;
              case 'm3':
                i.uniforms[r].value = new G().fromArray(o.value);
              case 'm4':
                i.uniforms[r].value = new ot().fromArray(o.value);
                break;
              default:
                i.uniforms[r].value = o.value;
            }
          }
        if (
          (void 0 !== t.defines && (i.defines = t.defines),
          void 0 !== t.vertexShader && (i.vertexShader = t.vertexShader),
          void 0 !== t.fragmentShader && (i.fragmentShader = t.fragmentShader),
          void 0 !== t.extensions)
        )
          for (var s in t.extensions) i.extensions[s] = t.extensions[s];
        if (
          (void 0 !== t.shading && (i.flatShading = 1 === t.shading),
          void 0 !== t.size && (i.size = t.size),
          void 0 !== t.sizeAttenuation &&
            (i.sizeAttenuation = t.sizeAttenuation),
          void 0 !== t.map && (i.map = n(t.map)),
          void 0 !== t.matcap && (i.matcap = n(t.matcap)),
          void 0 !== t.alphaMap && (i.alphaMap = n(t.alphaMap)),
          void 0 !== t.bumpMap && (i.bumpMap = n(t.bumpMap)),
          void 0 !== t.bumpScale && (i.bumpScale = t.bumpScale),
          void 0 !== t.normalMap && (i.normalMap = n(t.normalMap)),
          void 0 !== t.normalMapType && (i.normalMapType = t.normalMapType),
          void 0 !== t.normalScale)
        ) {
          var a = t.normalScale;
          !1 === Array.isArray(a) && (a = [a, a]),
            (i.normalScale = new U().fromArray(a));
        }
        return (
          void 0 !== t.displacementMap &&
            (i.displacementMap = n(t.displacementMap)),
          void 0 !== t.displacementScale &&
            (i.displacementScale = t.displacementScale),
          void 0 !== t.displacementBias &&
            (i.displacementBias = t.displacementBias),
          void 0 !== t.roughnessMap && (i.roughnessMap = n(t.roughnessMap)),
          void 0 !== t.metalnessMap && (i.metalnessMap = n(t.metalnessMap)),
          void 0 !== t.emissiveMap && (i.emissiveMap = n(t.emissiveMap)),
          void 0 !== t.emissiveIntensity &&
            (i.emissiveIntensity = t.emissiveIntensity),
          void 0 !== t.specularMap && (i.specularMap = n(t.specularMap)),
          void 0 !== t.envMap && (i.envMap = n(t.envMap)),
          void 0 !== t.envMapIntensity &&
            (i.envMapIntensity = t.envMapIntensity),
          void 0 !== t.reflectivity && (i.reflectivity = t.reflectivity),
          void 0 !== t.refractionRatio &&
            (i.refractionRatio = t.refractionRatio),
          void 0 !== t.lightMap && (i.lightMap = n(t.lightMap)),
          void 0 !== t.lightMapIntensity &&
            (i.lightMapIntensity = t.lightMapIntensity),
          void 0 !== t.aoMap && (i.aoMap = n(t.aoMap)),
          void 0 !== t.aoMapIntensity && (i.aoMapIntensity = t.aoMapIntensity),
          void 0 !== t.gradientMap && (i.gradientMap = n(t.gradientMap)),
          void 0 !== t.clearcoatMap && (i.clearcoatMap = n(t.clearcoatMap)),
          void 0 !== t.clearcoatRoughnessMap &&
            (i.clearcoatRoughnessMap = n(t.clearcoatRoughnessMap)),
          void 0 !== t.clearcoatNormalMap &&
            (i.clearcoatNormalMap = n(t.clearcoatNormalMap)),
          void 0 !== t.clearcoatNormalScale &&
            (i.clearcoatNormalScale = new U().fromArray(
              t.clearcoatNormalScale,
            )),
          i
        );
      },
      setTextures: function (t) {
        return (this.textures = t), this;
      },
    }));
  var yc = function (t) {
    var e = t.lastIndexOf('/');
    return -1 === e ? './' : t.substr(0, e + 1);
  };
  function vc() {
    He.call(this),
      (this.type = 'InstancedBufferGeometry'),
      (this.maxInstancedCount = void 0);
  }
  function _c(t, e, n, i) {
    'number' == typeof n &&
      ((i = n),
      (n = !1),
      console.error(
        'THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.',
      )),
      Ae.call(this, t, e, n),
      (this.meshPerAttribute = i || 1);
  }
  function xc(t) {
    Ea.call(this, t);
  }
  (vc.prototype = Object.assign(Object.create(He.prototype), {
    constructor: vc,
    isInstancedBufferGeometry: !0,
    copy: function (t) {
      return (
        He.prototype.copy.call(this, t),
        (this.maxInstancedCount = t.maxInstancedCount),
        this
      );
    },
    clone: function () {
      return new this.constructor().copy(this);
    },
    toJSON: function () {
      var t = He.prototype.toJSON.call(this);
      return (
        (t.maxInstancedCount = this.maxInstancedCount),
        (t.isInstancedBufferGeometry = !0),
        t
      );
    },
  })),
    (_c.prototype = Object.assign(Object.create(Ae.prototype), {
      constructor: _c,
      isInstancedBufferAttribute: !0,
      copy: function (t) {
        return (
          Ae.prototype.copy.call(this, t),
          (this.meshPerAttribute = t.meshPerAttribute),
          this
        );
      },
      toJSON: function () {
        var t = Ae.prototype.toJSON.call(this);
        return (
          (t.meshPerAttribute = this.meshPerAttribute),
          (t.isInstancedBufferAttribute = !0),
          t
        );
      },
    })),
    (xc.prototype = Object.assign(Object.create(Ea.prototype), {
      constructor: xc,
      load: function (t, e, n, i) {
        var r = this,
          o = new Ca(r.manager);
        o.setPath(r.path),
          o.load(
            t,
            function (t) {
              e(r.parse(JSON.parse(t)));
            },
            n,
            i,
          );
      },
      parse: function (t) {
        var e = t.isInstancedBufferGeometry ? new vc() : new He(),
          n = t.data.index;
        if (void 0 !== n) {
          var i = new wc[n.type](n.array);
          e.setIndex(new Ae(i, 1));
        }
        var r = t.data.attributes;
        for (var o in r) {
          var s = r[o],
            a =
              ((i = new wc[s.type](s.array)),
              new (s.isInstancedBufferAttribute ? _c : Ae)(
                i,
                s.itemSize,
                s.normalized,
              ));
          void 0 !== s.name && (a.name = s.name), e.setAttribute(o, a);
        }
        var c = t.data.morphAttributes;
        if (c)
          for (var o in c) {
            for (var l = c[o], h = [], u = 0, d = l.length; u < d; u++) {
              (s = l[u]),
                (a = new Ae(
                  (i = new wc[s.type](s.array)),
                  s.itemSize,
                  s.normalized,
                ));
              void 0 !== s.name && (a.name = s.name), h.push(a);
            }
            e.morphAttributes[o] = h;
          }
        t.data.morphTargetsRelative && (e.morphTargetsRelative = !0);
        var p = t.data.groups || t.data.drawcalls || t.data.offsets;
        if (void 0 !== p) {
          u = 0;
          for (var f = p.length; u !== f; ++u) {
            var m = p[u];
            e.addGroup(m.start, m.count, m.materialIndex);
          }
        }
        var b = t.data.boundingSphere;
        if (void 0 !== b) {
          var g = new J();
          void 0 !== b.center && g.fromArray(b.center),
            (e.boundingSphere = new Gt(g, b.radius));
        }
        return (
          t.name && (e.name = t.name),
          t.userData && (e.userData = t.userData),
          e
        );
      },
    }));
  var wc = {
    Int8Array: Int8Array,
    Uint8Array: Uint8Array,
    Uint8ClampedArray:
      'undefined' != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
    Int16Array: Int16Array,
    Uint16Array: Uint16Array,
    Int32Array: Int32Array,
    Uint32Array: Uint32Array,
    Float32Array: Float32Array,
    Float64Array: Float64Array,
  };
  function Ac(t) {
    Ea.call(this, t);
  }
  Ac.prototype = Object.assign(Object.create(Ea.prototype), {
    constructor: Ac,
    load: function (t, e, n, i) {
      var r = this,
        o = '' === this.path ? yc(t) : this.path;
      this.resourcePath = this.resourcePath || o;
      var s = new Ca(r.manager);
      s.setPath(this.path),
        s.load(
          t,
          function (n) {
            var o = null;
            try {
              o = JSON.parse(n);
            } catch (e) {
              return (
                void 0 !== i && i(e),
                void console.error(
                  "THREE:ObjectLoader: Can't parse " + t + '.',
                  e.message,
                )
              );
            }
            var s = o.metadata;
            void 0 !== s &&
            void 0 !== s.type &&
            'geometry' !== s.type.toLowerCase()
              ? r.parse(o, e)
              : console.error("THREE.ObjectLoader: Can't load " + t);
          },
          n,
          i,
        );
    },
    parse: function (t, e) {
      var n = this.parseShape(t.shapes),
        i = this.parseGeometries(t.geometries, n),
        r = this.parseImages(t.images, function () {
          void 0 !== e && e(a);
        }),
        o = this.parseTextures(t.textures, r),
        s = this.parseMaterials(t.materials, o),
        a = this.parseObject(t.object, i, s);
      return (
        t.animations && (a.animations = this.parseAnimations(t.animations)),
        (void 0 !== t.images && 0 !== t.images.length) ||
          (void 0 !== e && e(a)),
        a
      );
    },
    parseShape: function (t) {
      var e = {};
      if (void 0 !== t)
        for (var n = 0, i = t.length; n < i; n++) {
          var r = new rc().fromJSON(t[n]);
          e[r.uuid] = r;
        }
      return e;
    },
    parseGeometries: function (t, e) {
      var n = {};
      if (void 0 !== t)
        for (var i = new xc(), r = 0, o = t.length; r < o; r++) {
          var s,
            a = t[r];
          switch (a.type) {
            case 'PlaneGeometry':
            case 'PlaneBufferGeometry':
              s = new Qs[a.type](
                a.width,
                a.height,
                a.widthSegments,
                a.heightSegments,
              );
              break;
            case 'BoxGeometry':
            case 'BoxBufferGeometry':
            case 'CubeGeometry':
              s = new Qs[a.type](
                a.width,
                a.height,
                a.depth,
                a.widthSegments,
                a.heightSegments,
                a.depthSegments,
              );
              break;
            case 'CircleGeometry':
            case 'CircleBufferGeometry':
              s = new Qs[a.type](
                a.radius,
                a.segments,
                a.thetaStart,
                a.thetaLength,
              );
              break;
            case 'CylinderGeometry':
            case 'CylinderBufferGeometry':
              s = new Qs[a.type](
                a.radiusTop,
                a.radiusBottom,
                a.height,
                a.radialSegments,
                a.heightSegments,
                a.openEnded,
                a.thetaStart,
                a.thetaLength,
              );
              break;
            case 'ConeGeometry':
            case 'ConeBufferGeometry':
              s = new Qs[a.type](
                a.radius,
                a.height,
                a.radialSegments,
                a.heightSegments,
                a.openEnded,
                a.thetaStart,
                a.thetaLength,
              );
              break;
            case 'SphereGeometry':
            case 'SphereBufferGeometry':
              s = new Qs[a.type](
                a.radius,
                a.widthSegments,
                a.heightSegments,
                a.phiStart,
                a.phiLength,
                a.thetaStart,
                a.thetaLength,
              );
              break;
            case 'DodecahedronGeometry':
            case 'DodecahedronBufferGeometry':
            case 'IcosahedronGeometry':
            case 'IcosahedronBufferGeometry':
            case 'OctahedronGeometry':
            case 'OctahedronBufferGeometry':
            case 'TetrahedronGeometry':
            case 'TetrahedronBufferGeometry':
              s = new Qs[a.type](a.radius, a.detail);
              break;
            case 'RingGeometry':
            case 'RingBufferGeometry':
              s = new Qs[a.type](
                a.innerRadius,
                a.outerRadius,
                a.thetaSegments,
                a.phiSegments,
                a.thetaStart,
                a.thetaLength,
              );
              break;
            case 'TorusGeometry':
            case 'TorusBufferGeometry':
              s = new Qs[a.type](
                a.radius,
                a.tube,
                a.radialSegments,
                a.tubularSegments,
                a.arc,
              );
              break;
            case 'TorusKnotGeometry':
            case 'TorusKnotBufferGeometry':
              s = new Qs[a.type](
                a.radius,
                a.tube,
                a.tubularSegments,
                a.radialSegments,
                a.p,
                a.q,
              );
              break;
            case 'TubeGeometry':
            case 'TubeBufferGeometry':
              s = new Qs[a.type](
                new ec[a.path.type]().fromJSON(a.path),
                a.tubularSegments,
                a.radius,
                a.radialSegments,
                a.closed,
              );
              break;
            case 'LatheGeometry':
            case 'LatheBufferGeometry':
              s = new Qs[a.type](a.points, a.segments, a.phiStart, a.phiLength);
              break;
            case 'PolyhedronGeometry':
            case 'PolyhedronBufferGeometry':
              s = new Qs[a.type](a.vertices, a.indices, a.radius, a.details);
              break;
            case 'ShapeGeometry':
            case 'ShapeBufferGeometry':
              for (var c = [], l = 0, h = a.shapes.length; l < h; l++) {
                var u = e[a.shapes[l]];
                c.push(u);
              }
              s = new Qs[a.type](c, a.curveSegments);
              break;
            case 'ExtrudeGeometry':
            case 'ExtrudeBufferGeometry':
              for (c = [], l = 0, h = a.shapes.length; l < h; l++) {
                u = e[a.shapes[l]];
                c.push(u);
              }
              var d = a.options.extrudePath;
              void 0 !== d &&
                (a.options.extrudePath = new ec[d.type]().fromJSON(d)),
                (s = new Qs[a.type](c, a.options));
              break;
            case 'BufferGeometry':
            case 'InstancedBufferGeometry':
              s = i.parse(a);
              break;
            case 'Geometry':
              console.error(
                'THREE.ObjectLoader: Loading "Geometry" is not supported anymore.',
              );
              break;
            default:
              console.warn(
                'THREE.ObjectLoader: Unsupported geometry type "' +
                  a.type +
                  '"',
              );
              continue;
          }
          (s.uuid = a.uuid),
            void 0 !== a.name && (s.name = a.name),
            !0 === s.isBufferGeometry &&
              void 0 !== a.userData &&
              (s.userData = a.userData),
            (n[a.uuid] = s);
        }
      return n;
    },
    parseMaterials: function (t, e) {
      var n = {},
        i = {};
      if (void 0 !== t) {
        var r = new gc();
        r.setTextures(e);
        for (var o = 0, s = t.length; o < s; o++) {
          var a = t[o];
          if ('MultiMaterial' === a.type) {
            for (var c = [], l = 0; l < a.materials.length; l++) {
              var h = a.materials[l];
              void 0 === n[h.uuid] && (n[h.uuid] = r.parse(h)),
                c.push(n[h.uuid]);
            }
            i[a.uuid] = c;
          } else
            void 0 === n[a.uuid] && (n[a.uuid] = r.parse(a)),
              (i[a.uuid] = n[a.uuid]);
        }
      }
      return i;
    },
    parseAnimations: function (t) {
      for (var e = [], n = 0; n < t.length; n++) {
        var i = t[n],
          r = wa.parse(i);
        void 0 !== i.uuid && (r.uuid = i.uuid), e.push(r);
      }
      return e;
    },
    parseImages: function (t, e) {
      var n = this,
        i = {};
      function r(t) {
        return (
          n.manager.itemStart(t),
          o.load(
            t,
            function () {
              n.manager.itemEnd(t);
            },
            void 0,
            function () {
              n.manager.itemError(t), n.manager.itemEnd(t);
            },
          )
        );
      }
      if (void 0 !== t && t.length > 0) {
        var o = new Fa(new Sa(e));
        o.setCrossOrigin(this.crossOrigin);
        for (var s = 0, a = t.length; s < a; s++) {
          var c = t[s],
            l = c.url;
          if (Array.isArray(l)) {
            i[c.uuid] = [];
            for (var h = 0, u = l.length; h < u; h++) {
              var d = l[h],
                p = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(d)
                  ? d
                  : n.resourcePath + d;
              i[c.uuid].push(r(p));
            }
          } else {
            p = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c.url)
              ? c.url
              : n.resourcePath + c.url;
            i[c.uuid] = r(p);
          }
        }
      }
      return i;
    },
    parseTextures: function (t, e) {
      function n(t, e) {
        return 'number' == typeof t
          ? t
          : (console.warn(
              'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.',
              t,
            ),
            e[t]);
      }
      var i = {};
      if (void 0 !== t)
        for (var r = 0, o = t.length; r < o; r++) {
          var s,
            a = t[r];
          void 0 === a.image &&
            console.warn(
              'THREE.ObjectLoader: No "image" specified for',
              a.uuid,
            ),
            void 0 === e[a.image] &&
              console.warn('THREE.ObjectLoader: Undefined image', a.image),
            ((s = Array.isArray(e[a.image])
              ? new Qn(e[a.image])
              : new H(e[a.image])).needsUpdate = !0),
            (s.uuid = a.uuid),
            void 0 !== a.name && (s.name = a.name),
            void 0 !== a.mapping && (s.mapping = n(a.mapping, Sc)),
            void 0 !== a.offset && s.offset.fromArray(a.offset),
            void 0 !== a.repeat && s.repeat.fromArray(a.repeat),
            void 0 !== a.center && s.center.fromArray(a.center),
            void 0 !== a.rotation && (s.rotation = a.rotation),
            void 0 !== a.wrap &&
              ((s.wrapS = n(a.wrap[0], Ic)), (s.wrapT = n(a.wrap[1], Ic))),
            void 0 !== a.format && (s.format = a.format),
            void 0 !== a.type && (s.type = a.type),
            void 0 !== a.encoding && (s.encoding = a.encoding),
            void 0 !== a.minFilter && (s.minFilter = n(a.minFilter, Ec)),
            void 0 !== a.magFilter && (s.magFilter = n(a.magFilter, Ec)),
            void 0 !== a.anisotropy && (s.anisotropy = a.anisotropy),
            void 0 !== a.flipY && (s.flipY = a.flipY),
            void 0 !== a.premultiplyAlpha &&
              (s.premultiplyAlpha = a.premultiplyAlpha),
            void 0 !== a.unpackAlignment &&
              (s.unpackAlignment = a.unpackAlignment),
            (i[a.uuid] = s);
        }
      return i;
    },
    parseObject: function (t, e, n) {
      var i;
      function r(t) {
        return (
          void 0 === e[t] &&
            console.warn('THREE.ObjectLoader: Undefined geometry', t),
          e[t]
        );
      }
      function o(t) {
        if (void 0 !== t) {
          if (Array.isArray(t)) {
            for (var e = [], i = 0, r = t.length; i < r; i++) {
              var o = t[i];
              void 0 === n[o] &&
                console.warn('THREE.ObjectLoader: Undefined material', o),
                e.push(n[o]);
            }
            return e;
          }
          return (
            void 0 === n[t] &&
              console.warn('THREE.ObjectLoader: Undefined material', t),
            n[t]
          );
        }
      }
      switch (t.type) {
        case 'Scene':
          (i = new Mt()),
            void 0 !== t.background &&
              Number.isInteger(t.background) &&
              (i.background = new fe(t.background)),
            void 0 !== t.fog &&
              ('Fog' === t.fog.type
                ? (i.fog = new Or(t.fog.color, t.fog.near, t.fog.far))
                : 'FogExp2' === t.fog.type &&
                  (i.fog = new Br(t.fog.color, t.fog.density)));
          break;
        case 'PerspectiveCamera':
          (i = new Mn(t.fov, t.aspect, t.near, t.far)),
            void 0 !== t.focus && (i.focus = t.focus),
            void 0 !== t.zoom && (i.zoom = t.zoom),
            void 0 !== t.filmGauge && (i.filmGauge = t.filmGauge),
            void 0 !== t.filmOffset && (i.filmOffset = t.filmOffset),
            void 0 !== t.view && (i.view = Object.assign({}, t.view));
          break;
        case 'OrthographicCamera':
          (i = new dc(t.left, t.right, t.top, t.bottom, t.near, t.far)),
            void 0 !== t.zoom && (i.zoom = t.zoom),
            void 0 !== t.view && (i.view = Object.assign({}, t.view));
          break;
        case 'AmbientLight':
          i = new mc(t.color, t.intensity);
          break;
        case 'DirectionalLight':
          i = new fc(t.color, t.intensity);
          break;
        case 'PointLight':
          i = new uc(t.color, t.intensity, t.distance, t.decay);
          break;
        case 'RectAreaLight':
          i = new bc(t.color, t.intensity, t.width, t.height);
          break;
        case 'SpotLight':
          i = new lc(
            t.color,
            t.intensity,
            t.distance,
            t.angle,
            t.penumbra,
            t.decay,
          );
          break;
        case 'HemisphereLight':
          i = new sc(t.color, t.groundColor, t.intensity);
          break;
        case 'SkinnedMesh':
          console.warn(
            'THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.',
          );
        case 'Mesh':
          i = new ln((s = r(t.geometry)), (a = o(t.material)));
          break;
        case 'InstancedMesh':
          var s = r(t.geometry),
            a = o(t.material),
            c = t.count,
            l = t.instanceMatrix;
          (i = new mo(s, a, c)).instanceMatrix = new Ae(
            new Float32Array(l.array),
            16,
          );
          break;
        case 'LOD':
          i = new ro();
          break;
        case 'Line':
          i = new wo(r(t.geometry), o(t.material), t.mode);
          break;
        case 'LineLoop':
          i = new Io(r(t.geometry), o(t.material));
          break;
        case 'LineSegments':
          i = new So(r(t.geometry), o(t.material));
          break;
        case 'PointCloud':
        case 'Points':
          i = new Ro(r(t.geometry), o(t.material));
          break;
        case 'Sprite':
          i = new to(o(t.material));
          break;
        case 'Group':
          i = new Rr();
          break;
        default:
          i = new At();
      }
      if (
        ((i.uuid = t.uuid),
        void 0 !== t.name && (i.name = t.name),
        void 0 !== t.matrix
          ? (i.matrix.fromArray(t.matrix),
            void 0 !== t.matrixAutoUpdate &&
              (i.matrixAutoUpdate = t.matrixAutoUpdate),
            i.matrixAutoUpdate &&
              i.matrix.decompose(i.position, i.quaternion, i.scale))
          : (void 0 !== t.position && i.position.fromArray(t.position),
            void 0 !== t.rotation && i.rotation.fromArray(t.rotation),
            void 0 !== t.quaternion && i.quaternion.fromArray(t.quaternion),
            void 0 !== t.scale && i.scale.fromArray(t.scale)),
        void 0 !== t.castShadow && (i.castShadow = t.castShadow),
        void 0 !== t.receiveShadow && (i.receiveShadow = t.receiveShadow),
        t.shadow &&
          (void 0 !== t.shadow.bias && (i.shadow.bias = t.shadow.bias),
          void 0 !== t.shadow.radius && (i.shadow.radius = t.shadow.radius),
          void 0 !== t.shadow.mapSize &&
            i.shadow.mapSize.fromArray(t.shadow.mapSize),
          void 0 !== t.shadow.camera &&
            (i.shadow.camera = this.parseObject(t.shadow.camera))),
        void 0 !== t.visible && (i.visible = t.visible),
        void 0 !== t.frustumCulled && (i.frustumCulled = t.frustumCulled),
        void 0 !== t.renderOrder && (i.renderOrder = t.renderOrder),
        void 0 !== t.userData && (i.userData = t.userData),
        void 0 !== t.layers && (i.layers.mask = t.layers),
        void 0 !== t.children)
      )
        for (var h = t.children, u = 0; u < h.length; u++)
          i.add(this.parseObject(h[u], e, n));
      if ('LOD' === t.type) {
        void 0 !== t.autoUpdate && (i.autoUpdate = t.autoUpdate);
        for (var d = t.levels, p = 0; p < d.length; p++) {
          var f = d[p],
            m = i.getObjectByProperty('uuid', f.object);
          void 0 !== m && i.addLevel(m, f.distance);
        }
      }
      return i;
    },
  });
  var Mc,
    Sc = {
      UVMapping: 300,
      CubeReflectionMapping: 301,
      CubeRefractionMapping: 302,
      EquirectangularReflectionMapping: 303,
      EquirectangularRefractionMapping: 304,
      SphericalReflectionMapping: 305,
      CubeUVReflectionMapping: r,
      CubeUVRefractionMapping: 307,
    },
    Ic = {
      RepeatWrapping: o,
      ClampToEdgeWrapping: s,
      MirroredRepeatWrapping: a,
    },
    Ec = {
      NearestFilter: c,
      NearestMipmapNearestFilter: l,
      NearestMipmapLinearFilter: h,
      LinearFilter: u,
      LinearMipmapNearestFilter: 1007,
      LinearMipmapLinearFilter: d,
    };
  function Dc(t) {
    'undefined' == typeof createImageBitmap &&
      console.warn(
        'THREE.ImageBitmapLoader: createImageBitmap() not supported.',
      ),
      'undefined' == typeof fetch &&
        console.warn('THREE.ImageBitmapLoader: fetch() not supported.'),
      Ea.call(this, t),
      (this.options = void 0);
  }
  function Cc() {
    (this.type = 'ShapePath'),
      (this.color = new fe()),
      (this.subPaths = []),
      (this.currentPath = null);
  }
  function Tc(t) {
    (this.type = 'Font'), (this.data = t);
  }
  function Lc(t, e, n, i, r) {
    var o = r.glyphs[t] || r.glyphs['?'];
    if (o) {
      var s,
        a,
        c,
        l,
        h,
        u,
        d,
        p,
        f = new Cc();
      if (o.o)
        for (
          var m = o._cachedOutline || (o._cachedOutline = o.o.split(' ')),
            b = 0,
            g = m.length;
          b < g;

        ) {
          switch (m[b++]) {
            case 'm':
              (s = m[b++] * e + n), (a = m[b++] * e + i), f.moveTo(s, a);
              break;
            case 'l':
              (s = m[b++] * e + n), (a = m[b++] * e + i), f.lineTo(s, a);
              break;
            case 'q':
              (c = m[b++] * e + n),
                (l = m[b++] * e + i),
                (h = m[b++] * e + n),
                (u = m[b++] * e + i),
                f.quadraticCurveTo(h, u, c, l);
              break;
            case 'b':
              (c = m[b++] * e + n),
                (l = m[b++] * e + i),
                (h = m[b++] * e + n),
                (u = m[b++] * e + i),
                (d = m[b++] * e + n),
                (p = m[b++] * e + i),
                f.bezierCurveTo(h, u, d, p, c, l);
          }
        }
      return { offsetX: o.ha * e, path: f };
    }
    console.error(
      'THREE.Font: character "' +
        t +
        '" does not exists in font family ' +
        r.familyName +
        '.',
    );
  }
  function Rc(t) {
    Ea.call(this, t);
  }
  (Dc.prototype = Object.assign(Object.create(Ea.prototype), {
    constructor: Dc,
    setOptions: function (t) {
      return (this.options = t), this;
    },
    load: function (t, e, n, i) {
      void 0 === t && (t = ''),
        void 0 !== this.path && (t = this.path + t),
        (t = this.manager.resolveURL(t));
      var r = this,
        o = Ma.get(t);
      if (void 0 !== o)
        return (
          r.manager.itemStart(t),
          setTimeout(function () {
            e && e(o), r.manager.itemEnd(t);
          }, 0),
          o
        );
      fetch(t)
        .then(function (t) {
          return t.blob();
        })
        .then(function (t) {
          return void 0 === r.options
            ? createImageBitmap(t)
            : createImageBitmap(t, r.options);
        })
        .then(function (n) {
          Ma.add(t, n), e && e(n), r.manager.itemEnd(t);
        })
        .catch(function (e) {
          i && i(e), r.manager.itemError(t), r.manager.itemEnd(t);
        }),
        r.manager.itemStart(t);
    },
  })),
    Object.assign(Cc.prototype, {
      moveTo: function (t, e) {
        return (
          (this.currentPath = new ic()),
          this.subPaths.push(this.currentPath),
          this.currentPath.moveTo(t, e),
          this
        );
      },
      lineTo: function (t, e) {
        return this.currentPath.lineTo(t, e), this;
      },
      quadraticCurveTo: function (t, e, n, i) {
        return this.currentPath.quadraticCurveTo(t, e, n, i), this;
      },
      bezierCurveTo: function (t, e, n, i, r, o) {
        return this.currentPath.bezierCurveTo(t, e, n, i, r, o), this;
      },
      splineThru: function (t) {
        return this.currentPath.splineThru(t), this;
      },
      toShapes: function (t, e) {
        function n(t) {
          for (var e = [], n = 0, i = t.length; n < i; n++) {
            var r = t[n],
              o = new rc();
            (o.curves = r.curves), e.push(o);
          }
          return e;
        }
        function i(t, e) {
          for (var n = e.length, i = !1, r = n - 1, o = 0; o < n; r = o++) {
            var s = e[r],
              a = e[o],
              c = a.x - s.x,
              l = a.y - s.y;
            if (Math.abs(l) > Number.EPSILON) {
              if (
                (l < 0 && ((s = e[o]), (c = -c), (a = e[r]), (l = -l)),
                t.y < s.y || t.y > a.y)
              )
                continue;
              if (t.y === s.y) {
                if (t.x === s.x) return !0;
              } else {
                var h = l * (t.x - s.x) - c * (t.y - s.y);
                if (0 === h) return !0;
                if (h < 0) continue;
                i = !i;
              }
            } else {
              if (t.y !== s.y) continue;
              if ((a.x <= t.x && t.x <= s.x) || (s.x <= t.x && t.x <= a.x))
                return !0;
            }
          }
          return i;
        }
        var r = Ss.isClockWise,
          o = this.subPaths;
        if (0 === o.length) return [];
        if (!0 === e) return n(o);
        var s,
          a,
          c,
          l = [];
        if (1 === o.length)
          return (a = o[0]), ((c = new rc()).curves = a.curves), l.push(c), l;
        var h = !r(o[0].getPoints());
        h = t ? !h : h;
        var u,
          d,
          p = [],
          f = [],
          m = [],
          b = 0;
        (f[b] = void 0), (m[b] = []);
        for (var g = 0, y = o.length; g < y; g++)
          (s = r((u = (a = o[g]).getPoints()))),
            (s = t ? !s : s)
              ? (!h && f[b] && b++,
                (f[b] = { s: new rc(), p: u }),
                (f[b].s.curves = a.curves),
                h && b++,
                (m[b] = []))
              : m[b].push({ h: a, p: u[0] });
        if (!f[0]) return n(o);
        if (f.length > 1) {
          for (var v = !1, _ = [], x = 0, w = f.length; x < w; x++) p[x] = [];
          for (x = 0, w = f.length; x < w; x++)
            for (var A = m[x], M = 0; M < A.length; M++) {
              for (var S = A[M], I = !0, E = 0; E < f.length; E++)
                i(S.p, f[E].p) &&
                  (x !== E && _.push({ froms: x, tos: E, hole: M }),
                  I ? ((I = !1), p[E].push(S)) : (v = !0));
              I && p[x].push(S);
            }
          _.length > 0 && (v || (m = p));
        }
        g = 0;
        for (var D = f.length; g < D; g++) {
          (c = f[g].s), l.push(c);
          for (var C = 0, T = (d = m[g]).length; C < T; C++)
            c.holes.push(d[C].h);
        }
        return l;
      },
    }),
    Object.assign(Tc.prototype, {
      isFont: !0,
      generateShapes: function (t, e) {
        void 0 === e && (e = 100);
        for (
          var n = [],
            i = (function (t, e, n) {
              for (
                var i = Array.from ? Array.from(t) : String(t).split(''),
                  r = e / n.resolution,
                  o =
                    (n.boundingBox.yMax -
                      n.boundingBox.yMin +
                      n.underlineThickness) *
                    r,
                  s = [],
                  a = 0,
                  c = 0,
                  l = 0;
                l < i.length;
                l++
              ) {
                var h = i[l];
                if ('\n' === h) (a = 0), (c -= o);
                else {
                  var u = Lc(h, r, a, c, n);
                  (a += u.offsetX), s.push(u.path);
                }
              }
              return s;
            })(t, e, this.data),
            r = 0,
            o = i.length;
          r < o;
          r++
        )
          Array.prototype.push.apply(n, i[r].toShapes());
        return n;
      },
    }),
    (Rc.prototype = Object.assign(Object.create(Ea.prototype), {
      constructor: Rc,
      load: function (t, e, n, i) {
        var r = this,
          o = new Ca(this.manager);
        o.setPath(this.path),
          o.load(
            t,
            function (t) {
              var n;
              try {
                n = JSON.parse(t);
              } catch (e) {
                console.warn(
                  'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.',
                ),
                  (n = JSON.parse(t.substring(65, t.length - 2)));
              }
              var i = r.parse(n);
              e && e(i);
            },
            n,
            i,
          );
      },
      parse: function (t) {
        return new Tc(t);
      },
    }));
  var Fc = function () {
    return (
      void 0 === Mc &&
        (Mc = new (window.AudioContext || window.webkitAudioContext)()),
      Mc
    );
  };
  function Pc(t) {
    Ea.call(this, t);
  }
  function Bc() {
    this.coefficients = [];
    for (var t = 0; t < 9; t++) this.coefficients.push(new J());
  }
  function Oc(t, e) {
    oc.call(this, void 0, e), (this.sh = void 0 !== t ? t : new Bc());
  }
  function Vc(t, e, n) {
    Oc.call(this, void 0, n);
    var i = new fe().set(t),
      r = new fe().set(e),
      o = new J(i.r, i.g, i.b),
      s = new J(r.r, r.g, r.b),
      a = Math.sqrt(Math.PI),
      c = a * Math.sqrt(0.75);
    this.sh.coefficients[0].copy(o).add(s).multiplyScalar(a),
      this.sh.coefficients[1].copy(o).sub(s).multiplyScalar(c);
  }
  function Nc(t, e) {
    Oc.call(this, void 0, e);
    var n = new fe().set(t);
    this.sh.coefficients[0]
      .set(n.r, n.g, n.b)
      .multiplyScalar(2 * Math.sqrt(Math.PI));
  }
  (Pc.prototype = Object.assign(Object.create(Ea.prototype), {
    constructor: Pc,
    load: function (t, e, n, i) {
      var r = new Ca(this.manager);
      r.setResponseType('arraybuffer'),
        r.setPath(this.path),
        r.load(
          t,
          function (t) {
            var n = t.slice(0);
            Fc().decodeAudioData(n, function (t) {
              e(t);
            });
          },
          n,
          i,
        );
    },
  })),
    Object.assign(Bc.prototype, {
      isSphericalHarmonics3: !0,
      set: function (t) {
        for (var e = 0; e < 9; e++) this.coefficients[e].copy(t[e]);
        return this;
      },
      zero: function () {
        for (var t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0);
        return this;
      },
      getAt: function (t, e) {
        var n = t.x,
          i = t.y,
          r = t.z,
          o = this.coefficients;
        return (
          e.copy(o[0]).multiplyScalar(0.282095),
          e.addScaledVector(o[1], 0.488603 * i),
          e.addScaledVector(o[2], 0.488603 * r),
          e.addScaledVector(o[3], 0.488603 * n),
          e.addScaledVector(o[4], n * i * 1.092548),
          e.addScaledVector(o[5], i * r * 1.092548),
          e.addScaledVector(o[6], 0.315392 * (3 * r * r - 1)),
          e.addScaledVector(o[7], n * r * 1.092548),
          e.addScaledVector(o[8], 0.546274 * (n * n - i * i)),
          e
        );
      },
      getIrradianceAt: function (t, e) {
        var n = t.x,
          i = t.y,
          r = t.z,
          o = this.coefficients;
        return (
          e.copy(o[0]).multiplyScalar(0.886227),
          e.addScaledVector(o[1], 1.023328 * i),
          e.addScaledVector(o[2], 1.023328 * r),
          e.addScaledVector(o[3], 1.023328 * n),
          e.addScaledVector(o[4], 0.858086 * n * i),
          e.addScaledVector(o[5], 0.858086 * i * r),
          e.addScaledVector(o[6], 0.743125 * r * r - 0.247708),
          e.addScaledVector(o[7], 0.858086 * n * r),
          e.addScaledVector(o[8], 0.429043 * (n * n - i * i)),
          e
        );
      },
      add: function (t) {
        for (var e = 0; e < 9; e++) this.coefficients[e].add(t.coefficients[e]);
        return this;
      },
      addScaledSH: function (t, e) {
        for (var n = 0; n < 9; n++)
          this.coefficients[n].addScaledVector(t.coefficients[n], e);
        return this;
      },
      scale: function (t) {
        for (var e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t);
        return this;
      },
      lerp: function (t, e) {
        for (var n = 0; n < 9; n++)
          this.coefficients[n].lerp(t.coefficients[n], e);
        return this;
      },
      equals: function (t) {
        for (var e = 0; e < 9; e++)
          if (!this.coefficients[e].equals(t.coefficients[e])) return !1;
        return !0;
      },
      copy: function (t) {
        return this.set(t.coefficients);
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      fromArray: function (t, e) {
        void 0 === e && (e = 0);
        for (var n = this.coefficients, i = 0; i < 9; i++)
          n[i].fromArray(t, e + 3 * i);
        return this;
      },
      toArray: function (t, e) {
        void 0 === t && (t = []), void 0 === e && (e = 0);
        for (var n = this.coefficients, i = 0; i < 9; i++)
          n[i].toArray(t, e + 3 * i);
        return t;
      },
    }),
    Object.assign(Bc, {
      getBasisAt: function (t, e) {
        var n = t.x,
          i = t.y,
          r = t.z;
        (e[0] = 0.282095),
          (e[1] = 0.488603 * i),
          (e[2] = 0.488603 * r),
          (e[3] = 0.488603 * n),
          (e[4] = 1.092548 * n * i),
          (e[5] = 1.092548 * i * r),
          (e[6] = 0.315392 * (3 * r * r - 1)),
          (e[7] = 1.092548 * n * r),
          (e[8] = 0.546274 * (n * n - i * i));
      },
    }),
    (Oc.prototype = Object.assign(Object.create(oc.prototype), {
      constructor: Oc,
      isLightProbe: !0,
      copy: function (t) {
        return (
          oc.prototype.copy.call(this, t),
          this.sh.copy(t.sh),
          (this.intensity = t.intensity),
          this
        );
      },
      toJSON: function (t) {
        return oc.prototype.toJSON.call(this, t);
      },
    })),
    (Vc.prototype = Object.assign(Object.create(Oc.prototype), {
      constructor: Vc,
      isHemisphereLightProbe: !0,
      copy: function (t) {
        return Oc.prototype.copy.call(this, t), this;
      },
      toJSON: function (t) {
        return Oc.prototype.toJSON.call(this, t);
      },
    })),
    (Nc.prototype = Object.assign(Object.create(Oc.prototype), {
      constructor: Nc,
      isAmbientLightProbe: !0,
      copy: function (t) {
        return Oc.prototype.copy.call(this, t), this;
      },
      toJSON: function (t) {
        return Oc.prototype.toJSON.call(this, t);
      },
    }));
  var kc = new ot(),
    Uc = new ot();
  function Gc(t) {
    (this.autoStart = void 0 === t || t),
      (this.startTime = 0),
      (this.oldTime = 0),
      (this.elapsedTime = 0),
      (this.running = !1);
  }
  Object.assign(
    function () {
      (this.type = 'StereoCamera'),
        (this.aspect = 1),
        (this.eyeSep = 0.064),
        (this.cameraL = new Mn()),
        this.cameraL.layers.enable(1),
        (this.cameraL.matrixAutoUpdate = !1),
        (this.cameraR = new Mn()),
        this.cameraR.layers.enable(2),
        (this.cameraR.matrixAutoUpdate = !1),
        (this._cache = {
          focus: null,
          fov: null,
          aspect: null,
          near: null,
          far: null,
          zoom: null,
          eyeSep: null,
        });
    }.prototype,
    {
      update: function (t) {
        var e = this._cache;
        if (
          e.focus !== t.focus ||
          e.fov !== t.fov ||
          e.aspect !== t.aspect * this.aspect ||
          e.near !== t.near ||
          e.far !== t.far ||
          e.zoom !== t.zoom ||
          e.eyeSep !== this.eyeSep
        ) {
          (e.focus = t.focus),
            (e.fov = t.fov),
            (e.aspect = t.aspect * this.aspect),
            (e.near = t.near),
            (e.far = t.far),
            (e.zoom = t.zoom),
            (e.eyeSep = this.eyeSep);
          var n,
            i,
            r = t.projectionMatrix.clone(),
            o = e.eyeSep / 2,
            s = (o * e.near) / e.focus,
            a = (e.near * Math.tan(k.DEG2RAD * e.fov * 0.5)) / e.zoom;
          (Uc.elements[12] = -o),
            (kc.elements[12] = o),
            (n = -a * e.aspect + s),
            (i = a * e.aspect + s),
            (r.elements[0] = (2 * e.near) / (i - n)),
            (r.elements[8] = (i + n) / (i - n)),
            this.cameraL.projectionMatrix.copy(r),
            (n = -a * e.aspect - s),
            (i = a * e.aspect - s),
            (r.elements[0] = (2 * e.near) / (i - n)),
            (r.elements[8] = (i + n) / (i - n)),
            this.cameraR.projectionMatrix.copy(r);
        }
        this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(Uc),
          this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(kc);
      },
    },
  ),
    Object.assign(Gc.prototype, {
      start: function () {
        (this.startTime = (
          'undefined' == typeof performance ? Date : performance
        ).now()),
          (this.oldTime = this.startTime),
          (this.elapsedTime = 0),
          (this.running = !0);
      },
      stop: function () {
        this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
      },
      getElapsedTime: function () {
        return this.getDelta(), this.elapsedTime;
      },
      getDelta: function () {
        var t = 0;
        if (this.autoStart && !this.running) return this.start(), 0;
        if (this.running) {
          var e = (
            'undefined' == typeof performance ? Date : performance
          ).now();
          (t = (e - this.oldTime) / 1e3),
            (this.oldTime = e),
            (this.elapsedTime += t);
        }
        return t;
      },
    });
  var zc = new J(),
    jc = new Y(),
    Hc = new J(),
    Wc = new J();
  function Xc() {
    At.call(this),
      (this.type = 'AudioListener'),
      (this.context = Fc()),
      (this.gain = this.context.createGain()),
      this.gain.connect(this.context.destination),
      (this.filter = null),
      (this.timeDelta = 0),
      (this._clock = new Gc());
  }
  function Zc(t) {
    At.call(this),
      (this.type = 'Audio'),
      (this.listener = t),
      (this.context = t.context),
      (this.gain = this.context.createGain()),
      this.gain.connect(t.getInput()),
      (this.autoplay = !1),
      (this.buffer = null),
      (this.detune = 0),
      (this.loop = !1),
      (this.loopStart = 0),
      (this.loopEnd = 0),
      (this.offset = 0),
      (this.duration = void 0),
      (this.playbackRate = 1),
      (this.isPlaying = !1),
      (this.hasPlaybackControl = !0),
      (this.sourceType = 'empty'),
      (this._startedAt = 0),
      (this._pausedAt = 0),
      (this.filters = []);
  }
  (Xc.prototype = Object.assign(Object.create(At.prototype), {
    constructor: Xc,
    getInput: function () {
      return this.gain;
    },
    removeFilter: function () {
      return (
        null !== this.filter &&
          (this.gain.disconnect(this.filter),
          this.filter.disconnect(this.context.destination),
          this.gain.connect(this.context.destination),
          (this.filter = null)),
        this
      );
    },
    getFilter: function () {
      return this.filter;
    },
    setFilter: function (t) {
      return (
        null !== this.filter
          ? (this.gain.disconnect(this.filter),
            this.filter.disconnect(this.context.destination))
          : this.gain.disconnect(this.context.destination),
        (this.filter = t),
        this.gain.connect(this.filter),
        this.filter.connect(this.context.destination),
        this
      );
    },
    getMasterVolume: function () {
      return this.gain.gain.value;
    },
    setMasterVolume: function (t) {
      return (
        this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01), this
      );
    },
    updateMatrixWorld: function (t) {
      At.prototype.updateMatrixWorld.call(this, t);
      var e = this.context.listener,
        n = this.up;
      if (
        ((this.timeDelta = this._clock.getDelta()),
        this.matrixWorld.decompose(zc, jc, Hc),
        Wc.set(0, 0, -1).applyQuaternion(jc),
        e.positionX)
      ) {
        var i = this.context.currentTime + this.timeDelta;
        e.positionX.linearRampToValueAtTime(zc.x, i),
          e.positionY.linearRampToValueAtTime(zc.y, i),
          e.positionZ.linearRampToValueAtTime(zc.z, i),
          e.forwardX.linearRampToValueAtTime(Wc.x, i),
          e.forwardY.linearRampToValueAtTime(Wc.y, i),
          e.forwardZ.linearRampToValueAtTime(Wc.z, i),
          e.upX.linearRampToValueAtTime(n.x, i),
          e.upY.linearRampToValueAtTime(n.y, i),
          e.upZ.linearRampToValueAtTime(n.z, i);
      } else
        e.setPosition(zc.x, zc.y, zc.z),
          e.setOrientation(Wc.x, Wc.y, Wc.z, n.x, n.y, n.z);
    },
  })),
    (Zc.prototype = Object.assign(Object.create(At.prototype), {
      constructor: Zc,
      getOutput: function () {
        return this.gain;
      },
      setNodeSource: function (t) {
        return (
          (this.hasPlaybackControl = !1),
          (this.sourceType = 'audioNode'),
          (this.source = t),
          this.connect(),
          this
        );
      },
      setMediaElementSource: function (t) {
        return (
          (this.hasPlaybackControl = !1),
          (this.sourceType = 'mediaNode'),
          (this.source = this.context.createMediaElementSource(t)),
          this.connect(),
          this
        );
      },
      setMediaStreamSource: function (t) {
        return (
          (this.hasPlaybackControl = !1),
          (this.sourceType = 'mediaStreamNode'),
          (this.source = this.context.createMediaStreamSource(t)),
          this.connect(),
          this
        );
      },
      setBuffer: function (t) {
        return (
          (this.buffer = t),
          (this.sourceType = 'buffer'),
          this.autoplay && this.play(),
          this
        );
      },
      play: function (t) {
        if ((void 0 === t && (t = 0), !0 !== this.isPlaying)) {
          if (!1 !== this.hasPlaybackControl) {
            this._startedAt = this.context.currentTime + t;
            var e = this.context.createBufferSource();
            return (
              (e.buffer = this.buffer),
              (e.loop = this.loop),
              (e.loopStart = this.loopStart),
              (e.loopEnd = this.loopEnd),
              (e.onended = this.onEnded.bind(this)),
              e.start(
                this._startedAt,
                this._pausedAt + this.offset,
                this.duration,
              ),
              (this.isPlaying = !0),
              (this.source = e),
              this.setDetune(this.detune),
              this.setPlaybackRate(this.playbackRate),
              this.connect()
            );
          }
          console.warn('THREE.Audio: this Audio has no playback control.');
        } else console.warn('THREE.Audio: Audio is already playing.');
      },
      pause: function () {
        if (!1 !== this.hasPlaybackControl)
          return (
            !0 === this.isPlaying &&
              ((this._pausedAt +=
                Math.max(this.context.currentTime - this._startedAt, 0) *
                this.playbackRate),
              this.source.stop(),
              (this.source.onended = null),
              (this.isPlaying = !1)),
            this
          );
        console.warn('THREE.Audio: this Audio has no playback control.');
      },
      stop: function () {
        if (!1 !== this.hasPlaybackControl)
          return (
            (this._pausedAt = 0),
            this.source.stop(),
            (this.source.onended = null),
            (this.isPlaying = !1),
            this
          );
        console.warn('THREE.Audio: this Audio has no playback control.');
      },
      connect: function () {
        if (this.filters.length > 0) {
          this.source.connect(this.filters[0]);
          for (var t = 1, e = this.filters.length; t < e; t++)
            this.filters[t - 1].connect(this.filters[t]);
          this.filters[this.filters.length - 1].connect(this.getOutput());
        } else this.source.connect(this.getOutput());
        return this;
      },
      disconnect: function () {
        if (this.filters.length > 0) {
          this.source.disconnect(this.filters[0]);
          for (var t = 1, e = this.filters.length; t < e; t++)
            this.filters[t - 1].disconnect(this.filters[t]);
          this.filters[this.filters.length - 1].disconnect(this.getOutput());
        } else this.source.disconnect(this.getOutput());
        return this;
      },
      getFilters: function () {
        return this.filters;
      },
      setFilters: function (t) {
        return (
          t || (t = []),
          !0 === this.isPlaying
            ? (this.disconnect(), (this.filters = t), this.connect())
            : (this.filters = t),
          this
        );
      },
      setDetune: function (t) {
        if (((this.detune = t), void 0 !== this.source.detune))
          return (
            !0 === this.isPlaying &&
              this.source.detune.setTargetAtTime(
                this.detune,
                this.context.currentTime,
                0.01,
              ),
            this
          );
      },
      getDetune: function () {
        return this.detune;
      },
      getFilter: function () {
        return this.getFilters()[0];
      },
      setFilter: function (t) {
        return this.setFilters(t ? [t] : []);
      },
      setPlaybackRate: function (t) {
        if (!1 !== this.hasPlaybackControl)
          return (
            (this.playbackRate = t),
            !0 === this.isPlaying &&
              this.source.playbackRate.setTargetAtTime(
                this.playbackRate,
                this.context.currentTime,
                0.01,
              ),
            this
          );
        console.warn('THREE.Audio: this Audio has no playback control.');
      },
      getPlaybackRate: function () {
        return this.playbackRate;
      },
      onEnded: function () {
        this.isPlaying = !1;
      },
      getLoop: function () {
        return !1 === this.hasPlaybackControl
          ? (console.warn('THREE.Audio: this Audio has no playback control.'),
            !1)
          : this.loop;
      },
      setLoop: function (t) {
        if (!1 !== this.hasPlaybackControl)
          return (
            (this.loop = t),
            !0 === this.isPlaying && (this.source.loop = this.loop),
            this
          );
        console.warn('THREE.Audio: this Audio has no playback control.');
      },
      setLoopStart: function (t) {
        return (this.loopStart = t), this;
      },
      setLoopEnd: function (t) {
        return (this.loopEnd = t), this;
      },
      getVolume: function () {
        return this.gain.gain.value;
      },
      setVolume: function (t) {
        return (
          this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01),
          this
        );
      },
    }));
  var Yc = new J(),
    qc = new Y(),
    Qc = new J(),
    Jc = new J();
  function $c(t) {
    Zc.call(this, t),
      (this.panner = this.context.createPanner()),
      (this.panner.panningModel = 'HRTF'),
      this.panner.connect(this.gain);
  }
  function Kc(t, e) {
    (this.analyser = t.context.createAnalyser()),
      (this.analyser.fftSize = void 0 !== e ? e : 2048),
      (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
      t.getOutput().connect(this.analyser);
  }
  function tl(t, e, n) {
    (this.binding = t), (this.valueSize = n);
    var i,
      r = Float64Array;
    switch (e) {
      case 'quaternion':
        i = this._slerp;
        break;
      case 'string':
      case 'bool':
        (r = Array), (i = this._select);
        break;
      default:
        i = this._lerp;
    }
    (this.buffer = new r(4 * n)),
      (this._mixBufferRegion = i),
      (this.cumulativeWeight = 0),
      (this.useCount = 0),
      (this.referenceCount = 0);
  }
  ($c.prototype = Object.assign(Object.create(Zc.prototype), {
    constructor: $c,
    getOutput: function () {
      return this.panner;
    },
    getRefDistance: function () {
      return this.panner.refDistance;
    },
    setRefDistance: function (t) {
      return (this.panner.refDistance = t), this;
    },
    getRolloffFactor: function () {
      return this.panner.rolloffFactor;
    },
    setRolloffFactor: function (t) {
      return (this.panner.rolloffFactor = t), this;
    },
    getDistanceModel: function () {
      return this.panner.distanceModel;
    },
    setDistanceModel: function (t) {
      return (this.panner.distanceModel = t), this;
    },
    getMaxDistance: function () {
      return this.panner.maxDistance;
    },
    setMaxDistance: function (t) {
      return (this.panner.maxDistance = t), this;
    },
    setDirectionalCone: function (t, e, n) {
      return (
        (this.panner.coneInnerAngle = t),
        (this.panner.coneOuterAngle = e),
        (this.panner.coneOuterGain = n),
        this
      );
    },
    updateMatrixWorld: function (t) {
      if (
        (At.prototype.updateMatrixWorld.call(this, t),
        !0 !== this.hasPlaybackControl || !1 !== this.isPlaying)
      ) {
        this.matrixWorld.decompose(Yc, qc, Qc),
          Jc.set(0, 0, 1).applyQuaternion(qc);
        var e = this.panner;
        if (e.positionX) {
          var n = this.context.currentTime + this.listener.timeDelta;
          e.positionX.linearRampToValueAtTime(Yc.x, n),
            e.positionY.linearRampToValueAtTime(Yc.y, n),
            e.positionZ.linearRampToValueAtTime(Yc.z, n),
            e.orientationX.linearRampToValueAtTime(Jc.x, n),
            e.orientationY.linearRampToValueAtTime(Jc.y, n),
            e.orientationZ.linearRampToValueAtTime(Jc.z, n);
        } else
          e.setPosition(Yc.x, Yc.y, Yc.z), e.setOrientation(Jc.x, Jc.y, Jc.z);
      }
    },
  })),
    Object.assign(Kc.prototype, {
      getFrequencyData: function () {
        return this.analyser.getByteFrequencyData(this.data), this.data;
      },
      getAverageFrequency: function () {
        for (var t = 0, e = this.getFrequencyData(), n = 0; n < e.length; n++)
          t += e[n];
        return t / e.length;
      },
    }),
    Object.assign(tl.prototype, {
      accumulate: function (t, e) {
        var n = this.buffer,
          i = this.valueSize,
          r = t * i + i,
          o = this.cumulativeWeight;
        if (0 === o) {
          for (var s = 0; s !== i; ++s) n[r + s] = n[s];
          o = e;
        } else {
          var a = e / (o += e);
          this._mixBufferRegion(n, r, 0, a, i);
        }
        this.cumulativeWeight = o;
      },
      apply: function (t) {
        var e = this.valueSize,
          n = this.buffer,
          i = t * e + e,
          r = this.cumulativeWeight,
          o = this.binding;
        if (((this.cumulativeWeight = 0), r < 1)) {
          var s = 3 * e;
          this._mixBufferRegion(n, i, s, 1 - r, e);
        }
        for (var a = e, c = e + e; a !== c; ++a)
          if (n[a] !== n[a + e]) {
            o.setValue(n, i);
            break;
          }
      },
      saveOriginalState: function () {
        var t = this.binding,
          e = this.buffer,
          n = this.valueSize,
          i = 3 * n;
        t.getValue(e, i);
        for (var r = n, o = i; r !== o; ++r) e[r] = e[i + (r % n)];
        this.cumulativeWeight = 0;
      },
      restoreOriginalState: function () {
        var t = 3 * this.valueSize;
        this.binding.setValue(this.buffer, t);
      },
      _select: function (t, e, n, i, r) {
        if (i >= 0.5) for (var o = 0; o !== r; ++o) t[e + o] = t[n + o];
      },
      _slerp: function (t, e, n, i) {
        Y.slerpFlat(t, e, t, e, t, n, i);
      },
      _lerp: function (t, e, n, i, r) {
        for (var o = 1 - i, s = 0; s !== r; ++s) {
          var a = e + s;
          t[a] = t[a] * o + t[n + s] * i;
        }
      },
    });
  var el = '\\[\\]\\.:\\/',
    nl = new RegExp('[\\[\\]\\.:\\/]', 'g'),
    il = '[^\\[\\]\\.:\\/]',
    rl = '[^' + el.replace('\\.', '') + ']',
    ol = /((?:WC+[\/:])*)/.source.replace('WC', il),
    sl = /(WCOD+)?/.source.replace('WCOD', rl),
    al = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC', il),
    cl = /\.(WC+)(?:\[(.+)\])?/.source.replace('WC', il),
    ll = new RegExp('^' + ol + sl + al + cl + '$'),
    hl = ['material', 'materials', 'bones'];
  function ul(t, e, n) {
    var i = n || dl.parseTrackName(e);
    (this._targetGroup = t), (this._bindings = t.subscribe_(e, i));
  }
  function dl(t, e, n) {
    (this.path = e),
      (this.parsedPath = n || dl.parseTrackName(e)),
      (this.node = dl.findNode(t, this.parsedPath.nodeName) || t),
      (this.rootNode = t);
  }
  function pl(t, e, n) {
    (this._mixer = t), (this._clip = e), (this._localRoot = n || null);
    for (
      var i = e.tracks,
        r = i.length,
        o = new Array(r),
        s = { endingStart: E, endingEnd: E },
        a = 0;
      a !== r;
      ++a
    ) {
      var c = i[a].createInterpolant(null);
      (o[a] = c), (c.settings = s);
    }
    (this._interpolantSettings = s),
      (this._interpolants = o),
      (this._propertyBindings = new Array(r)),
      (this._cacheIndex = null),
      (this._byClipCacheIndex = null),
      (this._timeScaleInterpolant = null),
      (this._weightInterpolant = null),
      (this.loop = 2201),
      (this._loopCount = -1),
      (this._startTime = null),
      (this.time = 0),
      (this.timeScale = 1),
      (this._effectiveTimeScale = 1),
      (this.weight = 1),
      (this._effectiveWeight = 1),
      (this.repetitions = 1 / 0),
      (this.paused = !1),
      (this.enabled = !0),
      (this.clampWhenFinished = !1),
      (this.zeroSlopeAtStart = !0),
      (this.zeroSlopeAtEnd = !0);
  }
  function fl(t) {
    (this._root = t),
      this._initMemoryManager(),
      (this._accuIndex = 0),
      (this.time = 0),
      (this.timeScale = 1);
  }
  function ml(t) {
    'string' == typeof t &&
      (console.warn('THREE.Uniform: Type parameter is no longer needed.'),
      (t = arguments[1])),
      (this.value = t);
  }
  function bl(t, e, n) {
    Vr.call(this, t, e), (this.meshPerAttribute = n || 1);
  }
  function gl(t, e, n, i) {
    (this.ray = new qt(t, e)),
      (this.near = n || 0),
      (this.far = i || 1 / 0),
      (this.camera = null),
      (this.layers = new lt()),
      (this.params = {
        Mesh: {},
        Line: { threshold: 1 },
        LOD: {},
        Points: { threshold: 1 },
        Sprite: {},
      }),
      Object.defineProperties(this.params, {
        PointCloud: {
          get: function () {
            return (
              console.warn(
                'THREE.Raycaster: params.PointCloud has been renamed to params.Points.',
              ),
              this.Points
            );
          },
        },
      });
  }
  function yl(t, e) {
    return t.distance - e.distance;
  }
  function vl(t, e, n, i) {
    if ((t.layers.test(e.layers) && t.raycast(e, n), !0 === i))
      for (var r = t.children, o = 0, s = r.length; o < s; o++)
        vl(r[o], e, n, !0);
  }
  Object.assign(ul.prototype, {
    getValue: function (t, e) {
      this.bind();
      var n = this._targetGroup.nCachedObjects_,
        i = this._bindings[n];
      void 0 !== i && i.getValue(t, e);
    },
    setValue: function (t, e) {
      for (
        var n = this._bindings,
          i = this._targetGroup.nCachedObjects_,
          r = n.length;
        i !== r;
        ++i
      )
        n[i].setValue(t, e);
    },
    bind: function () {
      for (
        var t = this._bindings,
          e = this._targetGroup.nCachedObjects_,
          n = t.length;
        e !== n;
        ++e
      )
        t[e].bind();
    },
    unbind: function () {
      for (
        var t = this._bindings,
          e = this._targetGroup.nCachedObjects_,
          n = t.length;
        e !== n;
        ++e
      )
        t[e].unbind();
    },
  }),
    Object.assign(dl, {
      Composite: ul,
      create: function (t, e, n) {
        return t && t.isAnimationObjectGroup
          ? new dl.Composite(t, e, n)
          : new dl(t, e, n);
      },
      sanitizeNodeName: function (t) {
        return t.replace(/\s/g, '_').replace(nl, '');
      },
      parseTrackName: function (t) {
        var e = ll.exec(t);
        if (!e)
          throw new Error('PropertyBinding: Cannot parse trackName: ' + t);
        var n = {
            nodeName: e[2],
            objectName: e[3],
            objectIndex: e[4],
            propertyName: e[5],
            propertyIndex: e[6],
          },
          i = n.nodeName && n.nodeName.lastIndexOf('.');
        if (void 0 !== i && -1 !== i) {
          var r = n.nodeName.substring(i + 1);
          -1 !== hl.indexOf(r) &&
            ((n.nodeName = n.nodeName.substring(0, i)), (n.objectName = r));
        }
        if (null === n.propertyName || 0 === n.propertyName.length)
          throw new Error(
            'PropertyBinding: can not parse propertyName from trackName: ' + t,
          );
        return n;
      },
      findNode: function (t, e) {
        if (
          !e ||
          '' === e ||
          '.' === e ||
          -1 === e ||
          e === t.name ||
          e === t.uuid
        )
          return t;
        if (t.skeleton) {
          var n = t.skeleton.getBoneByName(e);
          if (void 0 !== n) return n;
        }
        if (t.children) {
          var i = function (t) {
              for (var n = 0; n < t.length; n++) {
                var r = t[n];
                if (r.name === e || r.uuid === e) return r;
                var o = i(r.children);
                if (o) return o;
              }
              return null;
            },
            r = i(t.children);
          if (r) return r;
        }
        return null;
      },
    }),
    Object.assign(dl.prototype, {
      _getValue_unavailable: function () {},
      _setValue_unavailable: function () {},
      BindingType: {
        Direct: 0,
        EntireArray: 1,
        ArrayElement: 2,
        HasFromToArray: 3,
      },
      Versioning: { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 },
      GetterByBindingType: [
        function (t, e) {
          t[e] = this.node[this.propertyName];
        },
        function (t, e) {
          for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i)
            t[e++] = n[i];
        },
        function (t, e) {
          t[e] = this.resolvedProperty[this.propertyIndex];
        },
        function (t, e) {
          this.resolvedProperty.toArray(t, e);
        },
      ],
      SetterByBindingTypeAndVersioning: [
        [
          function (t, e) {
            this.targetObject[this.propertyName] = t[e];
          },
          function (t, e) {
            (this.targetObject[this.propertyName] = t[e]),
              (this.targetObject.needsUpdate = !0);
          },
          function (t, e) {
            (this.targetObject[this.propertyName] = t[e]),
              (this.targetObject.matrixWorldNeedsUpdate = !0);
          },
        ],
        [
          function (t, e) {
            for (
              var n = this.resolvedProperty, i = 0, r = n.length;
              i !== r;
              ++i
            )
              n[i] = t[e++];
          },
          function (t, e) {
            for (
              var n = this.resolvedProperty, i = 0, r = n.length;
              i !== r;
              ++i
            )
              n[i] = t[e++];
            this.targetObject.needsUpdate = !0;
          },
          function (t, e) {
            for (
              var n = this.resolvedProperty, i = 0, r = n.length;
              i !== r;
              ++i
            )
              n[i] = t[e++];
            this.targetObject.matrixWorldNeedsUpdate = !0;
          },
        ],
        [
          function (t, e) {
            this.resolvedProperty[this.propertyIndex] = t[e];
          },
          function (t, e) {
            (this.resolvedProperty[this.propertyIndex] = t[e]),
              (this.targetObject.needsUpdate = !0);
          },
          function (t, e) {
            (this.resolvedProperty[this.propertyIndex] = t[e]),
              (this.targetObject.matrixWorldNeedsUpdate = !0);
          },
        ],
        [
          function (t, e) {
            this.resolvedProperty.fromArray(t, e);
          },
          function (t, e) {
            this.resolvedProperty.fromArray(t, e),
              (this.targetObject.needsUpdate = !0);
          },
          function (t, e) {
            this.resolvedProperty.fromArray(t, e),
              (this.targetObject.matrixWorldNeedsUpdate = !0);
          },
        ],
      ],
      getValue: function (t, e) {
        this.bind(), this.getValue(t, e);
      },
      setValue: function (t, e) {
        this.bind(), this.setValue(t, e);
      },
      bind: function () {
        var t = this.node,
          e = this.parsedPath,
          n = e.objectName,
          i = e.propertyName,
          r = e.propertyIndex;
        if (
          (t ||
            ((t = dl.findNode(this.rootNode, e.nodeName) || this.rootNode),
            (this.node = t)),
          (this.getValue = this._getValue_unavailable),
          (this.setValue = this._setValue_unavailable),
          t)
        ) {
          if (n) {
            var o = e.objectIndex;
            switch (n) {
              case 'materials':
                if (!t.material)
                  return void console.error(
                    'THREE.PropertyBinding: Can not bind to material as node does not have a material.',
                    this,
                  );
                if (!t.material.materials)
                  return void console.error(
                    'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.',
                    this,
                  );
                t = t.material.materials;
                break;
              case 'bones':
                if (!t.skeleton)
                  return void console.error(
                    'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.',
                    this,
                  );
                t = t.skeleton.bones;
                for (var s = 0; s < t.length; s++)
                  if (t[s].name === o) {
                    o = s;
                    break;
                  }
                break;
              default:
                if (void 0 === t[n])
                  return void console.error(
                    'THREE.PropertyBinding: Can not bind to objectName of node undefined.',
                    this,
                  );
                t = t[n];
            }
            if (void 0 !== o) {
              if (void 0 === t[o])
                return void console.error(
                  'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.',
                  this,
                  t,
                );
              t = t[o];
            }
          }
          var a = t[i];
          if (void 0 !== a) {
            var c = this.Versioning.None;
            (this.targetObject = t),
              void 0 !== t.needsUpdate
                ? (c = this.Versioning.NeedsUpdate)
                : void 0 !== t.matrixWorldNeedsUpdate &&
                  (c = this.Versioning.MatrixWorldNeedsUpdate);
            var l = this.BindingType.Direct;
            if (void 0 !== r) {
              if ('morphTargetInfluences' === i) {
                if (!t.geometry)
                  return void console.error(
                    'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.',
                    this,
                  );
                if (t.geometry.isBufferGeometry) {
                  if (!t.geometry.morphAttributes)
                    return void console.error(
                      'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.',
                      this,
                    );
                  for (
                    s = 0;
                    s < this.node.geometry.morphAttributes.position.length;
                    s++
                  )
                    if (t.geometry.morphAttributes.position[s].name === r) {
                      r = s;
                      break;
                    }
                } else {
                  if (!t.geometry.morphTargets)
                    return void console.error(
                      'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.',
                      this,
                    );
                  for (s = 0; s < this.node.geometry.morphTargets.length; s++)
                    if (t.geometry.morphTargets[s].name === r) {
                      r = s;
                      break;
                    }
                }
              }
              (l = this.BindingType.ArrayElement),
                (this.resolvedProperty = a),
                (this.propertyIndex = r);
            } else
              void 0 !== a.fromArray && void 0 !== a.toArray
                ? ((l = this.BindingType.HasFromToArray),
                  (this.resolvedProperty = a))
                : Array.isArray(a)
                ? ((l = this.BindingType.EntireArray),
                  (this.resolvedProperty = a))
                : (this.propertyName = i);
            (this.getValue = this.GetterByBindingType[l]),
              (this.setValue = this.SetterByBindingTypeAndVersioning[l][c]);
          } else {
            var h = e.nodeName;
            console.error(
              'THREE.PropertyBinding: Trying to update property for track: ' +
                h +
                '.' +
                i +
                " but it wasn't found.",
              t,
            );
          }
        } else
          console.error(
            'THREE.PropertyBinding: Trying to update node for track: ' +
              this.path +
              " but it wasn't found.",
          );
      },
      unbind: function () {
        (this.node = null),
          (this.getValue = this._getValue_unbound),
          (this.setValue = this._setValue_unbound);
      },
    }),
    Object.assign(dl.prototype, {
      _getValue_unbound: dl.prototype.getValue,
      _setValue_unbound: dl.prototype.setValue,
    }),
    Object.assign(
      function () {
        (this.uuid = k.generateUUID()),
          (this._objects = Array.prototype.slice.call(arguments)),
          (this.nCachedObjects_ = 0);
        var t = {};
        this._indicesByUUID = t;
        for (var e = 0, n = arguments.length; e !== n; ++e)
          t[arguments[e].uuid] = e;
        (this._paths = []),
          (this._parsedPaths = []),
          (this._bindings = []),
          (this._bindingsIndicesByPath = {});
        var i = this;
        this.stats = {
          objects: {
            get total() {
              return i._objects.length;
            },
            get inUse() {
              return this.total - i.nCachedObjects_;
            },
          },
          get bindingsPerObject() {
            return i._bindings.length;
          },
        };
      }.prototype,
      {
        isAnimationObjectGroup: !0,
        add: function () {
          for (
            var t = this._objects,
              e = t.length,
              n = this.nCachedObjects_,
              i = this._indicesByUUID,
              r = this._paths,
              o = this._parsedPaths,
              s = this._bindings,
              a = s.length,
              c = void 0,
              l = 0,
              h = arguments.length;
            l !== h;
            ++l
          ) {
            var u = arguments[l],
              d = u.uuid,
              p = i[d];
            if (void 0 === p) {
              (p = e++), (i[d] = p), t.push(u);
              for (var f = 0, m = a; f !== m; ++f)
                s[f].push(new dl(u, r[f], o[f]));
            } else if (p < n) {
              c = t[p];
              var b = --n,
                g = t[b];
              (i[g.uuid] = p), (t[p] = g), (i[d] = b), (t[b] = u);
              for (f = 0, m = a; f !== m; ++f) {
                var y = s[f],
                  v = y[b],
                  _ = y[p];
                (y[p] = v),
                  void 0 === _ && (_ = new dl(u, r[f], o[f])),
                  (y[b] = _);
              }
            } else
              t[p] !== c &&
                console.error(
                  'THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.',
                );
          }
          this.nCachedObjects_ = n;
        },
        remove: function () {
          for (
            var t = this._objects,
              e = this.nCachedObjects_,
              n = this._indicesByUUID,
              i = this._bindings,
              r = i.length,
              o = 0,
              s = arguments.length;
            o !== s;
            ++o
          ) {
            var a = arguments[o],
              c = a.uuid,
              l = n[c];
            if (void 0 !== l && l >= e) {
              var h = e++,
                u = t[h];
              (n[u.uuid] = l), (t[l] = u), (n[c] = h), (t[h] = a);
              for (var d = 0, p = r; d !== p; ++d) {
                var f = i[d],
                  m = f[h],
                  b = f[l];
                (f[l] = m), (f[h] = b);
              }
            }
          }
          this.nCachedObjects_ = e;
        },
        uncache: function () {
          for (
            var t = this._objects,
              e = t.length,
              n = this.nCachedObjects_,
              i = this._indicesByUUID,
              r = this._bindings,
              o = r.length,
              s = 0,
              a = arguments.length;
            s !== a;
            ++s
          ) {
            var c = arguments[s],
              l = c.uuid,
              h = i[l];
            if (void 0 !== h)
              if ((delete i[l], h < n)) {
                var u = --n,
                  d = t[u],
                  p = t[(y = --e)];
                (i[d.uuid] = h),
                  (t[h] = d),
                  (i[p.uuid] = u),
                  (t[u] = p),
                  t.pop();
                for (var f = 0, m = o; f !== m; ++f) {
                  var b = (v = r[f])[u],
                    g = v[y];
                  (v[h] = b), (v[u] = g), v.pop();
                }
              } else {
                var y;
                (i[(p = t[(y = --e)]).uuid] = h), (t[h] = p), t.pop();
                for (f = 0, m = o; f !== m; ++f) {
                  var v;
                  ((v = r[f])[h] = v[y]), v.pop();
                }
              }
          }
          this.nCachedObjects_ = n;
        },
        subscribe_: function (t, e) {
          var n = this._bindingsIndicesByPath,
            i = n[t],
            r = this._bindings;
          if (void 0 !== i) return r[i];
          var o = this._paths,
            s = this._parsedPaths,
            a = this._objects,
            c = a.length,
            l = this.nCachedObjects_,
            h = new Array(c);
          (i = r.length), (n[t] = i), o.push(t), s.push(e), r.push(h);
          for (var u = l, d = a.length; u !== d; ++u) {
            var p = a[u];
            h[u] = new dl(p, t, e);
          }
          return h;
        },
        unsubscribe_: function (t) {
          var e = this._bindingsIndicesByPath,
            n = e[t];
          if (void 0 !== n) {
            var i = this._paths,
              r = this._parsedPaths,
              o = this._bindings,
              s = o.length - 1,
              a = o[s];
            (e[t[s]] = n),
              (o[n] = a),
              o.pop(),
              (r[n] = r[s]),
              r.pop(),
              (i[n] = i[s]),
              i.pop();
          }
        },
      },
    ),
    Object.assign(pl.prototype, {
      play: function () {
        return this._mixer._activateAction(this), this;
      },
      stop: function () {
        return this._mixer._deactivateAction(this), this.reset();
      },
      reset: function () {
        return (
          (this.paused = !1),
          (this.enabled = !0),
          (this.time = 0),
          (this._loopCount = -1),
          (this._startTime = null),
          this.stopFading().stopWarping()
        );
      },
      isRunning: function () {
        return (
          this.enabled &&
          !this.paused &&
          0 !== this.timeScale &&
          null === this._startTime &&
          this._mixer._isActiveAction(this)
        );
      },
      isScheduled: function () {
        return this._mixer._isActiveAction(this);
      },
      startAt: function (t) {
        return (this._startTime = t), this;
      },
      setLoop: function (t, e) {
        return (this.loop = t), (this.repetitions = e), this;
      },
      setEffectiveWeight: function (t) {
        return (
          (this.weight = t),
          (this._effectiveWeight = this.enabled ? t : 0),
          this.stopFading()
        );
      },
      getEffectiveWeight: function () {
        return this._effectiveWeight;
      },
      fadeIn: function (t) {
        return this._scheduleFading(t, 0, 1);
      },
      fadeOut: function (t) {
        return this._scheduleFading(t, 1, 0);
      },
      crossFadeFrom: function (t, e, n) {
        if ((t.fadeOut(e), this.fadeIn(e), n)) {
          var i = this._clip.duration,
            r = t._clip.duration,
            o = r / i,
            s = i / r;
          t.warp(1, o, e), this.warp(s, 1, e);
        }
        return this;
      },
      crossFadeTo: function (t, e, n) {
        return t.crossFadeFrom(this, e, n);
      },
      stopFading: function () {
        var t = this._weightInterpolant;
        return (
          null !== t &&
            ((this._weightInterpolant = null),
            this._mixer._takeBackControlInterpolant(t)),
          this
        );
      },
      setEffectiveTimeScale: function (t) {
        return (
          (this.timeScale = t),
          (this._effectiveTimeScale = this.paused ? 0 : t),
          this.stopWarping()
        );
      },
      getEffectiveTimeScale: function () {
        return this._effectiveTimeScale;
      },
      setDuration: function (t) {
        return (this.timeScale = this._clip.duration / t), this.stopWarping();
      },
      syncWith: function (t) {
        return (
          (this.time = t.time),
          (this.timeScale = t.timeScale),
          this.stopWarping()
        );
      },
      halt: function (t) {
        return this.warp(this._effectiveTimeScale, 0, t);
      },
      warp: function (t, e, n) {
        var i = this._mixer,
          r = i.time,
          o = this._timeScaleInterpolant,
          s = this.timeScale;
        null === o &&
          ((o = i._lendControlInterpolant()), (this._timeScaleInterpolant = o));
        var a = o.parameterPositions,
          c = o.sampleValues;
        return (a[0] = r), (a[1] = r + n), (c[0] = t / s), (c[1] = e / s), this;
      },
      stopWarping: function () {
        var t = this._timeScaleInterpolant;
        return (
          null !== t &&
            ((this._timeScaleInterpolant = null),
            this._mixer._takeBackControlInterpolant(t)),
          this
        );
      },
      getMixer: function () {
        return this._mixer;
      },
      getClip: function () {
        return this._clip;
      },
      getRoot: function () {
        return this._localRoot || this._mixer._root;
      },
      _update: function (t, e, n, i) {
        if (this.enabled) {
          var r = this._startTime;
          if (null !== r) {
            var o = (t - r) * n;
            if (o < 0 || 0 === n) return;
            (this._startTime = null), (e = n * o);
          }
          e *= this._updateTimeScale(t);
          var s = this._updateTime(e),
            a = this._updateWeight(t);
          if (a > 0)
            for (
              var c = this._interpolants,
                l = this._propertyBindings,
                h = 0,
                u = c.length;
              h !== u;
              ++h
            )
              c[h].evaluate(s), l[h].accumulate(i, a);
        } else this._updateWeight(t);
      },
      _updateWeight: function (t) {
        var e = 0;
        if (this.enabled) {
          e = this.weight;
          var n = this._weightInterpolant;
          if (null !== n) {
            var i = n.evaluate(t)[0];
            (e *= i),
              t > n.parameterPositions[1] &&
                (this.stopFading(), 0 === i && (this.enabled = !1));
          }
        }
        return (this._effectiveWeight = e), e;
      },
      _updateTimeScale: function (t) {
        var e = 0;
        if (!this.paused) {
          e = this.timeScale;
          var n = this._timeScaleInterpolant;
          if (null !== n)
            (e *= n.evaluate(t)[0]),
              t > n.parameterPositions[1] &&
                (this.stopWarping(),
                0 === e ? (this.paused = !0) : (this.timeScale = e));
        }
        return (this._effectiveTimeScale = e), e;
      },
      _updateTime: function (t) {
        var e = this.time + t,
          n = this._clip.duration,
          i = this.loop,
          r = this._loopCount,
          o = 2202 === i;
        if (0 === t) return -1 === r ? e : o && 1 == (1 & r) ? n - e : e;
        if (2200 === i) {
          -1 === r && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
          t: {
            if (e >= n) e = n;
            else {
              if (!(e < 0)) {
                this.time = e;
                break t;
              }
              e = 0;
            }
            this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
              (this.time = e),
              this._mixer.dispatchEvent({
                type: 'finished',
                action: this,
                direction: t < 0 ? -1 : 1,
              });
          }
        } else {
          if (
            (-1 === r &&
              (t >= 0
                ? ((r = 0), this._setEndings(!0, 0 === this.repetitions, o))
                : this._setEndings(0 === this.repetitions, !0, o)),
            e >= n || e < 0)
          ) {
            var s = Math.floor(e / n);
            (e -= n * s), (r += Math.abs(s));
            var a = this.repetitions - r;
            if (a <= 0)
              this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
                (e = t > 0 ? n : 0),
                (this.time = e),
                this._mixer.dispatchEvent({
                  type: 'finished',
                  action: this,
                  direction: t > 0 ? 1 : -1,
                });
            else {
              if (1 === a) {
                var c = t < 0;
                this._setEndings(c, !c, o);
              } else this._setEndings(!1, !1, o);
              (this._loopCount = r),
                (this.time = e),
                this._mixer.dispatchEvent({
                  type: 'loop',
                  action: this,
                  loopDelta: s,
                });
            }
          } else this.time = e;
          if (o && 1 == (1 & r)) return n - e;
        }
        return e;
      },
      _setEndings: function (t, e, n) {
        var i = this._interpolantSettings;
        n
          ? ((i.endingStart = D), (i.endingEnd = D))
          : ((i.endingStart = t ? (this.zeroSlopeAtStart ? D : E) : C),
            (i.endingEnd = e ? (this.zeroSlopeAtEnd ? D : E) : C));
      },
      _scheduleFading: function (t, e, n) {
        var i = this._mixer,
          r = i.time,
          o = this._weightInterpolant;
        null === o &&
          ((o = i._lendControlInterpolant()), (this._weightInterpolant = o));
        var s = o.parameterPositions,
          a = o.sampleValues;
        return (s[0] = r), (a[0] = e), (s[1] = r + t), (a[1] = n), this;
      },
    }),
    (fl.prototype = Object.assign(Object.create(B.prototype), {
      constructor: fl,
      _bindAction: function (t, e) {
        var n = t._localRoot || this._root,
          i = t._clip.tracks,
          r = i.length,
          o = t._propertyBindings,
          s = t._interpolants,
          a = n.uuid,
          c = this._bindingsByRootAndName,
          l = c[a];
        void 0 === l && ((l = {}), (c[a] = l));
        for (var h = 0; h !== r; ++h) {
          var u = i[h],
            d = u.name,
            p = l[d];
          if (void 0 !== p) o[h] = p;
          else {
            if (void 0 !== (p = o[h])) {
              null === p._cacheIndex &&
                (++p.referenceCount, this._addInactiveBinding(p, a, d));
              continue;
            }
            var f = e && e._propertyBindings[h].binding.parsedPath;
            ++(p = new tl(
              dl.create(n, d, f),
              u.ValueTypeName,
              u.getValueSize(),
            )).referenceCount,
              this._addInactiveBinding(p, a, d),
              (o[h] = p);
          }
          s[h].resultBuffer = p.buffer;
        }
      },
      _activateAction: function (t) {
        if (!this._isActiveAction(t)) {
          if (null === t._cacheIndex) {
            var e = (t._localRoot || this._root).uuid,
              n = t._clip.uuid,
              i = this._actionsByClip[n];
            this._bindAction(t, i && i.knownActions[0]),
              this._addInactiveAction(t, n, e);
          }
          for (var r = t._propertyBindings, o = 0, s = r.length; o !== s; ++o) {
            var a = r[o];
            0 == a.useCount++ && (this._lendBinding(a), a.saveOriginalState());
          }
          this._lendAction(t);
        }
      },
      _deactivateAction: function (t) {
        if (this._isActiveAction(t)) {
          for (var e = t._propertyBindings, n = 0, i = e.length; n !== i; ++n) {
            var r = e[n];
            0 == --r.useCount &&
              (r.restoreOriginalState(), this._takeBackBinding(r));
          }
          this._takeBackAction(t);
        }
      },
      _initMemoryManager: function () {
        (this._actions = []),
          (this._nActiveActions = 0),
          (this._actionsByClip = {}),
          (this._bindings = []),
          (this._nActiveBindings = 0),
          (this._bindingsByRootAndName = {}),
          (this._controlInterpolants = []),
          (this._nActiveControlInterpolants = 0);
        var t = this;
        this.stats = {
          actions: {
            get total() {
              return t._actions.length;
            },
            get inUse() {
              return t._nActiveActions;
            },
          },
          bindings: {
            get total() {
              return t._bindings.length;
            },
            get inUse() {
              return t._nActiveBindings;
            },
          },
          controlInterpolants: {
            get total() {
              return t._controlInterpolants.length;
            },
            get inUse() {
              return t._nActiveControlInterpolants;
            },
          },
        };
      },
      _isActiveAction: function (t) {
        var e = t._cacheIndex;
        return null !== e && e < this._nActiveActions;
      },
      _addInactiveAction: function (t, e, n) {
        var i = this._actions,
          r = this._actionsByClip,
          o = r[e];
        if (void 0 === o)
          (o = { knownActions: [t], actionByRoot: {} }),
            (t._byClipCacheIndex = 0),
            (r[e] = o);
        else {
          var s = o.knownActions;
          (t._byClipCacheIndex = s.length), s.push(t);
        }
        (t._cacheIndex = i.length), i.push(t), (o.actionByRoot[n] = t);
      },
      _removeInactiveAction: function (t) {
        var e = this._actions,
          n = e[e.length - 1],
          i = t._cacheIndex;
        (n._cacheIndex = i), (e[i] = n), e.pop(), (t._cacheIndex = null);
        var r = t._clip.uuid,
          o = this._actionsByClip,
          s = o[r],
          a = s.knownActions,
          c = a[a.length - 1],
          l = t._byClipCacheIndex;
        (c._byClipCacheIndex = l),
          (a[l] = c),
          a.pop(),
          (t._byClipCacheIndex = null),
          delete s.actionByRoot[(t._localRoot || this._root).uuid],
          0 === a.length && delete o[r],
          this._removeInactiveBindingsForAction(t);
      },
      _removeInactiveBindingsForAction: function (t) {
        for (var e = t._propertyBindings, n = 0, i = e.length; n !== i; ++n) {
          var r = e[n];
          0 == --r.referenceCount && this._removeInactiveBinding(r);
        }
      },
      _lendAction: function (t) {
        var e = this._actions,
          n = t._cacheIndex,
          i = this._nActiveActions++,
          r = e[i];
        (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
      },
      _takeBackAction: function (t) {
        var e = this._actions,
          n = t._cacheIndex,
          i = --this._nActiveActions,
          r = e[i];
        (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
      },
      _addInactiveBinding: function (t, e, n) {
        var i = this._bindingsByRootAndName,
          r = i[e],
          o = this._bindings;
        void 0 === r && ((r = {}), (i[e] = r)),
          (r[n] = t),
          (t._cacheIndex = o.length),
          o.push(t);
      },
      _removeInactiveBinding: function (t) {
        var e = this._bindings,
          n = t.binding,
          i = n.rootNode.uuid,
          r = n.path,
          o = this._bindingsByRootAndName,
          s = o[i],
          a = e[e.length - 1],
          c = t._cacheIndex;
        (a._cacheIndex = c),
          (e[c] = a),
          e.pop(),
          delete s[r],
          0 === Object.keys(s).length && delete o[i];
      },
      _lendBinding: function (t) {
        var e = this._bindings,
          n = t._cacheIndex,
          i = this._nActiveBindings++,
          r = e[i];
        (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
      },
      _takeBackBinding: function (t) {
        var e = this._bindings,
          n = t._cacheIndex,
          i = --this._nActiveBindings,
          r = e[i];
        (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
      },
      _lendControlInterpolant: function () {
        var t = this._controlInterpolants,
          e = this._nActiveControlInterpolants++,
          n = t[e];
        return (
          void 0 === n &&
            (((n = new da(
              new Float32Array(2),
              new Float32Array(2),
              1,
              this._controlInterpolantsResultBuffer,
            )).__cacheIndex = e),
            (t[e] = n)),
          n
        );
      },
      _takeBackControlInterpolant: function (t) {
        var e = this._controlInterpolants,
          n = t.__cacheIndex,
          i = --this._nActiveControlInterpolants,
          r = e[i];
        (t.__cacheIndex = i), (e[i] = t), (r.__cacheIndex = n), (e[n] = r);
      },
      _controlInterpolantsResultBuffer: new Float32Array(1),
      clipAction: function (t, e) {
        var n = e || this._root,
          i = n.uuid,
          r = 'string' == typeof t ? wa.findByName(n, t) : t,
          o = null !== r ? r.uuid : t,
          s = this._actionsByClip[o],
          a = null;
        if (void 0 !== s) {
          var c = s.actionByRoot[i];
          if (void 0 !== c) return c;
          (a = s.knownActions[0]), null === r && (r = a._clip);
        }
        if (null === r) return null;
        var l = new pl(this, r, e);
        return this._bindAction(l, a), this._addInactiveAction(l, o, i), l;
      },
      existingAction: function (t, e) {
        var n = e || this._root,
          i = n.uuid,
          r = 'string' == typeof t ? wa.findByName(n, t) : t,
          o = r ? r.uuid : t,
          s = this._actionsByClip[o];
        return (void 0 !== s && s.actionByRoot[i]) || null;
      },
      stopAllAction: function () {
        var t = this._actions,
          e = this._nActiveActions,
          n = this._bindings,
          i = this._nActiveBindings;
        (this._nActiveActions = 0), (this._nActiveBindings = 0);
        for (var r = 0; r !== e; ++r) t[r].reset();
        for (r = 0; r !== i; ++r) n[r].useCount = 0;
        return this;
      },
      update: function (t) {
        t *= this.timeScale;
        for (
          var e = this._actions,
            n = this._nActiveActions,
            i = (this.time += t),
            r = Math.sign(t),
            o = (this._accuIndex ^= 1),
            s = 0;
          s !== n;
          ++s
        ) {
          e[s]._update(i, t, r, o);
        }
        var a = this._bindings,
          c = this._nActiveBindings;
        for (s = 0; s !== c; ++s) a[s].apply(o);
        return this;
      },
      setTime: function (t) {
        this.time = 0;
        for (var e = 0; e < this._actions.length; e++)
          this._actions[e].time = 0;
        return this.update(t);
      },
      getRoot: function () {
        return this._root;
      },
      uncacheClip: function (t) {
        var e = this._actions,
          n = t.uuid,
          i = this._actionsByClip,
          r = i[n];
        if (void 0 !== r) {
          for (var o = r.knownActions, s = 0, a = o.length; s !== a; ++s) {
            var c = o[s];
            this._deactivateAction(c);
            var l = c._cacheIndex,
              h = e[e.length - 1];
            (c._cacheIndex = null),
              (c._byClipCacheIndex = null),
              (h._cacheIndex = l),
              (e[l] = h),
              e.pop(),
              this._removeInactiveBindingsForAction(c);
          }
          delete i[n];
        }
      },
      uncacheRoot: function (t) {
        var e = t.uuid,
          n = this._actionsByClip;
        for (var i in n) {
          var r = n[i].actionByRoot[e];
          void 0 !== r &&
            (this._deactivateAction(r), this._removeInactiveAction(r));
        }
        var o = this._bindingsByRootAndName[e];
        if (void 0 !== o)
          for (var s in o) {
            var a = o[s];
            a.restoreOriginalState(), this._removeInactiveBinding(a);
          }
      },
      uncacheAction: function (t, e) {
        var n = this.existingAction(t, e);
        null !== n &&
          (this._deactivateAction(n), this._removeInactiveAction(n));
      },
    })),
    (ml.prototype.clone = function () {
      return new ml(
        void 0 === this.value.clone ? this.value : this.value.clone(),
      );
    }),
    (bl.prototype = Object.assign(Object.create(Vr.prototype), {
      constructor: bl,
      isInstancedInterleavedBuffer: !0,
      copy: function (t) {
        return (
          Vr.prototype.copy.call(this, t),
          (this.meshPerAttribute = t.meshPerAttribute),
          this
        );
      },
    })),
    Object.assign(gl.prototype, {
      set: function (t, e) {
        this.ray.set(t, e);
      },
      setFromCamera: function (t, e) {
        e && e.isPerspectiveCamera
          ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld),
            this.ray.direction
              .set(t.x, t.y, 0.5)
              .unproject(e)
              .sub(this.ray.origin)
              .normalize(),
            (this.camera = e))
          : e && e.isOrthographicCamera
          ? (this.ray.origin
              .set(t.x, t.y, (e.near + e.far) / (e.near - e.far))
              .unproject(e),
            this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld),
            (this.camera = e))
          : console.error('THREE.Raycaster: Unsupported camera type.');
      },
      intersectObject: function (t, e, n) {
        var i = n || [];
        return vl(t, this, i, e), i.sort(yl), i;
      },
      intersectObjects: function (t, e, n) {
        var i = n || [];
        if (!1 === Array.isArray(t))
          return (
            console.warn(
              'THREE.Raycaster.intersectObjects: objects is not an Array.',
            ),
            i
          );
        for (var r = 0, o = t.length; r < o; r++) vl(t[r], this, i, e);
        return i.sort(yl), i;
      },
    }),
    Object.assign(
      function (t, e, n) {
        return (
          (this.radius = void 0 !== t ? t : 1),
          (this.phi = void 0 !== e ? e : 0),
          (this.theta = void 0 !== n ? n : 0),
          this
        );
      }.prototype,
      {
        set: function (t, e, n) {
          return (this.radius = t), (this.phi = e), (this.theta = n), this;
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
        copy: function (t) {
          return (
            (this.radius = t.radius),
            (this.phi = t.phi),
            (this.theta = t.theta),
            this
          );
        },
        makeSafe: function () {
          var t = 1e-6;
          return (
            (this.phi = Math.max(t, Math.min(Math.PI - t, this.phi))), this
          );
        },
        setFromVector3: function (t) {
          return this.setFromCartesianCoords(t.x, t.y, t.z);
        },
        setFromCartesianCoords: function (t, e, n) {
          return (
            (this.radius = Math.sqrt(t * t + e * e + n * n)),
            0 === this.radius
              ? ((this.theta = 0), (this.phi = 0))
              : ((this.theta = Math.atan2(t, n)),
                (this.phi = Math.acos(k.clamp(e / this.radius, -1, 1)))),
            this
          );
        },
      },
    ),
    Object.assign(
      function (t, e, n) {
        return (
          (this.radius = void 0 !== t ? t : 1),
          (this.theta = void 0 !== e ? e : 0),
          (this.y = void 0 !== n ? n : 0),
          this
        );
      }.prototype,
      {
        set: function (t, e, n) {
          return (this.radius = t), (this.theta = e), (this.y = n), this;
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
        copy: function (t) {
          return (
            (this.radius = t.radius),
            (this.theta = t.theta),
            (this.y = t.y),
            this
          );
        },
        setFromVector3: function (t) {
          return this.setFromCartesianCoords(t.x, t.y, t.z);
        },
        setFromCartesianCoords: function (t, e, n) {
          return (
            (this.radius = Math.sqrt(t * t + n * n)),
            (this.theta = Math.atan2(t, n)),
            (this.y = e),
            this
          );
        },
      },
    );
  var _l = new U();
  function xl(t, e) {
    (this.min = void 0 !== t ? t : new U(1 / 0, 1 / 0)),
      (this.max = void 0 !== e ? e : new U(-1 / 0, -1 / 0));
  }
  Object.assign(xl.prototype, {
    set: function (t, e) {
      return this.min.copy(t), this.max.copy(e), this;
    },
    setFromPoints: function (t) {
      this.makeEmpty();
      for (var e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
      return this;
    },
    setFromCenterAndSize: function (t, e) {
      var n = _l.copy(e).multiplyScalar(0.5);
      return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
    },
    clone: function () {
      return new this.constructor().copy(this);
    },
    copy: function (t) {
      return this.min.copy(t.min), this.max.copy(t.max), this;
    },
    makeEmpty: function () {
      return (
        (this.min.x = this.min.y = 1 / 0),
        (this.max.x = this.max.y = -1 / 0),
        this
      );
    },
    isEmpty: function () {
      return this.max.x < this.min.x || this.max.y < this.min.y;
    },
    getCenter: function (t) {
      return (
        void 0 === t &&
          (console.warn('THREE.Box2: .getCenter() target is now required'),
          (t = new U())),
        this.isEmpty()
          ? t.set(0, 0)
          : t.addVectors(this.min, this.max).multiplyScalar(0.5)
      );
    },
    getSize: function (t) {
      return (
        void 0 === t &&
          (console.warn('THREE.Box2: .getSize() target is now required'),
          (t = new U())),
        this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
      );
    },
    expandByPoint: function (t) {
      return this.min.min(t), this.max.max(t), this;
    },
    expandByVector: function (t) {
      return this.min.sub(t), this.max.add(t), this;
    },
    expandByScalar: function (t) {
      return this.min.addScalar(-t), this.max.addScalar(t), this;
    },
    containsPoint: function (t) {
      return !(
        t.x < this.min.x ||
        t.x > this.max.x ||
        t.y < this.min.y ||
        t.y > this.max.y
      );
    },
    containsBox: function (t) {
      return (
        this.min.x <= t.min.x &&
        t.max.x <= this.max.x &&
        this.min.y <= t.min.y &&
        t.max.y <= this.max.y
      );
    },
    getParameter: function (t, e) {
      return (
        void 0 === e &&
          (console.warn('THREE.Box2: .getParameter() target is now required'),
          (e = new U())),
        e.set(
          (t.x - this.min.x) / (this.max.x - this.min.x),
          (t.y - this.min.y) / (this.max.y - this.min.y),
        )
      );
    },
    intersectsBox: function (t) {
      return !(
        t.max.x < this.min.x ||
        t.min.x > this.max.x ||
        t.max.y < this.min.y ||
        t.min.y > this.max.y
      );
    },
    clampPoint: function (t, e) {
      return (
        void 0 === e &&
          (console.warn('THREE.Box2: .clampPoint() target is now required'),
          (e = new U())),
        e.copy(t).clamp(this.min, this.max)
      );
    },
    distanceToPoint: function (t) {
      return _l.copy(t).clamp(this.min, this.max).sub(t).length();
    },
    intersect: function (t) {
      return this.min.max(t.min), this.max.min(t.max), this;
    },
    union: function (t) {
      return this.min.min(t.min), this.max.max(t.max), this;
    },
    translate: function (t) {
      return this.min.add(t), this.max.add(t), this;
    },
    equals: function (t) {
      return t.min.equals(this.min) && t.max.equals(this.max);
    },
  });
  var wl = new J(),
    Al = new J();
  function Ml(t, e) {
    (this.start = void 0 !== t ? t : new J()),
      (this.end = void 0 !== e ? e : new J());
  }
  function Sl(t) {
    At.call(this), (this.material = t), (this.render = function () {});
  }
  Object.assign(Ml.prototype, {
    set: function (t, e) {
      return this.start.copy(t), this.end.copy(e), this;
    },
    clone: function () {
      return new this.constructor().copy(this);
    },
    copy: function (t) {
      return this.start.copy(t.start), this.end.copy(t.end), this;
    },
    getCenter: function (t) {
      return (
        void 0 === t &&
          (console.warn('THREE.Line3: .getCenter() target is now required'),
          (t = new J())),
        t.addVectors(this.start, this.end).multiplyScalar(0.5)
      );
    },
    delta: function (t) {
      return (
        void 0 === t &&
          (console.warn('THREE.Line3: .delta() target is now required'),
          (t = new J())),
        t.subVectors(this.end, this.start)
      );
    },
    distanceSq: function () {
      return this.start.distanceToSquared(this.end);
    },
    distance: function () {
      return this.start.distanceTo(this.end);
    },
    at: function (t, e) {
      return (
        void 0 === e &&
          (console.warn('THREE.Line3: .at() target is now required'),
          (e = new J())),
        this.delta(e).multiplyScalar(t).add(this.start)
      );
    },
    closestPointToPointParameter: function (t, e) {
      wl.subVectors(t, this.start), Al.subVectors(this.end, this.start);
      var n = Al.dot(Al),
        i = Al.dot(wl) / n;
      return e && (i = k.clamp(i, 0, 1)), i;
    },
    closestPointToPoint: function (t, e, n) {
      var i = this.closestPointToPointParameter(t, e);
      return (
        void 0 === n &&
          (console.warn(
            'THREE.Line3: .closestPointToPoint() target is now required',
          ),
          (n = new J())),
        this.delta(n).multiplyScalar(i).add(this.start)
      );
    },
    applyMatrix4: function (t) {
      return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this;
    },
    equals: function (t) {
      return t.start.equals(this.start) && t.end.equals(this.end);
    },
  }),
    (Sl.prototype = Object.create(At.prototype)),
    (Sl.prototype.constructor = Sl),
    (Sl.prototype.isImmediateRenderObject = !0);
  var Il = new J();
  function El(t, e) {
    At.call(this),
      (this.light = t),
      this.light.updateMatrixWorld(),
      (this.matrix = t.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = e);
    for (
      var n = new He(),
        i = [
          0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1,
          1, 0, 0, 0, 0, -1, 1,
        ],
        r = 0,
        o = 1;
      r < 32;
      r++, o++
    ) {
      var s = (r / 32) * Math.PI * 2,
        a = (o / 32) * Math.PI * 2;
      i.push(Math.cos(s), Math.sin(s), 1, Math.cos(a), Math.sin(a), 1);
    }
    n.setAttribute('position', new Re(i, 3));
    var c = new bo({ fog: !1, toneMapped: !1 });
    (this.cone = new So(n, c)), this.add(this.cone), this.update();
  }
  (El.prototype = Object.create(At.prototype)),
    (El.prototype.constructor = El),
    (El.prototype.dispose = function () {
      this.cone.geometry.dispose(), this.cone.material.dispose();
    }),
    (El.prototype.update = function () {
      this.light.updateMatrixWorld();
      var t = this.light.distance ? this.light.distance : 1e3,
        e = t * Math.tan(this.light.angle);
      this.cone.scale.set(e, e, t),
        Il.setFromMatrixPosition(this.light.target.matrixWorld),
        this.cone.lookAt(Il),
        void 0 !== this.color
          ? this.cone.material.color.set(this.color)
          : this.cone.material.color.copy(this.light.color);
    });
  var Dl = new J(),
    Cl = new ot(),
    Tl = new ot();
  function Ll(t) {
    var e = [];
    t && t.isBone && e.push(t);
    for (var n = 0; n < t.children.length; n++)
      e.push.apply(e, Ll(t.children[n]));
    return e;
  }
  function Rl(t) {
    for (
      var e = Ll(t),
        n = new He(),
        i = [],
        r = [],
        o = new fe(0, 0, 1),
        s = new fe(0, 1, 0),
        a = 0;
      a < e.length;
      a++
    ) {
      var c = e[a];
      c.parent &&
        c.parent.isBone &&
        (i.push(0, 0, 0),
        i.push(0, 0, 0),
        r.push(o.r, o.g, o.b),
        r.push(s.r, s.g, s.b));
    }
    n.setAttribute('position', new Re(i, 3)),
      n.setAttribute('color', new Re(r, 3));
    var l = new bo({
      vertexColors: !0,
      depthTest: !1,
      depthWrite: !1,
      toneMapped: !1,
      transparent: !0,
    });
    So.call(this, n, l),
      (this.root = t),
      (this.bones = e),
      (this.matrix = t.matrixWorld),
      (this.matrixAutoUpdate = !1);
  }
  function Fl(t, e, n) {
    (this.light = t), this.light.updateMatrixWorld(), (this.color = n);
    var i = new Bs(e, 4, 2),
      r = new xe({ wireframe: !0, fog: !1, toneMapped: !1 });
    ln.call(this, i, r),
      (this.matrix = this.light.matrixWorld),
      (this.matrixAutoUpdate = !1),
      this.update();
  }
  (Rl.prototype = Object.create(So.prototype)),
    (Rl.prototype.constructor = Rl),
    (Rl.prototype.isSkeletonHelper = !0),
    (Rl.prototype.updateMatrixWorld = function (t) {
      var e = this.bones,
        n = this.geometry,
        i = n.getAttribute('position');
      Tl.getInverse(this.root.matrixWorld);
      for (var r = 0, o = 0; r < e.length; r++) {
        var s = e[r];
        s.parent &&
          s.parent.isBone &&
          (Cl.multiplyMatrices(Tl, s.matrixWorld),
          Dl.setFromMatrixPosition(Cl),
          i.setXYZ(o, Dl.x, Dl.y, Dl.z),
          Cl.multiplyMatrices(Tl, s.parent.matrixWorld),
          Dl.setFromMatrixPosition(Cl),
          i.setXYZ(o + 1, Dl.x, Dl.y, Dl.z),
          (o += 2));
      }
      (n.getAttribute('position').needsUpdate = !0),
        At.prototype.updateMatrixWorld.call(this, t);
    }),
    (Fl.prototype = Object.create(ln.prototype)),
    (Fl.prototype.constructor = Fl),
    (Fl.prototype.dispose = function () {
      this.geometry.dispose(), this.material.dispose();
    }),
    (Fl.prototype.update = function () {
      void 0 !== this.color
        ? this.material.color.set(this.color)
        : this.material.color.copy(this.light.color);
    });
  var Pl = new J(),
    Bl = new fe(),
    Ol = new fe();
  function Vl(t, e, n) {
    At.call(this),
      (this.light = t),
      this.light.updateMatrixWorld(),
      (this.matrix = t.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = n);
    var i = new Xo(e);
    i.rotateY(0.5 * Math.PI),
      (this.material = new xe({ wireframe: !0, fog: !1, toneMapped: !1 })),
      void 0 === this.color && (this.material.vertexColors = !0);
    var r = i.getAttribute('position'),
      o = new Float32Array(3 * r.count);
    i.setAttribute('color', new Ae(o, 3)),
      this.add(new ln(i, this.material)),
      this.update();
  }
  function Nl(t, e, n, i) {
    (t = t || 10),
      (e = e || 10),
      (n = new fe(void 0 !== n ? n : 4473924)),
      (i = new fe(void 0 !== i ? i : 8947848));
    for (
      var r = e / 2, o = t / e, s = t / 2, a = [], c = [], l = 0, h = 0, u = -s;
      l <= e;
      l++, u += o
    ) {
      a.push(-s, 0, u, s, 0, u), a.push(u, 0, -s, u, 0, s);
      var d = l === r ? n : i;
      d.toArray(c, h),
        (h += 3),
        d.toArray(c, h),
        (h += 3),
        d.toArray(c, h),
        (h += 3),
        d.toArray(c, h),
        (h += 3);
    }
    var p = new He();
    p.setAttribute('position', new Re(a, 3)),
      p.setAttribute('color', new Re(c, 3));
    var f = new bo({ vertexColors: !0, toneMapped: !1 });
    So.call(this, p, f);
  }
  function kl(t, e, n, i, r, o) {
    (t = t || 10),
      (e = e || 16),
      (n = n || 8),
      (i = i || 64),
      (r = new fe(void 0 !== r ? r : 4473924)),
      (o = new fe(void 0 !== o ? o : 8947848));
    var s,
      a,
      c,
      l,
      h,
      u,
      d,
      p = [],
      f = [];
    for (l = 0; l <= e; l++)
      (c = (l / e) * (2 * Math.PI)),
        (s = Math.sin(c) * t),
        (a = Math.cos(c) * t),
        p.push(0, 0, 0),
        p.push(s, 0, a),
        (d = 1 & l ? r : o),
        f.push(d.r, d.g, d.b),
        f.push(d.r, d.g, d.b);
    for (l = 0; l <= n; l++)
      for (d = 1 & l ? r : o, u = t - (t / n) * l, h = 0; h < i; h++)
        (c = (h / i) * (2 * Math.PI)),
          (s = Math.sin(c) * u),
          (a = Math.cos(c) * u),
          p.push(s, 0, a),
          f.push(d.r, d.g, d.b),
          (c = ((h + 1) / i) * (2 * Math.PI)),
          (s = Math.sin(c) * u),
          (a = Math.cos(c) * u),
          p.push(s, 0, a),
          f.push(d.r, d.g, d.b);
    var m = new He();
    m.setAttribute('position', new Re(p, 3)),
      m.setAttribute('color', new Re(f, 3));
    var b = new bo({ vertexColors: !0, toneMapped: !1 });
    So.call(this, m, b);
  }
  (Vl.prototype = Object.create(At.prototype)),
    (Vl.prototype.constructor = Vl),
    (Vl.prototype.dispose = function () {
      this.children[0].geometry.dispose(), this.children[0].material.dispose();
    }),
    (Vl.prototype.update = function () {
      var t = this.children[0];
      if (void 0 !== this.color) this.material.color.set(this.color);
      else {
        var e = t.geometry.getAttribute('color');
        Bl.copy(this.light.color), Ol.copy(this.light.groundColor);
        for (var n = 0, i = e.count; n < i; n++) {
          var r = n < i / 2 ? Bl : Ol;
          e.setXYZ(n, r.r, r.g, r.b);
        }
        e.needsUpdate = !0;
      }
      t.lookAt(Pl.setFromMatrixPosition(this.light.matrixWorld).negate());
    }),
    (Nl.prototype = Object.assign(Object.create(So.prototype), {
      constructor: Nl,
      copy: function (t) {
        return (
          So.prototype.copy.call(this, t),
          this.geometry.copy(t.geometry),
          this.material.copy(t.material),
          this
        );
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
    })),
    (kl.prototype = Object.create(So.prototype)),
    (kl.prototype.constructor = kl);
  var Ul = new J(),
    Gl = new J(),
    zl = new J();
  function jl(t, e, n) {
    At.call(this),
      (this.light = t),
      this.light.updateMatrixWorld(),
      (this.matrix = t.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = n),
      void 0 === e && (e = 1);
    var i = new He();
    i.setAttribute(
      'position',
      new Re([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3),
    );
    var r = new bo({ fog: !1, toneMapped: !1 });
    (this.lightPlane = new wo(i, r)),
      this.add(this.lightPlane),
      (i = new He()).setAttribute('position', new Re([0, 0, 0, 0, 0, 1], 3)),
      (this.targetLine = new wo(i, r)),
      this.add(this.targetLine),
      this.update();
  }
  (jl.prototype = Object.create(At.prototype)),
    (jl.prototype.constructor = jl),
    (jl.prototype.dispose = function () {
      this.lightPlane.geometry.dispose(),
        this.lightPlane.material.dispose(),
        this.targetLine.geometry.dispose(),
        this.targetLine.material.dispose();
    }),
    (jl.prototype.update = function () {
      Ul.setFromMatrixPosition(this.light.matrixWorld),
        Gl.setFromMatrixPosition(this.light.target.matrixWorld),
        zl.subVectors(Gl, Ul),
        this.lightPlane.lookAt(Gl),
        void 0 !== this.color
          ? (this.lightPlane.material.color.set(this.color),
            this.targetLine.material.color.set(this.color))
          : (this.lightPlane.material.color.copy(this.light.color),
            this.targetLine.material.color.copy(this.light.color)),
        this.targetLine.lookAt(Gl),
        (this.targetLine.scale.z = zl.length());
    });
  var Hl = new J(),
    Wl = new An();
  function Xl(t) {
    var e = new He(),
      n = new bo({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
      i = [],
      r = [],
      o = {},
      s = new fe(16755200),
      a = new fe(16711680),
      c = new fe(43775),
      l = new fe(16777215),
      h = new fe(3355443);
    function u(t, e, n) {
      d(t, n), d(e, n);
    }
    function d(t, e) {
      i.push(0, 0, 0),
        r.push(e.r, e.g, e.b),
        void 0 === o[t] && (o[t] = []),
        o[t].push(i.length / 3 - 1);
    }
    u('n1', 'n2', s),
      u('n2', 'n4', s),
      u('n4', 'n3', s),
      u('n3', 'n1', s),
      u('f1', 'f2', s),
      u('f2', 'f4', s),
      u('f4', 'f3', s),
      u('f3', 'f1', s),
      u('n1', 'f1', s),
      u('n2', 'f2', s),
      u('n3', 'f3', s),
      u('n4', 'f4', s),
      u('p', 'n1', a),
      u('p', 'n2', a),
      u('p', 'n3', a),
      u('p', 'n4', a),
      u('u1', 'u2', c),
      u('u2', 'u3', c),
      u('u3', 'u1', c),
      u('c', 't', l),
      u('p', 'c', h),
      u('cn1', 'cn2', h),
      u('cn3', 'cn4', h),
      u('cf1', 'cf2', h),
      u('cf3', 'cf4', h),
      e.setAttribute('position', new Re(i, 3)),
      e.setAttribute('color', new Re(r, 3)),
      So.call(this, e, n),
      (this.camera = t),
      this.camera.updateProjectionMatrix &&
        this.camera.updateProjectionMatrix(),
      (this.matrix = t.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.pointMap = o),
      this.update();
  }
  function Zl(t, e, n, i, r, o, s) {
    Hl.set(r, o, s).unproject(i);
    var a = e[t];
    if (void 0 !== a)
      for (var c = n.getAttribute('position'), l = 0, h = a.length; l < h; l++)
        c.setXYZ(a[l], Hl.x, Hl.y, Hl.z);
  }
  (Xl.prototype = Object.create(So.prototype)),
    (Xl.prototype.constructor = Xl),
    (Xl.prototype.update = function () {
      var t = this.geometry,
        e = this.pointMap;
      Wl.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
        Zl('c', e, t, Wl, 0, 0, -1),
        Zl('t', e, t, Wl, 0, 0, 1),
        Zl('n1', e, t, Wl, -1, -1, -1),
        Zl('n2', e, t, Wl, 1, -1, -1),
        Zl('n3', e, t, Wl, -1, 1, -1),
        Zl('n4', e, t, Wl, 1, 1, -1),
        Zl('f1', e, t, Wl, -1, -1, 1),
        Zl('f2', e, t, Wl, 1, -1, 1),
        Zl('f3', e, t, Wl, -1, 1, 1),
        Zl('f4', e, t, Wl, 1, 1, 1),
        Zl('u1', e, t, Wl, 0.7, 1.1, -1),
        Zl('u2', e, t, Wl, -0.7, 1.1, -1),
        Zl('u3', e, t, Wl, 0, 2, -1),
        Zl('cf1', e, t, Wl, -1, 0, 1),
        Zl('cf2', e, t, Wl, 1, 0, 1),
        Zl('cf3', e, t, Wl, 0, -1, 1),
        Zl('cf4', e, t, Wl, 0, 1, 1),
        Zl('cn1', e, t, Wl, -1, 0, -1),
        Zl('cn2', e, t, Wl, 1, 0, -1),
        Zl('cn3', e, t, Wl, 0, -1, -1),
        Zl('cn4', e, t, Wl, 0, 1, -1),
        (t.getAttribute('position').needsUpdate = !0);
    });
  var Yl = new Nt();
  function ql(t, e) {
    (this.object = t), void 0 === e && (e = 16776960);
    var n = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      i = new Float32Array(24),
      r = new He();
    r.setIndex(new Ae(n, 1)),
      r.setAttribute('position', new Ae(i, 3)),
      So.call(this, r, new bo({ color: e, toneMapped: !1 })),
      (this.matrixAutoUpdate = !1),
      this.update();
  }
  function Ql(t, e) {
    (this.type = 'Box3Helper'), (this.box = t), (e = e || 16776960);
    var n = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      i = new He();
    i.setIndex(new Ae(n, 1)),
      i.setAttribute(
        'position',
        new Re(
          [
            1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1,
            -1, 1, -1, -1,
          ],
          3,
        ),
      ),
      So.call(this, i, new bo({ color: e, toneMapped: !1 })),
      this.geometry.computeBoundingSphere();
  }
  function Jl(t, e, n) {
    (this.type = 'PlaneHelper'),
      (this.plane = t),
      (this.size = void 0 === e ? 1 : e);
    var i = void 0 !== n ? n : 16776960,
      r = new He();
    r.setAttribute(
      'position',
      new Re(
        [
          1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1,
          1, 1, 1, 0, 0, 1, 0, 0, 0,
        ],
        3,
      ),
    ),
      r.computeBoundingSphere(),
      wo.call(this, r, new bo({ color: i, toneMapped: !1 }));
    var o = new He();
    o.setAttribute(
      'position',
      new Re([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3),
    ),
      o.computeBoundingSphere(),
      this.add(
        new ln(
          o,
          new xe({
            color: i,
            opacity: 0.2,
            transparent: !0,
            depthWrite: !1,
            toneMapped: !1,
          }),
        ),
      );
  }
  (ql.prototype = Object.create(So.prototype)),
    (ql.prototype.constructor = ql),
    (ql.prototype.update = function (t) {
      if (
        (void 0 !== t &&
          console.warn('THREE.BoxHelper: .update() has no longer arguments.'),
        void 0 !== this.object && Yl.setFromObject(this.object),
        !Yl.isEmpty())
      ) {
        var e = Yl.min,
          n = Yl.max,
          i = this.geometry.attributes.position,
          r = i.array;
        (r[0] = n.x),
          (r[1] = n.y),
          (r[2] = n.z),
          (r[3] = e.x),
          (r[4] = n.y),
          (r[5] = n.z),
          (r[6] = e.x),
          (r[7] = e.y),
          (r[8] = n.z),
          (r[9] = n.x),
          (r[10] = e.y),
          (r[11] = n.z),
          (r[12] = n.x),
          (r[13] = n.y),
          (r[14] = e.z),
          (r[15] = e.x),
          (r[16] = n.y),
          (r[17] = e.z),
          (r[18] = e.x),
          (r[19] = e.y),
          (r[20] = e.z),
          (r[21] = n.x),
          (r[22] = e.y),
          (r[23] = e.z),
          (i.needsUpdate = !0),
          this.geometry.computeBoundingSphere();
      }
    }),
    (ql.prototype.setFromObject = function (t) {
      return (this.object = t), this.update(), this;
    }),
    (ql.prototype.copy = function (t) {
      return So.prototype.copy.call(this, t), (this.object = t.object), this;
    }),
    (ql.prototype.clone = function () {
      return new this.constructor().copy(this);
    }),
    (Ql.prototype = Object.create(So.prototype)),
    (Ql.prototype.constructor = Ql),
    (Ql.prototype.updateMatrixWorld = function (t) {
      var e = this.box;
      e.isEmpty() ||
        (e.getCenter(this.position),
        e.getSize(this.scale),
        this.scale.multiplyScalar(0.5),
        At.prototype.updateMatrixWorld.call(this, t));
    }),
    (Jl.prototype = Object.create(wo.prototype)),
    (Jl.prototype.constructor = Jl),
    (Jl.prototype.updateMatrixWorld = function (t) {
      var e = -this.plane.constant;
      Math.abs(e) < 1e-8 && (e = 1e-8),
        this.scale.set(0.5 * this.size, 0.5 * this.size, e),
        (this.children[0].material.side = e < 0 ? 1 : 0),
        this.lookAt(this.plane.normal),
        At.prototype.updateMatrixWorld.call(this, t);
    });
  var $l,
    Kl,
    th = new J();
  function eh(t, e, n, i, r, o) {
    At.call(this),
      void 0 === t && (t = new J(0, 0, 1)),
      void 0 === e && (e = new J(0, 0, 0)),
      void 0 === n && (n = 1),
      void 0 === i && (i = 16776960),
      void 0 === r && (r = 0.2 * n),
      void 0 === o && (o = 0.2 * r),
      void 0 === $l &&
        (($l = new He()).setAttribute(
          'position',
          new Re([0, 0, 0, 0, 1, 0], 3),
        ),
        (Kl = new Ws(0, 0.5, 1, 5, 1)).translate(0, -0.5, 0)),
      this.position.copy(e),
      (this.line = new wo($l, new bo({ color: i, toneMapped: !1 }))),
      (this.line.matrixAutoUpdate = !1),
      this.add(this.line),
      (this.cone = new ln(Kl, new xe({ color: i, toneMapped: !1 }))),
      (this.cone.matrixAutoUpdate = !1),
      this.add(this.cone),
      this.setDirection(t),
      this.setLength(n, r, o);
  }
  function nh(t) {
    var e = [0, 0, 0, (t = t || 1), 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
      n = new He();
    n.setAttribute('position', new Re(e, 3)),
      n.setAttribute(
        'color',
        new Re([1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1], 3),
      );
    var i = new bo({ vertexColors: !0, toneMapped: !1 });
    So.call(this, n, i);
  }
  (eh.prototype = Object.create(At.prototype)),
    (eh.prototype.constructor = eh),
    (eh.prototype.setDirection = function (t) {
      if (t.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
      else if (t.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
      else {
        th.set(t.z, 0, -t.x).normalize();
        var e = Math.acos(t.y);
        this.quaternion.setFromAxisAngle(th, e);
      }
    }),
    (eh.prototype.setLength = function (t, e, n) {
      void 0 === e && (e = 0.2 * t),
        void 0 === n && (n = 0.2 * e),
        this.line.scale.set(1, Math.max(1e-4, t - e), 1),
        this.line.updateMatrix(),
        this.cone.scale.set(n, e, n),
        (this.cone.position.y = t),
        this.cone.updateMatrix();
    }),
    (eh.prototype.setColor = function (t) {
      this.line.material.color.set(t), this.cone.material.color.set(t);
    }),
    (eh.prototype.copy = function (t) {
      return (
        At.prototype.copy.call(this, t, !1),
        this.line.copy(t.line),
        this.cone.copy(t.cone),
        this
      );
    }),
    (eh.prototype.clone = function () {
      return new this.constructor().copy(this);
    }),
    (nh.prototype = Object.create(So.prototype)),
    (nh.prototype.constructor = nh);
  var ih,
    rh,
    oh,
    sh = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
    ah = 5 + sh.length,
    ch = { [T]: 0, [L]: 1, 3002: 2, 3004: 3, 3005: 4, 3006: 5, 3007: 6 };
  new dc(),
    (ih = 20),
    (rh = new Float32Array(ih)),
    (oh = new J(0, 1, 0)),
    (new $s({
      defines: { n: ih },
      uniforms: {
        envMap: { value: null },
        samples: { value: 1 },
        weights: { value: rh },
        latitudinal: { value: !1 },
        dTheta: { value: 0 },
        mipInt: { value: 0 },
        poleAxis: { value: oh },
        inputEncoding: { value: ch[3e3] },
        outputEncoding: { value: ch[3e3] },
      },
      vertexShader:
        '\nprecision mediump float;\nprecision mediump int;\nattribute vec3 position;\nattribute vec2 uv;\nattribute float faceIndex;\nvarying vec3 vOutputDirection;\nvec3 getDirection(vec2 uv, float face) {\n\tuv = 2.0 * uv - 1.0;\n\tvec3 direction = vec3(uv, 1.0);\n\tif (face == 0.0) {\n\t\tdirection = direction.zyx;\n\t\tdirection.z *= -1.0;\n\t} else if (face == 1.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.z *= -1.0;\n\t} else if (face == 3.0) {\n\t\tdirection = direction.zyx;\n\t\tdirection.x *= -1.0;\n\t} else if (face == 4.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.y *= -1.0;\n\t} else if (face == 5.0) {\n\t\tdirection.xz *= -1.0;\n\t}\n\treturn direction;\n}\nvoid main() {\n\tvOutputDirection = getDirection(uv, faceIndex);\n\tgl_Position = vec4( position, 1.0 );\n}\n\t',
      fragmentShader:
        "\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform sampler2D envMap;\nuniform int samples;\nuniform float weights[n];\nuniform bool latitudinal;\nuniform float dTheta;\nuniform float mipInt;\nuniform vec3 poleAxis;\n\n\nuniform int inputEncoding;\nuniform int outputEncoding;\n\n#include <encodings_pars_fragment>\n\nvec4 inputTexelToLinear(vec4 value){\n\tif(inputEncoding == 0){\n\t\treturn value;\n\t}else if(inputEncoding == 1){\n\t\treturn sRGBToLinear(value);\n\t}else if(inputEncoding == 2){\n\t\treturn RGBEToLinear(value);\n\t}else if(inputEncoding == 3){\n\t\treturn RGBMToLinear(value, 7.0);\n\t}else if(inputEncoding == 4){\n\t\treturn RGBMToLinear(value, 16.0);\n\t}else if(inputEncoding == 5){\n\t\treturn RGBDToLinear(value, 256.0);\n\t}else{\n\t\treturn GammaToLinear(value, 2.2);\n\t}\n}\n\nvec4 linearToOutputTexel(vec4 value){\n\tif(outputEncoding == 0){\n\t\treturn value;\n\t}else if(outputEncoding == 1){\n\t\treturn LinearTosRGB(value);\n\t}else if(outputEncoding == 2){\n\t\treturn LinearToRGBE(value);\n\t}else if(outputEncoding == 3){\n\t\treturn LinearToRGBM(value, 7.0);\n\t}else if(outputEncoding == 4){\n\t\treturn LinearToRGBM(value, 16.0);\n\t}else if(outputEncoding == 5){\n\t\treturn LinearToRGBD(value, 256.0);\n\t}else{\n\t\treturn LinearToGamma(value, 2.2);\n\t}\n}\n\nvec4 envMapTexelToLinear(vec4 color) {\n\treturn inputTexelToLinear(color);\n}\n\t\n\n#define ENVMAP_TYPE_CUBE_UV\n#include <cube_uv_reflection_fragment>\n\nvec3 getSample(float theta, vec3 axis) {\n\tfloat cosTheta = cos(theta);\n\t// Rodrigues' axis-angle rotation\n\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t+ cross(axis, vOutputDirection) * sin(theta)\n\t\t+ axis * dot(axis, vOutputDirection) * (1.0 - cosTheta);\n\treturn bilinearCubeUV(envMap, sampleDirection, mipInt);\n}\n\nvoid main() {\n\tvec3 axis = latitudinal ? poleAxis : cross(poleAxis, vOutputDirection);\n\tif (all(equal(axis, vec3(0.0))))\n\t\taxis = vec3(vOutputDirection.z, 0.0, - vOutputDirection.x);\n\taxis = normalize(axis);\n\tgl_FragColor = vec4(0.0);\n\tgl_FragColor.rgb += weights[0] * getSample(0.0, axis);\n\tfor (int i = 1; i < n; i++) {\n\t\tif (i >= samples)\n\t\t\tbreak;\n\t\tfloat theta = dTheta * float(i);\n\t\tgl_FragColor.rgb += weights[i] * getSample(-1.0 * theta, axis);\n\t\tgl_FragColor.rgb += weights[i] * getSample(theta, axis);\n\t}\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t",
      blending: 0,
      depthTest: !1,
      depthWrite: !1,
    }).type = 'SphericalGaussianBlur'),
    (function () {
      for (var t = [], e = [], n = [], i = 8, r = 0; r < ah; r++) {
        var o = Math.pow(2, i);
        e.push(o);
        var s = 1 / o;
        r > 4 ? (s = sh[r - 8 + 4 - 1]) : 0 == r && (s = 0), n.push(s);
        for (
          var a = 1 / (o - 1),
            c = -a / 2,
            l = 1 + a / 2,
            h = [c, c, l, c, l, l, c, c, l, l, c, l],
            u = new Float32Array(108),
            d = new Float32Array(72),
            p = new Float32Array(36),
            f = 0;
          f < 6;
          f++
        ) {
          var m = ((f % 3) * 2) / 3 - 1,
            b = f > 2 ? 0 : -1,
            g = [
              m,
              b,
              0,
              m + 2 / 3,
              b,
              0,
              m + 2 / 3,
              b + 1,
              0,
              m,
              b,
              0,
              m + 2 / 3,
              b + 1,
              0,
              m,
              b + 1,
              0,
            ];
          u.set(g, 18 * f), d.set(h, 12 * f);
          var y = [f, f, f, f, f, f];
          p.set(y, 6 * f);
        }
        var v = new He();
        v.setAttribute('position', new Ae(u, 3)),
          v.setAttribute('uv', new Ae(d, 2)),
          v.setAttribute('faceIndex', new Ae(p, 1)),
          t.push(v),
          i > 4 && i--;
      }
    })();
  var lh = (1 + Math.sqrt(5)) / 2,
    hh = 1 / lh;
  new J(1, 1, 1),
    new J(-1, 1, 1),
    new J(1, 1, -1),
    new J(-1, 1, -1),
    new J(0, lh, hh),
    new J(0, lh, -hh),
    new J(hh, 0, lh),
    new J(-hh, 0, lh),
    new J(lh, hh, 0),
    new J(-lh, hh, 0);
  var uh = {
    DEG2RAD: Math.PI / 180,
    RAD2DEG: 180 / Math.PI,
    generateUUID: (function () {
      for (var t = [], e = 0; e < 256; e++)
        t[e] = (e < 16 ? '0' : '') + e.toString(16);
      return function () {
        var e = (4294967295 * Math.random()) | 0,
          n = (4294967295 * Math.random()) | 0,
          i = (4294967295 * Math.random()) | 0,
          r = (4294967295 * Math.random()) | 0;
        return (
          t[255 & e] +
          t[(e >> 8) & 255] +
          t[(e >> 16) & 255] +
          t[(e >> 24) & 255] +
          '-' +
          t[255 & n] +
          t[(n >> 8) & 255] +
          '-' +
          t[((n >> 16) & 15) | 64] +
          t[(n >> 24) & 255] +
          '-' +
          t[(63 & i) | 128] +
          t[(i >> 8) & 255] +
          '-' +
          t[(i >> 16) & 255] +
          t[(i >> 24) & 255] +
          t[255 & r] +
          t[(r >> 8) & 255] +
          t[(r >> 16) & 255] +
          t[(r >> 24) & 255]
        ).toUpperCase();
      };
    })(),
    clamp: function (t, e, n) {
      return Math.max(e, Math.min(n, t));
    },
    euclideanModulo: function (t, e) {
      return ((t % e) + e) % e;
    },
    mapLinear: function (t, e, n, i, r) {
      return i + ((t - e) * (r - i)) / (n - e);
    },
    lerp: function (t, e, n) {
      return (1 - n) * t + n * e;
    },
    smoothstep: function (t, e, n) {
      return t <= e
        ? 0
        : t >= n
        ? 1
        : (t = (t - e) / (n - e)) * t * (3 - 2 * t);
    },
    smootherstep: function (t, e, n) {
      return t <= e
        ? 0
        : t >= n
        ? 1
        : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10);
    },
    randInt: function (t, e) {
      return t + Math.floor(Math.random() * (e - t + 1));
    },
    randFloat: function (t, e) {
      return t + Math.random() * (e - t);
    },
    randFloatSpread: function (t) {
      return t * (0.5 - Math.random());
    },
    degToRad: function (t) {
      return t * uh.DEG2RAD;
    },
    radToDeg: function (t) {
      return t * uh.RAD2DEG;
    },
    isPowerOfTwo: function (t) {
      return 0 == (t & (t - 1)) && 0 !== t;
    },
    ceilPowerOfTwo: function (t) {
      return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));
    },
    floorPowerOfTwo: function (t) {
      return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
    },
    compareFloat: function (t, e, n) {
      return n || (n = 1e-5), !(Math.abs(t - e) - n > 0);
    },
  };
  function dh(t) {
    console.warn(
      'THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.',
    ),
      Ha.call(this, t),
      (this.type = 'catmullrom');
  }
  (Oa.create = function (t, e) {
    return (
      console.log('THREE.Curve.create() has been deprecated'),
      (t.prototype = Object.create(Oa.prototype)),
      (t.prototype.constructor = t),
      (t.prototype.getPoint = e),
      t
    );
  }),
    Object.assign(nc.prototype, {
      createPointsGeometry: function (t) {
        console.warn(
          'THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.',
        );
        var e = this.getPoints(t);
        return this.createGeometry(e);
      },
      createSpacedPointsGeometry: function (t) {
        console.warn(
          'THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.',
        );
        var e = this.getSpacedPoints(t);
        return this.createGeometry(e);
      },
      createGeometry: function (t) {
        console.warn(
          'THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.',
        );
        for (var e = new bn(), n = 0, i = t.length; n < i; n++) {
          var r = t[n];
          e.vertices.push(new J(r.x, r.y, r.z || 0));
        }
        return e;
      },
    }),
    Object.assign(ic.prototype, {
      fromPoints: function (t) {
        return (
          console.warn(
            'THREE.Path: .fromPoints() has been renamed to .setFromPoints().',
          ),
          this.setFromPoints(t)
        );
      },
    }),
    (dh.prototype = Object.create(Ha.prototype)),
    Object.assign(dh.prototype, {
      initFromArray: function () {
        console.error('THREE.Spline: .initFromArray() has been removed.');
      },
      getControlPointsArray: function () {
        console.error(
          'THREE.Spline: .getControlPointsArray() has been removed.',
        );
      },
      reparametrizeByArcLength: function () {
        console.error(
          'THREE.Spline: .reparametrizeByArcLength() has been removed.',
        );
      },
    }),
    (Nl.prototype.setColors = function () {
      console.error(
        'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.',
      );
    }),
    (Rl.prototype.update = function () {
      console.error(
        'THREE.SkeletonHelper: update() no longer needs to be called.',
      );
    }),
    Object.assign(Ea.prototype, {
      extractUrlBase: function (t) {
        return (
          console.warn(
            'THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.',
          ),
          yc(t)
        );
      },
    }),
    (Ea.Handlers = {
      add: function () {
        console.error(
          'THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.',
        );
      },
      get: function () {
        console.error(
          'THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.',
        );
      },
    }),
    Object.assign(Ac.prototype, {
      setTexturePath: function (t) {
        return (
          console.warn(
            'THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().',
          ),
          this.setResourcePath(t)
        );
      },
    }),
    Object.assign(xl.prototype, {
      center: function (t) {
        return (
          console.warn(
            'THREE.Box2: .center() has been renamed to .getCenter().',
          ),
          this.getCenter(t)
        );
      },
      empty: function () {
        return (
          console.warn('THREE.Box2: .empty() has been renamed to .isEmpty().'),
          this.isEmpty()
        );
      },
      isIntersectionBox: function (t) {
        return (
          console.warn(
            'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().',
          ),
          this.intersectsBox(t)
        );
      },
      size: function (t) {
        return (
          console.warn('THREE.Box2: .size() has been renamed to .getSize().'),
          this.getSize(t)
        );
      },
    }),
    Object.assign(Nt.prototype, {
      center: function (t) {
        return (
          console.warn(
            'THREE.Box3: .center() has been renamed to .getCenter().',
          ),
          this.getCenter(t)
        );
      },
      empty: function () {
        return (
          console.warn('THREE.Box3: .empty() has been renamed to .isEmpty().'),
          this.isEmpty()
        );
      },
      isIntersectionBox: function (t) {
        return (
          console.warn(
            'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().',
          ),
          this.intersectsBox(t)
        );
      },
      isIntersectionSphere: function (t) {
        return (
          console.warn(
            'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().',
          ),
          this.intersectsSphere(t)
        );
      },
      size: function (t) {
        return (
          console.warn('THREE.Box3: .size() has been renamed to .getSize().'),
          this.getSize(t)
        );
      },
    }),
    (Ln.prototype.setFromMatrix = function (t) {
      return (
        console.warn(
          'THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().',
        ),
        this.setFromProjectionMatrix(t)
      );
    }),
    (Ml.prototype.center = function (t) {
      return (
        console.warn(
          'THREE.Line3: .center() has been renamed to .getCenter().',
        ),
        this.getCenter(t)
      );
    }),
    Object.assign(k, {
      random16: function () {
        return (
          console.warn(
            'THREE.Math: .random16() has been deprecated. Use Math.random() instead.',
          ),
          Math.random()
        );
      },
      nearestPowerOfTwo: function (t) {
        return (
          console.warn(
            'THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().',
          ),
          k.floorPowerOfTwo(t)
        );
      },
      nextPowerOfTwo: function (t) {
        return (
          console.warn(
            'THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().',
          ),
          k.ceilPowerOfTwo(t)
        );
      },
    }),
    Object.assign(G.prototype, {
      flattenToArrayOffset: function (t, e) {
        return (
          console.warn(
            'THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.',
          ),
          this.toArray(t, e)
        );
      },
      multiplyVector3: function (t) {
        return (
          console.warn(
            'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.',
          ),
          t.applyMatrix3(this)
        );
      },
      multiplyVector3Array: function () {
        console.error(
          'THREE.Matrix3: .multiplyVector3Array() has been removed.',
        );
      },
      applyToBufferAttribute: function (t) {
        return (
          console.warn(
            'THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.',
          ),
          t.applyMatrix3(this)
        );
      },
      applyToVector3Array: function () {
        console.error(
          'THREE.Matrix3: .applyToVector3Array() has been removed.',
        );
      },
    }),
    Object.assign(ot.prototype, {
      extractPosition: function (t) {
        return (
          console.warn(
            'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().',
          ),
          this.copyPosition(t)
        );
      },
      flattenToArrayOffset: function (t, e) {
        return (
          console.warn(
            'THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.',
          ),
          this.toArray(t, e)
        );
      },
      getPosition: function () {
        return (
          console.warn(
            'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.',
          ),
          new J().setFromMatrixColumn(this, 3)
        );
      },
      setRotationFromQuaternion: function (t) {
        return (
          console.warn(
            'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().',
          ),
          this.makeRotationFromQuaternion(t)
        );
      },
      multiplyToArray: function () {
        console.warn('THREE.Matrix4: .multiplyToArray() has been removed.');
      },
      multiplyVector3: function (t) {
        return (
          console.warn(
            'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.',
          ),
          t.applyMatrix4(this)
        );
      },
      multiplyVector4: function (t) {
        return (
          console.warn(
            'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.',
          ),
          t.applyMatrix4(this)
        );
      },
      multiplyVector3Array: function () {
        console.error(
          'THREE.Matrix4: .multiplyVector3Array() has been removed.',
        );
      },
      rotateAxis: function (t) {
        console.warn(
          'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.',
        ),
          t.transformDirection(this);
      },
      crossVector: function (t) {
        return (
          console.warn(
            'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.',
          ),
          t.applyMatrix4(this)
        );
      },
      translate: function () {
        console.error('THREE.Matrix4: .translate() has been removed.');
      },
      rotateX: function () {
        console.error('THREE.Matrix4: .rotateX() has been removed.');
      },
      rotateY: function () {
        console.error('THREE.Matrix4: .rotateY() has been removed.');
      },
      rotateZ: function () {
        console.error('THREE.Matrix4: .rotateZ() has been removed.');
      },
      rotateByAxis: function () {
        console.error('THREE.Matrix4: .rotateByAxis() has been removed.');
      },
      applyToBufferAttribute: function (t) {
        return (
          console.warn(
            'THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.',
          ),
          t.applyMatrix4(this)
        );
      },
      applyToVector3Array: function () {
        console.error(
          'THREE.Matrix4: .applyToVector3Array() has been removed.',
        );
      },
      makeFrustum: function (t, e, n, i, r, o) {
        return (
          console.warn(
            'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.',
          ),
          this.makePerspective(t, e, i, n, r, o)
        );
      },
    }),
    (Kt.prototype.isIntersectionLine = function (t) {
      return (
        console.warn(
          'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().',
        ),
        this.intersectsLine(t)
      );
    }),
    (Y.prototype.multiplyVector3 = function (t) {
      return (
        console.warn(
          'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.',
        ),
        t.applyQuaternion(this)
      );
    }),
    Object.assign(qt.prototype, {
      isIntersectionBox: function (t) {
        return (
          console.warn(
            'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().',
          ),
          this.intersectsBox(t)
        );
      },
      isIntersectionPlane: function (t) {
        return (
          console.warn(
            'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().',
          ),
          this.intersectsPlane(t)
        );
      },
      isIntersectionSphere: function (t) {
        return (
          console.warn(
            'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().',
          ),
          this.intersectsSphere(t)
        );
      },
    }),
    Object.assign(he.prototype, {
      area: function () {
        return (
          console.warn(
            'THREE.Triangle: .area() has been renamed to .getArea().',
          ),
          this.getArea()
        );
      },
      barycoordFromPoint: function (t, e) {
        return (
          console.warn(
            'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().',
          ),
          this.getBarycoord(t, e)
        );
      },
      midpoint: function (t) {
        return (
          console.warn(
            'THREE.Triangle: .midpoint() has been renamed to .getMidpoint().',
          ),
          this.getMidpoint(t)
        );
      },
      normal: function (t) {
        return (
          console.warn(
            'THREE.Triangle: .normal() has been renamed to .getNormal().',
          ),
          this.getNormal(t)
        );
      },
      plane: function (t) {
        return (
          console.warn(
            'THREE.Triangle: .plane() has been renamed to .getPlane().',
          ),
          this.getPlane(t)
        );
      },
    }),
    Object.assign(he, {
      barycoordFromPoint: function (t, e, n, i, r) {
        return (
          console.warn(
            'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().',
          ),
          he.getBarycoord(t, e, n, i, r)
        );
      },
      normal: function (t, e, n, i) {
        return (
          console.warn(
            'THREE.Triangle: .normal() has been renamed to .getNormal().',
          ),
          he.getNormal(t, e, n, i)
        );
      },
    }),
    Object.assign(rc.prototype, {
      extractAllPoints: function (t) {
        return (
          console.warn(
            'THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.',
          ),
          this.extractPoints(t)
        );
      },
      extrude: function (t) {
        return (
          console.warn(
            'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.',
          ),
          new Ds(this, t)
        );
      },
      makeGeometry: function (t) {
        return (
          console.warn(
            'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.',
          ),
          new Us(this, t)
        );
      },
    }),
    Object.assign(U.prototype, {
      fromAttribute: function (t, e, n) {
        return (
          console.warn(
            'THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().',
          ),
          this.fromBufferAttribute(t, e, n)
        );
      },
      distanceToManhattan: function (t) {
        return (
          console.warn(
            'THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().',
          ),
          this.manhattanDistanceTo(t)
        );
      },
      lengthManhattan: function () {
        return (
          console.warn(
            'THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().',
          ),
          this.manhattanLength()
        );
      },
    }),
    Object.assign(J.prototype, {
      setEulerFromRotationMatrix: function () {
        console.error(
          'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.',
        );
      },
      setEulerFromQuaternion: function () {
        console.error(
          'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.',
        );
      },
      getPositionFromMatrix: function (t) {
        return (
          console.warn(
            'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().',
          ),
          this.setFromMatrixPosition(t)
        );
      },
      getScaleFromMatrix: function (t) {
        return (
          console.warn(
            'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().',
          ),
          this.setFromMatrixScale(t)
        );
      },
      getColumnFromMatrix: function (t, e) {
        return (
          console.warn(
            'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().',
          ),
          this.setFromMatrixColumn(e, t)
        );
      },
      applyProjection: function (t) {
        return (
          console.warn(
            'THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.',
          ),
          this.applyMatrix4(t)
        );
      },
      fromAttribute: function (t, e, n) {
        return (
          console.warn(
            'THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().',
          ),
          this.fromBufferAttribute(t, e, n)
        );
      },
      distanceToManhattan: function (t) {
        return (
          console.warn(
            'THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().',
          ),
          this.manhattanDistanceTo(t)
        );
      },
      lengthManhattan: function () {
        return (
          console.warn(
            'THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().',
          ),
          this.manhattanLength()
        );
      },
    }),
    Object.assign(W.prototype, {
      fromAttribute: function (t, e, n) {
        return (
          console.warn(
            'THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().',
          ),
          this.fromBufferAttribute(t, e, n)
        );
      },
      lengthManhattan: function () {
        return (
          console.warn(
            'THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().',
          ),
          this.manhattanLength()
        );
      },
    }),
    Object.assign(bn.prototype, {
      computeTangents: function () {
        console.error('THREE.Geometry: .computeTangents() has been removed.');
      },
      computeLineDistances: function () {
        console.error(
          'THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.',
        );
      },
      applyMatrix: function (t) {
        return (
          console.warn(
            'THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().',
          ),
          this.applyMatrix4(t)
        );
      },
    }),
    Object.assign(At.prototype, {
      getChildByName: function (t) {
        return (
          console.warn(
            'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().',
          ),
          this.getObjectByName(t)
        );
      },
      renderDepth: function () {
        console.warn(
          'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.',
        );
      },
      translate: function (t, e) {
        return (
          console.warn(
            'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.',
          ),
          this.translateOnAxis(e, t)
        );
      },
      getWorldRotation: function () {
        console.error(
          'THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.',
        );
      },
      applyMatrix: function (t) {
        return (
          console.warn(
            'THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().',
          ),
          this.applyMatrix4(t)
        );
      },
    }),
    Object.defineProperties(At.prototype, {
      eulerOrder: {
        get: function () {
          return (
            console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.'),
            this.rotation.order
          );
        },
        set: function (t) {
          console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.'),
            (this.rotation.order = t);
        },
      },
      useQuaternion: {
        get: function () {
          console.warn(
            'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.',
          );
        },
        set: function () {
          console.warn(
            'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.',
          );
        },
      },
    }),
    Object.assign(ln.prototype, {
      setDrawMode: function () {
        console.error(
          'THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.',
        );
      },
    }),
    Object.defineProperties(ln.prototype, {
      drawMode: {
        get: function () {
          return (
            console.error(
              'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.',
            ),
            0
          );
        },
        set: function () {
          console.error(
            'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.',
          );
        },
      },
    }),
    Object.defineProperties(ro.prototype, {
      objects: {
        get: function () {
          return (
            console.warn('THREE.LOD: .objects has been renamed to .levels.'),
            this.levels
          );
        },
      },
    }),
    Object.defineProperty(co.prototype, 'useVertexTexture', {
      get: function () {
        console.warn('THREE.Skeleton: useVertexTexture has been removed.');
      },
      set: function () {
        console.warn('THREE.Skeleton: useVertexTexture has been removed.');
      },
    }),
    (oo.prototype.initBones = function () {
      console.error('THREE.SkinnedMesh: initBones() has been removed.');
    }),
    Object.defineProperty(Oa.prototype, '__arcLengthDivisions', {
      get: function () {
        return (
          console.warn(
            'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.',
          ),
          this.arcLengthDivisions
        );
      },
      set: function (t) {
        console.warn(
          'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.',
        ),
          (this.arcLengthDivisions = t);
      },
    }),
    (Mn.prototype.setLens = function (t, e) {
      console.warn(
        'THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.',
      ),
        void 0 !== e && (this.filmGauge = e),
        this.setFocalLength(t);
    }),
    Object.defineProperties(oc.prototype, {
      onlyShadow: {
        set: function () {
          console.warn('THREE.Light: .onlyShadow has been removed.');
        },
      },
      shadowCameraFov: {
        set: function (t) {
          console.warn(
            'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.',
          ),
            (this.shadow.camera.fov = t);
        },
      },
      shadowCameraLeft: {
        set: function (t) {
          console.warn(
            'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.',
          ),
            (this.shadow.camera.left = t);
        },
      },
      shadowCameraRight: {
        set: function (t) {
          console.warn(
            'THREE.Light: .shadowCameraRight is now .shadow.camera.right.',
          ),
            (this.shadow.camera.right = t);
        },
      },
      shadowCameraTop: {
        set: function (t) {
          console.warn(
            'THREE.Light: .shadowCameraTop is now .shadow.camera.top.',
          ),
            (this.shadow.camera.top = t);
        },
      },
      shadowCameraBottom: {
        set: function (t) {
          console.warn(
            'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.',
          ),
            (this.shadow.camera.bottom = t);
        },
      },
      shadowCameraNear: {
        set: function (t) {
          console.warn(
            'THREE.Light: .shadowCameraNear is now .shadow.camera.near.',
          ),
            (this.shadow.camera.near = t);
        },
      },
      shadowCameraFar: {
        set: function (t) {
          console.warn(
            'THREE.Light: .shadowCameraFar is now .shadow.camera.far.',
          ),
            (this.shadow.camera.far = t);
        },
      },
      shadowCameraVisible: {
        set: function () {
          console.warn(
            'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.',
          );
        },
      },
      shadowBias: {
        set: function (t) {
          console.warn('THREE.Light: .shadowBias is now .shadow.bias.'),
            (this.shadow.bias = t);
        },
      },
      shadowDarkness: {
        set: function () {
          console.warn('THREE.Light: .shadowDarkness has been removed.');
        },
      },
      shadowMapWidth: {
        set: function (t) {
          console.warn(
            'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.',
          ),
            (this.shadow.mapSize.width = t);
        },
      },
      shadowMapHeight: {
        set: function (t) {
          console.warn(
            'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.',
          ),
            (this.shadow.mapSize.height = t);
        },
      },
    }),
    Object.defineProperties(Ae.prototype, {
      length: {
        get: function () {
          return (
            console.warn(
              'THREE.BufferAttribute: .length has been deprecated. Use .count instead.',
            ),
            this.array.length
          );
        },
      },
      dynamic: {
        get: function () {
          return (
            console.warn(
              'THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.',
            ),
            this.usage === P
          );
        },
        set: function () {
          console.warn(
            'THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.',
          ),
            this.setUsage(P);
        },
      },
    }),
    Object.assign(Ae.prototype, {
      setDynamic: function (t) {
        return (
          console.warn(
            'THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.',
          ),
          this.setUsage(!0 === t ? P : F),
          this
        );
      },
      copyIndicesArray: function () {
        console.error(
          'THREE.BufferAttribute: .copyIndicesArray() has been removed.',
        );
      },
      setArray: function () {
        console.error(
          'THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers',
        );
      },
    }),
    Object.assign(He.prototype, {
      addIndex: function (t) {
        console.warn(
          'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().',
        ),
          this.setIndex(t);
      },
      addAttribute: function (t, e) {
        return (
          console.warn(
            'THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().',
          ),
          (e && e.isBufferAttribute) || (e && e.isInterleavedBufferAttribute)
            ? 'index' === t
              ? (console.warn(
                  'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.',
                ),
                this.setIndex(e),
                this)
              : this.setAttribute(t, e)
            : (console.warn(
                'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).',
              ),
              this.setAttribute(t, new Ae(arguments[1], arguments[2])))
        );
      },
      addDrawCall: function (t, e, n) {
        void 0 !== n &&
          console.warn(
            'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.',
          ),
          console.warn(
            'THREE.BufferGeometry: .addDrawCall() is now .addGroup().',
          ),
          this.addGroup(t, e);
      },
      clearDrawCalls: function () {
        console.warn(
          'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().',
        ),
          this.clearGroups();
      },
      computeTangents: function () {
        console.warn(
          'THREE.BufferGeometry: .computeTangents() has been removed.',
        );
      },
      computeOffsets: function () {
        console.warn(
          'THREE.BufferGeometry: .computeOffsets() has been removed.',
        );
      },
      removeAttribute: function (t) {
        return (
          console.warn(
            'THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().',
          ),
          this.deleteAttribute(t)
        );
      },
      applyMatrix: function (t) {
        return (
          console.warn(
            'THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().',
          ),
          this.applyMatrix4(t)
        );
      },
    }),
    Object.defineProperties(He.prototype, {
      drawcalls: {
        get: function () {
          return (
            console.error(
              'THREE.BufferGeometry: .drawcalls has been renamed to .groups.',
            ),
            this.groups
          );
        },
      },
      offsets: {
        get: function () {
          return (
            console.warn(
              'THREE.BufferGeometry: .offsets has been renamed to .groups.',
            ),
            this.groups
          );
        },
      },
    }),
    Object.defineProperties(gl.prototype, {
      linePrecision: {
        get: function () {
          return (
            console.warn(
              'THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.',
            ),
            this.params.Line.threshold
          );
        },
        set: function (t) {
          console.warn(
            'THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.',
          ),
            (this.params.Line.threshold = t);
        },
      },
    }),
    Object.defineProperties(Vr.prototype, {
      dynamic: {
        get: function () {
          return (
            console.warn(
              'THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.',
            ),
            this.usage === P
          );
        },
        set: function (t) {
          console.warn(
            'THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.',
          ),
            this.setUsage(t);
        },
      },
    }),
    Object.assign(Vr.prototype, {
      setDynamic: function (t) {
        return (
          console.warn(
            'THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.',
          ),
          this.setUsage(!0 === t ? P : F),
          this
        );
      },
      setArray: function () {
        console.error(
          'THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers',
        );
      },
    }),
    Object.assign(Cs.prototype, {
      getArrays: function () {
        console.error(
          'THREE.ExtrudeBufferGeometry: .getArrays() has been removed.',
        );
      },
      addShapeList: function () {
        console.error(
          'THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.',
        );
      },
      addShape: function () {
        console.error(
          'THREE.ExtrudeBufferGeometry: .addShape() has been removed.',
        );
      },
    }),
    Object.defineProperties(ml.prototype, {
      dynamic: {
        set: function () {
          console.warn(
            'THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.',
          );
        },
      },
      onUpdate: {
        value: function () {
          return (
            console.warn(
              'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.',
            ),
            this
          );
        },
      },
    }),
    Object.defineProperties(_e.prototype, {
      wrapAround: {
        get: function () {
          console.warn('THREE.Material: .wrapAround has been removed.');
        },
        set: function () {
          console.warn('THREE.Material: .wrapAround has been removed.');
        },
      },
      overdraw: {
        get: function () {
          console.warn('THREE.Material: .overdraw has been removed.');
        },
        set: function () {
          console.warn('THREE.Material: .overdraw has been removed.');
        },
      },
      wrapRGB: {
        get: function () {
          return (
            console.warn('THREE.Material: .wrapRGB has been removed.'), new fe()
          );
        },
      },
      shading: {
        get: function () {
          console.error(
            'THREE.' +
              this.type +
              ': .shading has been removed. Use the boolean .flatShading instead.',
          );
        },
        set: function (t) {
          console.warn(
            'THREE.' +
              this.type +
              ': .shading has been removed. Use the boolean .flatShading instead.',
          ),
            (this.flatShading = 1 === t);
        },
      },
      stencilMask: {
        get: function () {
          return (
            console.warn(
              'THREE.' +
                this.type +
                ': .stencilMask has been removed. Use .stencilFuncMask instead.',
            ),
            this.stencilFuncMask
          );
        },
        set: function (t) {
          console.warn(
            'THREE.' +
              this.type +
              ': .stencilMask has been removed. Use .stencilFuncMask instead.',
          ),
            (this.stencilFuncMask = t);
        },
      },
    }),
    Object.defineProperties(ea.prototype, {
      metal: {
        get: function () {
          return (
            console.warn(
              'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.',
            ),
            !1
          );
        },
        set: function () {
          console.warn(
            'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead',
          );
        },
      },
    }),
    Object.defineProperties(wn.prototype, {
      derivatives: {
        get: function () {
          return (
            console.warn(
              'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.',
            ),
            this.extensions.derivatives
          );
        },
        set: function (t) {
          console.warn(
            'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.',
          ),
            (this.extensions.derivatives = t);
        },
      },
    }),
    Object.assign(Pr.prototype, {
      clearTarget: function (t, e, n, i) {
        console.warn(
          'THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.',
        ),
          this.setRenderTarget(t),
          this.clear(e, n, i);
      },
      animate: function (t) {
        console.warn(
          'THREE.WebGLRenderer: .animate() is now .setAnimationLoop().',
        ),
          this.setAnimationLoop(t);
      },
      getCurrentRenderTarget: function () {
        return (
          console.warn(
            'THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().',
          ),
          this.getRenderTarget()
        );
      },
      getMaxAnisotropy: function () {
        return (
          console.warn(
            'THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().',
          ),
          this.capabilities.getMaxAnisotropy()
        );
      },
      getPrecision: function () {
        return (
          console.warn(
            'THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.',
          ),
          this.capabilities.precision
        );
      },
      resetGLState: function () {
        return (
          console.warn(
            'THREE.WebGLRenderer: .resetGLState() is now .state.reset().',
          ),
          this.state.reset()
        );
      },
      supportsFloatTextures: function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).",
          ),
          this.extensions.get('OES_texture_float')
        );
      },
      supportsHalfFloatTextures: function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).",
          ),
          this.extensions.get('OES_texture_half_float')
        );
      },
      supportsStandardDerivatives: function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).",
          ),
          this.extensions.get('OES_standard_derivatives')
        );
      },
      supportsCompressedTextureS3TC: function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).",
          ),
          this.extensions.get('WEBGL_compressed_texture_s3tc')
        );
      },
      supportsCompressedTexturePVRTC: function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' ).",
          ),
          this.extensions.get('WEBGL_compressed_texture_pvrtc')
        );
      },
      supportsBlendMinMax: function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).",
          ),
          this.extensions.get('EXT_blend_minmax')
        );
      },
      supportsVertexTextures: function () {
        return (
          console.warn(
            'THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.',
          ),
          this.capabilities.vertexTextures
        );
      },
      supportsInstancedArrays: function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).",
          ),
          this.extensions.get('ANGLE_instanced_arrays')
        );
      },
      enableScissorTest: function (t) {
        console.warn(
          'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().',
        ),
          this.setScissorTest(t);
      },
      initMaterial: function () {
        console.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');
      },
      addPrePlugin: function () {
        console.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');
      },
      addPostPlugin: function () {
        console.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');
      },
      updateShadowMap: function () {
        console.warn(
          'THREE.WebGLRenderer: .updateShadowMap() has been removed.',
        );
      },
      setFaceCulling: function () {
        console.warn(
          'THREE.WebGLRenderer: .setFaceCulling() has been removed.',
        );
      },
      allocTextureUnit: function () {
        console.warn(
          'THREE.WebGLRenderer: .allocTextureUnit() has been removed.',
        );
      },
      setTexture: function () {
        console.warn('THREE.WebGLRenderer: .setTexture() has been removed.');
      },
      setTexture2D: function () {
        console.warn('THREE.WebGLRenderer: .setTexture2D() has been removed.');
      },
      setTextureCube: function () {
        console.warn(
          'THREE.WebGLRenderer: .setTextureCube() has been removed.',
        );
      },
      getActiveMipMapLevel: function () {
        return (
          console.warn(
            'THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().',
          ),
          this.getActiveMipmapLevel()
        );
      },
    }),
    Object.defineProperties(Pr.prototype, {
      shadowMapEnabled: {
        get: function () {
          return this.shadowMap.enabled;
        },
        set: function (t) {
          console.warn(
            'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.',
          ),
            (this.shadowMap.enabled = t);
        },
      },
      shadowMapType: {
        get: function () {
          return this.shadowMap.type;
        },
        set: function (t) {
          console.warn(
            'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.',
          ),
            (this.shadowMap.type = t);
        },
      },
      shadowMapCullFace: {
        get: function () {
          console.warn(
            'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.',
          );
        },
        set: function () {
          console.warn(
            'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.',
          );
        },
      },
      context: {
        get: function () {
          return (
            console.warn(
              'THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.',
            ),
            this.getContext()
          );
        },
      },
      vr: {
        get: function () {
          return (
            console.warn('THREE.WebGLRenderer: .vr has been renamed to .xr'),
            this.xr
          );
        },
      },
      gammaInput: {
        get: function () {
          return (
            console.warn(
              'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.',
            ),
            !1
          );
        },
        set: function () {
          console.warn(
            'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.',
          );
        },
      },
      gammaOutput: {
        get: function () {
          return (
            console.warn(
              'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.',
            ),
            !1
          );
        },
        set: function (t) {
          console.warn(
            'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.',
          ),
            (this.outputEncoding = !0 === t ? L : T);
        },
      },
    }),
    Object.defineProperties(Er.prototype, {
      cullFace: {
        get: function () {
          console.warn(
            'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.',
          );
        },
        set: function () {
          console.warn(
            'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.',
          );
        },
      },
      renderReverseSided: {
        get: function () {
          console.warn(
            'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.',
          );
        },
        set: function () {
          console.warn(
            'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.',
          );
        },
      },
      renderSingleSided: {
        get: function () {
          console.warn(
            'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.',
          );
        },
        set: function () {
          console.warn(
            'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.',
          );
        },
      },
    }),
    Object.defineProperties(X.prototype, {
      wrapS: {
        get: function () {
          return (
            console.warn(
              'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.',
            ),
            this.texture.wrapS
          );
        },
        set: function (t) {
          console.warn(
            'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.',
          ),
            (this.texture.wrapS = t);
        },
      },
      wrapT: {
        get: function () {
          return (
            console.warn(
              'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.',
            ),
            this.texture.wrapT
          );
        },
        set: function (t) {
          console.warn(
            'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.',
          ),
            (this.texture.wrapT = t);
        },
      },
      magFilter: {
        get: function () {
          return (
            console.warn(
              'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.',
            ),
            this.texture.magFilter
          );
        },
        set: function (t) {
          console.warn(
            'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.',
          ),
            (this.texture.magFilter = t);
        },
      },
      minFilter: {
        get: function () {
          return (
            console.warn(
              'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.',
            ),
            this.texture.minFilter
          );
        },
        set: function (t) {
          console.warn(
            'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.',
          ),
            (this.texture.minFilter = t);
        },
      },
      anisotropy: {
        get: function () {
          return (
            console.warn(
              'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.',
            ),
            this.texture.anisotropy
          );
        },
        set: function (t) {
          console.warn(
            'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.',
          ),
            (this.texture.anisotropy = t);
        },
      },
      offset: {
        get: function () {
          return (
            console.warn(
              'THREE.WebGLRenderTarget: .offset is now .texture.offset.',
            ),
            this.texture.offset
          );
        },
        set: function (t) {
          console.warn(
            'THREE.WebGLRenderTarget: .offset is now .texture.offset.',
          ),
            (this.texture.offset = t);
        },
      },
      repeat: {
        get: function () {
          return (
            console.warn(
              'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.',
            ),
            this.texture.repeat
          );
        },
        set: function (t) {
          console.warn(
            'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.',
          ),
            (this.texture.repeat = t);
        },
      },
      format: {
        get: function () {
          return (
            console.warn(
              'THREE.WebGLRenderTarget: .format is now .texture.format.',
            ),
            this.texture.format
          );
        },
        set: function (t) {
          console.warn(
            'THREE.WebGLRenderTarget: .format is now .texture.format.',
          ),
            (this.texture.format = t);
        },
      },
      type: {
        get: function () {
          return (
            console.warn(
              'THREE.WebGLRenderTarget: .type is now .texture.type.',
            ),
            this.texture.type
          );
        },
        set: function (t) {
          console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.'),
            (this.texture.type = t);
        },
      },
      generateMipmaps: {
        get: function () {
          return (
            console.warn(
              'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.',
            ),
            this.texture.generateMipmaps
          );
        },
        set: function (t) {
          console.warn(
            'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.',
          ),
            (this.texture.generateMipmaps = t);
        },
      },
    }),
    Object.defineProperties(Zc.prototype, {
      load: {
        value: function (t) {
          console.warn(
            'THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.',
          );
          var e = this;
          return (
            new Pc().load(t, function (t) {
              e.setBuffer(t);
            }),
            this
          );
        },
      },
      startTime: {
        set: function () {
          console.warn('THREE.Audio: .startTime is now .play( delay ).');
        },
      },
    }),
    (Kc.prototype.getData = function () {
      return (
        console.warn(
          'THREE.AudioAnalyser: .getData() is now .getFrequencyData().',
        ),
        this.getFrequencyData()
      );
    }),
    (In.prototype.updateCubeMap = function (t, e) {
      return (
        console.warn('THREE.CubeCamera: .updateCubeMap() is now .update().'),
        this.update(t, e)
      );
    }),
    (z.crossOrigin = void 0),
    (z.loadTexture = function (t, e, n, i) {
      console.warn(
        'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.',
      );
      var r = new Ba();
      r.setCrossOrigin(this.crossOrigin);
      var o = r.load(t, n, void 0, i);
      return e && (o.mapping = e), o;
    }),
    (z.loadTextureCube = function (t, e, n, i) {
      console.warn(
        'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.',
      );
      var r = new Pa();
      r.setCrossOrigin(this.crossOrigin);
      var o = r.load(t, n, void 0, i);
      return e && (o.mapping = e), o;
    }),
    (z.loadCompressedTexture = function () {
      console.error(
        'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.',
      );
    }),
    (z.loadCompressedTextureCube = function () {
      console.error(
        'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.',
      );
    }),
    'undefined' != typeof __THREE_DEVTOOLS__ &&
      __THREE_DEVTOOLS__.dispatchEvent(
        new CustomEvent('register', { detail: { revision: '115' } }),
      );
  var ph,
    fh,
    mh,
    bh,
    gh = {},
    yh = [],
    vh = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
  function _h(t, e) {
    for (var n in e) t[n] = e[n];
    return t;
  }
  function xh(t) {
    var e = t.parentNode;
    e && e.removeChild(t);
  }
  function wh(t, e, n) {
    var i,
      r,
      o,
      s = arguments,
      a = {};
    for (o in e)
      'key' == o ? (i = e[o]) : 'ref' == o ? (r = e[o]) : (a[o] = e[o]);
    if (arguments.length > 3)
      for (n = [n], o = 3; o < arguments.length; o++) n.push(s[o]);
    if (
      (null != n && (a.children = n),
      'function' == typeof t && null != t.defaultProps)
    )
      for (o in t.defaultProps) void 0 === a[o] && (a[o] = t.defaultProps[o]);
    return Ah(t, a, i, r, null);
  }
  function Ah(t, e, n, i, r) {
    var o = {
      type: t,
      props: e,
      key: n,
      ref: i,
      __k: null,
      __: null,
      __b: 0,
      __e: null,
      __d: void 0,
      __c: null,
      __h: null,
      constructor: void 0,
      __v: null == r ? ++ph.__v : r,
    };
    return null != ph.vnode && ph.vnode(o), o;
  }
  function Mh(t) {
    return t.children;
  }
  function Sh(t, e) {
    (this.props = t), (this.context = e);
  }
  function Ih(t, e) {
    if (null == e) return t.__ ? Ih(t.__, t.__.__k.indexOf(t) + 1) : null;
    for (var n; e < t.__k.length; e++)
      if (null != (n = t.__k[e]) && null != n.__e) return n.__e;
    return 'function' == typeof t.type ? Ih(t) : null;
  }
  function Eh(t) {
    var e, n;
    if (null != (t = t.__) && null != t.__c) {
      for (t.__e = t.__c.base = null, e = 0; e < t.__k.length; e++)
        if (null != (n = t.__k[e]) && null != n.__e) {
          t.__e = t.__c.base = n.__e;
          break;
        }
      return Eh(t);
    }
  }
  function Dh(t) {
    ((!t.__d && (t.__d = !0) && fh.push(t) && !Ch.__r++) ||
      bh !== ph.debounceRendering) &&
      ((bh = ph.debounceRendering) || mh)(Ch);
  }
  function Ch() {
    for (var t; (Ch.__r = fh.length); )
      (t = fh.sort(function (t, e) {
        return t.__v.__b - e.__v.__b;
      })),
        (fh = []),
        t.some(function (t) {
          var e, n, i, r, o, s;
          t.__d &&
            ((o = (r = (e = t).__v).__e),
            (s = e.__P) &&
              ((n = []),
              ((i = _h({}, r)).__v = r.__v + 1),
              Vh(
                s,
                r,
                i,
                e.__n,
                void 0 !== s.ownerSVGElement,
                null != r.__h ? [o] : null,
                n,
                null == o ? Ih(r) : o,
                r.__h,
              ),
              Nh(n, r),
              r.__e != o && Eh(r)));
        });
  }
  function Th(t, e, n, i, r, o, s, a, c, l) {
    var h,
      u,
      d,
      p,
      f,
      m,
      b,
      g = (i && i.__k) || yh,
      y = g.length;
    for (n.__k = [], h = 0; h < e.length; h++)
      if (
        null !=
        (p = n.__k[h] =
          null == (p = e[h]) || 'boolean' == typeof p
            ? null
            : 'string' == typeof p ||
              'number' == typeof p ||
              'bigint' == typeof p
            ? Ah(null, p, null, null, p)
            : Array.isArray(p)
            ? Ah(Mh, { children: p }, null, null, null)
            : p.__b > 0
            ? Ah(p.type, p.props, p.key, null, p.__v)
            : p)
      ) {
        if (
          ((p.__ = n),
          (p.__b = n.__b + 1),
          null === (d = g[h]) || (d && p.key == d.key && p.type === d.type))
        )
          g[h] = void 0;
        else
          for (u = 0; u < y; u++) {
            if ((d = g[u]) && p.key == d.key && p.type === d.type) {
              g[u] = void 0;
              break;
            }
            d = null;
          }
        Vh(t, p, (d = d || gh), r, o, s, a, c, l),
          (f = p.__e),
          (u = p.ref) &&
            d.ref != u &&
            (b || (b = []),
            d.ref && b.push(d.ref, null, p),
            b.push(u, p.__c || f, p)),
          null != f
            ? (null == m && (m = f),
              'function' == typeof p.type && null != p.__k && p.__k === d.__k
                ? (p.__d = c = Lh(p, c, t))
                : (c = Rh(t, p, d, g, f, c)),
              l || 'option' !== n.type
                ? 'function' == typeof n.type && (n.__d = c)
                : (t.value = ''))
            : c && d.__e == c && c.parentNode != t && (c = Ih(d));
      }
    for (n.__e = m, h = y; h--; )
      null != g[h] &&
        ('function' == typeof n.type &&
          null != g[h].__e &&
          g[h].__e == n.__d &&
          (n.__d = Ih(i, h + 1)),
        Gh(g[h], g[h]));
    if (b) for (h = 0; h < b.length; h++) Uh(b[h], b[++h], b[++h]);
  }
  function Lh(t, e, n) {
    var i, r;
    for (i = 0; i < t.__k.length; i++)
      (r = t.__k[i]) &&
        ((r.__ = t),
        (e =
          'function' == typeof r.type
            ? Lh(r, e, n)
            : Rh(n, r, r, t.__k, r.__e, e)));
    return e;
  }
  function Rh(t, e, n, i, r, o) {
    var s, a, c;
    if (void 0 !== e.__d) (s = e.__d), (e.__d = void 0);
    else if (null == n || r != o || null == r.parentNode)
      t: if (null == o || o.parentNode !== t) t.appendChild(r), (s = null);
      else {
        for (a = o, c = 0; (a = a.nextSibling) && c < i.length; c += 2)
          if (a == r) break t;
        t.insertBefore(r, o), (s = o);
      }
    return void 0 !== s ? s : r.nextSibling;
  }
  function Fh(t, e, n) {
    '-' === e[0]
      ? t.setProperty(e, n)
      : (t[e] =
          null == n ? '' : 'number' != typeof n || vh.test(e) ? n : n + 'px');
  }
  function Ph(t, e, n, i, r) {
    var o;
    t: if ('style' === e)
      if ('string' == typeof n) t.style.cssText = n;
      else {
        if (('string' == typeof i && (t.style.cssText = i = ''), i))
          for (e in i) (n && e in n) || Fh(t.style, e, '');
        if (n) for (e in n) (i && n[e] === i[e]) || Fh(t.style, e, n[e]);
      }
    else if ('o' === e[0] && 'n' === e[1])
      (o = e !== (e = e.replace(/Capture$/, ''))),
        (e = e.toLowerCase() in t ? e.toLowerCase().slice(2) : e.slice(2)),
        t.l || (t.l = {}),
        (t.l[e + o] = n),
        n
          ? i || t.addEventListener(e, o ? Oh : Bh, o)
          : t.removeEventListener(e, o ? Oh : Bh, o);
    else if ('dangerouslySetInnerHTML' !== e) {
      if (r) e = e.replace(/xlink[H:h]/, 'h').replace(/sName$/, 's');
      else if (
        'href' !== e &&
        'list' !== e &&
        'form' !== e &&
        'tabIndex' !== e &&
        'download' !== e &&
        e in t
      )
        try {
          t[e] = null == n ? '' : n;
          break t;
        } catch (t) {}
      'function' == typeof n ||
        (null != n && (!1 !== n || ('a' === e[0] && 'r' === e[1]))
          ? t.setAttribute(e, n)
          : t.removeAttribute(e));
    }
  }
  function Bh(t) {
    this.l[t.type + !1](ph.event ? ph.event(t) : t);
  }
  function Oh(t) {
    this.l[t.type + !0](ph.event ? ph.event(t) : t);
  }
  function Vh(t, e, n, i, r, o, s, a, c) {
    var l,
      h,
      u,
      d,
      p,
      f,
      m,
      b,
      g,
      y,
      v,
      _ = e.type;
    if (void 0 !== e.constructor) return null;
    null != n.__h &&
      ((c = n.__h), (a = e.__e = n.__e), (e.__h = null), (o = [a])),
      (l = ph.__b) && l(e);
    try {
      t: if ('function' == typeof _) {
        if (
          ((b = e.props),
          (g = (l = _.contextType) && i[l.__c]),
          (y = l ? (g ? g.props.value : l.__) : i),
          n.__c
            ? (m = (h = e.__c = n.__c).__ = h.__E)
            : ('prototype' in _ && _.prototype.render
                ? (e.__c = h = new _(b, y))
                : ((e.__c = h = new Sh(b, y)),
                  (h.constructor = _),
                  (h.render = zh)),
              g && g.sub(h),
              (h.props = b),
              h.state || (h.state = {}),
              (h.context = y),
              (h.__n = i),
              (u = h.__d = !0),
              (h.__h = [])),
          null == h.__s && (h.__s = h.state),
          null != _.getDerivedStateFromProps &&
            (h.__s == h.state && (h.__s = _h({}, h.__s)),
            _h(h.__s, _.getDerivedStateFromProps(b, h.__s))),
          (d = h.props),
          (p = h.state),
          u)
        )
          null == _.getDerivedStateFromProps &&
            null != h.componentWillMount &&
            h.componentWillMount(),
            null != h.componentDidMount && h.__h.push(h.componentDidMount);
        else {
          if (
            (null == _.getDerivedStateFromProps &&
              b !== d &&
              null != h.componentWillReceiveProps &&
              h.componentWillReceiveProps(b, y),
            (!h.__e &&
              null != h.shouldComponentUpdate &&
              !1 === h.shouldComponentUpdate(b, h.__s, y)) ||
              e.__v === n.__v)
          ) {
            (h.props = b),
              (h.state = h.__s),
              e.__v !== n.__v && (h.__d = !1),
              (h.__v = e),
              (e.__e = n.__e),
              (e.__k = n.__k),
              e.__k.forEach(function (t) {
                t && (t.__ = e);
              }),
              h.__h.length && s.push(h);
            break t;
          }
          null != h.componentWillUpdate && h.componentWillUpdate(b, h.__s, y),
            null != h.componentDidUpdate &&
              h.__h.push(function () {
                h.componentDidUpdate(d, p, f);
              });
        }
        (h.context = y),
          (h.props = b),
          (h.state = h.__s),
          (l = ph.__r) && l(e),
          (h.__d = !1),
          (h.__v = e),
          (h.__P = t),
          (l = h.render(h.props, h.state, h.context)),
          (h.state = h.__s),
          null != h.getChildContext && (i = _h(_h({}, i), h.getChildContext())),
          u ||
            null == h.getSnapshotBeforeUpdate ||
            (f = h.getSnapshotBeforeUpdate(d, p)),
          (v =
            null != l && l.type === Mh && null == l.key ? l.props.children : l),
          Th(t, Array.isArray(v) ? v : [v], e, n, i, r, o, s, a, c),
          (h.base = e.__e),
          (e.__h = null),
          h.__h.length && s.push(h),
          m && (h.__E = h.__ = null),
          (h.__e = !1);
      } else null == o && e.__v === n.__v ? ((e.__k = n.__k), (e.__e = n.__e)) : (e.__e = kh(n.__e, e, n, i, r, o, s, c));
      (l = ph.diffed) && l(e);
    } catch (t) {
      (e.__v = null),
        (c || null != o) &&
          ((e.__e = a), (e.__h = !!c), (o[o.indexOf(a)] = null)),
        ph.__e(t, e, n);
    }
  }
  function Nh(t, e) {
    ph.__c && ph.__c(e, t),
      t.some(function (e) {
        try {
          (t = e.__h),
            (e.__h = []),
            t.some(function (t) {
              t.call(e);
            });
        } catch (t) {
          ph.__e(t, e.__v);
        }
      });
  }
  function kh(t, e, n, i, r, o, s, a) {
    var c,
      l,
      h,
      u,
      d = n.props,
      p = e.props,
      f = e.type,
      m = 0;
    if (('svg' === f && (r = !0), null != o))
      for (; m < o.length; m++)
        if (
          (c = o[m]) &&
          (c === t || (f ? c.localName == f : 3 == c.nodeType))
        ) {
          (t = c), (o[m] = null);
          break;
        }
    if (null == t) {
      if (null === f) return document.createTextNode(p);
      (t = r
        ? document.createElementNS('http://www.w3.org/2000/svg', f)
        : document.createElement(f, p.is && p)),
        (o = null),
        (a = !1);
    }
    if (null === f) d === p || (a && t.data === p) || (t.data = p);
    else {
      if (
        ((o = o && yh.slice.call(t.childNodes)),
        (l = (d = n.props || gh).dangerouslySetInnerHTML),
        (h = p.dangerouslySetInnerHTML),
        !a)
      ) {
        if (null != o)
          for (d = {}, u = 0; u < t.attributes.length; u++)
            d[t.attributes[u].name] = t.attributes[u].value;
        (h || l) &&
          ((h && ((l && h.__html == l.__html) || h.__html === t.innerHTML)) ||
            (t.innerHTML = (h && h.__html) || ''));
      }
      if (
        ((function (t, e, n, i, r) {
          var o;
          for (o in n)
            'children' === o ||
              'key' === o ||
              o in e ||
              Ph(t, o, null, n[o], i);
          for (o in e)
            (r && 'function' != typeof e[o]) ||
              'children' === o ||
              'key' === o ||
              'value' === o ||
              'checked' === o ||
              n[o] === e[o] ||
              Ph(t, o, e[o], n[o], i);
        })(t, p, d, r, a),
        h)
      )
        e.__k = [];
      else if (
        ((m = e.props.children),
        Th(
          t,
          Array.isArray(m) ? m : [m],
          e,
          n,
          i,
          r && 'foreignObject' !== f,
          o,
          s,
          t.firstChild,
          a,
        ),
        null != o)
      )
        for (m = o.length; m--; ) null != o[m] && xh(o[m]);
      a ||
        ('value' in p &&
          void 0 !== (m = p.value) &&
          (m !== t.value || ('progress' === f && !m)) &&
          Ph(t, 'value', m, d.value, !1),
        'checked' in p &&
          void 0 !== (m = p.checked) &&
          m !== t.checked &&
          Ph(t, 'checked', m, d.checked, !1));
    }
    return t;
  }
  function Uh(t, e, n) {
    try {
      'function' == typeof t ? t(e) : (t.current = e);
    } catch (t) {
      ph.__e(t, n);
    }
  }
  function Gh(t, e, n) {
    var i, r, o;
    if (
      (ph.unmount && ph.unmount(t),
      (i = t.ref) && ((i.current && i.current !== t.__e) || Uh(i, null, e)),
      n || 'function' == typeof t.type || (n = null != (r = t.__e)),
      (t.__e = t.__d = void 0),
      null != (i = t.__c))
    ) {
      if (i.componentWillUnmount)
        try {
          i.componentWillUnmount();
        } catch (t) {
          ph.__e(t, e);
        }
      i.base = i.__P = null;
    }
    if ((i = t.__k)) for (o = 0; o < i.length; o++) i[o] && Gh(i[o], e, n);
    null != r && xh(r);
  }
  function zh(t, e, n) {
    return this.constructor(t, n);
  }
  function jh(t, e, n) {
    var i, r, o;
    ph.__ && ph.__(t, e),
      (r = (i = 'function' == typeof n) ? null : (n && n.__k) || e.__k),
      (o = []),
      Vh(
        e,
        (t = ((!i && n) || e).__k = wh(Mh, null, [t])),
        r || gh,
        gh,
        void 0 !== e.ownerSVGElement,
        !i && n
          ? [n]
          : r
          ? null
          : e.firstChild
          ? yh.slice.call(e.childNodes)
          : null,
        o,
        !i && n ? n : r ? r.__e : e.firstChild,
        i,
      ),
      Nh(o, t);
  }
  (ph = {
    __e: function (t, e) {
      for (var n, i, r; (e = e.__); )
        if ((n = e.__c) && !n.__)
          try {
            if (
              ((i = n.constructor) &&
                null != i.getDerivedStateFromError &&
                (n.setState(i.getDerivedStateFromError(t)), (r = n.__d)),
              null != n.componentDidCatch &&
                (n.componentDidCatch(t), (r = n.__d)),
              r)
            )
              return (n.__E = n);
          } catch (e) {
            t = e;
          }
      throw t;
    },
    __v: 0,
  }),
    (Sh.prototype.setState = function (t, e) {
      var n;
      (n =
        null != this.__s && this.__s !== this.state
          ? this.__s
          : (this.__s = _h({}, this.state))),
        'function' == typeof t && (t = t(_h({}, n), this.props)),
        t && _h(n, t),
        null != t && this.__v && (e && this.__h.push(e), Dh(this));
    }),
    (Sh.prototype.forceUpdate = function (t) {
      this.__v && ((this.__e = !0), t && this.__h.push(t), Dh(this));
    }),
    (Sh.prototype.render = Mh),
    (fh = []),
    (mh =
      'function' == typeof Promise
        ? Promise.prototype.then.bind(Promise.resolve())
        : setTimeout),
    (Ch.__r = 0);
  var Hh = function (t, e, n, i) {
      var r;
      e[0] = 0;
      for (var o = 1; o < e.length; o++) {
        var s = e[o++],
          a = e[o] ? ((e[0] |= s ? 1 : 2), n[e[o++]]) : e[++o];
        3 === s
          ? (i[0] = a)
          : 4 === s
          ? (i[1] = Object.assign(i[1] || {}, a))
          : 5 === s
          ? ((i[1] = i[1] || {})[e[++o]] = a)
          : 6 === s
          ? (i[1][e[++o]] += a + '')
          : s
          ? ((r = t.apply(a, Hh(t, a, n, ['', null]))),
            i.push(r),
            a[0] ? (e[0] |= 2) : ((e[o - 2] = 0), (e[o] = r)))
          : i.push(a);
      }
      return i;
    },
    Wh = new Map();
  var Xh = function (t) {
    var e = Wh.get(this);
    return (
      e || ((e = new Map()), Wh.set(this, e)),
      (e = Hh(
        this,
        e.get(t) ||
          (e.set(
            t,
            (e = (function (t) {
              for (
                var e,
                  n,
                  i = 1,
                  r = '',
                  o = '',
                  s = [0],
                  a = function (t) {
                    1 === i &&
                    (t || (r = r.replace(/^\s*\n\s*|\s*\n\s*$/g, '')))
                      ? s.push(0, t, r)
                      : 3 === i && (t || r)
                      ? (s.push(3, t, r), (i = 2))
                      : 2 === i && '...' === r && t
                      ? s.push(4, t, 0)
                      : 2 === i && r && !t
                      ? s.push(5, 0, !0, r)
                      : i >= 5 &&
                        ((r || (!t && 5 === i)) &&
                          (s.push(i, 0, r, n), (i = 6)),
                        t && (s.push(i, t, 0, n), (i = 6))),
                      (r = '');
                  },
                  c = 0;
                c < t.length;
                c++
              ) {
                c && (1 === i && a(), a(c));
                for (var l = 0; l < t[c].length; l++)
                  (e = t[c][l]),
                    1 === i
                      ? '<' === e
                        ? (a(), (s = [s]), (i = 3))
                        : (r += e)
                      : 4 === i
                      ? '--' === r && '>' === e
                        ? ((i = 1), (r = ''))
                        : (r = e + r[0])
                      : o
                      ? e === o
                        ? (o = '')
                        : (r += e)
                      : '"' === e || "'" === e
                      ? (o = e)
                      : '>' === e
                      ? (a(), (i = 1))
                      : i &&
                        ('=' === e
                          ? ((i = 5), (n = r), (r = ''))
                          : '/' === e && (i < 5 || '>' === t[c][l + 1])
                          ? (a(),
                            3 === i && (s = s[0]),
                            (i = s),
                            (s = s[0]).push(2, 0, i),
                            (i = 0))
                          : ' ' === e || '\t' === e || '\n' === e || '\r' === e
                          ? (a(), (i = 2))
                          : (r += e)),
                    3 === i && '!--' === r && ((i = 4), (s = s[0]));
              }
              return a(), s;
            })(t)),
          ),
          e),
        arguments,
        [],
      )).length > 1
        ? e
        : e[0]
    );
  }.bind(wh);
  class Zh extends Sh {
    constructor(t) {
      super(t),
        (this.state = {
          showMenuList: !0,
          pointShow: !0,
          panoramaArr: this.props.panoramaArray,
        });
    }
    menuClick(t) {
      let e = this.props.menuClick(t.id);
      this.setState({ panoramaArr: e });
    }
    showHiddenPoint() {
      this.props.showHiddenPoint(),
        this.setState({ pointShow: !this.state.pointShow });
    }
    showHiddenMenu() {
      this.setState({ showMenuList: !this.state.showMenuList });
    }
    render() {
      return Xh`<${Mh}>
        <!--导航条-->
        <div class="ccbim__panoramaMenu">
          <div class="ccbim__panoramaMenu__menuBtn">
            <div
              class=${this.state.showMenuList ? 'switch on' : 'switch'}
              onClick=${() => this.showHiddenMenu()}
              title="场景选择"
            >
              <svg class="menuIcon" aria-hidden="true">
                <use xlinkHref="#icongengduo"></use>
              </svg>
            </div>
            <div
              class=${this.state.pointShow ? 'switch on' : 'switch'}
              onClick=${() => this.showHiddenPoint()}
              title="热点显示"
            >
              <svg class="menuIcon" aria-hidden="true">
                <use xlinkHref="#iconyanjing"></use>
              </svg>
            </div>
          </div>
          ${
            this.state.showMenuList &&
            Xh`<ul class="ccbim__panoramaMenu__imgList">
              ${this.state.panoramaArr.map(
                (t) => Xh`
                  <li
                    class=${t.current && 'on'}
                    onClick=${() => this.menuClick(t)}
                  >
                    <span class="hoverName">${t.curCameraName}</span>
                    <img src=${t.previewImg} class="on" />
                    <p>${t.curCameraName}</p>
                  </li>
                `,
              )}
            </ul>`
          }
        </div>
      </${Mh}>`;
    }
  }
  function Yh(t, e) {
    jh(
      Xh`<${Zh}
      panoramaArray=${e.panoramaArray}
      menuClick=${e.menuClick}
      showHiddenPoint=${e.showHiddenPoint}
    />`,
      t,
    );
  }
  class qh extends Sh {
    constructor(t) {
      super(t);
    }
    render() {
      return Xh`<${Mh}>
        <!--错误-->
        <div class="ccbim__error">
          <div>
            <svg class="queueIcon" style="color: #FEC52A">
              <use xlinkHref="#iconjinggao"></use>
            </svg>
            <p style="user-select:text;">${this.props.panoramaErrorMsg}</p>
          </div>
        </div>
      </${Mh}>`;
    }
  }
  function Qh(t, e) {
    jh(Xh`<${qh} panoramaErrorMsg=${e} />`, t);
  }
  class Jh extends Sh {
    constructor(t) {
      super(t);
    }
    render() {
      return Xh`<${Mh}>
        <!--加载中-->
        <div class="ccbim__panoramaLoading">
          <div class="loading"></div>
          <div class="loading"></div>
          <div class="loading"></div>
          <div class="loading"></div>
          <div class="loading"></div>
          <div class="loading"></div>
          <div class="loading"></div>
          <div class="loading"></div>
        </div>
      </${Mh}>`;
    }
  }
  function $h(t, e) {
    jh(e ? Xh`<${Jh} />` : Xh``, t);
  }
  class Kh extends Sh {
    constructor(t) {
      super(t);
    }
    render() {
      return Xh`<${Mh}>
      <!--全景-->
      <div id="ccbim__panorama"></div>
      <!--错误-->
      <div id="ccbim__panoramaErrorMsg"></div>
      <!--加载中-->
      <div id="ccbim__panoramaLoading"></div>
      <!--导航条-->
      <div id="ccbim__panoramaMenu"></div>
    </${Mh}>`;
    }
  }
  var tu,
    eu = 'undefined' != typeof Symbol && Symbol,
    nu = 'Function.prototype.bind called on incompatible ',
    iu = Array.prototype.slice,
    ru = Object.prototype.toString,
    ou = '[object Function]',
    su =
      Function.prototype.bind ||
      function (t) {
        var e = this;
        if ('function' != typeof e || ru.call(e) !== ou)
          throw new TypeError(nu + e);
        for (
          var n,
            i = iu.call(arguments, 1),
            r = function () {
              if (this instanceof n) {
                var r = e.apply(this, i.concat(iu.call(arguments)));
                return Object(r) === r ? r : this;
              }
              return e.apply(t, i.concat(iu.call(arguments)));
            },
            o = Math.max(0, e.length - i.length),
            s = [],
            a = 0;
          a < o;
          a++
        )
          s.push('$' + a);
        if (
          ((n = Function(
            'binder',
            'return function (' +
              s.join(',') +
              '){ return binder.apply(this,arguments); }',
          )(r)),
          e.prototype)
        ) {
          var c = function () {};
          (c.prototype = e.prototype),
            (n.prototype = new c()),
            (c.prototype = null);
        }
        return n;
      },
    au = su.call(Function.call, Object.prototype.hasOwnProperty),
    cu = SyntaxError,
    lu = Function,
    hu = TypeError,
    uu = function (t) {
      try {
        return lu('"use strict"; return (' + t + ').constructor;')();
      } catch (t) {}
    },
    du = Object.getOwnPropertyDescriptor;
  if (du)
    try {
      du({}, '');
    } catch (t) {
      du = null;
    }
  var pu = function () {
      throw new hu();
    },
    fu = du
      ? (function () {
          try {
            return pu;
          } catch (t) {
            try {
              return du(arguments, 'callee').get;
            } catch (t) {
              return pu;
            }
          }
        })()
      : pu,
    mu =
      'function' == typeof eu &&
      'function' == typeof Symbol &&
      'symbol' == typeof eu('foo') &&
      'symbol' == typeof Symbol('bar') &&
      (function () {
        if (
          'function' != typeof Symbol ||
          'function' != typeof Object.getOwnPropertySymbols
        )
          return !1;
        if ('symbol' == typeof Symbol.iterator) return !0;
        var t = {},
          e = Symbol('test'),
          n = Object(e);
        if ('string' == typeof e) return !1;
        if ('[object Symbol]' !== Object.prototype.toString.call(e)) return !1;
        if ('[object Symbol]' !== Object.prototype.toString.call(n)) return !1;
        for (e in ((t[e] = 42), t)) return !1;
        if ('function' == typeof Object.keys && 0 !== Object.keys(t).length)
          return !1;
        if (
          'function' == typeof Object.getOwnPropertyNames &&
          0 !== Object.getOwnPropertyNames(t).length
        )
          return !1;
        var i = Object.getOwnPropertySymbols(t);
        if (1 !== i.length || i[0] !== e) return !1;
        if (!Object.prototype.propertyIsEnumerable.call(t, e)) return !1;
        if ('function' == typeof Object.getOwnPropertyDescriptor) {
          var r = Object.getOwnPropertyDescriptor(t, e);
          if (42 !== r.value || !0 !== r.enumerable) return !1;
        }
        return !0;
      })(),
    bu =
      Object.getPrototypeOf ||
      function (t) {
        return t.__proto__;
      },
    gu = {},
    yu = 'undefined' == typeof Uint8Array ? tu : bu(Uint8Array),
    vu = {
      '%AggregateError%':
        'undefined' == typeof AggregateError ? tu : AggregateError,
      '%Array%': Array,
      '%ArrayBuffer%': 'undefined' == typeof ArrayBuffer ? tu : ArrayBuffer,
      '%ArrayIteratorPrototype%': mu ? bu([][Symbol.iterator]()) : tu,
      '%AsyncFromSyncIteratorPrototype%': tu,
      '%AsyncFunction%': gu,
      '%AsyncGenerator%': gu,
      '%AsyncGeneratorFunction%': gu,
      '%AsyncIteratorPrototype%': gu,
      '%Atomics%': 'undefined' == typeof Atomics ? tu : Atomics,
      '%BigInt%': 'undefined' == typeof BigInt ? tu : BigInt,
      '%Boolean%': Boolean,
      '%DataView%': 'undefined' == typeof DataView ? tu : DataView,
      '%Date%': Date,
      '%decodeURI%': decodeURI,
      '%decodeURIComponent%': decodeURIComponent,
      '%encodeURI%': encodeURI,
      '%encodeURIComponent%': encodeURIComponent,
      '%Error%': Error,
      '%eval%': eval,
      '%EvalError%': EvalError,
      '%Float32Array%': 'undefined' == typeof Float32Array ? tu : Float32Array,
      '%Float64Array%': 'undefined' == typeof Float64Array ? tu : Float64Array,
      '%FinalizationRegistry%':
        'undefined' == typeof FinalizationRegistry ? tu : FinalizationRegistry,
      '%Function%': lu,
      '%GeneratorFunction%': gu,
      '%Int8Array%': 'undefined' == typeof Int8Array ? tu : Int8Array,
      '%Int16Array%': 'undefined' == typeof Int16Array ? tu : Int16Array,
      '%Int32Array%': 'undefined' == typeof Int32Array ? tu : Int32Array,
      '%isFinite%': isFinite,
      '%isNaN%': isNaN,
      '%IteratorPrototype%': mu ? bu(bu([][Symbol.iterator]())) : tu,
      '%JSON%': 'object' == typeof JSON ? JSON : tu,
      '%Map%': 'undefined' == typeof Map ? tu : Map,
      '%MapIteratorPrototype%':
        'undefined' != typeof Map && mu ? bu(new Map()[Symbol.iterator]()) : tu,
      '%Math%': Math,
      '%Number%': Number,
      '%Object%': Object,
      '%parseFloat%': parseFloat,
      '%parseInt%': parseInt,
      '%Promise%': 'undefined' == typeof Promise ? tu : Promise,
      '%Proxy%': 'undefined' == typeof Proxy ? tu : Proxy,
      '%RangeError%': RangeError,
      '%ReferenceError%': ReferenceError,
      '%Reflect%': 'undefined' == typeof Reflect ? tu : Reflect,
      '%RegExp%': RegExp,
      '%Set%': 'undefined' == typeof Set ? tu : Set,
      '%SetIteratorPrototype%':
        'undefined' != typeof Set && mu ? bu(new Set()[Symbol.iterator]()) : tu,
      '%SharedArrayBuffer%':
        'undefined' == typeof SharedArrayBuffer ? tu : SharedArrayBuffer,
      '%String%': String,
      '%StringIteratorPrototype%': mu ? bu(''[Symbol.iterator]()) : tu,
      '%Symbol%': mu ? Symbol : tu,
      '%SyntaxError%': cu,
      '%ThrowTypeError%': fu,
      '%TypedArray%': yu,
      '%TypeError%': hu,
      '%Uint8Array%': 'undefined' == typeof Uint8Array ? tu : Uint8Array,
      '%Uint8ClampedArray%':
        'undefined' == typeof Uint8ClampedArray ? tu : Uint8ClampedArray,
      '%Uint16Array%': 'undefined' == typeof Uint16Array ? tu : Uint16Array,
      '%Uint32Array%': 'undefined' == typeof Uint32Array ? tu : Uint32Array,
      '%URIError%': URIError,
      '%WeakMap%': 'undefined' == typeof WeakMap ? tu : WeakMap,
      '%WeakRef%': 'undefined' == typeof WeakRef ? tu : WeakRef,
      '%WeakSet%': 'undefined' == typeof WeakSet ? tu : WeakSet,
    },
    _u = function t(e) {
      var n;
      if ('%AsyncFunction%' === e) n = uu('async function () {}');
      else if ('%GeneratorFunction%' === e) n = uu('function* () {}');
      else if ('%AsyncGeneratorFunction%' === e)
        n = uu('async function* () {}');
      else if ('%AsyncGenerator%' === e) {
        var i = t('%AsyncGeneratorFunction%');
        i && (n = i.prototype);
      } else if ('%AsyncIteratorPrototype%' === e) {
        var r = t('%AsyncGenerator%');
        r && (n = bu(r.prototype));
      }
      return (vu[e] = n), n;
    },
    xu = {
      '%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
      '%ArrayPrototype%': ['Array', 'prototype'],
      '%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
      '%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
      '%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
      '%ArrayProto_values%': ['Array', 'prototype', 'values'],
      '%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
      '%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
      '%AsyncGeneratorPrototype%': [
        'AsyncGeneratorFunction',
        'prototype',
        'prototype',
      ],
      '%BooleanPrototype%': ['Boolean', 'prototype'],
      '%DataViewPrototype%': ['DataView', 'prototype'],
      '%DatePrototype%': ['Date', 'prototype'],
      '%ErrorPrototype%': ['Error', 'prototype'],
      '%EvalErrorPrototype%': ['EvalError', 'prototype'],
      '%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
      '%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
      '%FunctionPrototype%': ['Function', 'prototype'],
      '%Generator%': ['GeneratorFunction', 'prototype'],
      '%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
      '%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
      '%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
      '%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
      '%JSONParse%': ['JSON', 'parse'],
      '%JSONStringify%': ['JSON', 'stringify'],
      '%MapPrototype%': ['Map', 'prototype'],
      '%NumberPrototype%': ['Number', 'prototype'],
      '%ObjectPrototype%': ['Object', 'prototype'],
      '%ObjProto_toString%': ['Object', 'prototype', 'toString'],
      '%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
      '%PromisePrototype%': ['Promise', 'prototype'],
      '%PromiseProto_then%': ['Promise', 'prototype', 'then'],
      '%Promise_all%': ['Promise', 'all'],
      '%Promise_reject%': ['Promise', 'reject'],
      '%Promise_resolve%': ['Promise', 'resolve'],
      '%RangeErrorPrototype%': ['RangeError', 'prototype'],
      '%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
      '%RegExpPrototype%': ['RegExp', 'prototype'],
      '%SetPrototype%': ['Set', 'prototype'],
      '%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
      '%StringPrototype%': ['String', 'prototype'],
      '%SymbolPrototype%': ['Symbol', 'prototype'],
      '%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
      '%TypedArrayPrototype%': ['TypedArray', 'prototype'],
      '%TypeErrorPrototype%': ['TypeError', 'prototype'],
      '%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
      '%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
      '%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
      '%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
      '%URIErrorPrototype%': ['URIError', 'prototype'],
      '%WeakMapPrototype%': ['WeakMap', 'prototype'],
      '%WeakSetPrototype%': ['WeakSet', 'prototype'],
    },
    wu = su.call(Function.call, Array.prototype.concat),
    Au = su.call(Function.apply, Array.prototype.splice),
    Mu = su.call(Function.call, String.prototype.replace),
    Su = su.call(Function.call, String.prototype.slice),
    Iu =
      /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,
    Eu = /\\(\\)?/g,
    Du = function (t) {
      var e = Su(t, 0, 1),
        n = Su(t, -1);
      if ('%' === e && '%' !== n)
        throw new cu('invalid intrinsic syntax, expected closing `%`');
      if ('%' === n && '%' !== e)
        throw new cu('invalid intrinsic syntax, expected opening `%`');
      var i = [];
      return (
        Mu(t, Iu, function (t, e, n, r) {
          i[i.length] = n ? Mu(r, Eu, '$1') : e || t;
        }),
        i
      );
    },
    Cu = function (t, e) {
      var n,
        i = t;
      if ((au(xu, i) && (i = '%' + (n = xu[i])[0] + '%'), au(vu, i))) {
        var r = vu[i];
        if ((r === gu && (r = _u(i)), void 0 === r && !e))
          throw new hu(
            'intrinsic ' +
              t +
              ' exists, but is not available. Please file an issue!',
          );
        return { alias: n, name: i, value: r };
      }
      throw new cu('intrinsic ' + t + ' does not exist!');
    },
    Tu = function (t, e) {
      if ('string' != typeof t || 0 === t.length)
        throw new hu('intrinsic name must be a non-empty string');
      if (arguments.length > 1 && 'boolean' != typeof e)
        throw new hu('"allowMissing" argument must be a boolean');
      var n = Du(t),
        i = n.length > 0 ? n[0] : '',
        r = Cu('%' + i + '%', e),
        o = r.name,
        s = r.value,
        a = !1,
        c = r.alias;
      c && ((i = c[0]), Au(n, wu([0, 1], c)));
      for (var l = 1, h = !0; l < n.length; l += 1) {
        var u = n[l],
          d = Su(u, 0, 1),
          p = Su(u, -1);
        if (
          ('"' === d ||
            "'" === d ||
            '`' === d ||
            '"' === p ||
            "'" === p ||
            '`' === p) &&
          d !== p
        )
          throw new cu('property names with quotes must have matching quotes');
        if (
          (('constructor' !== u && h) || (a = !0),
          au(vu, (o = '%' + (i += '.' + u) + '%')))
        )
          s = vu[o];
        else if (null != s) {
          if (!(u in s)) {
            if (!e)
              throw new hu(
                'base intrinsic for ' +
                  t +
                  ' exists, but the property is not available.',
              );
            return;
          }
          if (du && l + 1 >= n.length) {
            var f = du(s, u);
            s =
              (h = !!f) && 'get' in f && !('originalValue' in f.get)
                ? f.get
                : s[u];
          } else (h = au(s, u)), (s = s[u]);
          h && !a && (vu[o] = s);
        }
      }
      return s;
    };
  'undefined' != typeof globalThis
    ? globalThis
    : 'undefined' != typeof window
    ? window
    : 'undefined' != typeof global
    ? global
    : 'undefined' != typeof self && self;
  function Lu(t, e, n) {
    return (
      t(
        (n = {
          path: e,
          exports: {},
          require: function (t, e) {
            return (function () {
              throw new Error(
                'Dynamic requires are not currently supported by @rollup/plugin-commonjs',
              );
            })(null == e && n.path);
          },
        }),
        n.exports,
      ),
      n.exports
    );
  }
  var Ru = Lu(function (t) {
      var e = Tu('%Function.prototype.apply%'),
        n = Tu('%Function.prototype.call%'),
        i = Tu('%Reflect.apply%', !0) || su.call(n, e),
        r = Tu('%Object.getOwnPropertyDescriptor%', !0),
        o = Tu('%Object.defineProperty%', !0),
        s = Tu('%Math.max%');
      if (o)
        try {
          o({}, 'a', { value: 1 });
        } catch (t) {
          o = null;
        }
      t.exports = function (t) {
        var e = i(su, n, arguments);
        if (r && o) {
          var a = r(e, 'length');
          a.configurable &&
            o(e, 'length', {
              value: 1 + s(0, t.length - (arguments.length - 1)),
            });
        }
        return e;
      };
      var a = function () {
        return i(su, e, arguments);
      };
      o ? o(t.exports, 'apply', { value: a }) : (t.exports.apply = a);
    }),
    Fu = Ru(Tu('String.prototype.indexOf')),
    Pu = function (t, e) {
      var n = Tu(t, !!e);
      return 'function' == typeof n && Fu(t, '.prototype.') > -1 ? Ru(n) : n;
    },
    Bu =
      'undefined' != typeof global
        ? global
        : 'undefined' != typeof self
        ? self
        : 'undefined' != typeof window
        ? window
        : {},
    Ou = [],
    Vu = [],
    Nu = 'undefined' != typeof Uint8Array ? Uint8Array : Array,
    ku = !1;
  function Uu() {
    ku = !0;
    for (
      var t =
          'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
        e = 0,
        n = t.length;
      e < n;
      ++e
    )
      (Ou[e] = t[e]), (Vu[t.charCodeAt(e)] = e);
    (Vu['-'.charCodeAt(0)] = 62), (Vu['_'.charCodeAt(0)] = 63);
  }
  function Gu(t, e, n) {
    for (var i, r, o = [], s = e; s < n; s += 3)
      (i = (t[s] << 16) + (t[s + 1] << 8) + t[s + 2]),
        o.push(
          Ou[((r = i) >> 18) & 63] +
            Ou[(r >> 12) & 63] +
            Ou[(r >> 6) & 63] +
            Ou[63 & r],
        );
    return o.join('');
  }
  function zu(t) {
    var e;
    ku || Uu();
    for (
      var n = t.length, i = n % 3, r = '', o = [], s = 16383, a = 0, c = n - i;
      a < c;
      a += s
    )
      o.push(Gu(t, a, a + s > c ? c : a + s));
    return (
      1 === i
        ? ((e = t[n - 1]),
          (r += Ou[e >> 2]),
          (r += Ou[(e << 4) & 63]),
          (r += '=='))
        : 2 === i &&
          ((e = (t[n - 2] << 8) + t[n - 1]),
          (r += Ou[e >> 10]),
          (r += Ou[(e >> 4) & 63]),
          (r += Ou[(e << 2) & 63]),
          (r += '=')),
      o.push(r),
      o.join('')
    );
  }
  function ju(t, e, n, i, r) {
    var o,
      s,
      a = 8 * r - i - 1,
      c = (1 << a) - 1,
      l = c >> 1,
      h = -7,
      u = n ? r - 1 : 0,
      d = n ? -1 : 1,
      p = t[e + u];
    for (
      u += d, o = p & ((1 << -h) - 1), p >>= -h, h += a;
      h > 0;
      o = 256 * o + t[e + u], u += d, h -= 8
    );
    for (
      s = o & ((1 << -h) - 1), o >>= -h, h += i;
      h > 0;
      s = 256 * s + t[e + u], u += d, h -= 8
    );
    if (0 === o) o = 1 - l;
    else {
      if (o === c) return s ? NaN : (1 / 0) * (p ? -1 : 1);
      (s += Math.pow(2, i)), (o -= l);
    }
    return (p ? -1 : 1) * s * Math.pow(2, o - i);
  }
  function Hu(t, e, n, i, r, o) {
    var s,
      a,
      c,
      l = 8 * o - r - 1,
      h = (1 << l) - 1,
      u = h >> 1,
      d = 23 === r ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
      p = i ? 0 : o - 1,
      f = i ? 1 : -1,
      m = e < 0 || (0 === e && 1 / e < 0) ? 1 : 0;
    for (
      e = Math.abs(e),
        isNaN(e) || e === 1 / 0
          ? ((a = isNaN(e) ? 1 : 0), (s = h))
          : ((s = Math.floor(Math.log(e) / Math.LN2)),
            e * (c = Math.pow(2, -s)) < 1 && (s--, (c *= 2)),
            (e += s + u >= 1 ? d / c : d * Math.pow(2, 1 - u)) * c >= 2 &&
              (s++, (c /= 2)),
            s + u >= h
              ? ((a = 0), (s = h))
              : s + u >= 1
              ? ((a = (e * c - 1) * Math.pow(2, r)), (s += u))
              : ((a = e * Math.pow(2, u - 1) * Math.pow(2, r)), (s = 0)));
      r >= 8;
      t[n + p] = 255 & a, p += f, a /= 256, r -= 8
    );
    for (
      s = (s << r) | a, l += r;
      l > 0;
      t[n + p] = 255 & s, p += f, s /= 256, l -= 8
    );
    t[n + p - f] |= 128 * m;
  }
  var Wu = {}.toString,
    Xu =
      Array.isArray ||
      function (t) {
        return '[object Array]' == Wu.call(t);
      };
  function Zu() {
    return qu.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
  }
  function Yu(t, e) {
    if (Zu() < e) throw new RangeError('Invalid typed array length');
    return (
      qu.TYPED_ARRAY_SUPPORT
        ? ((t = new Uint8Array(e)).__proto__ = qu.prototype)
        : (null === t && (t = new qu(e)), (t.length = e)),
      t
    );
  }
  function qu(t, e, n) {
    if (!(qu.TYPED_ARRAY_SUPPORT || this instanceof qu)) return new qu(t, e, n);
    if ('number' == typeof t) {
      if ('string' == typeof e)
        throw new Error(
          'If encoding is specified then the first argument must be a string',
        );
      return $u(this, t);
    }
    return Qu(this, t, e, n);
  }
  function Qu(t, e, n, i) {
    if ('number' == typeof e)
      throw new TypeError('"value" argument must not be a number');
    return 'undefined' != typeof ArrayBuffer && e instanceof ArrayBuffer
      ? (function (t, e, n, i) {
          if ((e.byteLength, n < 0 || e.byteLength < n))
            throw new RangeError("'offset' is out of bounds");
          if (e.byteLength < n + (i || 0))
            throw new RangeError("'length' is out of bounds");
          e =
            void 0 === n && void 0 === i
              ? new Uint8Array(e)
              : void 0 === i
              ? new Uint8Array(e, n)
              : new Uint8Array(e, n, i);
          qu.TYPED_ARRAY_SUPPORT
            ? ((t = e).__proto__ = qu.prototype)
            : (t = Ku(t, e));
          return t;
        })(t, e, n, i)
      : 'string' == typeof e
      ? (function (t, e, n) {
          ('string' == typeof n && '' !== n) || (n = 'utf8');
          if (!qu.isEncoding(n))
            throw new TypeError('"encoding" must be a valid string encoding');
          var i = 0 | nd(e, n),
            r = (t = Yu(t, i)).write(e, n);
          r !== i && (t = t.slice(0, r));
          return t;
        })(t, e, n)
      : (function (t, e) {
          if (ed(e)) {
            var n = 0 | td(e.length);
            return 0 === (t = Yu(t, n)).length || e.copy(t, 0, 0, n), t;
          }
          if (e) {
            if (
              ('undefined' != typeof ArrayBuffer &&
                e.buffer instanceof ArrayBuffer) ||
              'length' in e
            )
              return 'number' != typeof e.length || (i = e.length) != i
                ? Yu(t, 0)
                : Ku(t, e);
            if ('Buffer' === e.type && Xu(e.data)) return Ku(t, e.data);
          }
          var i;
          throw new TypeError(
            'First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.',
          );
        })(t, e);
  }
  function Ju(t) {
    if ('number' != typeof t)
      throw new TypeError('"size" argument must be a number');
    if (t < 0) throw new RangeError('"size" argument must not be negative');
  }
  function $u(t, e) {
    if ((Ju(e), (t = Yu(t, e < 0 ? 0 : 0 | td(e))), !qu.TYPED_ARRAY_SUPPORT))
      for (var n = 0; n < e; ++n) t[n] = 0;
    return t;
  }
  function Ku(t, e) {
    var n = e.length < 0 ? 0 : 0 | td(e.length);
    t = Yu(t, n);
    for (var i = 0; i < n; i += 1) t[i] = 255 & e[i];
    return t;
  }
  function td(t) {
    if (t >= Zu())
      throw new RangeError(
        'Attempt to allocate Buffer larger than maximum size: 0x' +
          Zu().toString(16) +
          ' bytes',
      );
    return 0 | t;
  }
  function ed(t) {
    return !(null == t || !t._isBuffer);
  }
  function nd(t, e) {
    if (ed(t)) return t.length;
    if (
      'undefined' != typeof ArrayBuffer &&
      'function' == typeof ArrayBuffer.isView &&
      (ArrayBuffer.isView(t) || t instanceof ArrayBuffer)
    )
      return t.byteLength;
    'string' != typeof t && (t = '' + t);
    var n = t.length;
    if (0 === n) return 0;
    for (var i = !1; ; )
      switch (e) {
        case 'ascii':
        case 'latin1':
        case 'binary':
          return n;
        case 'utf8':
        case 'utf-8':
        case void 0:
          return Cd(t).length;
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return 2 * n;
        case 'hex':
          return n >>> 1;
        case 'base64':
          return Td(t).length;
        default:
          if (i) return Cd(t).length;
          (e = ('' + e).toLowerCase()), (i = !0);
      }
  }
  function id(t, e, n) {
    var i = !1;
    if (((void 0 === e || e < 0) && (e = 0), e > this.length)) return '';
    if (((void 0 === n || n > this.length) && (n = this.length), n <= 0))
      return '';
    if ((n >>>= 0) <= (e >>>= 0)) return '';
    for (t || (t = 'utf8'); ; )
      switch (t) {
        case 'hex':
          return yd(this, e, n);
        case 'utf8':
        case 'utf-8':
          return fd(this, e, n);
        case 'ascii':
          return bd(this, e, n);
        case 'latin1':
        case 'binary':
          return gd(this, e, n);
        case 'base64':
          return pd(this, e, n);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return vd(this, e, n);
        default:
          if (i) throw new TypeError('Unknown encoding: ' + t);
          (t = (t + '').toLowerCase()), (i = !0);
      }
  }
  function rd(t, e, n) {
    var i = t[e];
    (t[e] = t[n]), (t[n] = i);
  }
  function od(t, e, n, i, r) {
    if (0 === t.length) return -1;
    if (
      ('string' == typeof n
        ? ((i = n), (n = 0))
        : n > 2147483647
        ? (n = 2147483647)
        : n < -2147483648 && (n = -2147483648),
      (n = +n),
      isNaN(n) && (n = r ? 0 : t.length - 1),
      n < 0 && (n = t.length + n),
      n >= t.length)
    ) {
      if (r) return -1;
      n = t.length - 1;
    } else if (n < 0) {
      if (!r) return -1;
      n = 0;
    }
    if (('string' == typeof e && (e = qu.from(e, i)), ed(e)))
      return 0 === e.length ? -1 : sd(t, e, n, i, r);
    if ('number' == typeof e)
      return (
        (e &= 255),
        qu.TYPED_ARRAY_SUPPORT &&
        'function' == typeof Uint8Array.prototype.indexOf
          ? r
            ? Uint8Array.prototype.indexOf.call(t, e, n)
            : Uint8Array.prototype.lastIndexOf.call(t, e, n)
          : sd(t, [e], n, i, r)
      );
    throw new TypeError('val must be string, number or Buffer');
  }
  function sd(t, e, n, i, r) {
    var o,
      s = 1,
      a = t.length,
      c = e.length;
    if (
      void 0 !== i &&
      ('ucs2' === (i = String(i).toLowerCase()) ||
        'ucs-2' === i ||
        'utf16le' === i ||
        'utf-16le' === i)
    ) {
      if (t.length < 2 || e.length < 2) return -1;
      (s = 2), (a /= 2), (c /= 2), (n /= 2);
    }
    function l(t, e) {
      return 1 === s ? t[e] : t.readUInt16BE(e * s);
    }
    if (r) {
      var h = -1;
      for (o = n; o < a; o++)
        if (l(t, o) === l(e, -1 === h ? 0 : o - h)) {
          if ((-1 === h && (h = o), o - h + 1 === c)) return h * s;
        } else -1 !== h && (o -= o - h), (h = -1);
    } else
      for (n + c > a && (n = a - c), o = n; o >= 0; o--) {
        for (var u = !0, d = 0; d < c; d++)
          if (l(t, o + d) !== l(e, d)) {
            u = !1;
            break;
          }
        if (u) return o;
      }
    return -1;
  }
  function ad(t, e, n, i) {
    n = Number(n) || 0;
    var r = t.length - n;
    i ? (i = Number(i)) > r && (i = r) : (i = r);
    var o = e.length;
    if (o % 2 != 0) throw new TypeError('Invalid hex string');
    i > o / 2 && (i = o / 2);
    for (var s = 0; s < i; ++s) {
      var a = parseInt(e.substr(2 * s, 2), 16);
      if (isNaN(a)) return s;
      t[n + s] = a;
    }
    return s;
  }
  function cd(t, e, n, i) {
    return Ld(Cd(e, t.length - n), t, n, i);
  }
  function ld(t, e, n, i) {
    return Ld(
      (function (t) {
        for (var e = [], n = 0; n < t.length; ++n)
          e.push(255 & t.charCodeAt(n));
        return e;
      })(e),
      t,
      n,
      i,
    );
  }
  function hd(t, e, n, i) {
    return ld(t, e, n, i);
  }
  function ud(t, e, n, i) {
    return Ld(Td(e), t, n, i);
  }
  function dd(t, e, n, i) {
    return Ld(
      (function (t, e) {
        for (var n, i, r, o = [], s = 0; s < t.length && !((e -= 2) < 0); ++s)
          (i = (n = t.charCodeAt(s)) >> 8), (r = n % 256), o.push(r), o.push(i);
        return o;
      })(e, t.length - n),
      t,
      n,
      i,
    );
  }
  function pd(t, e, n) {
    return 0 === e && n === t.length ? zu(t) : zu(t.slice(e, n));
  }
  function fd(t, e, n) {
    n = Math.min(t.length, n);
    for (var i = [], r = e; r < n; ) {
      var o,
        s,
        a,
        c,
        l = t[r],
        h = null,
        u = l > 239 ? 4 : l > 223 ? 3 : l > 191 ? 2 : 1;
      if (r + u <= n)
        switch (u) {
          case 1:
            l < 128 && (h = l);
            break;
          case 2:
            128 == (192 & (o = t[r + 1])) &&
              (c = ((31 & l) << 6) | (63 & o)) > 127 &&
              (h = c);
            break;
          case 3:
            (o = t[r + 1]),
              (s = t[r + 2]),
              128 == (192 & o) &&
                128 == (192 & s) &&
                (c = ((15 & l) << 12) | ((63 & o) << 6) | (63 & s)) > 2047 &&
                (c < 55296 || c > 57343) &&
                (h = c);
            break;
          case 4:
            (o = t[r + 1]),
              (s = t[r + 2]),
              (a = t[r + 3]),
              128 == (192 & o) &&
                128 == (192 & s) &&
                128 == (192 & a) &&
                (c =
                  ((15 & l) << 18) |
                  ((63 & o) << 12) |
                  ((63 & s) << 6) |
                  (63 & a)) > 65535 &&
                c < 1114112 &&
                (h = c);
        }
      null === h
        ? ((h = 65533), (u = 1))
        : h > 65535 &&
          ((h -= 65536),
          i.push(((h >>> 10) & 1023) | 55296),
          (h = 56320 | (1023 & h))),
        i.push(h),
        (r += u);
    }
    return (function (t) {
      var e = t.length;
      if (e <= md) return String.fromCharCode.apply(String, t);
      var n = '',
        i = 0;
      for (; i < e; )
        n += String.fromCharCode.apply(String, t.slice(i, (i += md)));
      return n;
    })(i);
  }
  (qu.TYPED_ARRAY_SUPPORT =
    void 0 === Bu.TYPED_ARRAY_SUPPORT || Bu.TYPED_ARRAY_SUPPORT),
    (qu.poolSize = 8192),
    (qu._augment = function (t) {
      return (t.__proto__ = qu.prototype), t;
    }),
    (qu.from = function (t, e, n) {
      return Qu(null, t, e, n);
    }),
    qu.TYPED_ARRAY_SUPPORT &&
      ((qu.prototype.__proto__ = Uint8Array.prototype),
      (qu.__proto__ = Uint8Array)),
    (qu.alloc = function (t, e, n) {
      return (function (t, e, n, i) {
        return (
          Ju(e),
          e <= 0
            ? Yu(t, e)
            : void 0 !== n
            ? 'string' == typeof i
              ? Yu(t, e).fill(n, i)
              : Yu(t, e).fill(n)
            : Yu(t, e)
        );
      })(null, t, e, n);
    }),
    (qu.allocUnsafe = function (t) {
      return $u(null, t);
    }),
    (qu.allocUnsafeSlow = function (t) {
      return $u(null, t);
    }),
    (qu.isBuffer = function (t) {
      return (
        null != t &&
        (!!t._isBuffer ||
          Rd(t) ||
          (function (t) {
            return (
              'function' == typeof t.readFloatLE &&
              'function' == typeof t.slice &&
              Rd(t.slice(0, 0))
            );
          })(t))
      );
    }),
    (qu.compare = function (t, e) {
      if (!ed(t) || !ed(e)) throw new TypeError('Arguments must be Buffers');
      if (t === e) return 0;
      for (
        var n = t.length, i = e.length, r = 0, o = Math.min(n, i);
        r < o;
        ++r
      )
        if (t[r] !== e[r]) {
          (n = t[r]), (i = e[r]);
          break;
        }
      return n < i ? -1 : i < n ? 1 : 0;
    }),
    (qu.isEncoding = function (t) {
      switch (String(t).toLowerCase()) {
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return !0;
        default:
          return !1;
      }
    }),
    (qu.concat = function (t, e) {
      if (!Xu(t))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (0 === t.length) return qu.alloc(0);
      var n;
      if (void 0 === e) for (e = 0, n = 0; n < t.length; ++n) e += t[n].length;
      var i = qu.allocUnsafe(e),
        r = 0;
      for (n = 0; n < t.length; ++n) {
        var o = t[n];
        if (!ed(o))
          throw new TypeError('"list" argument must be an Array of Buffers');
        o.copy(i, r), (r += o.length);
      }
      return i;
    }),
    (qu.byteLength = nd),
    (qu.prototype._isBuffer = !0),
    (qu.prototype.swap16 = function () {
      var t = this.length;
      if (t % 2 != 0)
        throw new RangeError('Buffer size must be a multiple of 16-bits');
      for (var e = 0; e < t; e += 2) rd(this, e, e + 1);
      return this;
    }),
    (qu.prototype.swap32 = function () {
      var t = this.length;
      if (t % 4 != 0)
        throw new RangeError('Buffer size must be a multiple of 32-bits');
      for (var e = 0; e < t; e += 4) rd(this, e, e + 3), rd(this, e + 1, e + 2);
      return this;
    }),
    (qu.prototype.swap64 = function () {
      var t = this.length;
      if (t % 8 != 0)
        throw new RangeError('Buffer size must be a multiple of 64-bits');
      for (var e = 0; e < t; e += 8)
        rd(this, e, e + 7),
          rd(this, e + 1, e + 6),
          rd(this, e + 2, e + 5),
          rd(this, e + 3, e + 4);
      return this;
    }),
    (qu.prototype.toString = function () {
      var t = 0 | this.length;
      return 0 === t
        ? ''
        : 0 === arguments.length
        ? fd(this, 0, t)
        : id.apply(this, arguments);
    }),
    (qu.prototype.equals = function (t) {
      if (!ed(t)) throw new TypeError('Argument must be a Buffer');
      return this === t || 0 === qu.compare(this, t);
    }),
    (qu.prototype.inspect = function () {
      var t = '';
      return (
        this.length > 0 &&
          ((t = this.toString('hex', 0, 50).match(/.{2}/g).join(' ')),
          this.length > 50 && (t += ' ... ')),
        '<Buffer ' + t + '>'
      );
    }),
    (qu.prototype.compare = function (t, e, n, i, r) {
      if (!ed(t)) throw new TypeError('Argument must be a Buffer');
      if (
        (void 0 === e && (e = 0),
        void 0 === n && (n = t ? t.length : 0),
        void 0 === i && (i = 0),
        void 0 === r && (r = this.length),
        e < 0 || n > t.length || i < 0 || r > this.length)
      )
        throw new RangeError('out of range index');
      if (i >= r && e >= n) return 0;
      if (i >= r) return -1;
      if (e >= n) return 1;
      if (this === t) return 0;
      for (
        var o = (r >>>= 0) - (i >>>= 0),
          s = (n >>>= 0) - (e >>>= 0),
          a = Math.min(o, s),
          c = this.slice(i, r),
          l = t.slice(e, n),
          h = 0;
        h < a;
        ++h
      )
        if (c[h] !== l[h]) {
          (o = c[h]), (s = l[h]);
          break;
        }
      return o < s ? -1 : s < o ? 1 : 0;
    }),
    (qu.prototype.includes = function (t, e, n) {
      return -1 !== this.indexOf(t, e, n);
    }),
    (qu.prototype.indexOf = function (t, e, n) {
      return od(this, t, e, n, !0);
    }),
    (qu.prototype.lastIndexOf = function (t, e, n) {
      return od(this, t, e, n, !1);
    }),
    (qu.prototype.write = function (t, e, n, i) {
      if (void 0 === e) (i = 'utf8'), (n = this.length), (e = 0);
      else if (void 0 === n && 'string' == typeof e)
        (i = e), (n = this.length), (e = 0);
      else {
        if (!isFinite(e))
          throw new Error(
            'Buffer.write(string, encoding, offset[, length]) is no longer supported',
          );
        (e |= 0),
          isFinite(n)
            ? ((n |= 0), void 0 === i && (i = 'utf8'))
            : ((i = n), (n = void 0));
      }
      var r = this.length - e;
      if (
        ((void 0 === n || n > r) && (n = r),
        (t.length > 0 && (n < 0 || e < 0)) || e > this.length)
      )
        throw new RangeError('Attempt to write outside buffer bounds');
      i || (i = 'utf8');
      for (var o = !1; ; )
        switch (i) {
          case 'hex':
            return ad(this, t, e, n);
          case 'utf8':
          case 'utf-8':
            return cd(this, t, e, n);
          case 'ascii':
            return ld(this, t, e, n);
          case 'latin1':
          case 'binary':
            return hd(this, t, e, n);
          case 'base64':
            return ud(this, t, e, n);
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return dd(this, t, e, n);
          default:
            if (o) throw new TypeError('Unknown encoding: ' + i);
            (i = ('' + i).toLowerCase()), (o = !0);
        }
    }),
    (qu.prototype.toJSON = function () {
      return {
        type: 'Buffer',
        data: Array.prototype.slice.call(this._arr || this, 0),
      };
    });
  var md = 4096;
  function bd(t, e, n) {
    var i = '';
    n = Math.min(t.length, n);
    for (var r = e; r < n; ++r) i += String.fromCharCode(127 & t[r]);
    return i;
  }
  function gd(t, e, n) {
    var i = '';
    n = Math.min(t.length, n);
    for (var r = e; r < n; ++r) i += String.fromCharCode(t[r]);
    return i;
  }
  function yd(t, e, n) {
    var i = t.length;
    (!e || e < 0) && (e = 0), (!n || n < 0 || n > i) && (n = i);
    for (var r = '', o = e; o < n; ++o) r += Dd(t[o]);
    return r;
  }
  function vd(t, e, n) {
    for (var i = t.slice(e, n), r = '', o = 0; o < i.length; o += 2)
      r += String.fromCharCode(i[o] + 256 * i[o + 1]);
    return r;
  }
  function _d(t, e, n) {
    if (t % 1 != 0 || t < 0) throw new RangeError('offset is not uint');
    if (t + e > n)
      throw new RangeError('Trying to access beyond buffer length');
  }
  function xd(t, e, n, i, r, o) {
    if (!ed(t))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (e > r || e < o)
      throw new RangeError('"value" argument is out of bounds');
    if (n + i > t.length) throw new RangeError('Index out of range');
  }
  function wd(t, e, n, i) {
    e < 0 && (e = 65535 + e + 1);
    for (var r = 0, o = Math.min(t.length - n, 2); r < o; ++r)
      t[n + r] = (e & (255 << (8 * (i ? r : 1 - r)))) >>> (8 * (i ? r : 1 - r));
  }
  function Ad(t, e, n, i) {
    e < 0 && (e = 4294967295 + e + 1);
    for (var r = 0, o = Math.min(t.length - n, 4); r < o; ++r)
      t[n + r] = (e >>> (8 * (i ? r : 3 - r))) & 255;
  }
  function Md(t, e, n, i, r, o) {
    if (n + i > t.length) throw new RangeError('Index out of range');
    if (n < 0) throw new RangeError('Index out of range');
  }
  function Sd(t, e, n, i, r) {
    return r || Md(t, 0, n, 4), Hu(t, e, n, i, 23, 4), n + 4;
  }
  function Id(t, e, n, i, r) {
    return r || Md(t, 0, n, 8), Hu(t, e, n, i, 52, 8), n + 8;
  }
  (qu.prototype.slice = function (t, e) {
    var n,
      i = this.length;
    if (
      ((t = ~~t) < 0 ? (t += i) < 0 && (t = 0) : t > i && (t = i),
      (e = void 0 === e ? i : ~~e) < 0
        ? (e += i) < 0 && (e = 0)
        : e > i && (e = i),
      e < t && (e = t),
      qu.TYPED_ARRAY_SUPPORT)
    )
      (n = this.subarray(t, e)).__proto__ = qu.prototype;
    else {
      var r = e - t;
      n = new qu(r, void 0);
      for (var o = 0; o < r; ++o) n[o] = this[o + t];
    }
    return n;
  }),
    (qu.prototype.readUIntLE = function (t, e, n) {
      (t |= 0), (e |= 0), n || _d(t, e, this.length);
      for (var i = this[t], r = 1, o = 0; ++o < e && (r *= 256); )
        i += this[t + o] * r;
      return i;
    }),
    (qu.prototype.readUIntBE = function (t, e, n) {
      (t |= 0), (e |= 0), n || _d(t, e, this.length);
      for (var i = this[t + --e], r = 1; e > 0 && (r *= 256); )
        i += this[t + --e] * r;
      return i;
    }),
    (qu.prototype.readUInt8 = function (t, e) {
      return e || _d(t, 1, this.length), this[t];
    }),
    (qu.prototype.readUInt16LE = function (t, e) {
      return e || _d(t, 2, this.length), this[t] | (this[t + 1] << 8);
    }),
    (qu.prototype.readUInt16BE = function (t, e) {
      return e || _d(t, 2, this.length), (this[t] << 8) | this[t + 1];
    }),
    (qu.prototype.readUInt32LE = function (t, e) {
      return (
        e || _d(t, 4, this.length),
        (this[t] | (this[t + 1] << 8) | (this[t + 2] << 16)) +
          16777216 * this[t + 3]
      );
    }),
    (qu.prototype.readUInt32BE = function (t, e) {
      return (
        e || _d(t, 4, this.length),
        16777216 * this[t] +
          ((this[t + 1] << 16) | (this[t + 2] << 8) | this[t + 3])
      );
    }),
    (qu.prototype.readIntLE = function (t, e, n) {
      (t |= 0), (e |= 0), n || _d(t, e, this.length);
      for (var i = this[t], r = 1, o = 0; ++o < e && (r *= 256); )
        i += this[t + o] * r;
      return i >= (r *= 128) && (i -= Math.pow(2, 8 * e)), i;
    }),
    (qu.prototype.readIntBE = function (t, e, n) {
      (t |= 0), (e |= 0), n || _d(t, e, this.length);
      for (var i = e, r = 1, o = this[t + --i]; i > 0 && (r *= 256); )
        o += this[t + --i] * r;
      return o >= (r *= 128) && (o -= Math.pow(2, 8 * e)), o;
    }),
    (qu.prototype.readInt8 = function (t, e) {
      return (
        e || _d(t, 1, this.length),
        128 & this[t] ? -1 * (255 - this[t] + 1) : this[t]
      );
    }),
    (qu.prototype.readInt16LE = function (t, e) {
      e || _d(t, 2, this.length);
      var n = this[t] | (this[t + 1] << 8);
      return 32768 & n ? 4294901760 | n : n;
    }),
    (qu.prototype.readInt16BE = function (t, e) {
      e || _d(t, 2, this.length);
      var n = this[t + 1] | (this[t] << 8);
      return 32768 & n ? 4294901760 | n : n;
    }),
    (qu.prototype.readInt32LE = function (t, e) {
      return (
        e || _d(t, 4, this.length),
        this[t] | (this[t + 1] << 8) | (this[t + 2] << 16) | (this[t + 3] << 24)
      );
    }),
    (qu.prototype.readInt32BE = function (t, e) {
      return (
        e || _d(t, 4, this.length),
        (this[t] << 24) | (this[t + 1] << 16) | (this[t + 2] << 8) | this[t + 3]
      );
    }),
    (qu.prototype.readFloatLE = function (t, e) {
      return e || _d(t, 4, this.length), ju(this, t, !0, 23, 4);
    }),
    (qu.prototype.readFloatBE = function (t, e) {
      return e || _d(t, 4, this.length), ju(this, t, !1, 23, 4);
    }),
    (qu.prototype.readDoubleLE = function (t, e) {
      return e || _d(t, 8, this.length), ju(this, t, !0, 52, 8);
    }),
    (qu.prototype.readDoubleBE = function (t, e) {
      return e || _d(t, 8, this.length), ju(this, t, !1, 52, 8);
    }),
    (qu.prototype.writeUIntLE = function (t, e, n, i) {
      ((t = +t), (e |= 0), (n |= 0), i) ||
        xd(this, t, e, n, Math.pow(2, 8 * n) - 1, 0);
      var r = 1,
        o = 0;
      for (this[e] = 255 & t; ++o < n && (r *= 256); )
        this[e + o] = (t / r) & 255;
      return e + n;
    }),
    (qu.prototype.writeUIntBE = function (t, e, n, i) {
      ((t = +t), (e |= 0), (n |= 0), i) ||
        xd(this, t, e, n, Math.pow(2, 8 * n) - 1, 0);
      var r = n - 1,
        o = 1;
      for (this[e + r] = 255 & t; --r >= 0 && (o *= 256); )
        this[e + r] = (t / o) & 255;
      return e + n;
    }),
    (qu.prototype.writeUInt8 = function (t, e, n) {
      return (
        (t = +t),
        (e |= 0),
        n || xd(this, t, e, 1, 255, 0),
        qu.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)),
        (this[e] = 255 & t),
        e + 1
      );
    }),
    (qu.prototype.writeUInt16LE = function (t, e, n) {
      return (
        (t = +t),
        (e |= 0),
        n || xd(this, t, e, 2, 65535, 0),
        qu.TYPED_ARRAY_SUPPORT
          ? ((this[e] = 255 & t), (this[e + 1] = t >>> 8))
          : wd(this, t, e, !0),
        e + 2
      );
    }),
    (qu.prototype.writeUInt16BE = function (t, e, n) {
      return (
        (t = +t),
        (e |= 0),
        n || xd(this, t, e, 2, 65535, 0),
        qu.TYPED_ARRAY_SUPPORT
          ? ((this[e] = t >>> 8), (this[e + 1] = 255 & t))
          : wd(this, t, e, !1),
        e + 2
      );
    }),
    (qu.prototype.writeUInt32LE = function (t, e, n) {
      return (
        (t = +t),
        (e |= 0),
        n || xd(this, t, e, 4, 4294967295, 0),
        qu.TYPED_ARRAY_SUPPORT
          ? ((this[e + 3] = t >>> 24),
            (this[e + 2] = t >>> 16),
            (this[e + 1] = t >>> 8),
            (this[e] = 255 & t))
          : Ad(this, t, e, !0),
        e + 4
      );
    }),
    (qu.prototype.writeUInt32BE = function (t, e, n) {
      return (
        (t = +t),
        (e |= 0),
        n || xd(this, t, e, 4, 4294967295, 0),
        qu.TYPED_ARRAY_SUPPORT
          ? ((this[e] = t >>> 24),
            (this[e + 1] = t >>> 16),
            (this[e + 2] = t >>> 8),
            (this[e + 3] = 255 & t))
          : Ad(this, t, e, !1),
        e + 4
      );
    }),
    (qu.prototype.writeIntLE = function (t, e, n, i) {
      if (((t = +t), (e |= 0), !i)) {
        var r = Math.pow(2, 8 * n - 1);
        xd(this, t, e, n, r - 1, -r);
      }
      var o = 0,
        s = 1,
        a = 0;
      for (this[e] = 255 & t; ++o < n && (s *= 256); )
        t < 0 && 0 === a && 0 !== this[e + o - 1] && (a = 1),
          (this[e + o] = (((t / s) >> 0) - a) & 255);
      return e + n;
    }),
    (qu.prototype.writeIntBE = function (t, e, n, i) {
      if (((t = +t), (e |= 0), !i)) {
        var r = Math.pow(2, 8 * n - 1);
        xd(this, t, e, n, r - 1, -r);
      }
      var o = n - 1,
        s = 1,
        a = 0;
      for (this[e + o] = 255 & t; --o >= 0 && (s *= 256); )
        t < 0 && 0 === a && 0 !== this[e + o + 1] && (a = 1),
          (this[e + o] = (((t / s) >> 0) - a) & 255);
      return e + n;
    }),
    (qu.prototype.writeInt8 = function (t, e, n) {
      return (
        (t = +t),
        (e |= 0),
        n || xd(this, t, e, 1, 127, -128),
        qu.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)),
        t < 0 && (t = 255 + t + 1),
        (this[e] = 255 & t),
        e + 1
      );
    }),
    (qu.prototype.writeInt16LE = function (t, e, n) {
      return (
        (t = +t),
        (e |= 0),
        n || xd(this, t, e, 2, 32767, -32768),
        qu.TYPED_ARRAY_SUPPORT
          ? ((this[e] = 255 & t), (this[e + 1] = t >>> 8))
          : wd(this, t, e, !0),
        e + 2
      );
    }),
    (qu.prototype.writeInt16BE = function (t, e, n) {
      return (
        (t = +t),
        (e |= 0),
        n || xd(this, t, e, 2, 32767, -32768),
        qu.TYPED_ARRAY_SUPPORT
          ? ((this[e] = t >>> 8), (this[e + 1] = 255 & t))
          : wd(this, t, e, !1),
        e + 2
      );
    }),
    (qu.prototype.writeInt32LE = function (t, e, n) {
      return (
        (t = +t),
        (e |= 0),
        n || xd(this, t, e, 4, 2147483647, -2147483648),
        qu.TYPED_ARRAY_SUPPORT
          ? ((this[e] = 255 & t),
            (this[e + 1] = t >>> 8),
            (this[e + 2] = t >>> 16),
            (this[e + 3] = t >>> 24))
          : Ad(this, t, e, !0),
        e + 4
      );
    }),
    (qu.prototype.writeInt32BE = function (t, e, n) {
      return (
        (t = +t),
        (e |= 0),
        n || xd(this, t, e, 4, 2147483647, -2147483648),
        t < 0 && (t = 4294967295 + t + 1),
        qu.TYPED_ARRAY_SUPPORT
          ? ((this[e] = t >>> 24),
            (this[e + 1] = t >>> 16),
            (this[e + 2] = t >>> 8),
            (this[e + 3] = 255 & t))
          : Ad(this, t, e, !1),
        e + 4
      );
    }),
    (qu.prototype.writeFloatLE = function (t, e, n) {
      return Sd(this, t, e, !0, n);
    }),
    (qu.prototype.writeFloatBE = function (t, e, n) {
      return Sd(this, t, e, !1, n);
    }),
    (qu.prototype.writeDoubleLE = function (t, e, n) {
      return Id(this, t, e, !0, n);
    }),
    (qu.prototype.writeDoubleBE = function (t, e, n) {
      return Id(this, t, e, !1, n);
    }),
    (qu.prototype.copy = function (t, e, n, i) {
      if (
        (n || (n = 0),
        i || 0 === i || (i = this.length),
        e >= t.length && (e = t.length),
        e || (e = 0),
        i > 0 && i < n && (i = n),
        i === n)
      )
        return 0;
      if (0 === t.length || 0 === this.length) return 0;
      if (e < 0) throw new RangeError('targetStart out of bounds');
      if (n < 0 || n >= this.length)
        throw new RangeError('sourceStart out of bounds');
      if (i < 0) throw new RangeError('sourceEnd out of bounds');
      i > this.length && (i = this.length),
        t.length - e < i - n && (i = t.length - e + n);
      var r,
        o = i - n;
      if (this === t && n < e && e < i)
        for (r = o - 1; r >= 0; --r) t[r + e] = this[r + n];
      else if (o < 1e3 || !qu.TYPED_ARRAY_SUPPORT)
        for (r = 0; r < o; ++r) t[r + e] = this[r + n];
      else Uint8Array.prototype.set.call(t, this.subarray(n, n + o), e);
      return o;
    }),
    (qu.prototype.fill = function (t, e, n, i) {
      if ('string' == typeof t) {
        if (
          ('string' == typeof e
            ? ((i = e), (e = 0), (n = this.length))
            : 'string' == typeof n && ((i = n), (n = this.length)),
          1 === t.length)
        ) {
          var r = t.charCodeAt(0);
          r < 256 && (t = r);
        }
        if (void 0 !== i && 'string' != typeof i)
          throw new TypeError('encoding must be a string');
        if ('string' == typeof i && !qu.isEncoding(i))
          throw new TypeError('Unknown encoding: ' + i);
      } else 'number' == typeof t && (t &= 255);
      if (e < 0 || this.length < e || this.length < n)
        throw new RangeError('Out of range index');
      if (n <= e) return this;
      var o;
      if (
        ((e >>>= 0),
        (n = void 0 === n ? this.length : n >>> 0),
        t || (t = 0),
        'number' == typeof t)
      )
        for (o = e; o < n; ++o) this[o] = t;
      else {
        var s = ed(t) ? t : Cd(new qu(t, i).toString()),
          a = s.length;
        for (o = 0; o < n - e; ++o) this[o + e] = s[o % a];
      }
      return this;
    });
  var Ed = /[^+\/0-9A-Za-z-_]/g;
  function Dd(t) {
    return t < 16 ? '0' + t.toString(16) : t.toString(16);
  }
  function Cd(t, e) {
    var n;
    e = e || 1 / 0;
    for (var i = t.length, r = null, o = [], s = 0; s < i; ++s) {
      if ((n = t.charCodeAt(s)) > 55295 && n < 57344) {
        if (!r) {
          if (n > 56319) {
            (e -= 3) > -1 && o.push(239, 191, 189);
            continue;
          }
          if (s + 1 === i) {
            (e -= 3) > -1 && o.push(239, 191, 189);
            continue;
          }
          r = n;
          continue;
        }
        if (n < 56320) {
          (e -= 3) > -1 && o.push(239, 191, 189), (r = n);
          continue;
        }
        n = 65536 + (((r - 55296) << 10) | (n - 56320));
      } else r && (e -= 3) > -1 && o.push(239, 191, 189);
      if (((r = null), n < 128)) {
        if ((e -= 1) < 0) break;
        o.push(n);
      } else if (n < 2048) {
        if ((e -= 2) < 0) break;
        o.push((n >> 6) | 192, (63 & n) | 128);
      } else if (n < 65536) {
        if ((e -= 3) < 0) break;
        o.push((n >> 12) | 224, ((n >> 6) & 63) | 128, (63 & n) | 128);
      } else {
        if (!(n < 1114112)) throw new Error('Invalid code point');
        if ((e -= 4) < 0) break;
        o.push(
          (n >> 18) | 240,
          ((n >> 12) & 63) | 128,
          ((n >> 6) & 63) | 128,
          (63 & n) | 128,
        );
      }
    }
    return o;
  }
  function Td(t) {
    return (function (t) {
      var e, n, i, r, o, s;
      ku || Uu();
      var a = t.length;
      if (a % 4 > 0)
        throw new Error('Invalid string. Length must be a multiple of 4');
      (o = '=' === t[a - 2] ? 2 : '=' === t[a - 1] ? 1 : 0),
        (s = new Nu((3 * a) / 4 - o)),
        (i = o > 0 ? a - 4 : a);
      var c = 0;
      for (e = 0, n = 0; e < i; e += 4, n += 3)
        (r =
          (Vu[t.charCodeAt(e)] << 18) |
          (Vu[t.charCodeAt(e + 1)] << 12) |
          (Vu[t.charCodeAt(e + 2)] << 6) |
          Vu[t.charCodeAt(e + 3)]),
          (s[c++] = (r >> 16) & 255),
          (s[c++] = (r >> 8) & 255),
          (s[c++] = 255 & r);
      return (
        2 === o
          ? ((r = (Vu[t.charCodeAt(e)] << 2) | (Vu[t.charCodeAt(e + 1)] >> 4)),
            (s[c++] = 255 & r))
          : 1 === o &&
            ((r =
              (Vu[t.charCodeAt(e)] << 10) |
              (Vu[t.charCodeAt(e + 1)] << 4) |
              (Vu[t.charCodeAt(e + 2)] >> 2)),
            (s[c++] = (r >> 8) & 255),
            (s[c++] = 255 & r)),
        s
      );
    })(
      (function (t) {
        if (
          (t = (function (t) {
            return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, '');
          })(t).replace(Ed, '')).length < 2
        )
          return '';
        for (; t.length % 4 != 0; ) t += '=';
        return t;
      })(t),
    );
  }
  function Ld(t, e, n, i) {
    for (var r = 0; r < i && !(r + n >= e.length || r >= t.length); ++r)
      e[r + n] = t[r];
    return r;
  }
  function Rd(t) {
    return (
      !!t.constructor &&
      'function' == typeof t.constructor.isBuffer &&
      t.constructor.isBuffer(t)
    );
  }
  function Fd() {
    throw new Error('setTimeout has not been defined');
  }
  function Pd() {
    throw new Error('clearTimeout has not been defined');
  }
  var Bd = Fd,
    Od = Pd;
  function Vd(t) {
    if (Bd === setTimeout) return setTimeout(t, 0);
    if ((Bd === Fd || !Bd) && setTimeout)
      return (Bd = setTimeout), setTimeout(t, 0);
    try {
      return Bd(t, 0);
    } catch (e) {
      try {
        return Bd.call(null, t, 0);
      } catch (e) {
        return Bd.call(this, t, 0);
      }
    }
  }
  'function' == typeof Bu.setTimeout && (Bd = setTimeout),
    'function' == typeof Bu.clearTimeout && (Od = clearTimeout);
  var Nd,
    kd = [],
    Ud = !1,
    Gd = -1;
  function zd() {
    Ud &&
      Nd &&
      ((Ud = !1),
      Nd.length ? (kd = Nd.concat(kd)) : (Gd = -1),
      kd.length && jd());
  }
  function jd() {
    if (!Ud) {
      var t = Vd(zd);
      Ud = !0;
      for (var e = kd.length; e; ) {
        for (Nd = kd, kd = []; ++Gd < e; ) Nd && Nd[Gd].run();
        (Gd = -1), (e = kd.length);
      }
      (Nd = null),
        (Ud = !1),
        (function (t) {
          if (Od === clearTimeout) return clearTimeout(t);
          if ((Od === Pd || !Od) && clearTimeout)
            return (Od = clearTimeout), clearTimeout(t);
          try {
            Od(t);
          } catch (e) {
            try {
              return Od.call(null, t);
            } catch (e) {
              return Od.call(this, t);
            }
          }
        })(t);
    }
  }
  function Hd(t, e) {
    (this.fun = t), (this.array = e);
  }
  Hd.prototype.run = function () {
    this.fun.apply(null, this.array);
  };
  function Wd() {}
  var Xd = Wd,
    Zd = Wd,
    Yd = Wd,
    qd = Wd,
    Qd = Wd,
    Jd = Wd,
    $d = Wd;
  var Kd = Bu.performance || {},
    tp =
      Kd.now ||
      Kd.mozNow ||
      Kd.msNow ||
      Kd.oNow ||
      Kd.webkitNow ||
      function () {
        return new Date().getTime();
      };
  var ep = new Date();
  var np = {
    nextTick: function (t) {
      var e = new Array(arguments.length - 1);
      if (arguments.length > 1)
        for (var n = 1; n < arguments.length; n++) e[n - 1] = arguments[n];
      kd.push(new Hd(t, e)), 1 !== kd.length || Ud || Vd(jd);
    },
    title: 'browser',
    browser: !0,
    env: {},
    argv: [],
    version: '',
    versions: {},
    on: Xd,
    addListener: Zd,
    once: Yd,
    off: qd,
    removeListener: Qd,
    removeAllListeners: Jd,
    emit: $d,
    binding: function (t) {
      throw new Error('process.binding is not supported');
    },
    cwd: function () {
      return '/';
    },
    chdir: function (t) {
      throw new Error('process.chdir is not supported');
    },
    umask: function () {
      return 0;
    },
    hrtime: function (t) {
      var e = 0.001 * tp.call(Kd),
        n = Math.floor(e),
        i = Math.floor((e % 1) * 1e9);
      return t && ((n -= t[0]), (i -= t[1]) < 0 && (n--, (i += 1e9))), [n, i];
    },
    platform: 'browser',
    release: {},
    config: {},
    uptime: function () {
      return (new Date() - ep) / 1e3;
    },
  };
  Object.create;
  function ip(t, e) {
    var n = { seen: [], stylize: op };
    return (
      arguments.length >= 3 && (n.depth = arguments[2]),
      arguments.length >= 4 && (n.colors = arguments[3]),
      hp(e) ? (n.showHidden = e) : e && xp(n, e),
      fp(n.showHidden) && (n.showHidden = !1),
      fp(n.depth) && (n.depth = 2),
      fp(n.colors) && (n.colors = !1),
      fp(n.customInspect) && (n.customInspect = !0),
      n.colors && (n.stylize = rp),
      sp(n, t, n.depth)
    );
  }
  function rp(t, e) {
    var n = ip.styles[e];
    return n
      ? '[' + ip.colors[n][0] + 'm' + t + '[' + ip.colors[n][1] + 'm'
      : t;
  }
  function op(t, e) {
    return t;
  }
  function sp(t, e, n) {
    if (
      t.customInspect &&
      e &&
      vp(e.inspect) &&
      e.inspect !== ip &&
      (!e.constructor || e.constructor.prototype !== e)
    ) {
      var i = e.inspect(n, t);
      return pp(i) || (i = sp(t, i, n)), i;
    }
    var r = (function (t, e) {
      if (fp(e)) return t.stylize('undefined', 'undefined');
      if (pp(e)) {
        var n =
          "'" +
          JSON.stringify(e)
            .replace(/^"|"$/g, '')
            .replace(/'/g, "\\'")
            .replace(/\\"/g, '"') +
          "'";
        return t.stylize(n, 'string');
      }
      if (dp(e)) return t.stylize('' + e, 'number');
      if (hp(e)) return t.stylize('' + e, 'boolean');
      if (up(e)) return t.stylize('null', 'null');
    })(t, e);
    if (r) return r;
    var o = Object.keys(e),
      s = (function (t) {
        var e = {};
        return (
          t.forEach(function (t, n) {
            e[t] = !0;
          }),
          e
        );
      })(o);
    if (
      (t.showHidden && (o = Object.getOwnPropertyNames(e)),
      yp(e) && (o.indexOf('message') >= 0 || o.indexOf('description') >= 0))
    )
      return ap(e);
    if (0 === o.length) {
      if (vp(e)) {
        var a = e.name ? ': ' + e.name : '';
        return t.stylize('[Function' + a + ']', 'special');
      }
      if (mp(e)) return t.stylize(RegExp.prototype.toString.call(e), 'regexp');
      if (gp(e)) return t.stylize(Date.prototype.toString.call(e), 'date');
      if (yp(e)) return ap(e);
    }
    var c,
      l = '',
      h = !1,
      u = ['{', '}'];
    (lp(e) && ((h = !0), (u = ['[', ']'])), vp(e)) &&
      (l = ' [Function' + (e.name ? ': ' + e.name : '') + ']');
    return (
      mp(e) && (l = ' ' + RegExp.prototype.toString.call(e)),
      gp(e) && (l = ' ' + Date.prototype.toUTCString.call(e)),
      yp(e) && (l = ' ' + ap(e)),
      0 !== o.length || (h && 0 != e.length)
        ? n < 0
          ? mp(e)
            ? t.stylize(RegExp.prototype.toString.call(e), 'regexp')
            : t.stylize('[Object]', 'special')
          : (t.seen.push(e),
            (c = h
              ? (function (t, e, n, i, r) {
                  for (var o = [], s = 0, a = e.length; s < a; ++s)
                    wp(e, String(s))
                      ? o.push(cp(t, e, n, i, String(s), !0))
                      : o.push('');
                  return (
                    r.forEach(function (r) {
                      r.match(/^\d+$/) || o.push(cp(t, e, n, i, r, !0));
                    }),
                    o
                  );
                })(t, e, n, s, o)
              : o.map(function (i) {
                  return cp(t, e, n, s, i, h);
                })),
            t.seen.pop(),
            (function (t, e, n) {
              if (
                t.reduce(function (t, e) {
                  return (
                    e.indexOf('\n'),
                    t + e.replace(/\u001b\[\d\d?m/g, '').length + 1
                  );
                }, 0) > 60
              )
                return (
                  n[0] +
                  ('' === e ? '' : e + '\n ') +
                  ' ' +
                  t.join(',\n  ') +
                  ' ' +
                  n[1]
                );
              return n[0] + e + ' ' + t.join(', ') + ' ' + n[1];
            })(c, l, u))
        : u[0] + l + u[1]
    );
  }
  function ap(t) {
    return '[' + Error.prototype.toString.call(t) + ']';
  }
  function cp(t, e, n, i, r, o) {
    var s, a, c;
    if (
      ((c = Object.getOwnPropertyDescriptor(e, r) || { value: e[r] }).get
        ? (a = c.set
            ? t.stylize('[Getter/Setter]', 'special')
            : t.stylize('[Getter]', 'special'))
        : c.set && (a = t.stylize('[Setter]', 'special')),
      wp(i, r) || (s = '[' + r + ']'),
      a ||
        (t.seen.indexOf(c.value) < 0
          ? (a = up(n) ? sp(t, c.value, null) : sp(t, c.value, n - 1)).indexOf(
              '\n',
            ) > -1 &&
            (a = o
              ? a
                  .split('\n')
                  .map(function (t) {
                    return '  ' + t;
                  })
                  .join('\n')
                  .substr(2)
              : '\n' +
                a
                  .split('\n')
                  .map(function (t) {
                    return '   ' + t;
                  })
                  .join('\n'))
          : (a = t.stylize('[Circular]', 'special'))),
      fp(s))
    ) {
      if (o && r.match(/^\d+$/)) return a;
      (s = JSON.stringify('' + r)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)
        ? ((s = s.substr(1, s.length - 2)), (s = t.stylize(s, 'name')))
        : ((s = s
            .replace(/'/g, "\\'")
            .replace(/\\"/g, '"')
            .replace(/(^"|"$)/g, "'")),
          (s = t.stylize(s, 'string')));
    }
    return s + ': ' + a;
  }
  function lp(t) {
    return Array.isArray(t);
  }
  function hp(t) {
    return 'boolean' == typeof t;
  }
  function up(t) {
    return null === t;
  }
  function dp(t) {
    return 'number' == typeof t;
  }
  function pp(t) {
    return 'string' == typeof t;
  }
  function fp(t) {
    return void 0 === t;
  }
  function mp(t) {
    return bp(t) && '[object RegExp]' === _p(t);
  }
  function bp(t) {
    return 'object' == typeof t && null !== t;
  }
  function gp(t) {
    return bp(t) && '[object Date]' === _p(t);
  }
  function yp(t) {
    return bp(t) && ('[object Error]' === _p(t) || t instanceof Error);
  }
  function vp(t) {
    return 'function' == typeof t;
  }
  function _p(t) {
    return Object.prototype.toString.call(t);
  }
  (ip.colors = {
    bold: [1, 22],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    white: [37, 39],
    grey: [90, 39],
    black: [30, 39],
    blue: [34, 39],
    cyan: [36, 39],
    green: [32, 39],
    magenta: [35, 39],
    red: [31, 39],
    yellow: [33, 39],
  }),
    (ip.styles = {
      special: 'cyan',
      number: 'yellow',
      boolean: 'yellow',
      undefined: 'grey',
      null: 'bold',
      string: 'green',
      date: 'magenta',
      regexp: 'red',
    });
  function xp(t, e) {
    if (!e || !bp(e)) return t;
    for (var n = Object.keys(e), i = n.length; i--; ) t[n[i]] = e[n[i]];
    return t;
  }
  function wp(t, e) {
    return Object.prototype.hasOwnProperty.call(t, e);
  }
  var Ap = ip,
    Mp = 'function' == typeof Map && Map.prototype,
    Sp =
      Object.getOwnPropertyDescriptor && Mp
        ? Object.getOwnPropertyDescriptor(Map.prototype, 'size')
        : null,
    Ip = Mp && Sp && 'function' == typeof Sp.get ? Sp.get : null,
    Ep = Mp && Map.prototype.forEach,
    Dp = 'function' == typeof Set && Set.prototype,
    Cp =
      Object.getOwnPropertyDescriptor && Dp
        ? Object.getOwnPropertyDescriptor(Set.prototype, 'size')
        : null,
    Tp = Dp && Cp && 'function' == typeof Cp.get ? Cp.get : null,
    Lp = Dp && Set.prototype.forEach,
    Rp =
      'function' == typeof WeakMap && WeakMap.prototype
        ? WeakMap.prototype.has
        : null,
    Fp =
      'function' == typeof WeakSet && WeakSet.prototype
        ? WeakSet.prototype.has
        : null,
    Pp =
      'function' == typeof WeakRef && WeakRef.prototype
        ? WeakRef.prototype.deref
        : null,
    Bp = Boolean.prototype.valueOf,
    Op = Object.prototype.toString,
    Vp = Function.prototype.toString,
    Np = String.prototype.match,
    kp = 'function' == typeof BigInt ? BigInt.prototype.valueOf : null,
    Up = Object.getOwnPropertySymbols,
    Gp =
      'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
        ? Symbol.prototype.toString
        : null,
    zp = 'function' == typeof Symbol && 'object' == typeof Symbol.iterator,
    jp = Object.prototype.propertyIsEnumerable,
    Hp =
      ('function' == typeof Reflect
        ? Reflect.getPrototypeOf
        : Object.getPrototypeOf) ||
      ([].__proto__ === Array.prototype
        ? function (t) {
            return t.__proto__;
          }
        : null),
    Wp = Ap.custom,
    Xp = Wp && $p(Wp) ? Wp : null,
    Zp =
      'function' == typeof Symbol && void 0 !== Symbol.toStringTag
        ? Symbol.toStringTag
        : null,
    Yp = function t(e, n, i, r) {
      var o = n || {};
      if (
        tf(o, 'quoteStyle') &&
        'single' !== o.quoteStyle &&
        'double' !== o.quoteStyle
      )
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
      if (
        tf(o, 'maxStringLength') &&
        ('number' == typeof o.maxStringLength
          ? o.maxStringLength < 0 && o.maxStringLength !== 1 / 0
          : null !== o.maxStringLength)
      )
        throw new TypeError(
          'option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`',
        );
      var s = !tf(o, 'customInspect') || o.customInspect;
      if ('boolean' != typeof s)
        throw new TypeError(
          'option "customInspect", if provided, must be `true` or `false`',
        );
      if (
        tf(o, 'indent') &&
        null !== o.indent &&
        '\t' !== o.indent &&
        !(parseInt(o.indent, 10) === o.indent && o.indent > 0)
      )
        throw new TypeError(
          'options "indent" must be "\\t", an integer > 0, or `null`',
        );
      if (void 0 === e) return 'undefined';
      if (null === e) return 'null';
      if ('boolean' == typeof e) return e ? 'true' : 'false';
      if ('string' == typeof e) return rf(e, o);
      if ('number' == typeof e)
        return 0 === e ? (1 / 0 / e > 0 ? '0' : '-0') : String(e);
      if ('bigint' == typeof e) return String(e) + 'n';
      var a = void 0 === o.depth ? 5 : o.depth;
      if ((void 0 === i && (i = 0), i >= a && a > 0 && 'object' == typeof e))
        return Jp(e) ? '[Array]' : '[Object]';
      var c = (function (t, e) {
        var n;
        if ('\t' === t.indent) n = '\t';
        else {
          if (!('number' == typeof t.indent && t.indent > 0)) return null;
          n = Array(t.indent + 1).join(' ');
        }
        return { base: n, prev: Array(e + 1).join(n) };
      })(o, i);
      if (void 0 === r) r = [];
      else if (nf(r, e) >= 0) return '[Circular]';
      function l(e, n, s) {
        if ((n && (r = r.slice()).push(n), s)) {
          var a = { depth: o.depth };
          return (
            tf(o, 'quoteStyle') && (a.quoteStyle = o.quoteStyle),
            t(e, a, i + 1, r)
          );
        }
        return t(e, o, i + 1, r);
      }
      if ('function' == typeof e) {
        var h = (function (t) {
            if (t.name) return t.name;
            var e = Np.call(Vp.call(t), /^function\s*([\w$]+)/);
            if (e) return e[1];
            return null;
          })(e),
          u = hf(e, l);
        return (
          '[Function' +
          (h ? ': ' + h : ' (anonymous)') +
          ']' +
          (u.length > 0 ? ' { ' + u.join(', ') + ' }' : '')
        );
      }
      if ($p(e)) {
        var d = zp
          ? String(e).replace(/^(Symbol\(.*\))_[^)]*$/, '$1')
          : Gp.call(e);
        return 'object' != typeof e || zp ? d : sf(d);
      }
      if (
        (function (t) {
          if (!t || 'object' != typeof t) return !1;
          if ('undefined' != typeof HTMLElement && t instanceof HTMLElement)
            return !0;
          return (
            'string' == typeof t.nodeName && 'function' == typeof t.getAttribute
          );
        })(e)
      ) {
        for (
          var p = '<' + String(e.nodeName).toLowerCase(),
            f = e.attributes || [],
            m = 0;
          m < f.length;
          m++
        )
          p += ' ' + f[m].name + '=' + qp(Qp(f[m].value), 'double', o);
        return (
          (p += '>'),
          e.childNodes && e.childNodes.length && (p += '...'),
          (p += '</' + String(e.nodeName).toLowerCase() + '>')
        );
      }
      if (Jp(e)) {
        if (0 === e.length) return '[]';
        var b = hf(e, l);
        return c &&
          !(function (t) {
            for (var e = 0; e < t.length; e++)
              if (nf(t[e], '\n') >= 0) return !1;
            return !0;
          })(b)
          ? '[' + lf(b, c) + ']'
          : '[ ' + b.join(', ') + ' ]';
      }
      if (
        (function (t) {
          return !(
            '[object Error]' !== ef(t) ||
            (Zp && 'object' == typeof t && Zp in t)
          );
        })(e)
      ) {
        var g = hf(e, l);
        return 0 === g.length
          ? '[' + String(e) + ']'
          : '{ [' + String(e) + '] ' + g.join(', ') + ' }';
      }
      if ('object' == typeof e && s) {
        if (Xp && 'function' == typeof e[Xp]) return e[Xp]();
        if ('function' == typeof e.inspect) return e.inspect();
      }
      if (
        (function (t) {
          if (!Ip || !t || 'object' != typeof t) return !1;
          try {
            Ip.call(t);
            try {
              Tp.call(t);
            } catch (t) {
              return !0;
            }
            return t instanceof Map;
          } catch (t) {}
          return !1;
        })(e)
      ) {
        var y = [];
        return (
          Ep.call(e, function (t, n) {
            y.push(l(n, e, !0) + ' => ' + l(t, e));
          }),
          cf('Map', Ip.call(e), y, c)
        );
      }
      if (
        (function (t) {
          if (!Tp || !t || 'object' != typeof t) return !1;
          try {
            Tp.call(t);
            try {
              Ip.call(t);
            } catch (t) {
              return !0;
            }
            return t instanceof Set;
          } catch (t) {}
          return !1;
        })(e)
      ) {
        var v = [];
        return (
          Lp.call(e, function (t) {
            v.push(l(t, e));
          }),
          cf('Set', Tp.call(e), v, c)
        );
      }
      if (
        (function (t) {
          if (!Rp || !t || 'object' != typeof t) return !1;
          try {
            Rp.call(t, Rp);
            try {
              Fp.call(t, Fp);
            } catch (t) {
              return !0;
            }
            return t instanceof WeakMap;
          } catch (t) {}
          return !1;
        })(e)
      )
        return af('WeakMap');
      if (
        (function (t) {
          if (!Fp || !t || 'object' != typeof t) return !1;
          try {
            Fp.call(t, Fp);
            try {
              Rp.call(t, Rp);
            } catch (t) {
              return !0;
            }
            return t instanceof WeakSet;
          } catch (t) {}
          return !1;
        })(e)
      )
        return af('WeakSet');
      if (
        (function (t) {
          if (!Pp || !t || 'object' != typeof t) return !1;
          try {
            return Pp.call(t), !0;
          } catch (t) {}
          return !1;
        })(e)
      )
        return af('WeakRef');
      if (
        (function (t) {
          return !(
            '[object Number]' !== ef(t) ||
            (Zp && 'object' == typeof t && Zp in t)
          );
        })(e)
      )
        return sf(l(Number(e)));
      if (
        (function (t) {
          if (!t || 'object' != typeof t || !kp) return !1;
          try {
            return kp.call(t), !0;
          } catch (t) {}
          return !1;
        })(e)
      )
        return sf(l(kp.call(e)));
      if (
        (function (t) {
          return !(
            '[object Boolean]' !== ef(t) ||
            (Zp && 'object' == typeof t && Zp in t)
          );
        })(e)
      )
        return sf(Bp.call(e));
      if (
        (function (t) {
          return !(
            '[object String]' !== ef(t) ||
            (Zp && 'object' == typeof t && Zp in t)
          );
        })(e)
      )
        return sf(l(String(e)));
      if (
        !(function (t) {
          return !(
            '[object Date]' !== ef(t) ||
            (Zp && 'object' == typeof t && Zp in t)
          );
        })(e) &&
        !(function (t) {
          return !(
            '[object RegExp]' !== ef(t) ||
            (Zp && 'object' == typeof t && Zp in t)
          );
        })(e)
      ) {
        var _ = hf(e, l),
          x = Hp
            ? Hp(e) === Object.prototype
            : e instanceof Object || e.constructor === Object,
          w = e instanceof Object ? '' : 'null prototype',
          A =
            !x && Zp && Object(e) === e && Zp in e
              ? ef(e).slice(8, -1)
              : w
              ? 'Object'
              : '',
          M =
            (x || 'function' != typeof e.constructor
              ? ''
              : e.constructor.name
              ? e.constructor.name + ' '
              : '') +
            (A || w ? '[' + [].concat(A || [], w || []).join(': ') + '] ' : '');
        return 0 === _.length
          ? M + '{}'
          : c
          ? M + '{' + lf(_, c) + '}'
          : M + '{ ' + _.join(', ') + ' }';
      }
      return String(e);
    };
  function qp(t, e, n) {
    var i = 'double' === (n.quoteStyle || e) ? '"' : "'";
    return i + t + i;
  }
  function Qp(t) {
    return String(t).replace(/"/g, '&quot;');
  }
  function Jp(t) {
    return !(
      '[object Array]' !== ef(t) ||
      (Zp && 'object' == typeof t && Zp in t)
    );
  }
  function $p(t) {
    if (zp) return t && 'object' == typeof t && t instanceof Symbol;
    if ('symbol' == typeof t) return !0;
    if (!t || 'object' != typeof t || !Gp) return !1;
    try {
      return Gp.call(t), !0;
    } catch (t) {}
    return !1;
  }
  var Kp =
    Object.prototype.hasOwnProperty ||
    function (t) {
      return t in this;
    };
  function tf(t, e) {
    return Kp.call(t, e);
  }
  function ef(t) {
    return Op.call(t);
  }
  function nf(t, e) {
    if (t.indexOf) return t.indexOf(e);
    for (var n = 0, i = t.length; n < i; n++) if (t[n] === e) return n;
    return -1;
  }
  function rf(t, e) {
    if (t.length > e.maxStringLength) {
      var n = t.length - e.maxStringLength,
        i = '... ' + n + ' more character' + (n > 1 ? 's' : '');
      return rf(t.slice(0, e.maxStringLength), e) + i;
    }
    return qp(
      t.replace(/(['\\])/g, '\\$1').replace(/[\x00-\x1f]/g, of),
      'single',
      e,
    );
  }
  function of(t) {
    var e = t.charCodeAt(0),
      n = { 8: 'b', 9: 't', 10: 'n', 12: 'f', 13: 'r' }[e];
    return n
      ? '\\' + n
      : '\\x' + (e < 16 ? '0' : '') + e.toString(16).toUpperCase();
  }
  function sf(t) {
    return 'Object(' + t + ')';
  }
  function af(t) {
    return t + ' { ? }';
  }
  function cf(t, e, n, i) {
    return t + ' (' + e + ') {' + (i ? lf(n, i) : n.join(', ')) + '}';
  }
  function lf(t, e) {
    if (0 === t.length) return '';
    var n = '\n' + e.prev + e.base;
    return n + t.join(',' + n) + '\n' + e.prev;
  }
  function hf(t, e) {
    var n = Jp(t),
      i = [];
    if (n) {
      i.length = t.length;
      for (var r = 0; r < t.length; r++) i[r] = tf(t, r) ? e(t[r], t) : '';
    }
    var o,
      s = 'function' == typeof Up ? Up(t) : [];
    if (zp) {
      o = {};
      for (var a = 0; a < s.length; a++) o['$' + s[a]] = s[a];
    }
    for (var c in t)
      tf(t, c) &&
        ((n && String(Number(c)) === c && c < t.length) ||
          (zp && o['$' + c] instanceof Symbol) ||
          (/[^\w$]/.test(c)
            ? i.push(e(c, t) + ': ' + e(t[c], t))
            : i.push(c + ': ' + e(t[c], t))));
    if ('function' == typeof Up)
      for (var l = 0; l < s.length; l++)
        jp.call(t, s[l]) && i.push('[' + e(s[l]) + ']: ' + e(t[s[l]], t));
    return i;
  }
  var uf = Tu('%TypeError%'),
    df = Tu('%WeakMap%', !0),
    pf = Tu('%Map%', !0),
    ff = Pu('WeakMap.prototype.get', !0),
    mf = Pu('WeakMap.prototype.set', !0),
    bf = Pu('WeakMap.prototype.has', !0),
    gf = Pu('Map.prototype.get', !0),
    yf = Pu('Map.prototype.set', !0),
    vf = Pu('Map.prototype.has', !0),
    _f = function (t, e) {
      for (var n, i = t; null !== (n = i.next); i = n)
        if (n.key === e)
          return (i.next = n.next), (n.next = t.next), (t.next = n), n;
    },
    xf = function () {
      var t,
        e,
        n,
        i = {
          assert: function (t) {
            if (!i.has(t))
              throw new uf('Side channel does not contain ' + Yp(t));
          },
          get: function (i) {
            if (df && i && ('object' == typeof i || 'function' == typeof i)) {
              if (t) return ff(t, i);
            } else if (pf) {
              if (e) return gf(e, i);
            } else if (n)
              return (function (t, e) {
                var n = _f(t, e);
                return n && n.value;
              })(n, i);
          },
          has: function (i) {
            if (df && i && ('object' == typeof i || 'function' == typeof i)) {
              if (t) return bf(t, i);
            } else if (pf) {
              if (e) return vf(e, i);
            } else if (n)
              return (function (t, e) {
                return !!_f(t, e);
              })(n, i);
            return !1;
          },
          set: function (i, r) {
            df && i && ('object' == typeof i || 'function' == typeof i)
              ? (t || (t = new df()), mf(t, i, r))
              : pf
              ? (e || (e = new pf()), yf(e, i, r))
              : (n || (n = { key: {}, next: null }),
                (function (t, e, n) {
                  var i = _f(t, e);
                  i
                    ? (i.value = n)
                    : (t.next = { key: e, next: t.next, value: n });
                })(n, i, r));
          },
        };
      return i;
    },
    wf = String.prototype.replace,
    Af = /%20/g,
    Mf = 'RFC3986',
    Sf = {
      default: Mf,
      formatters: {
        RFC1738: function (t) {
          return wf.call(t, Af, '+');
        },
        RFC3986: function (t) {
          return String(t);
        },
      },
      RFC1738: 'RFC1738',
      RFC3986: Mf,
    },
    If = Object.prototype.hasOwnProperty,
    Ef = Array.isArray,
    Df = (function () {
      for (var t = [], e = 0; e < 256; ++e)
        t.push('%' + ((e < 16 ? '0' : '') + e.toString(16)).toUpperCase());
      return t;
    })(),
    Cf = function (t, e) {
      for (
        var n = e && e.plainObjects ? Object.create(null) : {}, i = 0;
        i < t.length;
        ++i
      )
        void 0 !== t[i] && (n[i] = t[i]);
      return n;
    },
    Tf = {
      arrayToObject: Cf,
      assign: function (t, e) {
        return Object.keys(e).reduce(function (t, n) {
          return (t[n] = e[n]), t;
        }, t);
      },
      combine: function (t, e) {
        return [].concat(t, e);
      },
      compact: function (t) {
        for (
          var e = [{ obj: { o: t }, prop: 'o' }], n = [], i = 0;
          i < e.length;
          ++i
        )
          for (
            var r = e[i], o = r.obj[r.prop], s = Object.keys(o), a = 0;
            a < s.length;
            ++a
          ) {
            var c = s[a],
              l = o[c];
            'object' == typeof l &&
              null !== l &&
              -1 === n.indexOf(l) &&
              (e.push({ obj: o, prop: c }), n.push(l));
          }
        return (
          (function (t) {
            for (; t.length > 1; ) {
              var e = t.pop(),
                n = e.obj[e.prop];
              if (Ef(n)) {
                for (var i = [], r = 0; r < n.length; ++r)
                  void 0 !== n[r] && i.push(n[r]);
                e.obj[e.prop] = i;
              }
            }
          })(e),
          t
        );
      },
      decode: function (t, e, n) {
        var i = t.replace(/\+/g, ' ');
        if ('iso-8859-1' === n) return i.replace(/%[0-9a-f]{2}/gi, unescape);
        try {
          return decodeURIComponent(i);
        } catch (t) {
          return i;
        }
      },
      encode: function (t, e, n, i, r) {
        if (0 === t.length) return t;
        var o = t;
        if (
          ('symbol' == typeof t
            ? (o = Symbol.prototype.toString.call(t))
            : 'string' != typeof t && (o = String(t)),
          'iso-8859-1' === n)
        )
          return escape(o).replace(/%u[0-9a-f]{4}/gi, function (t) {
            return '%26%23' + parseInt(t.slice(2), 16) + '%3B';
          });
        for (var s = '', a = 0; a < o.length; ++a) {
          var c = o.charCodeAt(a);
          45 === c ||
          46 === c ||
          95 === c ||
          126 === c ||
          (c >= 48 && c <= 57) ||
          (c >= 65 && c <= 90) ||
          (c >= 97 && c <= 122) ||
          (r === Sf.RFC1738 && (40 === c || 41 === c))
            ? (s += o.charAt(a))
            : c < 128
            ? (s += Df[c])
            : c < 2048
            ? (s += Df[192 | (c >> 6)] + Df[128 | (63 & c)])
            : c < 55296 || c >= 57344
            ? (s +=
                Df[224 | (c >> 12)] +
                Df[128 | ((c >> 6) & 63)] +
                Df[128 | (63 & c)])
            : ((a += 1),
              (c = 65536 + (((1023 & c) << 10) | (1023 & o.charCodeAt(a)))),
              (s +=
                Df[240 | (c >> 18)] +
                Df[128 | ((c >> 12) & 63)] +
                Df[128 | ((c >> 6) & 63)] +
                Df[128 | (63 & c)]));
        }
        return s;
      },
      isBuffer: function (t) {
        return (
          !(!t || 'object' != typeof t) &&
          !!(
            t.constructor &&
            t.constructor.isBuffer &&
            t.constructor.isBuffer(t)
          )
        );
      },
      isRegExp: function (t) {
        return '[object RegExp]' === Object.prototype.toString.call(t);
      },
      maybeMap: function (t, e) {
        if (Ef(t)) {
          for (var n = [], i = 0; i < t.length; i += 1) n.push(e(t[i]));
          return n;
        }
        return e(t);
      },
      merge: function t(e, n, i) {
        if (!n) return e;
        if ('object' != typeof n) {
          if (Ef(e)) e.push(n);
          else {
            if (!e || 'object' != typeof e) return [e, n];
            ((i && (i.plainObjects || i.allowPrototypes)) ||
              !If.call(Object.prototype, n)) &&
              (e[n] = !0);
          }
          return e;
        }
        if (!e || 'object' != typeof e) return [e].concat(n);
        var r = e;
        return (
          Ef(e) && !Ef(n) && (r = Cf(e, i)),
          Ef(e) && Ef(n)
            ? (n.forEach(function (n, r) {
                if (If.call(e, r)) {
                  var o = e[r];
                  o && 'object' == typeof o && n && 'object' == typeof n
                    ? (e[r] = t(o, n, i))
                    : e.push(n);
                } else e[r] = n;
              }),
              e)
            : Object.keys(n).reduce(function (e, r) {
                var o = n[r];
                return If.call(e, r) ? (e[r] = t(e[r], o, i)) : (e[r] = o), e;
              }, r)
        );
      },
    },
    Lf = Object.prototype.hasOwnProperty,
    Rf = {
      brackets: function (t) {
        return t + '[]';
      },
      comma: 'comma',
      indices: function (t, e) {
        return t + '[' + e + ']';
      },
      repeat: function (t) {
        return t;
      },
    },
    Ff = Array.isArray,
    Pf = Array.prototype.push,
    Bf = function (t, e) {
      Pf.apply(t, Ff(e) ? e : [e]);
    },
    Of = Date.prototype.toISOString,
    Vf = Sf.default,
    Nf = {
      addQueryPrefix: !1,
      allowDots: !1,
      charset: 'utf-8',
      charsetSentinel: !1,
      delimiter: '&',
      encode: !0,
      encoder: Tf.encode,
      encodeValuesOnly: !1,
      format: Vf,
      formatter: Sf.formatters[Vf],
      indices: !1,
      serializeDate: function (t) {
        return Of.call(t);
      },
      skipNulls: !1,
      strictNullHandling: !1,
    },
    kf = function t(e, n, i, r, o, s, a, c, l, h, u, d, p, f, m) {
      var b = e;
      if (m.has(e)) throw new RangeError('Cyclic object value');
      if (
        ('function' == typeof a
          ? (b = a(n, b))
          : b instanceof Date
          ? (b = h(b))
          : 'comma' === i &&
            Ff(b) &&
            (b = Tf.maybeMap(b, function (t) {
              return t instanceof Date ? h(t) : t;
            })),
        null === b)
      ) {
        if (r) return s && !p ? s(n, Nf.encoder, f, 'key', u) : n;
        b = '';
      }
      if (
        (function (t) {
          return (
            'string' == typeof t ||
            'number' == typeof t ||
            'boolean' == typeof t ||
            'symbol' == typeof t ||
            'bigint' == typeof t
          );
        })(b) ||
        Tf.isBuffer(b)
      )
        return s
          ? [
              d(p ? n : s(n, Nf.encoder, f, 'key', u)) +
                '=' +
                d(s(b, Nf.encoder, f, 'value', u)),
            ]
          : [d(n) + '=' + d(String(b))];
      var g,
        y = [];
      if (void 0 === b) return y;
      if ('comma' === i && Ff(b))
        g = [{ value: b.length > 0 ? b.join(',') || null : void 0 }];
      else if (Ff(a)) g = a;
      else {
        var v = Object.keys(b);
        g = c ? v.sort(c) : v;
      }
      for (var _ = 0; _ < g.length; ++_) {
        var x = g[_],
          w = 'object' == typeof x && void 0 !== x.value ? x.value : b[x];
        if (!o || null !== w) {
          var A = Ff(b)
            ? 'function' == typeof i
              ? i(n, x)
              : n
            : n + (l ? '.' + x : '[' + x + ']');
          m.set(e, !0);
          var M = xf();
          Bf(y, t(w, A, i, r, o, s, a, c, l, h, u, d, p, f, M));
        }
      }
      return y;
    },
    Uf =
      (Object.prototype.hasOwnProperty,
      Array.isArray,
      function (t, e) {
        var n,
          i = t,
          r = (function (t) {
            if (!t) return Nf;
            if (
              null !== t.encoder &&
              void 0 !== t.encoder &&
              'function' != typeof t.encoder
            )
              throw new TypeError('Encoder has to be a function.');
            var e = t.charset || Nf.charset;
            if (
              void 0 !== t.charset &&
              'utf-8' !== t.charset &&
              'iso-8859-1' !== t.charset
            )
              throw new TypeError(
                'The charset option must be either utf-8, iso-8859-1, or undefined',
              );
            var n = Sf.default;
            if (void 0 !== t.format) {
              if (!Lf.call(Sf.formatters, t.format))
                throw new TypeError('Unknown format option provided.');
              n = t.format;
            }
            var i = Sf.formatters[n],
              r = Nf.filter;
            return (
              ('function' == typeof t.filter || Ff(t.filter)) && (r = t.filter),
              {
                addQueryPrefix:
                  'boolean' == typeof t.addQueryPrefix
                    ? t.addQueryPrefix
                    : Nf.addQueryPrefix,
                allowDots:
                  void 0 === t.allowDots ? Nf.allowDots : !!t.allowDots,
                charset: e,
                charsetSentinel:
                  'boolean' == typeof t.charsetSentinel
                    ? t.charsetSentinel
                    : Nf.charsetSentinel,
                delimiter: void 0 === t.delimiter ? Nf.delimiter : t.delimiter,
                encode: 'boolean' == typeof t.encode ? t.encode : Nf.encode,
                encoder:
                  'function' == typeof t.encoder ? t.encoder : Nf.encoder,
                encodeValuesOnly:
                  'boolean' == typeof t.encodeValuesOnly
                    ? t.encodeValuesOnly
                    : Nf.encodeValuesOnly,
                filter: r,
                format: n,
                formatter: i,
                serializeDate:
                  'function' == typeof t.serializeDate
                    ? t.serializeDate
                    : Nf.serializeDate,
                skipNulls:
                  'boolean' == typeof t.skipNulls ? t.skipNulls : Nf.skipNulls,
                sort: 'function' == typeof t.sort ? t.sort : null,
                strictNullHandling:
                  'boolean' == typeof t.strictNullHandling
                    ? t.strictNullHandling
                    : Nf.strictNullHandling,
              }
            );
          })(e);
        'function' == typeof r.filter
          ? (i = (0, r.filter)('', i))
          : Ff(r.filter) && (n = r.filter);
        var o,
          s = [];
        if ('object' != typeof i || null === i) return '';
        o =
          e && e.arrayFormat in Rf
            ? e.arrayFormat
            : e && 'indices' in e
            ? e.indices
              ? 'indices'
              : 'repeat'
            : 'indices';
        var a = Rf[o];
        n || (n = Object.keys(i)), r.sort && n.sort(r.sort);
        for (var c = xf(), l = 0; l < n.length; ++l) {
          var h = n[l];
          (r.skipNulls && null === i[h]) ||
            Bf(
              s,
              kf(
                i[h],
                h,
                a,
                r.strictNullHandling,
                r.skipNulls,
                r.encode ? r.encoder : null,
                r.filter,
                r.sort,
                r.allowDots,
                r.serializeDate,
                r.format,
                r.formatter,
                r.encodeValuesOnly,
                r.charset,
                c,
              ),
            );
        }
        var u = s.join(r.delimiter),
          d = !0 === r.addQueryPrefix ? '?' : '';
        return (
          r.charsetSentinel &&
            ('iso-8859-1' === r.charset
              ? (d += 'utf8=%26%2310003%3B&')
              : (d += 'utf8=%E2%9C%93&')),
          u.length > 0 ? d + u : ''
        );
      }),
    Gf = Lu(function (t, e) {
      !(function (e, n) {
        t.exports = n();
      })(0, function () {
        return (function (t) {
          var e = {};
          function n(i) {
            if (e[i]) return e[i].exports;
            var r = (e[i] = { exports: {}, id: i, loaded: !1 });
            return (
              t[i].call(r.exports, r, r.exports, n), (r.loaded = !0), r.exports
            );
          }
          return (n.m = t), (n.c = e), (n.p = ''), n(0);
        })([
          function (t, e, n) {
            t.exports = n(1);
          },
          function (t, e, n) {
            var i = n(2),
              r = n(3),
              o = n(4),
              s = n(22);
            function a(t) {
              var e = new o(t),
                n = r(o.prototype.request, e);
              return i.extend(n, o.prototype, e), i.extend(n, e), n;
            }
            var c = a(n(10));
            (c.Axios = o),
              (c.create = function (t) {
                return a(s(c.defaults, t));
              }),
              (c.Cancel = n(23)),
              (c.CancelToken = n(24)),
              (c.isCancel = n(9)),
              (c.all = function (t) {
                return Promise.all(t);
              }),
              (c.spread = n(25)),
              (t.exports = c),
              (t.exports.default = c);
          },
          function (t, e, n) {
            var i = n(3),
              r = Object.prototype.toString;
            function o(t) {
              return '[object Array]' === r.call(t);
            }
            function s(t) {
              return void 0 === t;
            }
            function a(t) {
              return null !== t && 'object' == typeof t;
            }
            function c(t) {
              return '[object Function]' === r.call(t);
            }
            function l(t, e) {
              if (null != t)
                if (('object' != typeof t && (t = [t]), o(t)))
                  for (var n = 0, i = t.length; n < i; n++)
                    e.call(null, t[n], n, t);
                else
                  for (var r in t)
                    Object.prototype.hasOwnProperty.call(t, r) &&
                      e.call(null, t[r], r, t);
            }
            t.exports = {
              isArray: o,
              isArrayBuffer: function (t) {
                return '[object ArrayBuffer]' === r.call(t);
              },
              isBuffer: function (t) {
                return (
                  null !== t &&
                  !s(t) &&
                  null !== t.constructor &&
                  !s(t.constructor) &&
                  'function' == typeof t.constructor.isBuffer &&
                  t.constructor.isBuffer(t)
                );
              },
              isFormData: function (t) {
                return 'undefined' != typeof FormData && t instanceof FormData;
              },
              isArrayBufferView: function (t) {
                return 'undefined' != typeof ArrayBuffer && ArrayBuffer.isView
                  ? ArrayBuffer.isView(t)
                  : t && t.buffer && t.buffer instanceof ArrayBuffer;
              },
              isString: function (t) {
                return 'string' == typeof t;
              },
              isNumber: function (t) {
                return 'number' == typeof t;
              },
              isObject: a,
              isUndefined: s,
              isDate: function (t) {
                return '[object Date]' === r.call(t);
              },
              isFile: function (t) {
                return '[object File]' === r.call(t);
              },
              isBlob: function (t) {
                return '[object Blob]' === r.call(t);
              },
              isFunction: c,
              isStream: function (t) {
                return a(t) && c(t.pipe);
              },
              isURLSearchParams: function (t) {
                return (
                  'undefined' != typeof URLSearchParams &&
                  t instanceof URLSearchParams
                );
              },
              isStandardBrowserEnv: function () {
                return (
                  ('undefined' == typeof navigator ||
                    ('ReactNative' !== navigator.product &&
                      'NativeScript' !== navigator.product &&
                      'NS' !== navigator.product)) &&
                  'undefined' != typeof window &&
                  'undefined' != typeof document
                );
              },
              forEach: l,
              merge: function t() {
                var e = {};
                function n(n, i) {
                  'object' == typeof e[i] && 'object' == typeof n
                    ? (e[i] = t(e[i], n))
                    : (e[i] = n);
                }
                for (var i = 0, r = arguments.length; i < r; i++)
                  l(arguments[i], n);
                return e;
              },
              deepMerge: function t() {
                var e = {};
                function n(n, i) {
                  'object' == typeof e[i] && 'object' == typeof n
                    ? (e[i] = t(e[i], n))
                    : (e[i] = 'object' == typeof n ? t({}, n) : n);
                }
                for (var i = 0, r = arguments.length; i < r; i++)
                  l(arguments[i], n);
                return e;
              },
              extend: function (t, e, n) {
                return (
                  l(e, function (e, r) {
                    t[r] = n && 'function' == typeof e ? i(e, n) : e;
                  }),
                  t
                );
              },
              trim: function (t) {
                return t.replace(/^\s*/, '').replace(/\s*$/, '');
              },
            };
          },
          function (t, e) {
            t.exports = function (t, e) {
              return function () {
                for (
                  var n = new Array(arguments.length), i = 0;
                  i < n.length;
                  i++
                )
                  n[i] = arguments[i];
                return t.apply(e, n);
              };
            };
          },
          function (t, e, n) {
            var i = n(2),
              r = n(5),
              o = n(6),
              s = n(7),
              a = n(22);
            function c(t) {
              (this.defaults = t),
                (this.interceptors = { request: new o(), response: new o() });
            }
            (c.prototype.request = function (t) {
              'string' == typeof t
                ? ((t = arguments[1] || {}).url = arguments[0])
                : (t = t || {}),
                (t = a(this.defaults, t)).method
                  ? (t.method = t.method.toLowerCase())
                  : this.defaults.method
                  ? (t.method = this.defaults.method.toLowerCase())
                  : (t.method = 'get');
              var e = [s, void 0],
                n = Promise.resolve(t);
              for (
                this.interceptors.request.forEach(function (t) {
                  e.unshift(t.fulfilled, t.rejected);
                }),
                  this.interceptors.response.forEach(function (t) {
                    e.push(t.fulfilled, t.rejected);
                  });
                e.length;

              )
                n = n.then(e.shift(), e.shift());
              return n;
            }),
              (c.prototype.getUri = function (t) {
                return (
                  (t = a(this.defaults, t)),
                  r(t.url, t.params, t.paramsSerializer).replace(/^\?/, '')
                );
              }),
              i.forEach(['delete', 'get', 'head', 'options'], function (t) {
                c.prototype[t] = function (e, n) {
                  return this.request(i.merge(n || {}, { method: t, url: e }));
                };
              }),
              i.forEach(['post', 'put', 'patch'], function (t) {
                c.prototype[t] = function (e, n, r) {
                  return this.request(
                    i.merge(r || {}, { method: t, url: e, data: n }),
                  );
                };
              }),
              (t.exports = c);
          },
          function (t, e, n) {
            var i = n(2);
            function r(t) {
              return encodeURIComponent(t)
                .replace(/%40/gi, '@')
                .replace(/%3A/gi, ':')
                .replace(/%24/g, '$')
                .replace(/%2C/gi, ',')
                .replace(/%20/g, '+')
                .replace(/%5B/gi, '[')
                .replace(/%5D/gi, ']');
            }
            t.exports = function (t, e, n) {
              if (!e) return t;
              var o;
              if (n) o = n(e);
              else if (i.isURLSearchParams(e)) o = e.toString();
              else {
                var s = [];
                i.forEach(e, function (t, e) {
                  null != t &&
                    (i.isArray(t) ? (e += '[]') : (t = [t]),
                    i.forEach(t, function (t) {
                      i.isDate(t)
                        ? (t = t.toISOString())
                        : i.isObject(t) && (t = JSON.stringify(t)),
                        s.push(r(e) + '=' + r(t));
                    }));
                }),
                  (o = s.join('&'));
              }
              if (o) {
                var a = t.indexOf('#');
                -1 !== a && (t = t.slice(0, a)),
                  (t += (-1 === t.indexOf('?') ? '?' : '&') + o);
              }
              return t;
            };
          },
          function (t, e, n) {
            var i = n(2);
            function r() {
              this.handlers = [];
            }
            (r.prototype.use = function (t, e) {
              return (
                this.handlers.push({ fulfilled: t, rejected: e }),
                this.handlers.length - 1
              );
            }),
              (r.prototype.eject = function (t) {
                this.handlers[t] && (this.handlers[t] = null);
              }),
              (r.prototype.forEach = function (t) {
                i.forEach(this.handlers, function (e) {
                  null !== e && t(e);
                });
              }),
              (t.exports = r);
          },
          function (t, e, n) {
            var i = n(2),
              r = n(8),
              o = n(9),
              s = n(10);
            function a(t) {
              t.cancelToken && t.cancelToken.throwIfRequested();
            }
            t.exports = function (t) {
              return (
                a(t),
                (t.headers = t.headers || {}),
                (t.data = r(t.data, t.headers, t.transformRequest)),
                (t.headers = i.merge(
                  t.headers.common || {},
                  t.headers[t.method] || {},
                  t.headers,
                )),
                i.forEach(
                  ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
                  function (e) {
                    delete t.headers[e];
                  },
                ),
                (t.adapter || s.adapter)(t).then(
                  function (e) {
                    return (
                      a(t),
                      (e.data = r(e.data, e.headers, t.transformResponse)),
                      e
                    );
                  },
                  function (e) {
                    return (
                      o(e) ||
                        (a(t),
                        e &&
                          e.response &&
                          (e.response.data = r(
                            e.response.data,
                            e.response.headers,
                            t.transformResponse,
                          ))),
                      Promise.reject(e)
                    );
                  },
                )
              );
            };
          },
          function (t, e, n) {
            var i = n(2);
            t.exports = function (t, e, n) {
              return (
                i.forEach(n, function (n) {
                  t = n(t, e);
                }),
                t
              );
            };
          },
          function (t, e) {
            t.exports = function (t) {
              return !(!t || !t.__CANCEL__);
            };
          },
          function (t, e, n) {
            var i = n(2),
              r = n(11),
              o = { 'Content-Type': 'application/x-www-form-urlencoded' };
            function s(t, e) {
              !i.isUndefined(t) &&
                i.isUndefined(t['Content-Type']) &&
                (t['Content-Type'] = e);
            }
            var a,
              c = {
                adapter:
                  (('undefined' != typeof XMLHttpRequest ||
                    (void 0 !== np &&
                      '[object process]' ===
                        Object.prototype.toString.call(np))) &&
                    (a = n(12)),
                  a),
                transformRequest: [
                  function (t, e) {
                    return (
                      r(e, 'Accept'),
                      r(e, 'Content-Type'),
                      i.isFormData(t) ||
                      i.isArrayBuffer(t) ||
                      i.isBuffer(t) ||
                      i.isStream(t) ||
                      i.isFile(t) ||
                      i.isBlob(t)
                        ? t
                        : i.isArrayBufferView(t)
                        ? t.buffer
                        : i.isURLSearchParams(t)
                        ? (s(
                            e,
                            'application/x-www-form-urlencoded;charset=utf-8',
                          ),
                          t.toString())
                        : i.isObject(t)
                        ? (s(e, 'application/json;charset=utf-8'),
                          JSON.stringify(t))
                        : t
                    );
                  },
                ],
                transformResponse: [
                  function (t) {
                    if ('string' == typeof t)
                      try {
                        t = JSON.parse(t);
                      } catch (t) {}
                    return t;
                  },
                ],
                timeout: 0,
                xsrfCookieName: 'XSRF-TOKEN',
                xsrfHeaderName: 'X-XSRF-TOKEN',
                maxContentLength: -1,
                validateStatus: function (t) {
                  return t >= 200 && t < 300;
                },
              };
            (c.headers = {
              common: { Accept: 'application/json, text/plain, */*' },
            }),
              i.forEach(['delete', 'get', 'head'], function (t) {
                c.headers[t] = {};
              }),
              i.forEach(['post', 'put', 'patch'], function (t) {
                c.headers[t] = i.merge(o);
              }),
              (t.exports = c);
          },
          function (t, e, n) {
            var i = n(2);
            t.exports = function (t, e) {
              i.forEach(t, function (n, i) {
                i !== e &&
                  i.toUpperCase() === e.toUpperCase() &&
                  ((t[e] = n), delete t[i]);
              });
            };
          },
          function (t, e, n) {
            var i = n(2),
              r = n(13),
              o = n(5),
              s = n(16),
              a = n(19),
              c = n(20),
              l = n(14);
            t.exports = function (t) {
              return new Promise(function (e, h) {
                var u = t.data,
                  d = t.headers;
                i.isFormData(u) && delete d['Content-Type'];
                var p = new XMLHttpRequest();
                if (t.auth) {
                  var f = t.auth.username || '',
                    m = t.auth.password || '';
                  d.Authorization = 'Basic ' + btoa(f + ':' + m);
                }
                var b = s(t.baseURL, t.url);
                if (
                  (p.open(
                    t.method.toUpperCase(),
                    o(b, t.params, t.paramsSerializer),
                    !0,
                  ),
                  (p.timeout = t.timeout),
                  (p.onreadystatechange = function () {
                    if (
                      p &&
                      4 === p.readyState &&
                      (0 !== p.status ||
                        (p.responseURL && 0 === p.responseURL.indexOf('file:')))
                    ) {
                      var n =
                          'getAllResponseHeaders' in p
                            ? a(p.getAllResponseHeaders())
                            : null,
                        i = {
                          data:
                            t.responseType && 'text' !== t.responseType
                              ? p.response
                              : p.responseText,
                          status: p.status,
                          statusText: p.statusText,
                          headers: n,
                          config: t,
                          request: p,
                        };
                      r(e, h, i), (p = null);
                    }
                  }),
                  (p.onabort = function () {
                    p &&
                      (h(l('Request aborted', t, 'ECONNABORTED', p)),
                      (p = null));
                  }),
                  (p.onerror = function () {
                    h(l('Network Error', t, null, p)), (p = null);
                  }),
                  (p.ontimeout = function () {
                    var e = 'timeout of ' + t.timeout + 'ms exceeded';
                    t.timeoutErrorMessage && (e = t.timeoutErrorMessage),
                      h(l(e, t, 'ECONNABORTED', p)),
                      (p = null);
                  }),
                  i.isStandardBrowserEnv())
                ) {
                  var g = n(21),
                    y =
                      (t.withCredentials || c(b)) && t.xsrfCookieName
                        ? g.read(t.xsrfCookieName)
                        : void 0;
                  y && (d[t.xsrfHeaderName] = y);
                }
                if (
                  ('setRequestHeader' in p &&
                    i.forEach(d, function (t, e) {
                      void 0 === u && 'content-type' === e.toLowerCase()
                        ? delete d[e]
                        : p.setRequestHeader(e, t);
                    }),
                  i.isUndefined(t.withCredentials) ||
                    (p.withCredentials = !!t.withCredentials),
                  t.responseType)
                )
                  try {
                    p.responseType = t.responseType;
                  } catch (e) {
                    if ('json' !== t.responseType) throw e;
                  }
                'function' == typeof t.onDownloadProgress &&
                  p.addEventListener('progress', t.onDownloadProgress),
                  'function' == typeof t.onUploadProgress &&
                    p.upload &&
                    p.upload.addEventListener('progress', t.onUploadProgress),
                  t.cancelToken &&
                    t.cancelToken.promise.then(function (t) {
                      p && (p.abort(), h(t), (p = null));
                    }),
                  void 0 === u && (u = null),
                  p.send(u);
              });
            };
          },
          function (t, e, n) {
            var i = n(14);
            t.exports = function (t, e, n) {
              var r = n.config.validateStatus;
              !r || r(n.status)
                ? t(n)
                : e(
                    i(
                      'Request failed with status code ' + n.status,
                      n.config,
                      null,
                      n.request,
                      n,
                    ),
                  );
            };
          },
          function (t, e, n) {
            var i = n(15);
            t.exports = function (t, e, n, r, o) {
              var s = new Error(t);
              return i(s, e, n, r, o);
            };
          },
          function (t, e) {
            t.exports = function (t, e, n, i, r) {
              return (
                (t.config = e),
                n && (t.code = n),
                (t.request = i),
                (t.response = r),
                (t.isAxiosError = !0),
                (t.toJSON = function () {
                  return {
                    message: this.message,
                    name: this.name,
                    description: this.description,
                    number: this.number,
                    fileName: this.fileName,
                    lineNumber: this.lineNumber,
                    columnNumber: this.columnNumber,
                    stack: this.stack,
                    config: this.config,
                    code: this.code,
                  };
                }),
                t
              );
            };
          },
          function (t, e, n) {
            var i = n(17),
              r = n(18);
            t.exports = function (t, e) {
              return t && !i(e) ? r(t, e) : e;
            };
          },
          function (t, e) {
            t.exports = function (t) {
              return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(t);
            };
          },
          function (t, e) {
            t.exports = function (t, e) {
              return e
                ? t.replace(/\/+$/, '') + '/' + e.replace(/^\/+/, '')
                : t;
            };
          },
          function (t, e, n) {
            var i = n(2),
              r = [
                'age',
                'authorization',
                'content-length',
                'content-type',
                'etag',
                'expires',
                'from',
                'host',
                'if-modified-since',
                'if-unmodified-since',
                'last-modified',
                'location',
                'max-forwards',
                'proxy-authorization',
                'referer',
                'retry-after',
                'user-agent',
              ];
            t.exports = function (t) {
              var e,
                n,
                o,
                s = {};
              return t
                ? (i.forEach(t.split('\n'), function (t) {
                    if (
                      ((o = t.indexOf(':')),
                      (e = i.trim(t.substr(0, o)).toLowerCase()),
                      (n = i.trim(t.substr(o + 1))),
                      e)
                    ) {
                      if (s[e] && r.indexOf(e) >= 0) return;
                      s[e] =
                        'set-cookie' === e
                          ? (s[e] ? s[e] : []).concat([n])
                          : s[e]
                          ? s[e] + ', ' + n
                          : n;
                    }
                  }),
                  s)
                : s;
            };
          },
          function (t, e, n) {
            var i = n(2);
            t.exports = i.isStandardBrowserEnv()
              ? (function () {
                  var t,
                    e = /(msie|trident)/i.test(navigator.userAgent),
                    n = document.createElement('a');
                  function r(t) {
                    var i = t;
                    return (
                      e && (n.setAttribute('href', i), (i = n.href)),
                      n.setAttribute('href', i),
                      {
                        href: n.href,
                        protocol: n.protocol
                          ? n.protocol.replace(/:$/, '')
                          : '',
                        host: n.host,
                        search: n.search ? n.search.replace(/^\?/, '') : '',
                        hash: n.hash ? n.hash.replace(/^#/, '') : '',
                        hostname: n.hostname,
                        port: n.port,
                        pathname:
                          '/' === n.pathname.charAt(0)
                            ? n.pathname
                            : '/' + n.pathname,
                      }
                    );
                  }
                  return (
                    (t = r(window.location.href)),
                    function (e) {
                      var n = i.isString(e) ? r(e) : e;
                      return n.protocol === t.protocol && n.host === t.host;
                    }
                  );
                })()
              : function () {
                  return !0;
                };
          },
          function (t, e, n) {
            var i = n(2);
            t.exports = i.isStandardBrowserEnv()
              ? {
                  write: function (t, e, n, r, o, s) {
                    var a = [];
                    a.push(t + '=' + encodeURIComponent(e)),
                      i.isNumber(n) &&
                        a.push('expires=' + new Date(n).toGMTString()),
                      i.isString(r) && a.push('path=' + r),
                      i.isString(o) && a.push('domain=' + o),
                      !0 === s && a.push('secure'),
                      (document.cookie = a.join('; '));
                  },
                  read: function (t) {
                    var e = document.cookie.match(
                      new RegExp('(^|;\\s*)(' + t + ')=([^;]*)'),
                    );
                    return e ? decodeURIComponent(e[3]) : null;
                  },
                  remove: function (t) {
                    this.write(t, '', Date.now() - 864e5);
                  },
                }
              : {
                  write: function () {},
                  read: function () {
                    return null;
                  },
                  remove: function () {},
                };
          },
          function (t, e, n) {
            var i = n(2);
            t.exports = function (t, e) {
              e = e || {};
              var n = {},
                r = ['url', 'method', 'params', 'data'],
                o = ['headers', 'auth', 'proxy'],
                s = [
                  'baseURL',
                  'url',
                  'transformRequest',
                  'transformResponse',
                  'paramsSerializer',
                  'timeout',
                  'withCredentials',
                  'adapter',
                  'responseType',
                  'xsrfCookieName',
                  'xsrfHeaderName',
                  'onUploadProgress',
                  'onDownloadProgress',
                  'maxContentLength',
                  'validateStatus',
                  'maxRedirects',
                  'httpAgent',
                  'httpsAgent',
                  'cancelToken',
                  'socketPath',
                ];
              i.forEach(r, function (t) {
                void 0 !== e[t] && (n[t] = e[t]);
              }),
                i.forEach(o, function (r) {
                  i.isObject(e[r])
                    ? (n[r] = i.deepMerge(t[r], e[r]))
                    : void 0 !== e[r]
                    ? (n[r] = e[r])
                    : i.isObject(t[r])
                    ? (n[r] = i.deepMerge(t[r]))
                    : void 0 !== t[r] && (n[r] = t[r]);
                }),
                i.forEach(s, function (i) {
                  void 0 !== e[i]
                    ? (n[i] = e[i])
                    : void 0 !== t[i] && (n[i] = t[i]);
                });
              var a = r.concat(o).concat(s),
                c = Object.keys(e).filter(function (t) {
                  return -1 === a.indexOf(t);
                });
              return (
                i.forEach(c, function (i) {
                  void 0 !== e[i]
                    ? (n[i] = e[i])
                    : void 0 !== t[i] && (n[i] = t[i]);
                }),
                n
              );
            };
          },
          function (t, e) {
            function n(t) {
              this.message = t;
            }
            (n.prototype.toString = function () {
              return 'Cancel' + (this.message ? ': ' + this.message : '');
            }),
              (n.prototype.__CANCEL__ = !0),
              (t.exports = n);
          },
          function (t, e, n) {
            var i = n(23);
            function r(t) {
              if ('function' != typeof t)
                throw new TypeError('executor must be a function.');
              var e;
              this.promise = new Promise(function (t) {
                e = t;
              });
              var n = this;
              t(function (t) {
                n.reason || ((n.reason = new i(t)), e(n.reason));
              });
            }
            (r.prototype.throwIfRequested = function () {
              if (this.reason) throw this.reason;
            }),
              (r.source = function () {
                var t;
                return {
                  token: new r(function (e) {
                    t = e;
                  }),
                  cancel: t,
                };
              }),
              (t.exports = r);
          },
          function (t, e) {
            t.exports = function (t) {
              return function (e) {
                return t.apply(null, e);
              };
            };
          },
        ]);
      });
    });
  (Gf.defaults.headers['X-Requested-With'] = 'XMLHttpRequest'),
    (Gf.defaults.headers.Accept = 'application/json');
  let zf = {
    camera: null,
    scene: null,
    scene2: null,
    renderer: null,
    raycaster: null,
    raycasterTarget: { x: 0, y: 0 },
    jumpHotArray: [],
    pageTimer: {},
    isUserInteracting: !1,
    initX: 0,
    initY: 0,
    scaleStart: [],
    onMouseDownMouseX: 0,
    onMouseDownMouseY: 0,
    lon: 0,
    onMouseDownLon: 0,
    lat: 0,
    onMouseDownLat: 0,
    phi: 0,
    theta: 0,
    rect: null,
    panoramaMaterialMap: new Map(),
    jumpHotMaterialMap: new Map(),
  };
  function jf(t, e) {
    (this.options = e),
      (this.dom = t),
      (this.panoramaFile = { fileJson: [], cloudUrl: '' }),
      (this.isNew = !1),
      (this.panorama = null),
      (this.box = null),
      (this.jumpHot = null),
      (this.panoramaImg = null),
      (this.panoramaId = null),
      (this.panoramaErrorMsg = '');
  }
  jf.prototype = Object.assign(Object.create(e.prototype), {
    constructor: jf,
    run() {
      if (!this.options.urlIp || !this.options.versionId) return !1;
      var t;
      (t = this.dom),
        jh(Xh`<${Kh} />`, t),
        $h(this.dom.ownerDocument.getElementById('ccbim__panoramaLoading'), !0);
      let e = {};
      (e.versionId = this.options.versionId),
        Gf({
          method: 'post',
          url: `${this.options.urlIp}/front/bimfile/modelConstructInfoCors.htm`,
          data: Uf(e),
        }).then((t) => {
          let { data: e } = t;
          if (e.success) {
            if (0 === e.result.jsons.length)
              return (
                (this.panoramaErrorMsg = '全景未转换完成'),
                $h(
                  this.dom.ownerDocument.getElementById(
                    'ccbim__panoramaLoading',
                  ),
                  !1,
                ),
                void Qh(
                  this.dom.ownerDocument.getElementById(
                    'ccbim__panoramaErrorMsg',
                  ),
                  this.panoramaErrorMsg,
                )
              );
            (this.panoramaFile.fileJson = e.result.jsons),
              this.loadPanoramaInfo();
          } else
            (this.panoramaErrorMsg = e.errorMsg),
              $h(
                this.dom.ownerDocument.getElementById('ccbim__panoramaLoading'),
                !1,
              ),
              Qh(
                this.dom.ownerDocument.getElementById(
                  'ccbim__panoramaErrorMsg',
                ),
                this.panoramaErrorMsg,
              );
        });
    },
    loadPanoramaInfo() {
      let t = this.panoramaFile.fileJson.filter((t) =>
        t.FileKey.includes('panorama'),
      )[0].URI;
      Gf({ method: 'get', url: t }).then((t) => {
        2 === t.data.var && (this.isNew = !0), this.handlePanoramaInfo(t.data);
      });
    },
    handlePanoramaInfo(t) {
      let e = this.panoramaFile.fileJson[0].URI,
        n = e.lastIndexOf('/');
      (this.panoramaFile.cloudUrl = e.slice(0, n + 1)),
        t.panoramaArray.forEach((t) => {
          this.panoramaFile.fileJson.forEach((e) => {
            for (let n = 0, i = t.panoramaImg.length; n < i; n++)
              e.FileKey.indexOf(t.panoramaImg[n].split('|')[1]) > 0 &&
                (t.panoramaImg[n] = this.panoramaFile.cloudUrl + e.FileKey);
            t.previewImg &&
              e.FileKey.indexOf(t.previewImg.split('|')[1]) > 0 &&
              (t.previewImg = this.panoramaFile.cloudUrl + e.FileKey),
              t.jumpHot.forEach((t) => {
                for (let n = 0, i = t.img.length; n < i; n++)
                  t.targetPic &&
                    e.FileKey.indexOf(t.targetPic.split('|')[1]) > 0 &&
                    (t.targetPic = this.panoramaFile.cloudUrl + e.FileKey);
              });
          }),
            t.jumpHot.forEach((t) => {
              for (let e = 0, n = t.img.length; e < n; e++)
                t.img[e] =
                  this.panoramaFile.cloudUrl +
                  'Pm720/Icon/' +
                  t.img[e].split('|')[1];
            }),
            (t.current = !1);
        }),
        (t.panoramaArray[0].current = !0),
        (this.panorama = t),
        (this.box = this.panorama.box),
        this.panoramaInit(),
        this.goToNextBox(this.panorama.panoramaArray[0].id),
        this.isNew &&
          Yh(this.dom.ownerDocument.getElementById('ccbim__panoramaMenu'), {
            panoramaArray: this.panorama.panoramaArray,
            menuClick: (t) => this.goToNextBox(t),
            showHiddenPoint: () => this.showHiddenPoint(),
          });
    },
    showHiddenPoint() {
      zf.jumpHotArray.forEach((t) => {
        t.visible = !t.visible;
      });
    },
    goToNextBox(t) {
      return (
        this.panorama.panoramaArray.forEach((e) => {
          (e.current = !1),
            e.id === t &&
              ((e.current = !0),
              $h(
                this.dom.ownerDocument.getElementById('ccbim__panoramaLoading'),
                !0,
              ),
              (this.jumpHot = e.jumpHot),
              (this.panoramaImg = e.panoramaImg),
              (this.panoramaId = e.id),
              this.setCameraTarget(e.cameraTarget));
        }),
        this.removePoint(),
        this.addSkyBox().then(() => {
          for (let t = 0; t < this.jumpHot.length; t++) this.addPoint(t);
          $h(
            this.dom.ownerDocument.getElementById('ccbim__panoramaLoading'),
            !1,
          );
        }),
        this.panorama.panoramaArray
      );
    },
    addSkyBox() {
      return new Promise((t) => {
        let e = null;
        if (zf.panoramaMaterialMap.has(this.panoramaId)) {
          zf.scene.children.forEach((t) => {
            t.userData.skyBox && zf.scene.remove(t);
          }),
            (e = new ln(
              new gn(this.box[0], this.box[1], this.box[2]),
              zf.panoramaMaterialMap.get(this.panoramaId),
            )),
            (e.userData.skyBox = !0),
            e.geometry.scale(-1, 1, 1),
            zf.scene.add(e);
          let n = setInterval(() => {
            let i = 0;
            e.material.forEach((e) => {
              e.opacity < 1
                ? (e.opacity = e.opacity + 0.1)
                : (i++, 6 === i && (clearInterval(n), t()));
            });
          }, 100);
          this.animate();
        } else {
          let n = new Ba();
          Promise.all(
            this.panoramaImg.map(function (t) {
              return new Promise(function (e, i) {
                n.load(t, function (t) {
                  e(new xe({ map: t, transparent: !0, opacity: 0.7 }));
                });
              });
            }),
          ).then((n) => {
            zf.panoramaMaterialMap.set(this.panoramaId, n),
              zf.scene.children.forEach((t) => {
                t.userData.skyBox && zf.scene.remove(t);
              }),
              (e = null),
              (e = new ln(new gn(this.box[0], this.box[1], this.box[2]), n)),
              (e.userData.skyBox = !0),
              e.geometry.scale(-1, 1, 1),
              zf.scene.add(e);
            let i = setInterval(() => {
              let n = 0;
              e.material.forEach((e) => {
                e.opacity < 1
                  ? (e.opacity = e.opacity + 0.1)
                  : (n++, 6 === n && (clearInterval(i), t()));
              });
            }, 100);
            this.animate();
          });
        }
      });
    },
    addPoint(t) {
      let e = new Bn(170, 170),
        n = '';
      zf.jumpHotMaterialMap.get(this.jumpHot[t].img[0])
        ? (n = zf.jumpHotMaterialMap.get(this.jumpHot[t].img[0]))
        : (zf.jumpHotMaterialMap.set(
            this.jumpHot[t].img[0],
            new Ba().load(this.jumpHot[t].img[0]),
          ),
          (n = new Ba().load(this.jumpHot[t].img[0])));
      let i = new ln(e, new xe({ map: n, transparent: !0, opacity: 0.7 }));
      (i.userData.target = this.jumpHot[t].target),
        i.position.set(
          -this.jumpHot[t].position[0],
          this.jumpHot[t].position[2],
          this.jumpHot[t].position[1],
        ),
        zf.scene2.add(i);
      let r = new Bn(300, 100),
        o = '';
      zf.jumpHotMaterialMap.get(this.jumpHot[t].targetPic)
        ? (o = zf.jumpHotMaterialMap.get(this.jumpHot[t].targetPic))
        : (zf.jumpHotMaterialMap.set(
            this.jumpHot[t].targetPic,
            new Ba().load(this.jumpHot[t].targetPic),
          ),
          (o = new Ba().load(this.jumpHot[t].targetPic)));
      let s = new ln(r, new ra({ map: o, transparent: !0, needsUpdate: !0 }));
      s.position.set(0, -160, 0), i.add(s);
      let a = 0,
        c = '';
      (zf.pageTimer['timer' + t] = setInterval(() => {
        a < this.jumpHot[t].img.length
          ? (zf.jumpHotMaterialMap.get(this.jumpHot[t].img[a])
              ? (c = zf.jumpHotMaterialMap.get(this.jumpHot[t].img[a]))
              : (zf.jumpHotMaterialMap.set(
                  this.jumpHot[t].img[a],
                  new Ba().load(this.jumpHot[t].img[a]),
                ),
                (c = new Ba().load(this.jumpHot[t].img[a]))),
            (i.material.map = c),
            a++)
          : (a = 0);
      }, 150)),
        zf.jumpHotArray.push(i);
    },
    removePoint() {
      for (let t in zf.pageTimer)
        zf.pageTimer.hasOwnProperty(t) && clearInterval(zf.pageTimer[t]);
      zf.jumpHotArray.forEach((t) => {
        zf.scene2.remove(t);
      }),
        (zf.jumpHotArray = []);
    },
    pointLookToCamera() {
      for (let t = 0; t < zf.scene2.children.length; t++)
        (zf.scene2.children[t].rotation.x = zf.camera.rotation.x),
          (zf.scene2.children[t].rotation.y = zf.camera.rotation.y),
          (zf.scene2.children[t].rotation.z = zf.camera.rotation.z);
    },
    panoramaInit() {
      this.setWidth();
      let t = this.dom.ownerDocument.getElementById('ccbim__panorama');
      (zf.renderer = new Pr()),
        (zf.renderer.autoClear = !1),
        zf.renderer.setPixelRatio(window.devicePixelRatio),
        zf.renderer.setSize(zf.rect.w, zf.rect.h),
        zf.renderer.setClearColor(16777215),
        t.appendChild(zf.renderer.domElement),
        (zf.scene = new Mt()),
        (zf.scene2 = new Mt()),
        (zf.raycaster = new gl()),
        this.setCamera();
      let e = new mc(4294967295);
      (e.name = 'AmbientLight'),
        zf.scene.add(e),
        (window.onresize = () => this.onWindowResize()),
        t.addEventListener(
          'mousedown',
          this.onDocumentMouseDown.bind(this),
          !1,
        ),
        t.addEventListener(
          'mousemove',
          this.onDocumentMouseMove.bind(this),
          !1,
        ),
        t.addEventListener('mouseup', this.onDocumentMouseUp.bind(this), !1),
        t.addEventListener('wheel', this.onDocumentMouseWheel.bind(this), !1),
        t.addEventListener(
          'touchstart',
          this.onDocumentTouchStart.bind(this),
          !1,
        ),
        t.addEventListener(
          'touchmove',
          this.onDocumentTouchMove.bind(this),
          !1,
        ),
        t.addEventListener('touchend', this.onDocumentTouchEnd.bind(this), !1),
        this.dispatchEvent({ type: 'renderFinish', object: !0 });
    },
    setCamera() {
      (zf.camera = new Mn(75, zf.rect.w / zf.rect.h, 1, 5e4)),
        (zf.camera.target = new J(0, 0, 0)),
        zf.camera.lookAt(zf.camera.target);
    },
    setWidth() {
      (zf.rect = this.dom.getBoundingClientRect()),
        (zf.rect.w = zf.rect.right - zf.rect.left),
        (zf.rect.h = window.innerHeight - zf.rect.top);
    },
    setCameraTarget(t) {
      if (t) {
        let e = new J(1, 0, 0),
          n = new J(t[0], 0, t[1]),
          i = (n.angleTo(e) / Math.PI) * 180;
        if (
          (n.cross(e),
          n.y > 0 ? (zf.lon = -i) : (zf.lon = i),
          (zf.onMouseDownLon = zf.lon),
          Math.abs(t[2]) > 2500)
        ) {
          let e = new J(0, 1, 0),
            n = new J(0, t[2], t[1]),
            i = (n.angleTo(e) / Math.PI) * 180;
          n.cross(e),
            n.x < 0
              ? 3e3 === t[2]
                ? (zf.lat = 360 - -i)
                : (zf.lat = -i)
              : (zf.lat = i),
            (zf.onMouseDownLat = zf.lat);
        }
      }
      this.cameraMove();
    },
    cameraMove() {
      (zf.lat = Math.max(-85, Math.min(85, zf.lat))),
        (zf.phi = (90 - zf.lat) * (Math.PI / 180)),
        (zf.theta = zf.lon * (Math.PI / 180)),
        (zf.camera.target.x = Math.sin(zf.phi) * Math.cos(zf.theta)),
        (zf.camera.target.y = Math.cos(zf.phi)),
        (zf.camera.target.z = Math.sin(zf.phi) * Math.sin(zf.theta)),
        zf.camera.lookAt(zf.camera.target);
    },
    onWindowResize() {
      setTimeout(() => {
        this.setWidth(),
          (zf.camera.aspect = zf.rect.w / zf.rect.h),
          zf.camera.updateProjectionMatrix(),
          zf.renderer.setSize(zf.rect.w, zf.rect.h);
      });
    },
    onDocumentMouseDown(t) {
      t.preventDefault(),
        t.stopPropagation(),
        (zf.isUserInteracting = !0),
        (zf.onMouseDownMouseX = t.offsetX),
        (zf.onMouseDownMouseY = t.offsetY),
        (zf.onMouseDownLon = zf.lon),
        (zf.onMouseDownLat = zf.lat),
        (zf.raycasterTarget.x = (t.offsetX / zf.rect.w) * 2 - 1),
        (zf.raycasterTarget.y = (-t.offsetY / zf.rect.h) * 2 + 1),
        zf.raycaster.setFromCamera(zf.raycasterTarget, zf.camera);
      var e = zf.raycaster.intersectObjects(zf.jumpHotArray);
      e.length > 0 &&
        (this.goToNextBox(e[0].object.userData.target),
        this.isNew &&
          Yh(this.dom.ownerDocument.getElementById('ccbim__panoramaMenu'), {
            panoramaArray: this.panorama.panoramaArray,
            menuClick: (t) => this.goToNextBox(t),
            showHiddenPoint: () => this.showHiddenPoint(),
          }));
    },
    onDocumentTouchStart(t) {
      (zf.isUserInteracting = !0),
        (zf.onMouseDownMouseX = t.targetTouches[0].pageX),
        (zf.onMouseDownMouseY = t.targetTouches[0].pageY),
        (zf.onMouseDownLon = zf.lon),
        (zf.onMouseDownLat = zf.lat),
        (zf.initX = t.target.offsetLeft),
        (zf.initY = t.target.offsetTop),
        t.touches.length >= 2 && (zf.scaleStart = t.touches);
    },
    onDocumentMouseMove(t) {
      t.preventDefault(),
        t.stopPropagation(),
        !0 === zf.isUserInteracting &&
          ((zf.lon =
            0.1 * (zf.onMouseDownMouseX - t.offsetX) + zf.onMouseDownLon),
          (zf.lat =
            0.1 * (t.offsetY - zf.onMouseDownMouseY) + zf.onMouseDownLat),
          this.cameraMove()),
        (zf.raycasterTarget.x = (t.offsetX / zf.rect.w) * 2 - 1),
        (zf.raycasterTarget.y = (-t.offsetY / zf.rect.h) * 2 + 1),
        zf.raycaster.setFromCamera(zf.raycasterTarget, zf.camera),
        zf.raycaster.intersectObjects(zf.jumpHotArray).length > 0
          ? (zf.renderer.domElement.style.cursor = 'pointer')
          : (zf.renderer.domElement.style.cursor = 'auto');
    },
    onDocumentTouchMove(t) {
      if (
        (t.preventDefault(),
        t.stopPropagation(),
        1 === t.touches.length &&
          zf.isUserInteracting &&
          ((zf.lon =
            0.3 * (zf.onMouseDownMouseX - t.targetTouches[0].pageX) +
            zf.onMouseDownLon),
          (zf.lat =
            0.3 * (t.targetTouches[0].pageY - zf.onMouseDownMouseY) +
            zf.onMouseDownLat),
          this.cameraMove()),
        t.touches.length >= 2 && zf.isUserInteracting)
      ) {
        var e = t.touches,
          n =
            this.getDistance(e[0], e[1]) /
            this.getDistance(zf.scaleStart[0], zf.scaleStart[1]);
        let i;
        (t.scale = n.toFixed(2)),
          (i = n > 1 ? zf.camera.fov + -2.5 : zf.camera.fov + 2.5),
          (zf.camera.fov = Math.max(45, Math.min(80, i))),
          zf.camera.updateProjectionMatrix();
      }
    },
    onDocumentMouseUp(t) {
      t.preventDefault(), t.stopPropagation(), (zf.isUserInteracting = !1);
    },
    onDocumentTouchEnd() {
      zf.isUserInteracting = !1;
    },
    onDocumentMouseWheel(t) {
      t.preventDefault(), t.stopPropagation();
      let e = zf.camera.fov + 0.05 * t.deltaY;
      (zf.camera.fov = Math.max(45, Math.min(80, e))),
        zf.camera.updateProjectionMatrix();
    },
    getDistance(t, e) {
      let n = e.pageX - t.pageX,
        i = e.pageY - t.pageY;
      return Math.sqrt(n * n + i * i);
    },
    animate() {
      requestAnimationFrame(this.animate.bind(this)),
        this.pointLookToCamera(),
        zf.renderer.clear(),
        zf.renderer.render(zf.scene, zf.camera),
        zf.renderer.clearDepth(),
        zf.renderer.render(zf.scene2, zf.camera);
    },
  });
  let Hf = {
    TRIANGLES: 0,
    TRIANGLE_STRIP: 1,
    TRIANGLE_FAN: 2,
    LINES: 3,
    LINE_LOOP: 4,
    LINE_STRIP: 5,
    POINT: 6,
  };
  function Wf(t) {
    (this.buffer = void 0),
      (this.context = void 0),
      (this.bufferAttribute = void 0),
      (this.drawMode = t),
      (this.needUpdate = !1);
  }
  Wf.prototype = Object.assign(Object.create(B.prototype), {
    constructor: Wf,
    isVertexIndex: !0,
    getDrawMode: function () {
      return this.drawMode;
    },
    setIndex: function (t) {
      (this.bufferAttribute = new Le(t, 1)), (this.needUpdate = !0);
    },
    getBufferAttribute: function () {
      return this.bufferAttribute;
    },
    update: function (t) {
      !1 !== this.needUpdate &&
        this.bufferAttribute &&
        (this.buffer && this.context.deleteBuffer(this.buffer),
        (this.context = t),
        (this.buffer = this.context.createBuffer()),
        this.buffer &&
          (this.context.bindBuffer(
            this.context.ELEMENT_ARRAY_BUFFER,
            this.buffer,
          ),
          this.context.bufferData(
            this.context.ELEMENT_ARRAY_BUFFER,
            this.bufferAttribute.array,
            this.context.STATIC_DRAW,
          ),
          this.context.bindBuffer(this.context.ELEMENT_ARRAY_BUFFER, null),
          (this.needUpdate = !1)));
    },
    bind: function (t) {
      this.buffer &&
        this.context.bindBuffer(this.context.ELEMENT_ARRAY_BUFFER, this.buffer);
    },
    release: function (t) {
      this.buffer &&
        (this.context.deleteBuffer(this.buffer),
        (this.buffer = void 0),
        (this.context = void 0)),
        (this.bufferAttribute = void 0),
        (this.needUpdate = !1);
    },
  });
  let Xf = {
    makeRotationMatrix4:
      ((Zf = new ot()),
      function (t, e, n, i) {
        i.identity(),
          Zf.makeTranslation(-t.x, -t.y, -t.z),
          i.premultiply(Zf),
          Zf.makeRotationAxis(e, n),
          i.premultiply(Zf),
          Zf.makeTranslation(t.x, t.y, t.z),
          i.premultiply(Zf);
      }),
    makeScaleMatrix4: (function () {
      var t = new ot();
      return function (e, n, i) {
        i.identity(),
          t.makeTranslation(-e.x, -e.y, -e.z),
          i.premultiply(t),
          t.makeScale(n, n, n),
          i.premultiply(t),
          t.makeTranslation(e.x, e.y, e.z),
          i.premultiply(t);
      };
    })(),
    makeCoordinateMatrix4: function (t, e, n, i, r) {
      r.set(
        t.x,
        e.x,
        n.x,
        i.x,
        t.y,
        e.y,
        n.y,
        i.y,
        t.z,
        e.z,
        n.z,
        i.z,
        0,
        0,
        0,
        1,
      );
    },
    isNumberNearZero: function (t) {
      return Math.abs(t) < 1e-9;
    },
    isZeroNumber: function (t) {
      return Math.abs(t) < 1e-7;
    },
    isZeroVector3: function (t) {
      return this.isZeroNumber(t.length());
    },
    origin: new J(0, 0, 0),
    xAxis: new J(1, 0, 0),
    yAxis: new J(0, 1, 0),
    zAxis: new J(0, 0, 1),
    isParallelVector3: (function () {
      let t = new J();
      return function (e, n) {
        return t.crossVectors(e, n), this.isZeroVector3(t);
      };
    })(),
    computeAxisAngle: (function () {
      let t = new J(),
        e = new J(),
        n = new J(),
        i = new J(),
        r = new J();
      return function (o, s, a) {
        t.copy(o).normalize(), e.copy(s).normalize(), n.copy(a).normalize();
        let c = t.crossVectors(t, e).angleTo(n);
        t.copy(o).normalize(),
          c > Math.PI / 2 && n.negate(),
          i.copy(t),
          i.multiplyScalar(t.dot(n)),
          i.subVectors(t, i),
          r.copy(n),
          r.multiplyScalar(e.dot(n)),
          r.subVectors(e, r);
        let l = i.angleTo(r);
        return c > Math.PI / 2 && (l = 2 * Math.PI - l), l;
      };
    })(),
    computeIntersectionRayLine3: (function () {
      let t = new J(),
        e = new J(),
        n = new J();
      return function (i, r, o, s, a) {
        let c = i.direction;
        if (this.isZeroVector3(c)) return !1;
        if (
          (t.subVectors(r.end, r.start),
          this.isZeroVector3(t) || this.isParallelVector3(c, t))
        )
          return !1;
        let l = i.origin,
          h = 0,
          u = 0;
        e.subVectors(r.start, l);
        let d = t.dot(c),
          p = t.dot(t),
          f = c.dot(c);
        if (this.isNumberNearZero(d))
          n.set(-t.x, -t.y, -t.z), (h = n.dot(e) / p), (u = c.dot(e) / f);
        else {
          let n = d / p - f / d;
          this.isNumberNearZero(n)
            ? (u = c.dot(e) / f)
            : ((u = (t.dot(e) / p - c.dot(e) / d) / n),
              (h = (u * d) / p - t.dot(e) / p));
        }
        return (
          s && (s.copy(r.start), s.addScaledVector(t, h)),
          a && (a.copy(l), a.addScaledVector(l.normalize(), u)),
          o || (h >= 0 && h <= 1)
        );
      };
    })(),
    computeIntersectionRayBox3: (function () {
      let t = new J(),
        e = new J();
      return function (n, i) {
        let r = i.min,
          o = i.max,
          s = 0,
          a = 0,
          c = !1,
          l = n.origin,
          h = n.direction;
        if (this.isZeroNumber(h.x)) {
          if (l.x > o.x || l.x < r.x) return;
        } else
          h.x > 0
            ? ((t.x = (r.x - l.x) / h.x), (e.x = (o.x - l.x) / h.x))
            : ((t.x = (o.x - l.x) / h.x), (e.x = (r.x - l.x) / h.x)),
            (s = t.x),
            (a = e.x),
            (c = !0);
        if (this.isZeroNumber(h.y)) {
          if (l.y > o.y || l.y < r.y) return;
        } else
          h.y >= 0
            ? ((t.y = (r.y - l.y) / h.y), (e.y = (o.y - l.y) / h.y))
            : ((t.y = (o.y - l.y) / h.y), (e.y = (r.y - l.y) / h.y)),
            (s = c ? Math.max(s, t.y) : t.y),
            (a = c ? Math.min(a, e.y) : e.y),
            (c = !0);
        if (this.isZeroNumber(h.z)) {
          if (l.z > o.z || l.z < r.z) return;
        } else
          h.z >= 0
            ? ((t.z = (r.z - l.z) / h.z), (e.z = (o.z - l.z) / h.z))
            : ((t.z = (o.z - l.z) / h.z), (e.z = (r.z - l.z) / h.z)),
            (s = c ? Math.max(s, t.z) : t.z),
            (a = c ? Math.min(a, e.z) : e.z),
            (c = !0);
        if (c && !(s > a)) return { near: s, far: a };
      };
    })(),
    computeAreaOfPolygon: function (t) {
      let e = t.length;
      if (e < 3) return 0;
      let n = e - 1,
        i = t[0].y * (t[n].x - t[1].x);
      for (let e = 1; e < n; e++) i += t[e].y * (t[e - 1].x - t[e + 1].x);
      return (i += t[n].y * (t[n - 1].x - t[0].x)), i / 2;
    },
    isConterClock: function (t) {
      return this.computeAreaOfPolygon(t) > 0;
    },
    getCoordinateByRefAxis: (function () {
      let t = new J(),
        e = new J(),
        n = new J();
      return function (i, r, o) {
        t.copy(r).normalize(),
          e.crossVectors(this.zAxis, t),
          this.isZeroVector3(e)
            ? t.dot(this.zAxis) > 0
              ? (e.set(1, 0, 0), n.set(0, 1, 0))
              : (e.set(-1, 0, 0), n.set(0, -1, 0))
            : n.crossVectors(t, e);
        let s = o;
        return (
          s || (s = new ot()),
          this.makeCoordinateMatrix4(
            e.normalize(),
            n.normalize(),
            t.normalize(),
            i || this.origin,
            s,
          ),
          s
        );
      };
    })(),
    getBox3Corner: function (t, e, n) {
      let i = n;
      i || (i = new J());
      let r = t.min,
        o = t.max;
      return i.set(1 & e ? o.x : r.x, 2 & e ? o.y : r.y, 4 & e ? o.z : r.z), i;
    },
    getBox3MaxCorner: function (t, e, n) {
      return this.getBox3Corner(
        t,
        (e.x > 0 ? 1 : 0) | (e.y > 0 ? 2 : 0) | (e.z > 0 ? 4 : 0),
        n,
      );
    },
    getBox3MinCorner: function (t, e, n) {
      return this.getBox3Corner(
        t,
        (-e.x > 0 ? 1 : 0) | (-e.y > 0 ? 2 : 0) | (-e.z > 0 ? 4 : 0),
        n,
      );
    },
    getInstanceMatrixByArray: function (t, e, n, i, r, o) {
      var s = 4 * r;
      o.set(
        t[s],
        e[s],
        n[s],
        i[s],
        t[s + 1],
        e[s + 1],
        n[s + 1],
        i[s + 1],
        t[s + 2],
        e[s + 2],
        n[s + 2],
        i[s + 2],
        t[s + 3],
        e[s + 3],
        n[s + 3],
        i[s + 3],
      );
    },
  };
  var Zf;
  function Yf(t, e) {
    (this.geoID = t),
      (this.bufferSegment = e),
      (this.boundingBox = null),
      (this.renderObject = null),
      (this.isCCy = !1),
      (this.lineCountBefore = 0),
      (this.lineCountThis = 0);
  }
  Yf.prototype = {
    constructor: Yf,
    getGeoID: function () {
      return this.geoID;
    },
    setRenderObject: function (t) {
      this.renderObject !== t &&
        (this.renderObject &&
          (this.boundingBox
            ? this.renderObject.removeDrawGeoData(this)
            : this.renderObject.removeDrawSegment(this.bufferSegment)),
        (this.renderObject = t),
        this.renderObject &&
          (this.boundingBox
            ? this.renderObject.addDrawGeoData(this)
            : this.renderObject.addDrawSegment(this.bufferSegment)));
    },
    getRenderObject: function () {
      return this.renderObject;
    },
    getBufferSegment: function () {
      return this.bufferSegment;
    },
    clone: function () {
      return new Yf(this.geoID, this.bufferSegment.clone());
    },
    expandBoundingByPoint: function (t) {
      this.boundingBox || (this.boundingBox = new Nt()),
        this.boundingBox.expandByPoint(t);
    },
    getBoundingBox: function () {
      return this.boundingBox;
    },
  };
  let qf = 1,
    Qf = 2,
    Jf = 4;
  function $f(t) {
    (this.uuid = t),
      (this.floorID = 0),
      (this.comtype = 0),
      (this.comid = 0),
      (this.handle = ''),
      (this.visibility = qf | Qf | Jf),
      (this.layerIDArray = []),
      (this.geoDataArray = []),
      (this.style = null),
      (this.sceneNode = null),
      (this.modelNodeID = 0),
      (this.modelNode = null),
      (this.offsetInModelNode = -1),
      (this.boundingBox = new Nt());
  }
  $f.prototype = {
    constructor: $f,
    isPMEntity: !0,
    setEntInfo: function (t, e, n, i, r) {
      (this.uuid = t),
        (this.floorID = e),
        (this.comtype = n),
        (this.comid = i),
        (this.handle = r);
    },
    getID: function () {
      return this.uuid;
    },
    getFloorID: function () {
      return this.floorID;
    },
    getComtype: function () {
      return this.comtype;
    },
    getComid: function () {
      return this.comid;
    },
    getHandle: function () {
      return this.handle;
    },
    setRenderVisible: function (t) {
      let e = this.getRenderVisible();
      if (e === t) return;
      let n = this.isLayerShow(),
        i = e && n;
      this.updateVisibility(qf, t),
        i !== (this.getRenderVisible() && n) && this.flush();
    },
    getRenderVisible: function () {
      return this.getVisibility(qf);
    },
    isRenderVisible: function () {
      return this.getRenderVisible() && this.isLayerShow();
    },
    setSelectVisible: function (t) {
      this.updateVisibility(Qf, t);
    },
    getSelectVisible: function () {
      return this.getVisibility(Qf);
    },
    setWireVisible: function (t) {
      this.updateVisibility(Jf, t);
    },
    getWireVisible: function () {
      return this.getVisibility(Jf);
    },
    updateVisibility: function (t, e) {
      e ? (this.visibility |= t) : (this.visibility &= ~t);
    },
    getVisibility: function (t) {
      return void 0 !== t && 0 != (this.visibility & t);
    },
    addLayerID: function (t) {
      this.layerIDArray.push(t);
    },
    hasLayerID: function (t) {
      return (
        -1 === t ||
        0 === this.layerIDArray.length ||
        (1 === this.layerIDArray.length && -1 === this.layerIDArray[0]) ||
        this.layerIDArray.indexOf(t) >= 0
      );
    },
    isLayerShow: function () {
      if (!this.modelNode) return !0;
      let t = this.modelNode.getModelTree();
      if (!t) return !0;
      let e = t.getCurrentLayer();
      return !e || this.hasLayerID(e.getID());
    },
    addGeoData: function (t) {
      this.geoDataArray.push(t),
        t.getBoundingBox() && this.boundingBox.union(t.getBoundingBox());
    },
    getGeoDataArray: function () {
      return this.geoDataArray;
    },
    clearGeoData: function () {
      for (let t = 0, e = this.geoDataArray.length; t < e; t++)
        this.geoDataArray[t].setRenderObject(null);
      this.geoDataArray = [];
    },
    setSceneNode: function (t) {
      this.sceneNode = t;
    },
    getSceneNode: function () {
      return this.sceneNode;
    },
    setModelNodeID: function (t) {
      this.modelNodeID = t;
    },
    getModelNodeID: function () {
      return this.modelNodeID;
    },
    setModelNode: function (t, e) {
      (this.modelNode = t), (this.offsetInModelNode = e);
    },
    getModelNode: function () {
      return this.modelNode;
    },
    getModel: function () {
      if (!this.modelNode) return;
      let t = this.modelNode.getModelTree();
      return t ? t.getModel() : void 0;
    },
    setOffsetInModelNode: function (t) {
      this.offsetInModelNode = t;
    },
    getOffsetInModelNode: function () {
      return this.offsetInModelNode;
    },
    expandBoundingBoxByPoint: function (t) {
      this.boundingBox.expandByPoint(t);
    },
    getBoundingBox: function () {
      return this.boundingBox;
    },
    setStyle: function (t) {
      this.style !== t && ((this.style = t), this.flush());
    },
    getStyle: function () {
      return this.style;
    },
    flush: function () {
      this.sceneNode && this.sceneNode.flushEntity(this);
    },
    raycast: function (t) {
      if (!this.getSelectVisible() || !this.isRenderVisible()) return;
      if (
        !this.boundingBox.isEmpty() &&
        !Xf.computeIntersectionRayBox3(t.ray, this.boundingBox)
      )
        return;
      let e,
        n = [];
      for (let i = 0, r = this.geoDataArray.length; i < r; ++i) {
        let r = this.geoDataArray[i].renderObject;
        if (!r) continue;
        let o = r.raycast(t, n, this.geoDataArray[i].bufferSegment);
        o && (!e || o.distance < e.distance) && (e = o);
      }
      return e;
    },
    clone: function () {
      return new $f().copy(this);
    },
    copy: function (t) {
      (this.uuid = t.uuid),
        (this.floorID = t.floorID),
        (this.comtype = t.comtype),
        (this.comid = t.comid),
        (this.handle = t.handle),
        (this.visibility = t.visibility),
        (this.geoDataArray = []);
      for (let e = 0, n = t.geoDataArray.length; e < n; ++e)
        this.geoDataArray.push(t.geoDataArray[e].clone());
      return (
        (this.sceneNode = t.sceneNode), (this.entityNode = t.entityNode), this
      );
    },
  };
  let Kf = 0,
    tm = 0,
    em = 1,
    nm = 2,
    im = 3,
    rm = 4;
  function om(t, e, n, i, r) {
    (this.type = t),
      (this.name = e),
      (this.value = n),
      (this.uuid = r || ++Kf),
      (this.modelTree = i),
      (this.parent = null),
      (this.childArray = []),
      (this.entityArray = []),
      (this.entityStyle = null),
      (this.visible = !0),
      (this.typeList = {}),
      (this.boundingBox = null);
  }
  function sm(t, e) {
    (this.name = t), (this.id = e);
  }
  function am(t) {
    (this.model = t),
      (this.root = new om(tm, 'root', 0, this)),
      (this.layerArray = []),
      (this.currentLayer = null),
      (this.nodeMap = new Map());
  }
  (om.prototype = {
    constructor: om,
    getType: function () {
      return this.type;
    },
    getName: function () {
      return this.name;
    },
    getValue: function () {
      return this.value;
    },
    getID: function () {
      return this.uuid;
    },
    getModelTree: function () {
      return this.modelTree;
    },
    addChild: function (t) {
      this.parent
        ? console.warn('The node is in another node already.')
        : ((t.parent = this), this.childArray.push(t), this.dirtyBounding());
    },
    getChildArray: function () {
      return this.childArray;
    },
    getParent: function () {
      return this.parent;
    },
    insertEntity: function (t) {
      t.getModelNode()
        ? console.warn('The entity is in model-node already.')
        : (t.setModelNode(this, this.entityArray.length),
          this.entityArray.push(t),
          t.setRenderVisible(this.visible),
          t.setStyle(this.entityStyle),
          this.dirtyBounding());
    },
    removeEntity: function (t) {
      if (t.getModelNode() !== this)
        return void console.warn('The entity is not in this model-node.');
      let e = t.getOffsetInModelNode();
      if (e >= 0) {
        t.setModelNode(null, -1), this.entityArray.splice(e, 1);
        for (let t = e, n = this.entityArray.length; t < n; ++t)
          this.entityArray[t].setOffsetInModelNode(t);
      }
      this.dirtyBounding();
    },
    getEntityArray: function () {
      return this.entityArray;
    },
    setEntityStyle: function (t, e, n = !0, i) {
      if (void 0 === i || !i.has(this.uuid)) {
        if (this.entityStyle !== t) {
          for (let e = 0, i = this.entityArray.length; e < i; ++e)
            this.entityArray[e].setStyle(t),
              n
                ? this.entityArray[e].setSelectVisible(!0)
                : this.entityArray[e].setSelectVisible(!1);
          this.entityStyle = t;
        }
        if (e)
          for (let r = 0, o = this.childArray.length; r < o; ++r)
            this.childArray[r].setEntityStyle(t, e, n, i);
      }
    },
    setNodeVisible: function (t, e, n) {
      this.visible = t;
      for (let t = 0, e = this.entityArray.length; t < e; ++t)
        this.entityArray[t].setRenderVisible(this.visible);
      if (e)
        for (let n = 0, i = this.childArray.length; n < i; ++n)
          this.childArray[n].setNodeVisible(t, e);
    },
    findChildByTypeValue: (function () {
      function t(e, n, i) {
        for (let r = 0, o = e.length; r < o; ++r) {
          let o = e[r];
          o.getType() === n && i.push(o), t(o.getChildArray(), n, i);
        }
      }
      return function (e, n) {
        let i = this.typeList[e];
        if (void 0 === i) {
          i = new Map();
          let n = [];
          t(this.childArray, e, n);
          for (let t = 0, e = n.length; t < e; ++t) {
            let e = n[t].getValue(),
              r = i.get(e);
            void 0 === r && ((r = []), i.set(e, r)), r.push(n[t]);
          }
          this.typeList[e] = i;
        }
        let r = i.get(n);
        if (void 0 === r) return [];
        let o = [];
        for (let t = 0, e = r.length; t < e; ++t) o.push(r[t]);
        return o;
      };
    })(),
    clear: function () {
      (this.parent = null),
        (this.entityArray = []),
        (this.entityStyle = null),
        (this.visible = !0),
        (this.typeList = {}),
        (this.boundingBox = null);
    },
    dirtyBounding: function () {
      let t = this;
      for (; t; ) (t.boundingBox = null), (t = t.getParent());
    },
    getBoundingBox: (function () {
      function t(e) {
        if (e.boundingBox) return e.boundingBox;
        e.boundingBox = new Nt();
        for (let t = 0, n = e.entityArray.length; t < n; ++t) {
          let n = e.entityArray[t].getBoundingBox();
          n && !n.isEmpty() && e.boundingBox.union(n);
        }
        for (let n = 0, i = e.childArray.length; n < i; ++n)
          e.boundingBox.union(t(e.childArray[n]));
        return e.boundingBox;
      }
      return function () {
        return t(this).clone();
      };
    })(),
  }),
    (sm.prototype = {
      constructor: sm,
      getName: function () {
        return this.name;
      },
      getID: function () {
        return this.id;
      },
    }),
    (am.prototype = {
      constructor: am,
      getModel: function () {
        return this.model;
      },
      insertNode: function (t) {
        this.root.addChild(t);
      },
      getRootNode: function () {
        return this.root;
      },
      addLayer: function (t) {
        this.layerArray.push(t);
      },
      getLayerArray: function () {
        return this.layerArray;
      },
      findNodeByID: (function () {
        function t(e, n) {
          for (let i = 0, r = e.length; i < r; ++i) {
            let r = e[i];
            if (r.getID() === n) return r;
            if (((r = t(r.getChildArray())), r)) return r;
          }
          return null;
        }
        return function (e) {
          let n = this.nodeMap.get(e);
          return (
            n ||
              ((n = t(this.root.getChildArray(), e)),
              n && this.nodeMap.set(e, n)),
            n
          );
        };
      })(),
      findNodeByTypeValue: function (t, e) {
        return this.root.findChildByTypeValue(t, e);
      },
      setCurrentLayer: (function () {
        function t(e, n, i) {
          for (let r = 0, o = e.length; r < o; ++r) {
            let o = e[r],
              s = o.getEntityArray();
            for (let t = 0, e = s.length; t < e; ++t) {
              let e = s[t];
              if (n) {
                (e.getRenderVisible() && e.hasLayerID(n.getID())) !==
                  (e.getRenderVisible() && e.hasLayerID(i.getID())) &&
                  e.flush();
              } else e.flush();
            }
            t(o.getChildArray(), n, i);
          }
        }
        return function (e) {
          let n = null;
          for (let t = 0, i = this.layerArray.length; t < i; ++t)
            this.layerArray[t].getID() === e && (n = this.layerArray[t]);
          if (!n || this.currentLayer === n) return;
          let i = this.currentLayer;
          (this.currentLayer = n),
            t(this.root.getChildArray(), i, this.currentLayer);
        };
      })(),
      getCurrentLayer: function () {
        return this.currentLayer;
      },
      setEntityStyleByTypeValue: function (t, e, n, i, r) {
        let o = this.findNodeByTypeValue(t, e);
        for (let t = 0, e = o.length; t < e; ++t) o[t].setEntityStyle(n, i, r);
      },
      setEntityStyleByID: function (t, e, n, i) {
        let r = this.findNodeByID(t);
        r && r.setEntityStyle(e, n, i);
      },
      setNodeVisibleByTypeValue: function (t, e, n, i) {
        let r = this.findNodeByTypeValue(t, e);
        for (let t = 0, e = r.length; t < e; ++t) r[t].setNodeVisible(n, i);
      },
      setNodeVisibleByID: function (t, e, n) {
        let i = this.findNodeByID(t);
        i && i.setNodeVisible(e, n);
      },
      clear: function () {
        !(function (t) {
          t.clear();
          let e = t.getChildArray();
          for (let t = 0, n = e.length; t < n; ++t) e[t].clear();
        })(this.root),
          (this.layerArray = []),
          (this.currentLayer = null),
          this.nodeMap.clear();
      },
    });
  var cm = cm || {};
  (cm.AxisNetLine = function () {
    (this.bb = null), (this.bb_pos = 0);
  }),
    (cm.AxisNetLine.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (cm.AxisNetLine.getRootAsAxisNetLine = function (t, e) {
      return (e || new cm.AxisNetLine()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (cm.AxisNetLine.prototype.textHeight = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readFloat32(this.bb_pos + t) : 0;
    }),
    (cm.AxisNetLine.prototype.textRoundRadius = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t ? this.bb.readFloat32(this.bb_pos + t) : 0;
    }),
    (cm.AxisNetLine.prototype.name = function (t) {
      var e = this.bb.__offset(this.bb_pos, 8);
      return e ? this.bb.__string(this.bb_pos + e, t) : null;
    }),
    (cm.AxisNetLine.prototype.textInsert = function (t) {
      var e = this.bb.__offset(this.bb_pos, 10);
      return e
        ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (cm.AxisNetLine.prototype.textInsertLength = function () {
      var t = this.bb.__offset(this.bb_pos, 10);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (cm.AxisNetLine.prototype.textInsertArray = function () {
      var t = this.bb.__offset(this.bb_pos, 10);
      return t
        ? new Float32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (cm.AxisNetLine.prototype.start = function (t) {
      var e = this.bb.__offset(this.bb_pos, 12);
      return e
        ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (cm.AxisNetLine.prototype.startLength = function () {
      var t = this.bb.__offset(this.bb_pos, 12);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (cm.AxisNetLine.prototype.startArray = function () {
      var t = this.bb.__offset(this.bb_pos, 12);
      return t
        ? new Float32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (cm.AxisNetLine.prototype.end = function (t) {
      var e = this.bb.__offset(this.bb_pos, 14);
      return e
        ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (cm.AxisNetLine.prototype.endLength = function () {
      var t = this.bb.__offset(this.bb_pos, 14);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (cm.AxisNetLine.prototype.endArray = function () {
      var t = this.bb.__offset(this.bb_pos, 14);
      return t
        ? new Float32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (cm.AxisNetLine.startAxisNetLine = function (t) {
      t.startObject(6);
    }),
    (cm.AxisNetLine.addTextHeight = function (t, e) {
      t.addFieldFloat32(0, e, 0);
    }),
    (cm.AxisNetLine.addTextRoundRadius = function (t, e) {
      t.addFieldFloat32(1, e, 0);
    }),
    (cm.AxisNetLine.addName = function (t, e) {
      t.addFieldOffset(2, e, 0);
    }),
    (cm.AxisNetLine.addTextInsert = function (t, e) {
      t.addFieldOffset(3, e, 0);
    }),
    (cm.AxisNetLine.createTextInsertVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addFloat32(e[n]);
      return t.endVector();
    }),
    (cm.AxisNetLine.startTextInsertVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (cm.AxisNetLine.addStart = function (t, e) {
      t.addFieldOffset(4, e, 0);
    }),
    (cm.AxisNetLine.createStartVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addFloat32(e[n]);
      return t.endVector();
    }),
    (cm.AxisNetLine.startStartVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (cm.AxisNetLine.addEnd = function (t, e) {
      t.addFieldOffset(5, e, 0);
    }),
    (cm.AxisNetLine.createEndVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addFloat32(e[n]);
      return t.endVector();
    }),
    (cm.AxisNetLine.startEndVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (cm.AxisNetLine.endAxisNetLine = function (t) {
      return t.endObject();
    }),
    (cm.AxisNetArc = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (cm.AxisNetArc.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (cm.AxisNetArc.getRootAsAxisNetArc = function (t, e) {
      return (e || new cm.AxisNetArc()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (cm.AxisNetArc.prototype.textHeight = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readFloat32(this.bb_pos + t) : 0;
    }),
    (cm.AxisNetArc.prototype.textRoundRadius = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t ? this.bb.readFloat32(this.bb_pos + t) : 0;
    }),
    (cm.AxisNetArc.prototype.name = function (t) {
      var e = this.bb.__offset(this.bb_pos, 8);
      return e ? this.bb.__string(this.bb_pos + e, t) : null;
    }),
    (cm.AxisNetArc.prototype.textInsert = function (t) {
      var e = this.bb.__offset(this.bb_pos, 10);
      return e
        ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (cm.AxisNetArc.prototype.textInsertLength = function () {
      var t = this.bb.__offset(this.bb_pos, 10);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (cm.AxisNetArc.prototype.textInsertArray = function () {
      var t = this.bb.__offset(this.bb_pos, 10);
      return t
        ? new Float32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (cm.AxisNetArc.prototype.center = function (t) {
      var e = this.bb.__offset(this.bb_pos, 12);
      return e
        ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (cm.AxisNetArc.prototype.centerLength = function () {
      var t = this.bb.__offset(this.bb_pos, 12);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (cm.AxisNetArc.prototype.centerArray = function () {
      var t = this.bb.__offset(this.bb_pos, 12);
      return t
        ? new Float32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (cm.AxisNetArc.prototype.radius = function () {
      var t = this.bb.__offset(this.bb_pos, 14);
      return t ? this.bb.readFloat32(this.bb_pos + t) : 0;
    }),
    (cm.AxisNetArc.prototype.startAngle = function () {
      var t = this.bb.__offset(this.bb_pos, 16);
      return t ? this.bb.readFloat32(this.bb_pos + t) : 0;
    }),
    (cm.AxisNetArc.prototype.endAngle = function () {
      var t = this.bb.__offset(this.bb_pos, 18);
      return t ? this.bb.readFloat32(this.bb_pos + t) : 0;
    }),
    (cm.AxisNetArc.prototype.antiClockWise = function (t) {
      var e = this.bb.__offset(this.bb_pos, 20);
      return e ? this.bb.__string(this.bb_pos + e, t) : null;
    }),
    (cm.AxisNetArc.startAxisNetArc = function (t) {
      t.startObject(9);
    }),
    (cm.AxisNetArc.addTextHeight = function (t, e) {
      t.addFieldFloat32(0, e, 0);
    }),
    (cm.AxisNetArc.addTextRoundRadius = function (t, e) {
      t.addFieldFloat32(1, e, 0);
    }),
    (cm.AxisNetArc.addName = function (t, e) {
      t.addFieldOffset(2, e, 0);
    }),
    (cm.AxisNetArc.addTextInsert = function (t, e) {
      t.addFieldOffset(3, e, 0);
    }),
    (cm.AxisNetArc.createTextInsertVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addFloat32(e[n]);
      return t.endVector();
    }),
    (cm.AxisNetArc.startTextInsertVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (cm.AxisNetArc.addCenter = function (t, e) {
      t.addFieldOffset(4, e, 0);
    }),
    (cm.AxisNetArc.createCenterVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addFloat32(e[n]);
      return t.endVector();
    }),
    (cm.AxisNetArc.startCenterVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (cm.AxisNetArc.addRadius = function (t, e) {
      t.addFieldFloat32(5, e, 0);
    }),
    (cm.AxisNetArc.addStartAngle = function (t, e) {
      t.addFieldFloat32(6, e, 0);
    }),
    (cm.AxisNetArc.addEndAngle = function (t, e) {
      t.addFieldFloat32(7, e, 0);
    }),
    (cm.AxisNetArc.addAntiClockWise = function (t, e) {
      t.addFieldOffset(8, e, 0);
    }),
    (cm.AxisNetArc.endAxisNetArc = function (t) {
      return t.endObject();
    }),
    (cm.line = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (cm.line.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (cm.line.getRootAsline = function (t, e) {
      return (e || new cm.line()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (cm.line.prototype.start = function (t) {
      var e = this.bb.__offset(this.bb_pos, 4);
      return e
        ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (cm.line.prototype.startLength = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (cm.line.prototype.startArray = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t
        ? new Float32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (cm.line.prototype.end = function (t) {
      var e = this.bb.__offset(this.bb_pos, 6);
      return e
        ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (cm.line.prototype.endLength = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (cm.line.prototype.endArray = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t
        ? new Float32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (cm.line.startline = function (t) {
      t.startObject(2);
    }),
    (cm.line.addStart = function (t, e) {
      t.addFieldOffset(0, e, 0);
    }),
    (cm.line.createStartVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addFloat32(e[n]);
      return t.endVector();
    }),
    (cm.line.startStartVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (cm.line.addEnd = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (cm.line.createEndVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addFloat32(e[n]);
      return t.endVector();
    }),
    (cm.line.startEndVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (cm.line.endline = function (t) {
      return t.endObject();
    }),
    (cm.OneFloorCrossLineInfo = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (cm.OneFloorCrossLineInfo.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (cm.OneFloorCrossLineInfo.getRootAsOneFloorCrossLineInfo = function (t, e) {
      return (e || new cm.OneFloorCrossLineInfo()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (cm.OneFloorCrossLineInfo.prototype.floorId = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (cm.OneFloorCrossLineInfo.prototype.floorHeight = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t ? this.bb.readFloat32(this.bb_pos + t) : 0;
    }),
    (cm.OneFloorCrossLineInfo.prototype.floorElevation = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t ? this.bb.readFloat32(this.bb_pos + t) : 0;
    }),
    (cm.OneFloorCrossLineInfo.prototype.floorName = function (t) {
      var e = this.bb.__offset(this.bb_pos, 10);
      return e ? this.bb.__string(this.bb_pos + e, t) : null;
    }),
    (cm.OneFloorCrossLineInfo.prototype.axisNetLineArray = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 12);
      return n
        ? (e || new cm.AxisNetLine()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (cm.OneFloorCrossLineInfo.prototype.axisNetLineArrayLength = function () {
      var t = this.bb.__offset(this.bb_pos, 12);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (cm.OneFloorCrossLineInfo.prototype.axisNetArcArray = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 14);
      return n
        ? (e || new cm.AxisNetArc()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (cm.OneFloorCrossLineInfo.prototype.axisNetArcArrayLength = function () {
      var t = this.bb.__offset(this.bb_pos, 14);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (cm.OneFloorCrossLineInfo.prototype.crossLines = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 16);
      return n
        ? (e || new cm.line()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (cm.OneFloorCrossLineInfo.prototype.crossLinesLength = function () {
      var t = this.bb.__offset(this.bb_pos, 16);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (cm.OneFloorCrossLineInfo.startOneFloorCrossLineInfo = function (t) {
      t.startObject(7);
    }),
    (cm.OneFloorCrossLineInfo.addFloorId = function (t, e) {
      t.addFieldInt32(0, e, 0);
    }),
    (cm.OneFloorCrossLineInfo.addFloorHeight = function (t, e) {
      t.addFieldFloat32(1, e, 0);
    }),
    (cm.OneFloorCrossLineInfo.addFloorElevation = function (t, e) {
      t.addFieldFloat32(2, e, 0);
    }),
    (cm.OneFloorCrossLineInfo.addFloorName = function (t, e) {
      t.addFieldOffset(3, e, 0);
    }),
    (cm.OneFloorCrossLineInfo.addAxisNetLineArray = function (t, e) {
      t.addFieldOffset(4, e, 0);
    }),
    (cm.OneFloorCrossLineInfo.createAxisNetLineArrayVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (cm.OneFloorCrossLineInfo.startAxisNetLineArrayVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (cm.OneFloorCrossLineInfo.addAxisNetArcArray = function (t, e) {
      t.addFieldOffset(5, e, 0);
    }),
    (cm.OneFloorCrossLineInfo.createAxisNetArcArrayVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (cm.OneFloorCrossLineInfo.startAxisNetArcArrayVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (cm.OneFloorCrossLineInfo.addCrossLines = function (t, e) {
      t.addFieldOffset(6, e, 0);
    }),
    (cm.OneFloorCrossLineInfo.createCrossLinesVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (cm.OneFloorCrossLineInfo.startCrossLinesVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (cm.OneFloorCrossLineInfo.endOneFloorCrossLineInfo = function (t) {
      return t.endObject();
    }),
    (cm.FloorCrossLineGroup = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (cm.FloorCrossLineGroup.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (cm.FloorCrossLineGroup.getRootAsFloorCrossLineGroup = function (t, e) {
      return (e || new cm.FloorCrossLineGroup()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (cm.FloorCrossLineGroup.prototype.floorPlanGraph = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 4);
      return n
        ? (e || new cm.OneFloorCrossLineInfo()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (cm.FloorCrossLineGroup.prototype.floorPlanGraphLength = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (cm.FloorCrossLineGroup.startFloorCrossLineGroup = function (t) {
      t.startObject(1);
    }),
    (cm.FloorCrossLineGroup.addFloorPlanGraph = function (t, e) {
      t.addFieldOffset(0, e, 0);
    }),
    (cm.FloorCrossLineGroup.createFloorPlanGraphVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (cm.FloorCrossLineGroup.startFloorPlanGraphVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (cm.FloorCrossLineGroup.endFloorCrossLineGroup = function (t) {
      return t.endObject();
    }),
    (cm.GjInfo_index = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (cm.GjInfo_index.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (cm.GjInfo_index.getRootAsGjInfo_index = function (t, e) {
      return (e || new cm.GjInfo_index()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (cm.GjInfo_index.prototype.name = function (t) {
      var e = this.bb.__offset(this.bb_pos, 4);
      return e ? this.bb.__string(this.bb_pos + e, t) : null;
    }),
    (cm.GjInfo_index.prototype.id = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (cm.GjInfo_index.prototype.handleInfo = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 8);
      return n
        ? this.bb.__string(this.bb.__vector(this.bb_pos + n) + 4 * t, e)
        : null;
    }),
    (cm.GjInfo_index.prototype.handleInfoLength = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (cm.GjInfo_index.startGjInfo_index = function (t) {
      t.startObject(3);
    }),
    (cm.GjInfo_index.addName = function (t, e) {
      t.addFieldOffset(0, e, 0);
    }),
    (cm.GjInfo_index.addId = function (t, e) {
      t.addFieldInt32(1, e, 0);
    }),
    (cm.GjInfo_index.addHandleInfo = function (t, e) {
      t.addFieldOffset(2, e, 0);
    }),
    (cm.GjInfo_index.createHandleInfoVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (cm.GjInfo_index.startHandleInfoVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (cm.GjInfo_index.endGjInfo_index = function (t) {
      return t.endObject();
    }),
    (cm.ComtypeInfo_gjinfoindex = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (cm.ComtypeInfo_gjinfoindex.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (cm.ComtypeInfo_gjinfoindex.getRootAsComtypeInfo_gjinfoindex = function (
      t,
      e,
    ) {
      return (e || new cm.ComtypeInfo_gjinfoindex()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (cm.ComtypeInfo_gjinfoindex.prototype.uuid = function (t) {
      var e = this.bb.__offset(this.bb_pos, 4);
      return e ? this.bb.__string(this.bb_pos + e, t) : null;
    }),
    (cm.ComtypeInfo_gjinfoindex.prototype.id = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (cm.ComtypeInfo_gjinfoindex.prototype.name = function (t) {
      var e = this.bb.__offset(this.bb_pos, 8);
      return e ? this.bb.__string(this.bb_pos + e, t) : null;
    }),
    (cm.ComtypeInfo_gjinfoindex.prototype.bId = function () {
      var t = this.bb.__offset(this.bb_pos, 10);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (cm.ComtypeInfo_gjinfoindex.prototype.bName = function (t) {
      var e = this.bb.__offset(this.bb_pos, 12);
      return e ? this.bb.__string(this.bb_pos + e, t) : null;
    }),
    (cm.ComtypeInfo_gjinfoindex.prototype.gjInfo = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 14);
      return n
        ? (e || new cm.GjInfo_index()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (cm.ComtypeInfo_gjinfoindex.prototype.gjInfoLength = function () {
      var t = this.bb.__offset(this.bb_pos, 14);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (cm.ComtypeInfo_gjinfoindex.startComtypeInfo_gjinfoindex = function (t) {
      t.startObject(6);
    }),
    (cm.ComtypeInfo_gjinfoindex.addUuid = function (t, e) {
      t.addFieldOffset(0, e, 0);
    }),
    (cm.ComtypeInfo_gjinfoindex.addId = function (t, e) {
      t.addFieldInt32(1, e, 0);
    }),
    (cm.ComtypeInfo_gjinfoindex.addName = function (t, e) {
      t.addFieldOffset(2, e, 0);
    }),
    (cm.ComtypeInfo_gjinfoindex.addBId = function (t, e) {
      t.addFieldInt32(3, e, 0);
    }),
    (cm.ComtypeInfo_gjinfoindex.addBName = function (t, e) {
      t.addFieldOffset(4, e, 0);
    }),
    (cm.ComtypeInfo_gjinfoindex.addGjInfo = function (t, e) {
      t.addFieldOffset(5, e, 0);
    }),
    (cm.ComtypeInfo_gjinfoindex.createGjInfoVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (cm.ComtypeInfo_gjinfoindex.startGjInfoVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (cm.ComtypeInfo_gjinfoindex.endComtypeInfo_gjinfoindex = function (t) {
      return t.endObject();
    }),
    (cm.SubComtypeInfo_gjinfoindex = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (cm.SubComtypeInfo_gjinfoindex.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (cm.SubComtypeInfo_gjinfoindex.getRootAsSubComtypeInfo_gjinfoindex =
      function (t, e) {
        return (e || new cm.SubComtypeInfo_gjinfoindex()).__init(
          t.readInt32(t.position()) + t.position(),
          t,
        );
      }),
    (cm.SubComtypeInfo_gjinfoindex.prototype.id = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (cm.SubComtypeInfo_gjinfoindex.prototype.name = function (t) {
      var e = this.bb.__offset(this.bb_pos, 6);
      return e ? this.bb.__string(this.bb_pos + e, t) : null;
    }),
    (cm.SubComtypeInfo_gjinfoindex.prototype.uuid = function (t) {
      var e = this.bb.__offset(this.bb_pos, 8);
      return e ? this.bb.__string(this.bb_pos + e, t) : null;
    }),
    (cm.SubComtypeInfo_gjinfoindex.prototype.gjInfo = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 10);
      return n
        ? (e || new cm.GjInfo_index()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (cm.SubComtypeInfo_gjinfoindex.prototype.gjInfoLength = function () {
      var t = this.bb.__offset(this.bb_pos, 10);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (cm.SubComtypeInfo_gjinfoindex.prototype.subcomtypeInfo = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 12);
      return n
        ? (e || new cm.SubComtypeInfo_gjinfoindex()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (cm.SubComtypeInfo_gjinfoindex.prototype.subcomtypeInfoLength =
      function () {
        var t = this.bb.__offset(this.bb_pos, 12);
        return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
      }),
    (cm.SubComtypeInfo_gjinfoindex.startSubComtypeInfo_gjinfoindex = function (
      t,
    ) {
      t.startObject(5);
    }),
    (cm.SubComtypeInfo_gjinfoindex.addId = function (t, e) {
      t.addFieldInt32(0, e, 0);
    }),
    (cm.SubComtypeInfo_gjinfoindex.addName = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (cm.SubComtypeInfo_gjinfoindex.addUuid = function (t, e) {
      t.addFieldOffset(2, e, 0);
    }),
    (cm.SubComtypeInfo_gjinfoindex.addGjInfo = function (t, e) {
      t.addFieldOffset(3, e, 0);
    }),
    (cm.SubComtypeInfo_gjinfoindex.createGjInfoVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (cm.SubComtypeInfo_gjinfoindex.startGjInfoVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (cm.SubComtypeInfo_gjinfoindex.addSubcomtypeInfo = function (t, e) {
      t.addFieldOffset(4, e, 0);
    }),
    (cm.SubComtypeInfo_gjinfoindex.createSubcomtypeInfoVector = function (
      t,
      e,
    ) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (cm.SubComtypeInfo_gjinfoindex.startSubcomtypeInfoVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (cm.SubComtypeInfo_gjinfoindex.endSubComtypeInfo_gjinfoindex = function (
      t,
    ) {
      return t.endObject();
    }),
    (cm.ComtypeGroupInfo_gjinfoindex = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (cm.ComtypeGroupInfo_gjinfoindex.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (cm.ComtypeGroupInfo_gjinfoindex.getRootAsComtypeGroupInfo_gjinfoindex =
      function (t, e) {
        return (e || new cm.ComtypeGroupInfo_gjinfoindex()).__init(
          t.readInt32(t.position()) + t.position(),
          t,
        );
      }),
    (cm.ComtypeGroupInfo_gjinfoindex.prototype.bId = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (cm.ComtypeGroupInfo_gjinfoindex.prototype.bName = function (t) {
      var e = this.bb.__offset(this.bb_pos, 6);
      return e ? this.bb.__string(this.bb_pos + e, t) : null;
    }),
    (cm.ComtypeGroupInfo_gjinfoindex.prototype.subcomtypeInfo = function (
      t,
      e,
    ) {
      var n = this.bb.__offset(this.bb_pos, 8);
      return n
        ? (e || new cm.SubComtypeInfo_gjinfoindex()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (cm.ComtypeGroupInfo_gjinfoindex.prototype.subcomtypeInfoLength =
      function () {
        var t = this.bb.__offset(this.bb_pos, 8);
        return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
      }),
    (cm.ComtypeGroupInfo_gjinfoindex.startComtypeGroupInfo_gjinfoindex =
      function (t) {
        t.startObject(3);
      }),
    (cm.ComtypeGroupInfo_gjinfoindex.addBId = function (t, e) {
      t.addFieldInt32(0, e, 0);
    }),
    (cm.ComtypeGroupInfo_gjinfoindex.addBName = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (cm.ComtypeGroupInfo_gjinfoindex.addSubcomtypeInfo = function (t, e) {
      t.addFieldOffset(2, e, 0);
    }),
    (cm.ComtypeGroupInfo_gjinfoindex.createSubcomtypeInfoVector = function (
      t,
      e,
    ) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (cm.ComtypeGroupInfo_gjinfoindex.startSubcomtypeInfoVector = function (
      t,
      e,
    ) {
      t.startVector(4, e, 4);
    }),
    (cm.ComtypeGroupInfo_gjinfoindex.endComtypeGroupInfo_gjinfoindex =
      function (t) {
        return t.endObject();
      }),
    (cm.SimFloorInfoAddCAxisNet = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (cm.SimFloorInfoAddCAxisNet.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (cm.SimFloorInfoAddCAxisNet.getRootAsSimFloorInfoAddCAxisNet = function (
      t,
      e,
    ) {
      return (e || new cm.SimFloorInfoAddCAxisNet()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (cm.SimFloorInfoAddCAxisNet.prototype.floorid = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (cm.SimFloorInfoAddCAxisNet.prototype.floorname = function (t) {
      var e = this.bb.__offset(this.bb_pos, 6);
      return e ? this.bb.__string(this.bb_pos + e, t) : null;
    }),
    (cm.SimFloorInfoAddCAxisNet.prototype.showid = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (cm.SimFloorInfoAddCAxisNet.prototype.comtypeGroupInfo = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 10);
      return n
        ? (e || new cm.ComtypeGroupInfo_gjinfoindex()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (cm.SimFloorInfoAddCAxisNet.prototype.comtypeGroupInfoLength = function () {
      var t = this.bb.__offset(this.bb_pos, 10);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (cm.SimFloorInfoAddCAxisNet.startSimFloorInfoAddCAxisNet = function (t) {
      t.startObject(4);
    }),
    (cm.SimFloorInfoAddCAxisNet.addFloorid = function (t, e) {
      t.addFieldInt32(0, e, 0);
    }),
    (cm.SimFloorInfoAddCAxisNet.addFloorname = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (cm.SimFloorInfoAddCAxisNet.addShowid = function (t, e) {
      t.addFieldInt32(2, e, 0);
    }),
    (cm.SimFloorInfoAddCAxisNet.addComtypeGroupInfo = function (t, e) {
      t.addFieldOffset(3, e, 0);
    }),
    (cm.SimFloorInfoAddCAxisNet.createComtypeGroupInfoVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (cm.SimFloorInfoAddCAxisNet.startComtypeGroupInfoVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (cm.SimFloorInfoAddCAxisNet.endSimFloorInfoAddCAxisNet = function (t) {
      return t.endObject();
    }),
    (cm.CBuildStageInfo = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (cm.CBuildStageInfo.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (cm.CBuildStageInfo.getRootAsCBuildStageInfo = function (t, e) {
      return (e || new cm.CBuildStageInfo()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (cm.CBuildStageInfo.prototype.stageid = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (cm.CBuildStageInfo.prototype.stagename = function (t) {
      var e = this.bb.__offset(this.bb_pos, 6);
      return e ? this.bb.__string(this.bb_pos + e, t) : null;
    }),
    (cm.CBuildStageInfo.startCBuildStageInfo = function (t) {
      t.startObject(2);
    }),
    (cm.CBuildStageInfo.addStageid = function (t, e) {
      t.addFieldInt32(0, e, 0);
    }),
    (cm.CBuildStageInfo.addStagename = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (cm.CBuildStageInfo.endCBuildStageInfo = function (t) {
      return t.endObject();
    }),
    (cm.CSimBuildInfo = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (cm.CSimBuildInfo.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (cm.CSimBuildInfo.getRootAsCSimBuildInfo = function (t, e) {
      return (e || new cm.CSimBuildInfo()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (cm.CSimBuildInfo.prototype.buildid = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (cm.CSimBuildInfo.prototype.buildname = function (t) {
      var e = this.bb.__offset(this.bb_pos, 6);
      return e ? this.bb.__string(this.bb_pos + e, t) : null;
    }),
    (cm.CSimBuildInfo.prototype.floors = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 8);
      return n
        ? (e || new cm.SimFloorInfoAddCAxisNet()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (cm.CSimBuildInfo.prototype.floorsLength = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (cm.CSimBuildInfo.startCSimBuildInfo = function (t) {
      t.startObject(3);
    }),
    (cm.CSimBuildInfo.addBuildid = function (t, e) {
      t.addFieldInt32(0, e, 0);
    }),
    (cm.CSimBuildInfo.addBuildname = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (cm.CSimBuildInfo.addFloors = function (t, e) {
      t.addFieldOffset(2, e, 0);
    }),
    (cm.CSimBuildInfo.createFloorsVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (cm.CSimBuildInfo.startFloorsVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (cm.CSimBuildInfo.endCSimBuildInfo = function (t) {
      return t.endObject();
    }),
    (cm.UserDataInfo = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (cm.UserDataInfo.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (cm.UserDataInfo.getRootAsUserDataInfo = function (t, e) {
      return (e || new cm.UserDataInfo()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (cm.UserDataInfo.prototype.strName = function (t) {
      var e = this.bb.__offset(this.bb_pos, 4);
      return e ? this.bb.__string(this.bb_pos + e, t) : null;
    }),
    (cm.UserDataInfo.prototype.strValue = function (t) {
      var e = this.bb.__offset(this.bb_pos, 6);
      return e ? this.bb.__string(this.bb_pos + e, t) : null;
    }),
    (cm.UserDataInfo.startUserDataInfo = function (t) {
      t.startObject(2);
    }),
    (cm.UserDataInfo.addStrName = function (t, e) {
      t.addFieldOffset(0, e, 0);
    }),
    (cm.UserDataInfo.addStrValue = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (cm.UserDataInfo.endUserDataInfo = function (t) {
      return t.endObject();
    }),
    (cm.HandleInfo = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (cm.HandleInfo.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (cm.HandleInfo.getRootAsHandleInfo = function (t, e) {
      return (e || new cm.HandleInfo()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (cm.HandleInfo.prototype.floorid = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (cm.HandleInfo.prototype.id = function (t) {
      var e = this.bb.__offset(this.bb_pos, 6);
      return e ? this.bb.__string(this.bb_pos + e, t) : null;
    }),
    (cm.HandleInfo.prototype.userData = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 8);
      return n
        ? (e || new cm.UserDataInfo()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (cm.HandleInfo.prototype.userDataLength = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (cm.HandleInfo.prototype.parmtextindex = function (t) {
      var e = this.bb.__offset(this.bb_pos, 10);
      return e
        ? this.bb.readInt32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (cm.HandleInfo.prototype.parmtextindexLength = function () {
      var t = this.bb.__offset(this.bb_pos, 10);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (cm.HandleInfo.prototype.parmtextindexArray = function () {
      var t = this.bb.__offset(this.bb_pos, 10);
      return t
        ? new Int32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (cm.HandleInfo.startHandleInfo = function (t) {
      t.startObject(4);
    }),
    (cm.HandleInfo.addFloorid = function (t, e) {
      t.addFieldInt32(0, e, 0);
    }),
    (cm.HandleInfo.addId = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (cm.HandleInfo.addUserData = function (t, e) {
      t.addFieldOffset(2, e, 0);
    }),
    (cm.HandleInfo.createUserDataVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (cm.HandleInfo.startUserDataVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (cm.HandleInfo.addParmtextindex = function (t, e) {
      t.addFieldOffset(3, e, 0);
    }),
    (cm.HandleInfo.createParmtextindexVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addInt32(e[n]);
      return t.endVector();
    }),
    (cm.HandleInfo.startParmtextindexVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (cm.HandleInfo.endHandleInfo = function (t) {
      return t.endObject();
    }),
    (cm.CBuildProject = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (cm.CBuildProject.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (cm.CBuildProject.getRootAsCBuildProject = function (t, e) {
      return (e || new cm.CBuildProject()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (cm.CBuildProject.prototype.builds = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 4);
      return n
        ? (e || new cm.CSimBuildInfo()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (cm.CBuildProject.prototype.buildsLength = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (cm.CBuildProject.prototype.stages = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 6);
      return n
        ? (e || new cm.CBuildStageInfo()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (cm.CBuildProject.prototype.stagesLength = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (cm.CBuildProject.startCBuildProject = function (t) {
      t.startObject(2);
    }),
    (cm.CBuildProject.addBuilds = function (t, e) {
      t.addFieldOffset(0, e, 0);
    }),
    (cm.CBuildProject.createBuildsVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (cm.CBuildProject.startBuildsVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (cm.CBuildProject.addStages = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (cm.CBuildProject.createStagesVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (cm.CBuildProject.startStagesVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (cm.CBuildProject.endCBuildProject = function (t) {
      return t.endObject();
    }),
    (cm.CBuildProject_map = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (cm.CBuildProject_map.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (cm.CBuildProject_map.getRootAsCBuildProject_map = function (t, e) {
      return (e || new cm.CBuildProject_map()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (cm.CBuildProject_map.prototype.handleinfos = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 4);
      return n
        ? (e || new cm.HandleInfo()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (cm.CBuildProject_map.prototype.handleinfosLength = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (cm.CBuildProject_map.prototype.parmtextlist = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 6);
      return n
        ? this.bb.__string(this.bb.__vector(this.bb_pos + n) + 4 * t, e)
        : null;
    }),
    (cm.CBuildProject_map.prototype.parmtextlistLength = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (cm.CBuildProject_map.startCBuildProject_map = function (t) {
      t.startObject(2);
    }),
    (cm.CBuildProject_map.addHandleinfos = function (t, e) {
      t.addFieldOffset(0, e, 0);
    }),
    (cm.CBuildProject_map.createHandleinfosVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (cm.CBuildProject_map.startHandleinfosVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (cm.CBuildProject_map.addParmtextlist = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (cm.CBuildProject_map.createParmtextlistVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (cm.CBuildProject_map.startParmtextlistVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (cm.CBuildProject_map.endCBuildProject_map = function (t) {
      return t.endObject();
    }),
    (cm.CComponentsInfoAddBuildinfo = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (cm.CComponentsInfoAddBuildinfo.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (cm.CComponentsInfoAddBuildinfo.getRootAsCComponentsInfoAddBuildinfo =
      function (t, e) {
        return (e || new cm.CComponentsInfoAddBuildinfo()).__init(
          t.readInt32(t.position()) + t.position(),
          t,
        );
      }),
    (cm.CComponentsInfoAddBuildinfo.prototype.mPBuildproject = function (t) {
      var e = this.bb.__offset(this.bb_pos, 4);
      return e
        ? (t || new cm.CBuildProject()).__init(
            this.bb.__indirect(this.bb_pos + e),
            this.bb,
          )
        : null;
    }),
    (cm.CComponentsInfoAddBuildinfo.startCComponentsInfoAddBuildinfo =
      function (t) {
        t.startObject(1);
      }),
    (cm.CComponentsInfoAddBuildinfo.addMPBuildproject = function (t, e) {
      t.addFieldOffset(0, e, 0);
    }),
    (cm.CComponentsInfoAddBuildinfo.endCComponentsInfoAddBuildinfo = function (
      t,
    ) {
      return t.endObject();
    }),
    (cm.CComponentsInfoAddBuildinfo.finishCComponentsInfoAddBuildinfoBuffer =
      function (t, e) {
        t.finish(e);
      }),
    (cm.CComponentsInfoAddBuildinfoMap = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (cm.CComponentsInfoAddBuildinfoMap.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (cm.CComponentsInfoAddBuildinfoMap.getRootAsCComponentsInfoAddBuildinfoMap =
      function (t, e) {
        return (e || new cm.CComponentsInfoAddBuildinfoMap()).__init(
          t.readInt32(t.position()) + t.position(),
          t,
        );
      }),
    (cm.CComponentsInfoAddBuildinfoMap.prototype.mPBuildprojectMap = function (
      t,
    ) {
      var e = this.bb.__offset(this.bb_pos, 4);
      return e
        ? (t || new cm.CBuildProject_map()).__init(
            this.bb.__indirect(this.bb_pos + e),
            this.bb,
          )
        : null;
    }),
    (cm.CComponentsInfoAddBuildinfoMap.startCComponentsInfoAddBuildinfoMap =
      function (t) {
        t.startObject(1);
      }),
    (cm.CComponentsInfoAddBuildinfoMap.addMPBuildprojectMap = function (t, e) {
      t.addFieldOffset(0, e, 0);
    }),
    (cm.CComponentsInfoAddBuildinfoMap.endCComponentsInfoAddBuildinfoMap =
      function (t) {
        return t.endObject();
      });
  var lm = {};
  function hm() {
    this.type = 'ComponentFBInterface';
  }
  (lm.SIZEOF_SHORT = 2),
    (lm.SIZEOF_INT = 4),
    (lm.FILE_IDENTIFIER_LENGTH = 4),
    (lm.Encoding = { UTF8_BYTES: 1, UTF16_STRING: 2 }),
    (lm.int32 = new Int32Array(2)),
    (lm.float32 = new Float32Array(lm.int32.buffer)),
    (lm.float64 = new Float64Array(lm.int32.buffer)),
    (lm.isLittleEndian =
      1 === new Uint16Array(new Uint8Array([1, 0]).buffer)[0]),
    (lm.Long = function (t, e) {
      (this.low = 0 | t), (this.high = 0 | e);
    }),
    (lm.Long.create = function (t, e) {
      return 0 == t && 0 == e ? lm.Long.ZERO : new lm.Long(t, e);
    }),
    (lm.Long.prototype.toFloat64 = function () {
      return (this.low >>> 0) + 4294967296 * this.high;
    }),
    (lm.Long.prototype.equals = function (t) {
      return this.low == t.low && this.high == t.high;
    }),
    (lm.Long.ZERO = new lm.Long(0, 0)),
    (lm.Builder = function (t) {
      if (t) e = t;
      else var e = 1024;
      (this.bb = lm.ByteBuffer.allocate(e)),
        (this.space = e),
        (this.minalign = 1),
        (this.vtable = null),
        (this.vtable_in_use = 0),
        (this.isNested = !1),
        (this.object_start = 0),
        (this.vtables = []),
        (this.vector_num_elems = 0),
        (this.force_defaults = !1);
    }),
    (lm.Builder.prototype.forceDefaults = function (t) {
      this.force_defaults = t;
    }),
    (lm.Builder.prototype.dataBuffer = function () {
      return this.bb;
    }),
    (lm.Builder.prototype.asUint8Array = function () {
      return this.bb
        .bytes()
        .subarray(this.bb.position(), this.bb.position() + this.offset());
    }),
    (lm.Builder.prototype.prep = function (t, e) {
      t > this.minalign && (this.minalign = t);
      for (
        var n = (1 + ~(this.bb.capacity() - this.space + e)) & (t - 1);
        this.space < n + t + e;

      ) {
        var i = this.bb.capacity();
        (this.bb = lm.Builder.growByteBuffer(this.bb)),
          (this.space += this.bb.capacity() - i);
      }
      this.pad(n);
    }),
    (lm.Builder.prototype.pad = function (t) {
      for (var e = 0; e < t; e++) this.bb.writeInt8(--this.space, 0);
    }),
    (lm.Builder.prototype.writeInt8 = function (t) {
      this.bb.writeInt8((this.space -= 1), t);
    }),
    (lm.Builder.prototype.writeInt16 = function (t) {
      this.bb.writeInt16((this.space -= 2), t);
    }),
    (lm.Builder.prototype.writeInt32 = function (t) {
      this.bb.writeInt32((this.space -= 4), t);
    }),
    (lm.Builder.prototype.writeInt64 = function (t) {
      this.bb.writeInt64((this.space -= 8), t);
    }),
    (lm.Builder.prototype.writeFloat32 = function (t) {
      this.bb.writeFloat32((this.space -= 4), t);
    }),
    (lm.Builder.prototype.writeFloat64 = function (t) {
      this.bb.writeFloat64((this.space -= 8), t);
    }),
    (lm.Builder.prototype.addInt8 = function (t) {
      this.prep(1, 0), this.writeInt8(t);
    }),
    (lm.Builder.prototype.addInt16 = function (t) {
      this.prep(2, 0), this.writeInt16(t);
    }),
    (lm.Builder.prototype.addInt32 = function (t) {
      this.prep(4, 0), this.writeInt32(t);
    }),
    (lm.Builder.prototype.addInt64 = function (t) {
      this.prep(8, 0), this.writeInt64(t);
    }),
    (lm.Builder.prototype.addFloat32 = function (t) {
      this.prep(4, 0), this.writeFloat32(t);
    }),
    (lm.Builder.prototype.addFloat64 = function (t) {
      this.prep(8, 0), this.writeFloat64(t);
    }),
    (lm.Builder.prototype.addFieldInt8 = function (t, e, n) {
      (this.force_defaults || e != n) && (this.addInt8(e), this.slot(t));
    }),
    (lm.Builder.prototype.addFieldInt16 = function (t, e, n) {
      (this.force_defaults || e != n) && (this.addInt16(e), this.slot(t));
    }),
    (lm.Builder.prototype.addFieldInt32 = function (t, e, n) {
      (this.force_defaults || e != n) && (this.addInt32(e), this.slot(t));
    }),
    (lm.Builder.prototype.addFieldInt64 = function (t, e, n) {
      (!this.force_defaults && e.equals(n)) || (this.addInt64(e), this.slot(t));
    }),
    (lm.Builder.prototype.addFieldFloat32 = function (t, e, n) {
      (this.force_defaults || e != n) && (this.addFloat32(e), this.slot(t));
    }),
    (lm.Builder.prototype.addFieldFloat64 = function (t, e, n) {
      (this.force_defaults || e != n) && (this.addFloat64(e), this.slot(t));
    }),
    (lm.Builder.prototype.addFieldOffset = function (t, e, n) {
      (this.force_defaults || e != n) && (this.addOffset(e), this.slot(t));
    }),
    (lm.Builder.prototype.addFieldStruct = function (t, e, n) {
      e != n && (this.nested(e), this.slot(t));
    }),
    (lm.Builder.prototype.nested = function (t) {
      if (t != this.offset())
        throw new Error('FlatBuffers: struct must be serialized inline.');
    }),
    (lm.Builder.prototype.notNested = function () {
      if (this.isNested)
        throw new Error(
          'FlatBuffers: object serialization must not be nested.',
        );
    }),
    (lm.Builder.prototype.slot = function (t) {
      this.vtable[t] = this.offset();
    }),
    (lm.Builder.prototype.offset = function () {
      return this.bb.capacity() - this.space;
    }),
    (lm.Builder.growByteBuffer = function (t) {
      var e = t.capacity();
      if (3221225472 & e)
        throw new Error('FlatBuffers: cannot grow buffer beyond 2 gigabytes.');
      var n = e << 1,
        i = lm.ByteBuffer.allocate(n);
      return i.setPosition(n - e), i.bytes().set(t.bytes(), n - e), i;
    }),
    (lm.Builder.prototype.addOffset = function (t) {
      this.prep(lm.SIZEOF_INT, 0),
        this.writeInt32(this.offset() - t + lm.SIZEOF_INT);
    }),
    (lm.Builder.prototype.startObject = function (t) {
      this.notNested(),
        null == this.vtable && (this.vtable = []),
        (this.vtable_in_use = t);
      for (var e = 0; e < t; e++) this.vtable[e] = 0;
      (this.isNested = !0), (this.object_start = this.offset());
    }),
    (lm.Builder.prototype.endObject = function () {
      if (null == this.vtable || !this.isNested)
        throw new Error('FlatBuffers: endObject called without startObject');
      this.addInt32(0);
      for (
        var t = this.offset(), e = this.vtable_in_use - 1;
        e >= 0 && 0 == this.vtable[e];
        e--
      );
      for (var n = e + 1; e >= 0; e--)
        this.addInt16(0 != this.vtable[e] ? t - this.vtable[e] : 0);
      this.addInt16(t - this.object_start);
      var i = (n + 2) * lm.SIZEOF_SHORT;
      this.addInt16(i);
      var r = 0,
        o = this.space;
      t: for (e = 0; e < this.vtables.length; e++) {
        var s = this.bb.capacity() - this.vtables[e];
        if (i == this.bb.readInt16(s)) {
          for (var a = lm.SIZEOF_SHORT; a < i; a += lm.SIZEOF_SHORT)
            if (this.bb.readInt16(o + a) != this.bb.readInt16(s + a))
              continue t;
          r = this.vtables[e];
          break;
        }
      }
      return (
        r
          ? ((this.space = this.bb.capacity() - t),
            this.bb.writeInt32(this.space, r - t))
          : (this.vtables.push(this.offset()),
            this.bb.writeInt32(this.bb.capacity() - t, this.offset() - t)),
        (this.isNested = !1),
        t
      );
    }),
    (lm.Builder.prototype.finish = function (t, e) {
      if (e) {
        var n = e;
        if (
          (this.prep(this.minalign, lm.SIZEOF_INT + lm.FILE_IDENTIFIER_LENGTH),
          n.length != lm.FILE_IDENTIFIER_LENGTH)
        )
          throw new Error(
            'FlatBuffers: file identifier must be length ' +
              lm.FILE_IDENTIFIER_LENGTH,
          );
        for (var i = lm.FILE_IDENTIFIER_LENGTH - 1; i >= 0; i--)
          this.writeInt8(n.charCodeAt(i));
      }
      this.prep(this.minalign, lm.SIZEOF_INT),
        this.addOffset(t),
        this.bb.setPosition(this.space);
    }),
    (lm.Builder.prototype.requiredField = function (t, e) {
      var n = this.bb.capacity() - t,
        i = n - this.bb.readInt32(n);
      if (!(0 != this.bb.readInt16(i + e)))
        throw new Error('FlatBuffers: field ' + e + ' must be set');
    }),
    (lm.Builder.prototype.startVector = function (t, e, n) {
      this.notNested(),
        (this.vector_num_elems = e),
        this.prep(lm.SIZEOF_INT, t * e),
        this.prep(n, t * e);
    }),
    (lm.Builder.prototype.endVector = function () {
      return this.writeInt32(this.vector_num_elems), this.offset();
    }),
    (lm.Builder.prototype.createString = function (t) {
      if (t instanceof Uint8Array) var e = t;
      else {
        e = [];
        for (var n = 0; n < t.length; ) {
          var i,
            r = t.charCodeAt(n++);
          if (r < 55296 || r >= 56320) i = r;
          else i = (r << 10) + t.charCodeAt(n++) + -56613888;
          i < 128
            ? e.push(i)
            : (i < 2048
                ? e.push(((i >> 6) & 31) | 192)
                : (i < 65536
                    ? e.push(((i >> 12) & 15) | 224)
                    : e.push(((i >> 18) & 7) | 240, ((i >> 12) & 63) | 128),
                  e.push(((i >> 6) & 63) | 128)),
              e.push((63 & i) | 128));
        }
      }
      this.addInt8(0),
        this.startVector(1, e.length, 1),
        this.bb.setPosition((this.space -= e.length));
      n = 0;
      for (var o = this.space, s = this.bb.bytes(); n < e.length; n++)
        s[o++] = e[n];
      return this.endVector();
    }),
    (lm.Builder.prototype.createLong = function (t, e) {
      return lm.Long.create(t, e);
    }),
    (lm.ByteBuffer = function (t) {
      (this.bytes_ = t), (this.position_ = 0);
    }),
    (lm.ByteBuffer.allocate = function (t) {
      return new lm.ByteBuffer(new Uint8Array(t));
    }),
    (lm.ByteBuffer.prototype.bytes = function () {
      return this.bytes_;
    }),
    (lm.ByteBuffer.prototype.position = function () {
      return this.position_;
    }),
    (lm.ByteBuffer.prototype.setPosition = function (t) {
      this.position_ = t;
    }),
    (lm.ByteBuffer.prototype.capacity = function () {
      return this.bytes_.length;
    }),
    (lm.ByteBuffer.prototype.readInt8 = function (t) {
      return (this.readUint8(t) << 24) >> 24;
    }),
    (lm.ByteBuffer.prototype.readUint8 = function (t) {
      return this.bytes_[t];
    }),
    (lm.ByteBuffer.prototype.readInt16 = function (t) {
      return (this.readUint16(t) << 16) >> 16;
    }),
    (lm.ByteBuffer.prototype.readUint16 = function (t) {
      return this.bytes_[t] | (this.bytes_[t + 1] << 8);
    }),
    (lm.ByteBuffer.prototype.readInt32 = function (t) {
      return (
        this.bytes_[t] |
        (this.bytes_[t + 1] << 8) |
        (this.bytes_[t + 2] << 16) |
        (this.bytes_[t + 3] << 24)
      );
    }),
    (lm.ByteBuffer.prototype.readUint32 = function (t) {
      return this.readInt32(t) >>> 0;
    }),
    (lm.ByteBuffer.prototype.readInt64 = function (t) {
      return new lm.Long(this.readInt32(t), this.readInt32(t + 4));
    }),
    (lm.ByteBuffer.prototype.readUint64 = function (t) {
      return new lm.Long(this.readUint32(t), this.readUint32(t + 4));
    }),
    (lm.ByteBuffer.prototype.readFloat32 = function (t) {
      return (lm.int32[0] = this.readInt32(t)), lm.float32[0];
    }),
    (lm.ByteBuffer.prototype.readFloat64 = function (t) {
      return (
        (lm.int32[lm.isLittleEndian ? 0 : 1] = this.readInt32(t)),
        (lm.int32[lm.isLittleEndian ? 1 : 0] = this.readInt32(t + 4)),
        lm.float64[0]
      );
    }),
    (lm.ByteBuffer.prototype.writeInt8 = function (t, e) {
      this.bytes_[t] = e;
    }),
    (lm.ByteBuffer.prototype.writeUint8 = function (t, e) {
      this.bytes_[t] = e;
    }),
    (lm.ByteBuffer.prototype.writeInt16 = function (t, e) {
      (this.bytes_[t] = e), (this.bytes_[t + 1] = e >> 8);
    }),
    (lm.ByteBuffer.prototype.writeUint16 = function (t, e) {
      (this.bytes_[t] = e), (this.bytes_[t + 1] = e >> 8);
    }),
    (lm.ByteBuffer.prototype.writeInt32 = function (t, e) {
      (this.bytes_[t] = e),
        (this.bytes_[t + 1] = e >> 8),
        (this.bytes_[t + 2] = e >> 16),
        (this.bytes_[t + 3] = e >> 24);
    }),
    (lm.ByteBuffer.prototype.writeUint32 = function (t, e) {
      (this.bytes_[t] = e),
        (this.bytes_[t + 1] = e >> 8),
        (this.bytes_[t + 2] = e >> 16),
        (this.bytes_[t + 3] = e >> 24);
    }),
    (lm.ByteBuffer.prototype.writeInt64 = function (t, e) {
      this.writeInt32(t, e.low), this.writeInt32(t + 4, e.high);
    }),
    (lm.ByteBuffer.prototype.writeUint64 = function (t, e) {
      this.writeUint32(t, e.low), this.writeUint32(t + 4, e.high);
    }),
    (lm.ByteBuffer.prototype.writeFloat32 = function (t, e) {
      (lm.float32[0] = e), this.writeInt32(t, lm.int32[0]);
    }),
    (lm.ByteBuffer.prototype.writeFloat64 = function (t, e) {
      (lm.float64[0] = e),
        this.writeInt32(t, lm.int32[lm.isLittleEndian ? 0 : 1]),
        this.writeInt32(t + 4, lm.int32[lm.isLittleEndian ? 1 : 0]);
    }),
    (lm.ByteBuffer.prototype.getBufferIdentifier = function () {
      if (
        this.bytes_.length <
        this.position_ + lm.SIZEOF_INT + lm.FILE_IDENTIFIER_LENGTH
      )
        throw new Error(
          'FlatBuffers: ByteBuffer is too short to contain an identifier.',
        );
      for (var t = '', e = 0; e < lm.FILE_IDENTIFIER_LENGTH; e++)
        t += String.fromCharCode(
          this.readInt8(this.position_ + lm.SIZEOF_INT + e),
        );
      return t;
    }),
    (lm.ByteBuffer.prototype.__offset = function (t, e) {
      var n = t - this.readInt32(t);
      return e < this.readInt16(n) ? this.readInt16(n + e) : 0;
    }),
    (lm.ByteBuffer.prototype.__union = function (t, e) {
      return (t.bb_pos = e + this.readInt32(e)), (t.bb = this), t;
    }),
    (lm.ByteBuffer.prototype.__string = function (t, e) {
      t += this.readInt32(t);
      var n = this.readInt32(t),
        i = '',
        r = 0;
      if (((t += lm.SIZEOF_INT), e === lm.Encoding.UTF8_BYTES))
        return this.bytes_.subarray(t, t + n);
      for (; r < n; ) {
        var o,
          s = this.readUint8(t + r++);
        if (s < 192) o = s;
        else {
          var a = this.readUint8(t + r++);
          if (s < 224) o = ((31 & s) << 6) | (63 & a);
          else {
            var c = this.readUint8(t + r++);
            if (s < 240) o = ((15 & s) << 12) | ((63 & a) << 6) | (63 & c);
            else
              o =
                ((7 & s) << 18) |
                ((63 & a) << 12) |
                ((63 & c) << 6) |
                (63 & this.readUint8(t + r++));
          }
        }
        o < 65536
          ? (i += String.fromCharCode(o))
          : ((o -= 65536),
            (i += String.fromCharCode(55296 + (o >> 10), 56320 + (1023 & o))));
      }
      return i;
    }),
    (lm.ByteBuffer.prototype.__indirect = function (t) {
      return t + this.readInt32(t);
    }),
    (lm.ByteBuffer.prototype.__vector = function (t) {
      return t + this.readInt32(t) + lm.SIZEOF_INT;
    }),
    (lm.ByteBuffer.prototype.__vector_len = function (t) {
      return this.readInt32(t + this.readInt32(t));
    }),
    (lm.ByteBuffer.prototype.__has_identifier = function (t) {
      if (t.length != lm.FILE_IDENTIFIER_LENGTH)
        throw new Error(
          'FlatBuffers: file identifier must be length ' +
            lm.FILE_IDENTIFIER_LENGTH,
        );
      for (var e = 0; e < lm.FILE_IDENTIFIER_LENGTH; e++)
        if (
          t.charCodeAt(e) != this.readInt8(this.position_ + lm.SIZEOF_INT + e)
        )
          return !1;
      return !0;
    }),
    (lm.ByteBuffer.prototype.createLong = function (t, e) {
      return lm.Long.create(t, e);
    }),
    (hm.prototype = {
      constructor: hm,
      createFloorCrossLine: function (t) {
        let e = new lm.ByteBuffer(new Uint8Array(t)),
          n = cm.FloorCrossLineGroup.getRootAsFloorCrossLineGroup(e),
          i = [];
        for (let t = 0; t < n.floorPlanGraphLength(); t++) {
          let e = n.floorPlanGraph(t),
            r = [];
          for (let t = 0; t < e.axisNetLineArrayLength(); t++) {
            let n = e.axisNetLineArray(t),
              i = {
                textHeight: n.textHeight(),
                textRoundRadius: n.textRoundRadius(),
                name: n.name(),
                textInsert: n.textInsertArray(),
                start: n.startArray(),
                end: n.endArray(),
              };
            r.push(i);
          }
          let o = [];
          for (let t = 0; t < e.axisNetArcArrayLength(); t++) {
            let n = e.axisNetArcArray(t),
              i = {
                textHeight: n.textHeight(),
                textRoundRadius: n.textRoundRadius(),
                name: n.name(),
                textInsert: n.textInsertArray(),
                center: n.centerArray(),
                radius: n.radius(),
                startAngle: n.startAngle(),
                endAngle: n.endAngle(),
                antiClockWise: n.antiClockWise(),
              };
            o.push(i);
          }
          let s = [];
          for (let t = 0; t < e.crossLinesLength(); t++) {
            let n = e.crossLines(t),
              i = {
                start: Array.prototype.slice.call(n.startArray()),
                end: Array.prototype.slice.call(n.endArray()),
              };
            s.push(i);
          }
          let a = {
            floorId: e.floorId(),
            floorHeight: e.floorHeight(),
            floorElevation: e.floorElevation(),
            floorName: e.floorName(),
            axisNetLineArray: r,
            axisNetArcArray: o,
            crossLines: s,
          };
          i.push(a);
        }
        return i;
      },
    });
  var um = {
    enabled: !1,
    files: {},
    add: function (t, e) {
      !1 !== this.enabled && (this.files[t] = e);
    },
    get: function (t) {
      if (!1 !== this.enabled) return this.files[t];
    },
    remove: function (t) {
      delete this.files[t];
    },
    clear: function () {
      this.files = {};
    },
  };
  var dm = new (function (t, e, n) {
      var i = this,
        r = !1,
        o = 0,
        s = 0,
        a = void 0;
      (this.onStart = void 0),
        (this.onLoad = t),
        (this.onProgress = e),
        (this.onError = n),
        (this.itemStart = function (t) {
          s++, !1 === r && void 0 !== i.onStart && i.onStart(t, o, s), (r = !0);
        }),
        (this.itemEnd = function (t) {
          o++,
            void 0 !== i.onProgress && i.onProgress(t, o, s),
            o === s && ((r = !1), void 0 !== i.onLoad && i.onLoad());
        }),
        (this.itemError = function (t) {
          void 0 !== i.onError && i.onError(t);
        }),
        (this.resolveURL = function (t) {
          return a ? a(t) : t;
        }),
        (this.setURLModifier = function (t) {
          return (a = t), this;
        });
    })(),
    pm = {};
  function fm(t) {
    this.manager = void 0 !== t ? t : dm;
  }
  function mm(t) {
    this.manager = void 0 !== t ? t : Ia;
  }
  function bm(t) {
    (t = t || {}),
      (this.fileLoader = t.fileLoader),
      (this.TGALoader = t.tgaLoader || new mm()),
      (this.textureLoader = t.textureLoader || new Ba()),
      (this.textureWrapS = void 0 !== t.wrapS ? t.wrapS : o),
      (this.textureWrapT = void 0 !== t.wrapT ? t.wrapT : o),
      (this.texturemaxAnisotropy =
        void 0 !== t.maxAnisotropy ? t.maxAnisotropy : 0),
      (this.sceneScale = 0.001),
      (this.model = null);
  }
  function gm() {
    (this.name = 'FileIndex'),
      (this.id = 0),
      (this.url = ''),
      (this.fileSize = 0),
      (this.type = 0);
  }
  function ym(t, e) {
    (this.type = 'gridBuilder'),
      (this.origin = t.origin),
      (this.gridSize = t.gridSize),
      (this.material = t.material),
      (this.offset = {
        bndBoxMin: e.bndBoxMin,
        bndBoxMax: e.bndBoxMax,
        columnOffset: e.columnOffset,
        columnCount: e.columnCount,
        rowOffset: e.rowOffset,
        rowCount: e.rowCount,
        vertexColPos: e.vertexColPos,
        vertexRowPos: e.vertexRowPos,
        vertexHeight: e.vertexHeight,
      });
  }
  function vm(t, e, n, i) {
    (this.offset = t),
      (this.count = e),
      (this.offset_old = n),
      (this.count_old = i);
  }
  Object.assign(fm.prototype, {
    load: function (t, e, n, i) {
      void 0 === t && (t = ''),
        void 0 !== this.path && (t = this.path + t),
        (t = this.manager.resolveURL(t));
      var r = this,
        o = um.get(t);
      if (void 0 !== o)
        return (
          r.manager.itemStart(t),
          setTimeout(function () {
            e && e(o), r.manager.itemEnd(t);
          }, 0),
          o
        );
      if (void 0 === pm[t]) {
        var s = t.match(/^data:(.*?)(;base64)?,(.*)$/);
        if (s) {
          var a = s[1],
            c = !!s[2],
            l = s[3];
          (l = decodeURIComponent(l)), c && (l = atob(l));
          try {
            var h,
              u = (this.responseType || '').toLowerCase();
            switch (u) {
              case 'arraybuffer':
              case 'blob':
                for (var d = new Uint8Array(l.length), p = 0; p < l.length; p++)
                  d[p] = l.charCodeAt(p);
                h = 'blob' === u ? new Blob([d.buffer], { type: a }) : d.buffer;
                break;
              case 'document':
                var f = new DOMParser();
                h = f.parseFromString(l, a);
                break;
              case 'json':
                h = JSON.parse(l);
                break;
              default:
                h = l;
            }
            setTimeout(function () {
              e && e(h), r.manager.itemEnd(t);
            }, 0);
          } catch (e) {
            setTimeout(function () {
              i && i(e), r.manager.itemError(t), r.manager.itemEnd(t);
            }, 0);
          }
        } else {
          (pm[t] = []), pm[t].push({ onLoad: e, onProgress: n, onError: i });
          var m = new XMLHttpRequest();
          for (var b in (m.open('GET', t, !0),
          m.addEventListener(
            'load',
            function (e) {
              var n = this.response;
              um.add(t, n);
              var i = pm[t];
              if ((delete pm[t], 200 === this.status || 0 === this.status)) {
                0 === this.status &&
                  console.warn('THREE.FileLoader: HTTP Status 0 received.');
                for (var o = 0, s = i.length; o < s; o++) {
                  (a = i[o]).onLoad && a.onLoad(n);
                }
                r.manager.itemEnd(t);
              } else {
                for (o = 0, s = i.length; o < s; o++) {
                  var a;
                  (a = i[o]).onError && a.onError(e);
                }
                r.manager.itemError(t), r.manager.itemEnd(t);
              }
            },
            !1,
          ),
          m.addEventListener(
            'progress',
            function (e) {
              for (var n = pm[t], i = 0, r = n.length; i < r; i++) {
                var o = n[i];
                o.onProgress && o.onProgress(e);
              }
            },
            !1,
          ),
          m.addEventListener(
            'error',
            function (e) {
              var n = pm[t];
              delete pm[t];
              for (var i = 0, o = n.length; i < o; i++) {
                var s = n[i];
                s.onError && s.onError(e);
              }
              r.manager.itemError(t), r.manager.itemEnd(t);
            },
            !1,
          ),
          m.addEventListener(
            'abort',
            function (e) {
              var n = pm[t];
              delete pm[t];
              for (var i = 0, o = n.length; i < o; i++) {
                var s = n[i];
                s.onError && s.onError(e);
              }
              r.manager.itemError(t), r.manager.itemEnd(t);
            },
            !1,
          ),
          void 0 !== this.responseType && (m.responseType = this.responseType),
          void 0 !== this.withCredentials &&
            (m.withCredentials = this.withCredentials),
          m.overrideMimeType &&
            m.overrideMimeType(
              void 0 !== this.mimeType ? this.mimeType : 'text/plain',
            ),
          this.requestHeader))
            m.setRequestHeader(b, this.requestHeader[b]);
          m.send(null);
        }
        return r.manager.itemStart(t), m;
      }
      pm[t].push({ onLoad: e, onProgress: n, onError: i });
    },
    setPath: function (t) {
      return (this.path = t), this;
    },
    setResponseType: function (t) {
      return (this.responseType = t), this;
    },
    setWithCredentials: function (t) {
      return (this.withCredentials = t), this;
    },
    setMimeType: function (t) {
      return (this.mimeType = t), this;
    },
    setRequestHeader: function (t) {
      return (this.requestHeader = t), this;
    },
  }),
    (mm.prototype = {
      constructor: mm,
      load: function (t, e, n, i) {
        var r = this,
          o = new H(),
          s = new fm(this.manager);
        return (
          s.setResponseType('arraybuffer'),
          s.setPath(this.path),
          s.load(
            t,
            function (t) {
              (o.image = r.parse(t)),
                (o.needsUpdate = !0),
                void 0 !== e && e(o);
            },
            n,
            i,
          ),
          o
        );
      },
      parse: function (t) {
        var e = 0,
          n = 1,
          i = 2,
          r = 3,
          o = 9,
          s = 10,
          a = 11,
          c = 48,
          l = 4,
          h = 0,
          u = 1,
          d = 2,
          p = 3;
        t.length < 19 &&
          console.error('THREE.TGALoader: Not enough data to contain header.');
        var f = new Uint8Array(t),
          m = 0,
          b = {
            id_length: f[m++],
            colormap_type: f[m++],
            image_type: f[m++],
            colormap_index: f[m++] | (f[m++] << 8),
            colormap_length: f[m++] | (f[m++] << 8),
            colormap_size: f[m++],
            origin: [f[m++] | (f[m++] << 8), f[m++] | (f[m++] << 8)],
            width: f[m++] | (f[m++] << 8),
            height: f[m++] | (f[m++] << 8),
            pixel_size: f[m++],
            flags: f[m++],
          };
        !(function (t) {
          switch (t.image_type) {
            case n:
            case o:
              (t.colormap_length > 256 ||
                24 !== t.colormap_size ||
                1 !== t.colormap_type) &&
                console.error(
                  'THREE.TGALoader: Invalid type colormap data for indexed type.',
                );
              break;
            case i:
            case r:
            case s:
            case a:
              t.colormap_type &&
                console.error(
                  'THREE.TGALoader: Invalid type colormap data for colormap type.',
                );
              break;
            case e:
              console.error('THREE.TGALoader: No data.');
            default:
              console.error(
                'THREE.TGALoader: Invalid type "%s".',
                t.image_type,
              );
          }
          (t.width <= 0 || t.height <= 0) &&
            console.error('THREE.TGALoader: Invalid image size.'),
            8 !== t.pixel_size &&
              16 !== t.pixel_size &&
              24 !== t.pixel_size &&
              32 !== t.pixel_size &&
              console.error(
                'THREE.TGALoader: Invalid pixel size "%s".',
                t.pixel_size,
              );
        })(b),
          b.id_length + m > t.length &&
            console.error('THREE.TGALoader: No data.'),
          (m += b.id_length);
        var g = !1,
          y = !1,
          v = !1;
        switch (b.image_type) {
          case o:
            (g = !0), (y = !0);
            break;
          case n:
            y = !0;
            break;
          case s:
            g = !0;
            break;
          case i:
            break;
          case a:
            (g = !0), (v = !0);
            break;
          case r:
            v = !0;
        }
        var _ = 'undefined' != typeof OffscreenCanvas,
          x = _
            ? new OffscreenCanvas(b.width, b.height)
            : document.createElement('canvas');
        (x.width = b.width), (x.height = b.height);
        var w = x.getContext('2d'),
          A = w.createImageData(b.width, b.height),
          M = (function (t, e, n, i, r) {
            var o, s, a, c;
            if (
              ((s = n.pixel_size >> 3),
              (a = n.width * n.height * s),
              e &&
                (c = r.subarray(
                  i,
                  (i += n.colormap_length * (n.colormap_size >> 3)),
                )),
              t)
            ) {
              var l, h, u;
              o = new Uint8Array(a);
              for (var d = 0, p = new Uint8Array(s); d < a; )
                if (((h = 1 + (127 & (l = r[i++]))), 128 & l)) {
                  for (u = 0; u < s; ++u) p[u] = r[i++];
                  for (u = 0; u < h; ++u) o.set(p, d + u * s);
                  d += s * h;
                } else {
                  for (h *= s, u = 0; u < h; ++u) o[d + u] = r[i++];
                  d += h;
                }
            } else o = r.subarray(i, (i += e ? n.width * n.height : a));
            return { pixel_data: o, palettes: c };
          })(g, y, b, m, f);
        return (
          (function (t, e, n, i, r) {
            var o, s, a, f, m, g;
            switch ((b.flags & c) >> l) {
              default:
              case d:
                (o = 0), (a = 1), (m = e), (s = 0), (f = 1), (g = n);
                break;
              case h:
                (o = 0), (a = 1), (m = e), (s = n - 1), (f = -1), (g = -1);
                break;
              case p:
                (o = e - 1), (a = -1), (m = -1), (s = 0), (f = 1), (g = n);
                break;
              case u:
                (o = e - 1),
                  (a = -1),
                  (m = -1),
                  (s = n - 1),
                  (f = -1),
                  (g = -1);
            }
            if (v)
              switch (b.pixel_size) {
                case 8:
                  !(function (t, e, n, i, r, o, s, a) {
                    var c,
                      l,
                      h,
                      u = 0,
                      d = b.width;
                    for (h = e; h !== i; h += n)
                      for (l = r; l !== s; l += o, u++)
                        (c = a[u]),
                          (t[4 * (l + d * h) + 0] = c),
                          (t[4 * (l + d * h) + 1] = c),
                          (t[4 * (l + d * h) + 2] = c),
                          (t[4 * (l + d * h) + 3] = 255);
                  })(t, s, f, g, o, a, m, i);
                  break;
                case 16:
                  !(function (t, e, n, i, r, o, s, a) {
                    var c,
                      l,
                      h = 0,
                      u = b.width;
                    for (l = e; l !== i; l += n)
                      for (c = r; c !== s; c += o, h += 2)
                        (t[4 * (c + u * l) + 0] = a[h + 0]),
                          (t[4 * (c + u * l) + 1] = a[h + 0]),
                          (t[4 * (c + u * l) + 2] = a[h + 0]),
                          (t[4 * (c + u * l) + 3] = a[h + 1]);
                  })(t, s, f, g, o, a, m, i);
                  break;
                default:
                  console.error('THREE.TGALoader: Format not supported.');
              }
            else
              switch (b.pixel_size) {
                case 8:
                  !(function (t, e, n, i, r, o, s, a, c) {
                    var l,
                      h,
                      u,
                      d = c,
                      p = 0,
                      f = b.width;
                    for (u = e; u !== i; u += n)
                      for (h = r; h !== s; h += o, p++)
                        (l = a[p]),
                          (t[4 * (h + f * u) + 3] = 255),
                          (t[4 * (h + f * u) + 2] = d[3 * l + 0]),
                          (t[4 * (h + f * u) + 1] = d[3 * l + 1]),
                          (t[4 * (h + f * u) + 0] = d[3 * l + 2]);
                  })(t, s, f, g, o, a, m, i, r);
                  break;
                case 16:
                  !(function (t, e, n, i, r, o, s, a) {
                    var c,
                      l,
                      h,
                      u = 0,
                      d = b.width;
                    for (h = e; h !== i; h += n)
                      for (l = r; l !== s; l += o, u += 2)
                        (c = a[u + 0] + (a[u + 1] << 8)),
                          (t[4 * (l + d * h) + 0] = (31744 & c) >> 7),
                          (t[4 * (l + d * h) + 1] = (992 & c) >> 2),
                          (t[4 * (l + d * h) + 2] = (31 & c) >> 3),
                          (t[4 * (l + d * h) + 3] = 32768 & c ? 0 : 255);
                  })(t, s, f, g, o, a, m, i);
                  break;
                case 24:
                  !(function (t, e, n, i, r, o, s, a) {
                    var c,
                      l,
                      h = 0,
                      u = b.width;
                    for (l = e; l !== i; l += n)
                      for (c = r; c !== s; c += o, h += 3)
                        (t[4 * (c + u * l) + 3] = 255),
                          (t[4 * (c + u * l) + 2] = a[h + 0]),
                          (t[4 * (c + u * l) + 1] = a[h + 1]),
                          (t[4 * (c + u * l) + 0] = a[h + 2]);
                  })(t, s, f, g, o, a, m, i);
                  break;
                case 32:
                  !(function (t, e, n, i, r, o, s, a) {
                    var c,
                      l,
                      h = 0,
                      u = b.width;
                    for (l = e; l !== i; l += n)
                      for (c = r; c !== s; c += o, h += 4)
                        (t[4 * (c + u * l) + 2] = a[h + 0]),
                          (t[4 * (c + u * l) + 1] = a[h + 1]),
                          (t[4 * (c + u * l) + 0] = a[h + 2]),
                          (t[4 * (c + u * l) + 3] = a[h + 3]);
                  })(t, s, f, g, o, a, m, i);
                  break;
                default:
                  console.error('THREE.TGALoader: Format not supported.');
              }
          })(A.data, b.width, b.height, M.pixel_data, M.palettes),
          w.putImageData(A, 0, 0),
          _ ? x.transferToImageBitmap() : x
        );
      },
      setPath: function (t) {
        return (this.path = t), this;
      },
    }),
    (bm.prototype = {
      constructor: bm,
      getFileLoader: function () {
        return this.fileLoader;
      },
      getModel: function () {
        return this.model;
      },
      createModel: function (t) {},
      loadSceneNode: function (t, e, n) {},
    }),
    (gm.prototype = {
      constructor: gm,
      setID: function (t) {
        this.id = t;
      },
      getID: function () {
        return this.id;
      },
      setType: function (t) {
        this.type = t;
      },
      getType: function () {
        return this.type;
      },
      setURL: function (t) {
        this.url = t;
      },
      getURL: function () {
        return this.url;
      },
      setFileSize: function (t) {
        this.fileSize = t;
      },
      getFileSize: function () {
        return this.fileSize;
      },
    }),
    (ym.prototype = {
      constructor: ym,
      getAttribute() {
        let t = this.origin[2],
          e = this.origin[0] + this.offset.columnOffset * this.gridSize,
          n = this.origin[1] + this.offset.rowOffset * this.gridSize,
          i = [];
        for (let r = 0, o = this.offset.rowCount; r < o; r++)
          for (let o = 0, s = this.offset.columnCount; o < s; o++)
            i.push(e + this.gridSize * o, n + this.gridSize * r, t);
        let r = [];
        for (
          let t = 0, e = this.offset.rowCount * this.offset.columnCount;
          t < e;
          t++
        )
          t >=
            this.offset.rowCount * this.offset.columnCount -
              this.offset.columnCount ||
            (t % this.offset.columnCount != this.offset.columnCount - 1 &&
              (r.push(t, t + 1, t + 1 + this.offset.columnCount),
              r.push(
                t,
                t + 1 + this.offset.columnCount,
                t + this.offset.columnCount,
              )));
        for (let t = 0, e = this.offset.vertexColPos.length; t < e; t++) {
          i[
            3 *
              (this.offset.vertexColPos[t] +
                this.offset.columnCount * this.offset.vertexRowPos[t]) +
              2
          ] = this.offset.vertexHeight[t];
        }
        let o = [],
          s = 0,
          a = 0;
        for (let t = 0, e = this.offset.rowCount; t < e; t++) {
          s = t / 50;
          for (let t = 0, e = this.offset.columnCount; t < e; t++)
            (a = t / 50), o.push(s, a);
        }
        return { position: i, index: r, uv: o };
      },
    }),
    (vm.prototype = {
      constructor: vm,
      set: function (t, e) {
        return (this.offset = t), (this.count = e), this;
      },
      set2: function (t, e, n, i) {
        return (
          (this.offset = t),
          (this.count = e),
          (this.offset_old = n),
          (this.count_old = i),
          this
        );
      },
      start: function () {
        return this.offset;
      },
      end: function () {
        return this.offset + this.count;
      },
      union: function (t) {
        let e = this.offset,
          n = this.count,
          i = t.offset,
          r = t.count;
        if (e + n < i || i + r < e) return !1;
        let o = e + n,
          s = i + r,
          a = Math.max(o, s),
          c = Math.min(e, i),
          l = this.offset_old,
          h = this.count_old,
          u = t.offset_old,
          d = l + h,
          p = u + t.count_old,
          f = Math.max(d, p),
          m = Math.min(l, u);
        return this.set2(c, a - c, m, f - m), !0;
      },
      subtract: function (t) {
        let e = [],
          n = this.offset,
          i = this.count,
          r = t.offset,
          o = t.count;
        if (n + i <= r || r + o <= n) return e;
        e.push(this);
        let s = n + i,
          a = r + o,
          c = Math.max(n, r),
          l = Math.min(s, a),
          h = c - n,
          u = s - l,
          d = this.offset_old,
          p = this.count_old,
          f = t.offset_old,
          m = d + p,
          b = f + t.count_old,
          g = Math.max(d, f),
          y = Math.min(m, b),
          v = g - d,
          _ = m - y;
        return (
          0 !== h && 0 !== u
            ? (this.set2(n, h, d, v), e.push(new vm(l + 1, u, y + 1, _)))
            : 0 !== h && 0 === u
            ? this.set2(n, h, d, v)
            : 0 === h && 0 !== u
            ? this.set2(l, u, y, _)
            : this.set2(0, 0, 0, 0),
          e
        );
      },
      copy: function (t) {
        this.set2(t.offset, t.count, t.offset_old, t.count_old);
      },
      clone: function () {
        return new vm(this.offset, this.count, this.offset_old, this.count_old);
      },
    });
  var _m = { name: 'instanceMatrixR1', itemSize: 4 },
    xm = { name: 'instanceMatrixR2', itemSize: 4 },
    wm = { name: 'instanceMatrixR3', itemSize: 4 },
    Am = { name: 'instanceMatrixR4', itemSize: 4 };
  function Mm(t, e) {
    (this.name = t),
      (this.bufferAttribute = e),
      (this.layout = -1),
      (this.offset = 0);
  }
  function Sm() {
    (this.buffer = void 0),
      (this.context = void 0),
      (this.programID = -1),
      (this.vertexAttributes = []),
      (this.needUpdate = !1);
  }
  (Mm.prototype = {
    constructor: Mm,
    getName: function () {
      return this.name;
    },
    setBufferAttribute: function (t) {
      this.bufferAttribute = t;
    },
    getBufferAttribute: function () {
      return this.bufferAttribute;
    },
    setLayout: function (t) {
      this.layout = t;
    },
    getLayout: function () {
      return this.layout;
    },
    setOffset: function (t) {
      this.offset = t;
    },
    getOffset: function () {
      return this.offset;
    },
  }),
    (Sm.prototype = Object.assign(Object.create(B.prototype), {
      constructor: Sm,
      dirty: function () {
        this.needUpdate = !0;
      },
      addBufferAttribute: function (t, e) {
        if (!t || !e) return;
        let n = this.getAttribute(t);
        if (n) {
          if (n.getBufferAttribute().array.length !== e.array.length)
            return void console.warn(
              'VBO buffer size out of range, please create a new one.',
            );
          n.setBufferAttribute(e);
        } else this.vertexAttributes.push(new Mm(t, e));
        this.dirty();
      },
      removeAttribute: function (t) {
        for (let e = 0, n = this.vertexAttributes.length; e < n; e++)
          if (this.vertexAttributes[e].getName() === t) {
            this.vertexAttributes.splice(e, 1);
            break;
          }
        this.dirty();
      },
      getAttribute: function (t) {
        for (let e = 0, n = this.vertexAttributes.length; e < n; e++) {
          let n = this.vertexAttributes[e];
          if (n.getName() === t) return n;
        }
      },
      getBufferAttribute: function (t) {
        let e = this.getAttribute(t);
        if (e) return e.getBufferAttribute();
      },
      getAttributeArray: function () {
        return this.vertexAttributes;
      },
      update: function (t) {
        if (!this.needUpdate) return;
        if (!this.buffer) {
          this.programID = void 0;
          let e = this.vertexAttributes.length,
            n = 0;
          for (let t = 0; t < e; t++)
            n += this.vertexAttributes[t].getBufferAttribute().array.length;
          if (
            ((this.context = t),
            (this.buffer = this.context.createBuffer()),
            !this.buffer)
          )
            return;
          this.context.bindBuffer(this.context.ARRAY_BUFFER, this.buffer),
            this.context.bufferData(
              this.context.ARRAY_BUFFER,
              4 * n,
              this.context.STATIC_DRAW,
            ),
            this.context.bindBuffer(this.context.ARRAY_BUFFER, null);
        }
        if (!this.buffer) return;
        this.context.bindBuffer(this.context.ARRAY_BUFFER, this.buffer);
        let e = 0,
          n = this.vertexAttributes.length;
        for (let t = 0; t < n; t++) {
          let n = this.vertexAttributes[t];
          n.setOffset(e);
          let i = n.getBufferAttribute();
          this.context.bufferSubData(this.context.ARRAY_BUFFER, 4 * e, i.array),
            (e += i.array.length);
        }
        this.context.bindBuffer(this.context.ARRAY_BUFFER, null),
          (this.needUpdate = !1);
      },
      bind: function (t, e, n, i) {
        if (this.buffer) {
          if (this.programID !== e.id) {
            let t = e.getAttributes();
            for (let e = 0, n = this.vertexAttributes.length; e < n; e++) {
              let n = this.vertexAttributes[e],
                i = t[n.getName()];
              void 0 !== i && n.setLayout(i);
            }
            this.programID = e.id;
          }
          this.context.bindBuffer(this.context.ARRAY_BUFFER, this.buffer);
          for (let t = 0, e = this.vertexAttributes.length; t < e; t++) {
            let e = this.vertexAttributes[t];
            e.getLayout() < 0 ||
              (n.enableAttributeAndDivisor(e.getLayout(), i),
              this.context.vertexAttribPointer(
                e.getLayout(),
                e.getBufferAttribute().itemSize,
                this.context.FLOAT,
                !1,
                0,
                4 * e.getOffset(),
              ));
          }
        }
      },
      release: function (t) {
        this.buffer &&
          (this.context.deleteBuffer(this.buffer),
          (this.buffer = void 0),
          (this.context = void 0)),
          (this.programID = -1),
          (this.vertexAttributes = []),
          (this.needUpdate = !1);
      },
    }));
  let Im = { type: 'update' };
  function Em(t, e) {
    At.call(this),
      (this.type = 'PMRenderObject'),
      (this.renderBuffer = t),
      (this.material = e || t.material),
      (this.drawSegmentArray = []),
      (this.currentSegmentArray = []),
      (this.drawGeoDataArray = []),
      (this.currentInstanceVertexArray = null),
      (this.numInstance = 0),
      (this.dynamicRenderingEnable = !1),
      (this.currentRenderingLevel = 1),
      (this.validDraw = !1),
      (this.boundingBox = new Nt()),
      (this.boundingSphere = new Gt()),
      (this.needBounding = !0),
      (this.needUpdate = !1);
  }
  function Dm() {
    Rr.call(this),
      (this.type = 'RenderNode'),
      (this.renderObjectMap = new Map());
  }
  (Em.prototype = Object.assign(Object.create(At.prototype), {
    constructor: Em,
    isPMRenderObject: !0,
    addDrawSegment: function (t) {
      if (t) {
        for (let e = 0, n = this.drawSegmentArray.length; e < n; ++e)
          if (t === this.drawSegmentArray[e]) return;
        this.drawSegmentArray.push(t), (this.needUpdate = !0);
      }
    },
    removeDrawSegment: function (t) {
      if (t)
        for (let e = 0, n = this.drawSegmentArray.length; e < n; ++e)
          if (t === this.drawSegmentArray[e])
            return (
              this.drawSegmentArray.splice(e, 1), void (this.needUpdate = !0)
            );
    },
    addDrawGeoData: function (t) {
      if (t) {
        for (let e = 0, n = this.drawGeoDataArray.length; e < n; ++e)
          if (t === this.drawGeoDataArray[e]) return;
        this.drawGeoDataArray.push(t), (this.needUpdate = !0);
      }
    },
    removeDrawGeoData: function (t) {
      if (t)
        for (let e = 0, n = this.drawGeoDataArray.length; e < n; ++e)
          if (t === this.drawGeoDataArray[e])
            return (
              this.drawGeoDataArray.splice(e, 1), void (this.needUpdate = !0)
            );
    },
    getRenderBuffer: function () {
      return this.renderBuffer;
    },
    getMaterial: function () {
      return this.material;
    },
    getCurrentIndex: function () {
      return this.renderBuffer.getVertexIndex();
    },
    getCurrentSegmentArray: function () {
      return this.currentSegmentArray;
    },
    getCurrentInstanceVertexArray: function () {
      return this.currentInstanceVertexArray;
    },
    getNuminstance: function () {
      return this.numInstance;
    },
    getBoundingBox: function () {
      return this.boundingBox;
    },
    clone: function (t) {
      return new this.constructor(this.renderBuffer, this.material).copy(
        this,
        t,
      );
    },
    copy: function (t, e) {
      At.prototype.copy.call(this, t, e),
        (this.renderBuffer = t.renderBuffer),
        (this.currentInstanceVertexArray = t.currentInstanceVertexArray),
        (this.material = t.material),
        (this.drawSegmentArray = []);
      for (let e = 0, n = t.drawSegmentArray.length; e < n; ++e)
        this.drawSegmentArray.push(t.drawSegmentArray[e].clone());
      this.currentSegmentArray = [];
      for (let e = 0, n = t.currentSegmentArray.length; e < n; ++e)
        this.currentSegmentArray.push(t.currentSegmentArray[e].clone());
      return (
        (this.numInstance = t.numInstance),
        (this.validDraw = t.validDraw),
        this.boundingBox.copy(t.boundingBox),
        this.boundingSphere.copy(t.boundingSphere),
        (this.needUpdate = t.needUpdate),
        (this.dynamicRenderingEnable = t.dynamicRenderingEnable),
        this
      );
    },
    setDynamicRenderingEnable: function (t) {
      this.dynamicRenderingEnable = !!t;
    },
    update: (function () {
      function t(t, e) {
        return t.offset - e.offset;
      }
      return function (e) {
        if (!this.needUpdate) return;
        let n = this.getCurrentIndex();
        if (!n) return void (this.validDraw = !1);
        if ((n.update(e), !this.renderBuffer.update(e)))
          return void (this.validDraw = !1);
        let i,
          r = [];
        for (let t = 0, e = this.drawGeoDataArray.length; t < e; ++t)
          r.push(this.drawGeoDataArray[t].getBufferSegment());
        (r = r.concat(this.drawSegmentArray)),
          (this.currentSegmentArray = []),
          r.sort(t);
        for (let t = 0, e = r.length; t < e; ++t) {
          let e = r[t];
          (i && i.union(e)) ||
            ((i = new vm(e.offset, e.count, e.offset_old, e.count_old)),
            this.currentSegmentArray.push(i));
        }
        this.updateInstanceDrawing(e) ||
          (this.validDraw = this.currentSegmentArray.length > 0),
          (this.instanceDrawing = this.numInstance > 0),
          this.updateBounding(),
          (this.needUpdate = !1),
          this.onUpdate();
      };
    })(),
    updateInstanceDrawing: function (t) {
      if (
        (this.currentInstanceVertexArray &&
          (this.currentInstanceVertexArray.release(t),
          (this.currentInstanceVertexArray = null)),
        (this.numInstance = 0),
        !this.renderBuffer.isPMInstanceRenderBuffer)
      )
        return !1;
      let e = this.renderBuffer.getInstanceVertexAttributeArray(),
        n = 0;
      for (let t = 0, e = this.currentSegmentArray.length; t < e; ++t)
        n += this.currentSegmentArray[t].count;
      let i = new Sm(),
        r = e.getAttributeArray();
      for (let t = 0, e = r.length; t < e; ++t) {
        let e = r[t],
          o = e.bufferAttribute,
          s = o.itemSize,
          a = new Float32Array(s * n),
          c = 0;
        for (let t = 0, e = this.currentSegmentArray.length; t < e; ++t) {
          let e = this.currentSegmentArray[t],
            n = s * e.offset,
            i = s * e.count,
            r = o.array.subarray(n, n + i);
          a.set(r, c), (c += i);
        }
        i.addBufferAttribute(e.name, new Re(a, s));
      }
      return (
        i.update(t),
        (this.currentInstanceVertexArray = i),
        (this.numInstance = n),
        (this.validDraw = this.numInstance > 0),
        !0
      );
    },
    computeRenderingLevelByCameraPosition: (function () {
      function t(t, e, n) {
        if (t.empty()) return 1;
        let i = e.distanceTo(t.center) / t.radius,
          r = n || 50;
        return (i = 1 - Math.min(i, r) / r), Math.min(i + 0.1, 1);
      }
      return function (e, n) {
        if (!this.renderBuffer || !this.renderBuffer.isPMInstanceRenderBuffer)
          return;
        let i = this.renderBuffer.getVertexBoundingSphere();
        if (!i.empty())
          if (this.renderBuffer.isPMInstanceRenderBuffer) {
            let i = this.renderBuffer.getInstanceBoundingSphereArray(),
              r = -1;
            for (let o = 0, s = this.currentSegmentArray.length; o < s; ++o) {
              let s = this.currentSegmentArray[o];
              for (let o = s.offset, a = s.end(); o < a; ++o)
                r = Math.max(r, t(i[o], e, n));
            }
            this.currentRenderingLevel = r;
          } else this.currentRenderingLevel = t(i, e, n);
      };
    })(),
    release: function (t) {
      this.currentInstanceVertexArray &&
        (this.currentInstanceVertexArray.release(t),
        (this.currentInstanceVertexArray = null)),
        (this.drawGeoDataArray = []);
    },
    draw: function (t, e, n, i, r) {
      i.initAttributes(),
        this.renderBuffer.getVertexAttributeArray().bind(t, r, i, 0),
        this.currentInstanceVertexArray &&
          this.currentInstanceVertexArray.bind(t, r, i, 1),
        i.disableUnusedAttributes();
      let o = this.getCurrentIndex();
      switch (o.getDrawMode()) {
        case Hf.POINT:
          e.setMode(t.POINTS);
          break;
        case Hf.TRIANGLES:
          e.setMode(t.TRIANGLES);
          break;
        case Hf.TRIANGLE_STRIP:
          e.setMode(t.TRIANGLE_STRIP);
          break;
        case Hf.TRIANGLE_FAN:
          e.setMode(t.TRIANGLE_FAN);
          break;
        case Hf.LINES:
          e.setMode(t.LINES);
          break;
        case Hf.LINE_LOOP:
          e.setMode(t.LINE_LOOP);
          break;
        case Hf.LINE_STRIP:
          e.setMode(t.LINE_STRIP);
      }
      if (
        (o.bind(t),
        e.setIndex({ type: t.UNSIGNED_INT, bytesPerElement: 4 }),
        this.numInstance > 0)
      )
        this.dynamicRenderingEnable
          ? e.renderInstances(
              void 0,
              0,
              o.bufferAttribute.array.length * this.currentRenderingLevel,
              this.numInstance,
            )
          : e.renderInstances(
              void 0,
              0,
              o.bufferAttribute.array.length,
              this.numInstance,
            );
      else
        for (
          var s = this.currentSegmentArray, a = 0, c = s.length;
          a < c;
          ++a
        ) {
          var l = s[a];
          e.render(l.offset, l.count);
        }
    },
    updateBounding: (function () {
      let t = new J(),
        e = new ot(),
        n = new Gt();
      return function () {
        if (!this.needBounding) return;
        this.boundingBox.reset(),
          this.boundingSphere.center.set(0, 0, 0),
          (this.boundingSphere.radius = 0);
        let i = this.currentInstanceVertexArray;
        if (i) {
          let t = i.getBufferAttribute(_m.name).array,
            r = i.getBufferAttribute(xm.name).array,
            o = i.getBufferAttribute(wm.name).array,
            s = i.getBufferAttribute(Am.name).array,
            a = this.renderBuffer.getVertexBoundingSphere();
          for (let i = 0, c = this.numInstance; i < c; ++i)
            Xf.getInstanceMatrixByArray(t, r, o, s, i, e),
              n.copy(a).applyMatrix4(e),
              this.boundingSphere.expandBySphere(n);
          this.boundingSphere.getBoundingBox(this.boundingBox);
        } else {
          for (let t = 0, e = this.drawGeoDataArray.length; t < e; ++t)
            this.boundingBox.union(this.drawGeoDataArray[t].getBoundingBox());
          !(function (e, n, i, r) {
            for (let o = 0, s = i.length; o < s; ++o) {
              let s = i[o];
              for (let i = s.offset, o = s.offset + s.count; i < o; ++i) {
                let o = 3 * n[i];
                t.set(e[o], e[o + 1], e[o + 2]), r.expandByPoint(t);
              }
            }
          })(
            this.renderBuffer
              .getVertexAttributeArray()
              .getBufferAttribute('position').array,
            this.renderBuffer.getVertexIndex().bufferAttribute.array,
            this.drawSegmentArray,
            this.boundingBox,
          ),
            this.boundingBox.getCenter(this.boundingSphere.center),
            (this.boundingSphere.radius =
              0.5 * this.boundingBox.min.distanceTo(this.boundingBox.max));
        }
      };
    })(),
    raycast: (function () {
      var t = new ot(),
        e = new ot(),
        n = new qt(),
        i = new J(),
        r = new J(),
        o = new J(),
        s = new J(),
        a = new vm(0, 0, 0, 0),
        c = new Gt();
      function l(t, e, n, i, r, o, a) {
        if (null === i.intersectTriangle(r, o, a, !1, s)) return null;
        e && s.applyMatrix4(e);
        var c = n.ray.origin.distanceTo(s);
        return c < n.near || c > n.far
          ? null
          : { distance: c, point: s.clone(), object: t };
      }
      function h(t, e, n, s, a, c, h, u) {
        var d;
        switch (s) {
          case Hf.TRIANGLES:
            for (let s = c.offset, p = c.end(); s < p; s += 3) {
              let c = 3 * a[s];
              i.set(n[c], n[c + 1], n[c + 2]),
                (c = 3 * a[s + 1]),
                r.set(n[c], n[c + 1], n[c + 2]),
                (c = 3 * a[s + 2]),
                o.set(n[c], n[c + 1], n[c + 2]);
              let p = l(t, e, h, u, i, r, o);
              if (p) {
                let t = new ye(a[s], a[s + 1], a[s + 2]);
                e && (i.applyMatrix4(e), r.applyMatrix4(e), o.applyMatrix4(e)),
                  he.getNormal(i, r, o, t.normal),
                  (p.face = t),
                  (p.vA = i.clone()),
                  (p.vB = r.clone()),
                  (p.vC = o.clone()),
                  (!d || p.distance < d.distance) && (d = p);
              }
            }
        }
        return d;
      }
      return function (i, r, o) {
        if (
          !(
            this.renderBuffer &&
            this.material &&
            this.material.visible &&
            this.validDraw
          )
        )
          return;
        if (!1 === i.ray.intersectsSphere(this.boundingSphere)) return;
        let s = this.renderBuffer
            .getVertexAttributeArray()
            .getBufferAttribute('position'),
          l = this.renderBuffer.getVertexIndex().bufferAttribute;
        if (!s || !l) return;
        let u,
          d = l.array,
          p = this.renderBuffer.getVertexIndex().drawMode;
        if (this.renderBuffer.isPMInstanceRenderBuffer) {
          let r = o
              ? this.renderBuffer.getInstanceVertexAttributeArray()
              : this.currentInstanceVertexArray,
            l = r.getBufferAttribute(_m.name).array,
            f = r.getBufferAttribute(xm.name).array,
            m = r.getBufferAttribute(wm.name).array,
            b = r.getBufferAttribute(Am.name).array,
            g = this.renderBuffer.getVertexBoundingSphere();
          a.set(0, d.length);
          for (
            let r = o ? o.offset : 0, y = o ? o.end() : this.numInstance;
            r < y;
            ++r
          ) {
            if (
              (Xf.getInstanceMatrixByArray(l, f, m, b, r, t),
              c.copy(g).applyMatrix4(t),
              !1 === i.ray.intersectsSphere(c))
            )
              continue;
            e.getInverse(t), n.copy(i.ray).applyMatrix4(e);
            let o = h(this, t, s.array, p, d, a, i, n);
            o &&
              (!u || o.distance < u.distance) &&
              ((u = o), (u.instanceID = r));
          }
        } else {
          let t = [];
          o ? t.push(o) : (t = this.currentSegmentArray), n.copy(i.ray);
          let e = this.renderBuffer.getVertexAttributeArray(),
            r = e.getBufferAttribute('oldIndex');
          if (r) {
            let i = function (t, e, n, i) {
                let r = t.origin,
                  o = e,
                  s = n,
                  a = t.direction,
                  c = s.clone(),
                  l = o.clone();
                c.sub(o), l.sub(r);
                let h = new J();
                h.crossVectors(a, c);
                let u,
                  d,
                  p = h.lengthSq();
                if (p < 1e-7) return null;
                let f = new J();
                f.crossVectors(l, c);
                let m = new J();
                m.crossVectors(l, a);
                let b = f.dot(h),
                  g = m.dot(h);
                (b /= p), (g /= p);
                let y = i / c.length();
                if (g - 1 <= y && -g <= y) {
                  let t = r.clone();
                  t.addScaledVector(a, b);
                  let e = o.clone();
                  e.addScaledVector(c, g);
                  let n = t.distanceTo(e);
                  if (n <= i)
                    return (u = b + n), (d = t), { distance: u, point: d };
                }
                return null;
              },
              o = e.getBufferAttribute('position'),
              s = o.array,
              a = r.array,
              c = o.itemSize,
              l = new DataView(s.buffer),
              h = new J(),
              d = new J(),
              p = 0,
              f = 0;
            for (let e = 0, r = t.length; e < r; ++e) {
              let r = t[e];
              for (
                let t = r.offset_old + 1, e = r.offset_old + r.count_old;
                t < e;
                ++t
              ) {
                let e = a[t];
                if (4294967295 === e) {
                  ++t;
                  continue;
                }
                let r = a[t - 1],
                  o = e * c,
                  m = r * c;
                if (
                  ((h.x = s[o]),
                  (h.y = s[o + 1]),
                  (h.z = s[o + 2]),
                  (d.x = s[m]),
                  (d.y = s[m + 1]),
                  (d.z = s[m + 2]),
                  this.renderBuffer.WebGl2Buffer)
                ) {
                  let t = 1048575 & l.getInt32(4 * (o + 3), !0);
                  (p = 0.001 * t),
                    (t = 1048575 & l.getInt32(4 * (m + 3), !0)),
                    (f = 0.001 * t);
                } else (p = s[o + 3]), (f = s[m + 3]);
                let b = i(n, h, d, Math.max(p, f));
                b &&
                  (!u || b.distance < u.distance) &&
                  ((b.object = this),
                  (b.line = { a: e, b: r }),
                  (b.vA = h.clone()),
                  (b.vB = d.clone()),
                  (b.radiusA = p),
                  (b.radiusB = f),
                  (u = b));
              }
            }
          } else
            for (let e = 0, r = t.length; e < r; ++e) {
              let r = h(this, void 0, s.array, p, d, t[e], i, n);
              r && (!u || r.distance < u.distance) && (u = r);
            }
        }
        return u ? (r.push(u), u) : void 0;
      };
    })(),
    bindUpdateEvent: function (t, e) {
      t &&
        (e
          ? this.addEventListener(Im.type, t)
          : this.removeEventListener(Im.type, t));
    },
    onUpdate: function () {
      this.dispatchEvent(Im);
    },
  })),
    (Dm.prototype = Object.assign(Object.create(Rr.prototype), {
      constructor: Dm,
      isPMRenderNode: !0,
      removeAll: function () {
        Rr.prototype.removeAll.call(this), this.renderObjectMap.clear();
      },
      getOrCreateRenderObject: function (t, e, n) {
        let i = this.renderObjectMap.get(t);
        return (
          i ||
            ((i = new Em(e, n)), this.add(i), this.renderObjectMap.set(t, i)),
          i
        );
      },
    }));
  let Cm = { type: 'loadRenderDataEvent' },
    Tm = { type: 'releaseRenderDataEvent' },
    Lm = {
      type: 'flushRenderObject',
      renderNode: void 0,
      renderObject: void 0,
      entity: void 0,
    },
    Rm = {
      type: 'removeRenderObject',
      renderNode: void 0,
      renderObject: void 0,
      gl: void 0,
    };
  function Fm(t, e, n, i) {
    n && (i ? t.addEventListener(e, n) : t.removeEventListener(e, n));
  }
  function Pm(t) {
    Rr.call(this),
      (this.type = 'SceneNode'),
      (this.bndBox = new Nt()),
      (this.dataInterface = t),
      (this.pageData = null),
      (this.lodDataArray = []),
      (this.entInfoFileList = []),
      (this.curPage = null),
      (this.entityMap = new Map()),
      (this.entityArray = []),
      (this.renderNodeMap = new Map()),
      (this.renderBufferMap = new Map()),
      (this.isLoading = !1),
      (this.promiseArr = []);
  }
  function Bm(t, e, n) {
    (this.viewToken = t),
      (this.sceneNode = new Pm(e)),
      (this.textureImageMap = new Map()),
      (this.materialMap = new Map()),
      (this.materialMap_CCY = new Map()),
      (this.refDefinitionMap = new Map()),
      (this.modelTree = new am(this)),
      (this.dwgLayoutMap = new Map()),
      (this.floorAxisArray = []),
      (this.name = n);
  }
  (Pm.prototype = Object.assign(Object.create(Rr.prototype), {
    constructor: Pm,
    isPMSceneNode: !0,
    setVisible: function (t) {
      this.visible = t;
    },
    setBndBox: function (t) {
      t && this.bndBox.copy(t);
    },
    getBndBox: function () {
      if (this.bndBox.isEmpty())
        for (let t = 0, e = this.children.length; t < e; ++t) {
          let e = this.children[t];
          e.isPMSceneNode && this.bndBox.union(e.getBndBox());
        }
      return this.bndBox;
    },
    expandBndBox: function (t) {
      if (!t) return;
      let e = this;
      for (; e && e.isPMSceneNode; ) e.bndBox.union(t), (e = e.parent);
    },
    setPageData: function (t) {
      this.pageData = t;
    },
    getPageData: function () {
      return this.pageData;
    },
    addPageLOD: function (t) {
      t && this.lodDataArray.push(t);
    },
    getPageLODArray: function () {
      return this.lodDataArray;
    },
    addEntInfoFileList: function (t) {
      this.entInfoFileList.push(t);
    },
    getEntInfoFileList: function () {
      return this.entInfoFileList;
    },
    releaseRenderData: function (t) {
      let e = this;
      if (e.curPage) {
        for (let t = 0, n = e.entityArray.length; t < n; ++t) {
          let n = e.entityArray[t],
            i = n.getModelNode();
          i && i.removeEntity(n), n.setSceneNode(null), n.clearGeoData();
        }
        (e.entityArray = []),
          e.renderNodeMap.forEach((n) => {
            let i = n.children;
            for (let r = 0, o = i.length; r < o; ++r) {
              let o = i[r];
              o.isPMRenderObject &&
                (o.release(t),
                (Rm.renderNode = n),
                (Rm.renderObject = o),
                (Rm.gl = t),
                e.dispatchEvent(Rm));
            }
            n.removeAll();
          }),
          e.renderBufferMap.forEach((e) => {
            e.release(t);
          }),
          e.renderBufferMap.clear(),
          (e.curPage = null),
          e.dispatchEvent(Tm);
      }
    },
    loadRenderData: function (t, e, n) {
      if (this.curPage !== e && !this.isLoading) {
        if (
          ((this.isLoading = !0),
          this.releaseRenderData(t),
          (this.curPage = e),
          this.curPage)
        ) {
          this.dataInterface.loadSceneNode(this, this.curPage, this.promiseArr);
          for (let t = 0, e = this.promiseArr.length; t < e; ++t)
            n.push(this.promiseArr[t]);
        }
        this.promiseArr.length > 0
          ? Promise.all(this.promiseArr).then(() => {
              for (let t = 0, e = this.promiseArr.length; t < e; t++)
                this.promiseArr[t] = null;
              (this.promiseArr = []),
                this.dataInterface.redefineEntData(
                  this.renderBufferMap,
                  this.entityMap,
                ),
                this.entityMap.forEach((t) => {
                  this.insertEntity(t);
                }),
                this.entityMap.clear();
              for (let t = 0, e = this.entityArray.length; t < e; ++t) {
                let e = this.entityArray[t];
                this.flushEntity(e);
              }
              this.dispatchEvent(Cm), (this.isLoading = !1);
            })
          : (this.isLoading = !1);
      }
    },
    getCurPage: function () {
      return this.curPage;
    },
    getOrCreateRenderNode: function (t) {
      let e = this.renderNodeMap.get(t);
      return (
        e || ((e = new Dm()), this.renderNodeMap.set(t, e), this.add(e)), e
      );
    },
    insertEntity: function (t) {
      t.getSceneNode()
        ? console.warn('The entity is in scene-node already.')
        : (this.entityArray.push(t), t.setSceneNode(this));
    },
    getEntityArray: function () {
      return this.entityArray;
    },
    flushEntity: function (t) {
      if (!t) return;
      let e = t.getStyle(),
        n = t.getGeoDataArray();
      if (t.isRenderVisible())
        for (let i = 0, r = n.length; i < r; i++) {
          let r = n[i],
            o = this.renderBufferMap.get(r.getGeoID());
          if (o) {
            let n = o.getMaterial();
            if (e)
              if (0 === o.CycleSegCount)
                switch (o.getIndexMode()) {
                  case Hf.TRIANGLES:
                  case Hf.TRIANGLE_FAN:
                  case Hf.TRIANGLE_STRIP:
                    n = e.meshMaterial;
                    break;
                  case Hf.LINES:
                  case Hf.LINE_LOOP:
                  case Hf.LINE_STRIP:
                    n = e.lineMaterial;
                }
              else n = e.ccyMaterial;
            let i = this.getOrCreateRenderNode(n),
              s = i.getOrCreateRenderObject(r.getGeoID(), o, n);
            r.setRenderObject(s),
              (Lm.renderNode = i),
              (Lm.renderObject = s),
              (Lm.entity = t),
              this.dispatchEvent(Lm);
          } else
            r.setRenderObject(null),
              console.warn('Associate to render-buffer failed.');
        }
      else for (let t = 0, e = n.length; t < e; t++) n[t].setRenderObject(null);
    },
    bindFlushObjectEvent: function (t, e) {
      Fm(this, Lm.type, t, e);
    },
    bindRemoveObjectEvent: function (t, e) {
      Fm(this, Rm.type, t, e);
    },
    bindLoadRenderDataEvent: function (t, e) {
      Fm(this, Cm.type, t, e);
    },
    bindReleaseRenderDataEvent: function (t, e) {
      Fm(this, Tm.type, t, e);
    },
  })),
    (Bm.prototype = {
      constructor: Bm,
      isPMModel: !0,
      getViewToken: function () {
        return this.viewToken;
      },
      getSceneNode: function () {
        return this.sceneNode;
      },
      setSceneNode: function (t) {
        this.sceneNode = t;
      },
      getBoundingBox: function () {
        return this.modelTree
          .getRootNode()
          .getBoundingBox()
          .union(this.sceneNode.getBndBox());
      },
      getTextureImageMap: function () {
        return this.textureImageMap;
      },
      getMaterialMap: function () {
        return this.materialMap;
      },
      getMaterialMap_CCY: function () {
        return this.materialMap_CCY;
      },
      getRefDefinitionMap: function () {
        return this.refDefinitionMap;
      },
      getModelTree: function () {
        return this.modelTree;
      },
      getDwgLayoutMap: function () {
        return this.dwgLayoutMap;
      },
      setDwgLayoutMap: function (t) {
        this.dwgLayoutMap = t;
      },
      setFloorAxisArray: function (t) {
        this.floorAxisArray = t;
      },
      getFloorAxisArray: function () {
        return this.floorAxisArray;
      },
      setName: function (t) {
        this.name = t;
      },
      getName: function () {
        return this.name;
      },
      clear: (function () {
        function t(e, n) {
          if (!e.isPMSceneNode) return;
          e.releaseRenderData(n);
          let i = e.children;
          for (let e = 0, r = i.length; e < r; ++e) t(i[e], n);
        }
        return function (e) {
          t(this.getSceneNode(), e),
            this.textureImageMap.clear(),
            this.materialMap.clear(),
            this.refDefinitionMap.clear(),
            this.modelTree.clear(),
            this.dwgLayoutMap.clear(),
            (this.floorAxisArray = []);
        };
      })(),
    });
  var Om = Om || {};
  function Vm() {
    (this.id = 0),
      (this.vertexAttributeArray = null),
      (this.vertexIndex = null),
      (this.material = null),
      (this.vertexBoundingSphere = new Gt()),
      (this.CycleSegCount = 0),
      (this.WebGl2Buffer = !1);
  }
  function Nm() {
    Vm.call(this),
      (this.instanceVertexAttributeArray = null),
      (this.instanceBoundingSphereArray = []);
  }
  function km() {
    (this.type = 'PageData'),
      (this.contentSize = 0),
      (this.bufferGeometryFileList = []),
      (this.entDataFileList = []),
      (this.usage = 0);
  }
  function Um() {
    (this.type = 'RefDefinition'),
      (this.uuid = 0),
      (this.refObjectArray = []),
      (this.bndBox = null);
  }
  function Gm(t, e) {
    bm.call(this, t),
      (this.viewer = e),
      (this.cancelCreateModel = !1),
      (this.hasloadOnce = !1),
      (this.gridMeshGeoMap = new Map()),
      (this.gridMeshEntMap = new Map()),
      (this.gridMeshInfoMap = new Map());
  }
  function zm() {
    (this.instanceMatR1 = []),
      (this.instanceMatR2 = []),
      (this.instanceMatR3 = []),
      (this.instanceMatR4 = []),
      (this.refObject = null),
      (this.refInstanceID = ''),
      (this.curMatrixIndex = 0);
  }
  function jm(t) {
    Pr.call(this, t);
  }
  function Hm() {
    this.next = null;
  }
  function Wm() {
    (this.head = null), (this.tail = null), (this.size = 0);
  }
  function Xm(t) {
    Hm.call(this), (this.renderTarget = t);
  }
  function Zm(t) {
    Hm.call(this), (this.scissorTest = !!t);
  }
  function Ym(t, e, n, i) {
    Hm.call(this), (this.viewPort = new W(t, e, n, i));
  }
  function qm(t, e, n) {
    Hm.call(this),
      (this.clearColor = !!t),
      (this.clearDepth = !!e),
      (this.clearStencil = !!n);
  }
  function Qm(t, e) {
    Hm.call(this), (this.scene = t), (this.camera = e);
  }
  function Jm(t, e) {
    Hm.call(this), (this.scene = t), (this.camera = e);
  }
  function $m(t, e, n) {
    Hm.call(this), (this.item = t), (this.scene = e), (this.camera = n);
  }
  function Km() {
    An.call(this),
      (this.type = 'PMCamera'),
      this.position.set(0, 0, 0),
      (this.target = new J(0, 1, 0)),
      this.up.set(0, 0, 1),
      (this.pixelVector = new W()),
      (this.near = 1e-4),
      (this.far = 1e6),
      (this.fov = 1),
      (this.aspect = 1),
      (this.viewWidth = 1),
      (this.viewHeight = 1),
      (this.isPerspectiveCamera = !0),
      (this.isOrthographicCamera = !1);
  }
  (Om.Image = function () {
    (this.bb = null), (this.bb_pos = 0);
  }),
    (Om.Image.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (Om.Image.getRootAsImage = function (t, e) {
      return (e || new Om.Image()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (Om.Image.prototype.uuid = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Om.Image.prototype.url = function (t) {
      var e = this.bb.__offset(this.bb_pos, 6);
      return e ? this.bb.__string(this.bb_pos + e, t) : null;
    }),
    (Om.Image.prototype.isUserImage = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return !!t && !!this.bb.readInt8(this.bb_pos + t);
    }),
    (Om.Image.startImage = function (t) {
      t.startObject(3);
    }),
    (Om.Image.addUuid = function (t, e) {
      t.addFieldInt32(0, e, 0);
    }),
    (Om.Image.addUrl = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (Om.Image.addIsUserImage = function (t, e) {
      t.addFieldInt8(2, +e, 0);
    }),
    (Om.Image.endImage = function (t) {
      return t.endObject();
    }),
    (Om.Material = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (Om.Material.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (Om.Material.getRootAsMaterial = function (t, e) {
      return (e || new Om.Material()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (Om.Material.prototype.uuid = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Om.Material.prototype.image = function (t) {
      var e = this.bb.__offset(this.bb_pos, 6);
      return e
        ? (t || new Om.Image()).__init(
            this.bb.__indirect(this.bb_pos + e),
            this.bb,
          )
        : null;
    }),
    (Om.Material.prototype.lightType = function (t) {
      var e = this.bb.__offset(this.bb_pos, 8);
      return e ? this.bb.__string(this.bb_pos + e, t) : null;
    }),
    (Om.Material.prototype.color = function (t) {
      var e = this.bb.__offset(this.bb_pos, 10);
      return e ? this.bb.__string(this.bb_pos + e, t) : null;
    }),
    (Om.Material.prototype.transparency = function () {
      var t = this.bb.__offset(this.bb_pos, 12);
      return t ? this.bb.readFloat32(this.bb_pos + t) : 0;
    }),
    (Om.Material.prototype.enableTransparent = function () {
      var t = this.bb.__offset(this.bb_pos, 14);
      return !!t && !!this.bb.readInt8(this.bb_pos + t);
    }),
    (Om.Material.prototype.depthFunc = function () {
      var t = this.bb.__offset(this.bb_pos, 16);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Om.Material.prototype.polygonOffsetFactor = function () {
      var t = this.bb.__offset(this.bb_pos, 18);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Om.Material.prototype.polygonOffsetUnits = function () {
      var t = this.bb.__offset(this.bb_pos, 20);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Om.Material.prototype.enablePolygonOffset = function () {
      var t = this.bb.__offset(this.bb_pos, 22);
      return !!t && !!this.bb.readInt8(this.bb_pos + t);
    }),
    (Om.Material.prototype.doubleSide = function () {
      var t = this.bb.__offset(this.bb_pos, 24);
      return !!t && !!this.bb.readInt8(this.bb_pos + t);
    }),
    (Om.Material.startMaterial = function (t) {
      t.startObject(11);
    }),
    (Om.Material.addUuid = function (t, e) {
      t.addFieldInt32(0, e, 0);
    }),
    (Om.Material.addImage = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (Om.Material.addLightType = function (t, e) {
      t.addFieldOffset(2, e, 0);
    }),
    (Om.Material.addColor = function (t, e) {
      t.addFieldOffset(3, e, 0);
    }),
    (Om.Material.addTransparency = function (t, e) {
      t.addFieldFloat32(4, e, 0);
    }),
    (Om.Material.addEnableTransparent = function (t, e) {
      t.addFieldInt8(5, +e, 0);
    }),
    (Om.Material.addDepthFunc = function (t, e) {
      t.addFieldInt32(6, e, 0);
    }),
    (Om.Material.addPolygonOffsetFactor = function (t, e) {
      t.addFieldInt32(7, e, 0);
    }),
    (Om.Material.addPolygonOffsetUnits = function (t, e) {
      t.addFieldInt32(8, e, 0);
    }),
    (Om.Material.addEnablePolygonOffset = function (t, e) {
      t.addFieldInt8(9, +e, 0);
    }),
    (Om.Material.addDoubleSide = function (t, e) {
      t.addFieldInt8(10, +e, 0);
    }),
    (Om.Material.endMaterial = function (t) {
      return t.endObject();
    }),
    (Om.FileData_Material = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (Om.FileData_Material.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (Om.FileData_Material.getRootAsFileData_Material = function (t, e) {
      return (e || new Om.FileData_Material()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (Om.FileData_Material.prototype.id = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Om.FileData_Material.prototype.materialArray = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 6);
      return n
        ? (e || new Om.Material()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (Om.FileData_Material.prototype.materialArrayLength = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Om.FileData_Material.startFileData_Material = function (t) {
      t.startObject(2);
    }),
    (Om.FileData_Material.addId = function (t, e) {
      t.addFieldInt32(0, e, 0);
    }),
    (Om.FileData_Material.addMaterialArray = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (Om.FileData_Material.createMaterialArrayVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (Om.FileData_Material.startMaterialArrayVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Om.FileData_Material.endFileData_Material = function (t) {
      return t.endObject();
    }),
    (Om.GeoData_Line = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (Om.GeoData_Line.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (Om.GeoData_Line.getRootAsGeoData_Line = function (t, e) {
      return (e || new Om.GeoData_Line()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (Om.GeoData_Line.prototype.uuid = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Om.GeoData_Line.prototype.vertexs = function (t) {
      var e = this.bb.__offset(this.bb_pos, 6);
      return e
        ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (Om.GeoData_Line.prototype.vertexsLength = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Om.GeoData_Line.prototype.vertexsArray = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t
        ? new Float32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (Om.GeoData_Line.prototype.width = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t ? this.bb.readFloat32(this.bb_pos + t) : 0;
    }),
    (Om.GeoData_Line.prototype.color = function (t) {
      var e = this.bb.__offset(this.bb_pos, 10);
      return e ? this.bb.__string(this.bb_pos + e, t) : null;
    }),
    (Om.GeoData_Line.startGeoData_Line = function (t) {
      t.startObject(4);
    }),
    (Om.GeoData_Line.addUuid = function (t, e) {
      t.addFieldInt32(0, e, 0);
    }),
    (Om.GeoData_Line.addVertexs = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (Om.GeoData_Line.createVertexsVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addFloat32(e[n]);
      return t.endVector();
    }),
    (Om.GeoData_Line.startVertexsVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Om.GeoData_Line.addWidth = function (t, e) {
      t.addFieldFloat32(2, e, 0);
    }),
    (Om.GeoData_Line.addColor = function (t, e) {
      t.addFieldOffset(3, e, 0);
    }),
    (Om.GeoData_Line.endGeoData_Line = function (t) {
      return t.endObject();
    }),
    (Om.GeoData_Face = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (Om.GeoData_Face.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (Om.GeoData_Face.getRootAsGeoData_Face = function (t, e) {
      return (e || new Om.GeoData_Face()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (Om.GeoData_Face.prototype.uuid = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Om.GeoData_Face.prototype.vertexs = function (t) {
      var e = this.bb.__offset(this.bb_pos, 6);
      return e
        ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (Om.GeoData_Face.prototype.vertexsLength = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Om.GeoData_Face.prototype.vertexsArray = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t
        ? new Float32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (Om.GeoData_Face.prototype.triangles = function (t) {
      var e = this.bb.__offset(this.bb_pos, 8);
      return e
        ? this.bb.readInt32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (Om.GeoData_Face.prototype.trianglesLength = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Om.GeoData_Face.prototype.trianglesArray = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t
        ? new Int32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (Om.GeoData_Face.prototype.normals = function (t) {
      var e = this.bb.__offset(this.bb_pos, 10);
      return e
        ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (Om.GeoData_Face.prototype.normalsLength = function () {
      var t = this.bb.__offset(this.bb_pos, 10);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Om.GeoData_Face.prototype.normalsArray = function () {
      var t = this.bb.__offset(this.bb_pos, 10);
      return t
        ? new Float32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (Om.GeoData_Face.prototype.vertexParams = function (t) {
      var e = this.bb.__offset(this.bb_pos, 12);
      return e
        ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (Om.GeoData_Face.prototype.vertexParamsLength = function () {
      var t = this.bb.__offset(this.bb_pos, 12);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Om.GeoData_Face.prototype.vertexParamsArray = function () {
      var t = this.bb.__offset(this.bb_pos, 12);
      return t
        ? new Float32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (Om.GeoData_Face.prototype.material = function () {
      var t = this.bb.__offset(this.bb_pos, 14);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Om.GeoData_Face.startGeoData_Face = function (t) {
      t.startObject(6);
    }),
    (Om.GeoData_Face.addUuid = function (t, e) {
      t.addFieldInt32(0, e, 0);
    }),
    (Om.GeoData_Face.addVertexs = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (Om.GeoData_Face.createVertexsVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addFloat32(e[n]);
      return t.endVector();
    }),
    (Om.GeoData_Face.startVertexsVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Om.GeoData_Face.addTriangles = function (t, e) {
      t.addFieldOffset(2, e, 0);
    }),
    (Om.GeoData_Face.createTrianglesVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addInt32(e[n]);
      return t.endVector();
    }),
    (Om.GeoData_Face.startTrianglesVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Om.GeoData_Face.addNormals = function (t, e) {
      t.addFieldOffset(3, e, 0);
    }),
    (Om.GeoData_Face.createNormalsVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addFloat32(e[n]);
      return t.endVector();
    }),
    (Om.GeoData_Face.startNormalsVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Om.GeoData_Face.addVertexParams = function (t, e) {
      t.addFieldOffset(4, e, 0);
    }),
    (Om.GeoData_Face.createVertexParamsVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addFloat32(e[n]);
      return t.endVector();
    }),
    (Om.GeoData_Face.startVertexParamsVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Om.GeoData_Face.addMaterial = function (t, e) {
      t.addFieldInt32(5, e, 0);
    }),
    (Om.GeoData_Face.endGeoData_Face = function (t) {
      return t.endObject();
    }),
    (Om.GeoData_Mesh = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (Om.GeoData_Mesh.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (Om.GeoData_Mesh.getRootAsGeoData_Mesh = function (t, e) {
      return (e || new Om.GeoData_Mesh()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (Om.GeoData_Mesh.prototype.uuid = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Om.GeoData_Mesh.prototype.origin = function (t) {
      var e = this.bb.__offset(this.bb_pos, 6);
      return e
        ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (Om.GeoData_Mesh.prototype.originLength = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Om.GeoData_Mesh.prototype.originArray = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t
        ? new Float32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (Om.GeoData_Mesh.prototype.columnCount = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t ? this.bb.readUint16(this.bb_pos + t) : 0;
    }),
    (Om.GeoData_Mesh.prototype.rowCount = function () {
      var t = this.bb.__offset(this.bb_pos, 10);
      return t ? this.bb.readUint16(this.bb_pos + t) : 0;
    }),
    (Om.GeoData_Mesh.prototype.gridSize = function () {
      var t = this.bb.__offset(this.bb_pos, 12);
      return t ? this.bb.readFloat32(this.bb_pos + t) : 0;
    }),
    (Om.GeoData_Mesh.prototype.material = function () {
      var t = this.bb.__offset(this.bb_pos, 14);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Om.GeoData_Mesh.prototype.otherFace = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 16);
      return n
        ? (e || new Om.GeoData_Face()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (Om.GeoData_Mesh.prototype.otherFaceLength = function () {
      var t = this.bb.__offset(this.bb_pos, 16);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Om.GeoData_Mesh.startGeoData_Mesh = function (t) {
      t.startObject(7);
    }),
    (Om.GeoData_Mesh.addUuid = function (t, e) {
      t.addFieldInt32(0, e, 0);
    }),
    (Om.GeoData_Mesh.addOrigin = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (Om.GeoData_Mesh.createOriginVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addFloat32(e[n]);
      return t.endVector();
    }),
    (Om.GeoData_Mesh.startOriginVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Om.GeoData_Mesh.addColumnCount = function (t, e) {
      t.addFieldInt16(2, e, 0);
    }),
    (Om.GeoData_Mesh.addRowCount = function (t, e) {
      t.addFieldInt16(3, e, 0);
    }),
    (Om.GeoData_Mesh.addGridSize = function (t, e) {
      t.addFieldFloat32(4, e, 0);
    }),
    (Om.GeoData_Mesh.addMaterial = function (t, e) {
      t.addFieldInt32(5, e, 0);
    }),
    (Om.GeoData_Mesh.addOtherFace = function (t, e) {
      t.addFieldOffset(6, e, 0);
    }),
    (Om.GeoData_Mesh.createOtherFaceVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (Om.GeoData_Mesh.startOtherFaceVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Om.GeoData_Mesh.endGeoData_Mesh = function (t) {
      return t.endObject();
    }),
    (Om.GeoData_Group = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (Om.GeoData_Group.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (Om.GeoData_Group.getRootAsGeoData_Group = function (t, e) {
      return (e || new Om.GeoData_Group()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (Om.GeoData_Group.prototype.uuid = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Om.GeoData_Group.prototype.geoDataArray = function (t) {
      var e = this.bb.__offset(this.bb_pos, 6);
      return e
        ? this.bb.readInt32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (Om.GeoData_Group.prototype.geoDataArrayLength = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Om.GeoData_Group.prototype.geoDataArrayArray = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t
        ? new Int32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (Om.GeoData_Group.startGeoData_Group = function (t) {
      t.startObject(2);
    }),
    (Om.GeoData_Group.addUuid = function (t, e) {
      t.addFieldInt32(0, e, 0);
    }),
    (Om.GeoData_Group.addGeoDataArray = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (Om.GeoData_Group.createGeoDataArrayVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addInt32(e[n]);
      return t.endVector();
    }),
    (Om.GeoData_Group.startGeoDataArrayVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Om.GeoData_Group.endGeoData_Group = function (t) {
      return t.endObject();
    }),
    (Om.FileData_RefSource = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (Om.FileData_RefSource.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (Om.FileData_RefSource.getRootAsFileData_RefSource = function (t, e) {
      return (e || new Om.FileData_RefSource()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (Om.FileData_RefSource.prototype.id = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Om.FileData_RefSource.prototype.lineArray = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 6);
      return n
        ? (e || new Om.GeoData_Line()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (Om.FileData_RefSource.prototype.lineArrayLength = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Om.FileData_RefSource.prototype.faceArray = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 8);
      return n
        ? (e || new Om.GeoData_Face()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (Om.FileData_RefSource.prototype.faceArrayLength = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Om.FileData_RefSource.prototype.groupArray = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 10);
      return n
        ? (e || new Om.GeoData_Group()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (Om.FileData_RefSource.prototype.groupArrayLength = function () {
      var t = this.bb.__offset(this.bb_pos, 10);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Om.FileData_RefSource.startFileData_RefSource = function (t) {
      t.startObject(4);
    }),
    (Om.FileData_RefSource.addId = function (t, e) {
      t.addFieldInt32(0, e, 0);
    }),
    (Om.FileData_RefSource.addLineArray = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (Om.FileData_RefSource.createLineArrayVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (Om.FileData_RefSource.startLineArrayVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Om.FileData_RefSource.addFaceArray = function (t, e) {
      t.addFieldOffset(2, e, 0);
    }),
    (Om.FileData_RefSource.createFaceArrayVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (Om.FileData_RefSource.startFaceArrayVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Om.FileData_RefSource.addGroupArray = function (t, e) {
      t.addFieldOffset(3, e, 0);
    }),
    (Om.FileData_RefSource.createGroupArrayVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (Om.FileData_RefSource.startGroupArrayVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Om.FileData_RefSource.endFileData_RefSource = function (t) {
      return t.endObject();
    }),
    (Om.EntData_Triangle = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (Om.EntData_Triangle.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (Om.EntData_Triangle.getRootAsEntData_Triangle = function (t, e) {
      return (e || new Om.EntData_Triangle()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (Om.EntData_Triangle.prototype.uuid = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Om.EntData_Triangle.prototype.bndBoxMin = function (t) {
      var e = this.bb.__offset(this.bb_pos, 6);
      return e
        ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (Om.EntData_Triangle.prototype.bndBoxMinLength = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Om.EntData_Triangle.prototype.bndBoxMinArray = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t
        ? new Float32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (Om.EntData_Triangle.prototype.bndBoxMax = function (t) {
      var e = this.bb.__offset(this.bb_pos, 8);
      return e
        ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (Om.EntData_Triangle.prototype.bndBoxMaxLength = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Om.EntData_Triangle.prototype.bndBoxMaxArray = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t
        ? new Float32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (Om.EntData_Triangle.prototype.faceID = function () {
      var t = this.bb.__offset(this.bb_pos, 10);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Om.EntData_Triangle.prototype.vertexOffset = function () {
      var t = this.bb.__offset(this.bb_pos, 12);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Om.EntData_Triangle.prototype.vertexCount = function () {
      var t = this.bb.__offset(this.bb_pos, 14);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Om.EntData_Triangle.prototype.vertexParamsOffset = function () {
      var t = this.bb.__offset(this.bb_pos, 16);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Om.EntData_Triangle.prototype.vertexParamsCount = function () {
      var t = this.bb.__offset(this.bb_pos, 18);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Om.EntData_Triangle.prototype.trianglesOffset = function () {
      var t = this.bb.__offset(this.bb_pos, 20);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Om.EntData_Triangle.prototype.trianglesCount = function () {
      var t = this.bb.__offset(this.bb_pos, 22);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Om.EntData_Triangle.startEntData_Triangle = function (t) {
      t.startObject(10);
    }),
    (Om.EntData_Triangle.addUuid = function (t, e) {
      t.addFieldInt32(0, e, 0);
    }),
    (Om.EntData_Triangle.addBndBoxMin = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (Om.EntData_Triangle.createBndBoxMinVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addFloat32(e[n]);
      return t.endVector();
    }),
    (Om.EntData_Triangle.startBndBoxMinVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Om.EntData_Triangle.addBndBoxMax = function (t, e) {
      t.addFieldOffset(2, e, 0);
    }),
    (Om.EntData_Triangle.createBndBoxMaxVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addFloat32(e[n]);
      return t.endVector();
    }),
    (Om.EntData_Triangle.startBndBoxMaxVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Om.EntData_Triangle.addFaceID = function (t, e) {
      t.addFieldInt32(3, e, 0);
    }),
    (Om.EntData_Triangle.addVertexOffset = function (t, e) {
      t.addFieldInt32(4, e, 0);
    }),
    (Om.EntData_Triangle.addVertexCount = function (t, e) {
      t.addFieldInt32(5, e, 0);
    }),
    (Om.EntData_Triangle.addVertexParamsOffset = function (t, e) {
      t.addFieldInt32(6, e, 0);
    }),
    (Om.EntData_Triangle.addVertexParamsCount = function (t, e) {
      t.addFieldInt32(7, e, 0);
    }),
    (Om.EntData_Triangle.addTrianglesOffset = function (t, e) {
      t.addFieldInt32(8, e, 0);
    }),
    (Om.EntData_Triangle.addTrianglesCount = function (t, e) {
      t.addFieldInt32(9, e, 0);
    }),
    (Om.EntData_Triangle.endEntData_Triangle = function (t) {
      return t.endObject();
    }),
    (Om.EntData_Reference = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (Om.EntData_Reference.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (Om.EntData_Reference.getRootAsEntData_Reference = function (t, e) {
      return (e || new Om.EntData_Reference()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (Om.EntData_Reference.prototype.uuid = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Om.EntData_Reference.prototype.bndBoxMin = function (t) {
      var e = this.bb.__offset(this.bb_pos, 6);
      return e
        ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (Om.EntData_Reference.prototype.bndBoxMinLength = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Om.EntData_Reference.prototype.bndBoxMinArray = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t
        ? new Float32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (Om.EntData_Reference.prototype.bndBoxMax = function (t) {
      var e = this.bb.__offset(this.bb_pos, 8);
      return e
        ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (Om.EntData_Reference.prototype.bndBoxMaxLength = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Om.EntData_Reference.prototype.bndBoxMaxArray = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t
        ? new Float32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (Om.EntData_Reference.prototype.groupID = function () {
      var t = this.bb.__offset(this.bb_pos, 10);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Om.EntData_Reference.prototype.matrix = function (t) {
      var e = this.bb.__offset(this.bb_pos, 12);
      return e
        ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (Om.EntData_Reference.prototype.matrixLength = function () {
      var t = this.bb.__offset(this.bb_pos, 12);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Om.EntData_Reference.prototype.matrixArray = function () {
      var t = this.bb.__offset(this.bb_pos, 12);
      return t
        ? new Float32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (Om.EntData_Reference.startEntData_Reference = function (t) {
      t.startObject(5);
    }),
    (Om.EntData_Reference.addUuid = function (t, e) {
      t.addFieldInt32(0, e, 0);
    }),
    (Om.EntData_Reference.addBndBoxMin = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (Om.EntData_Reference.createBndBoxMinVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addFloat32(e[n]);
      return t.endVector();
    }),
    (Om.EntData_Reference.startBndBoxMinVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Om.EntData_Reference.addBndBoxMax = function (t, e) {
      t.addFieldOffset(2, e, 0);
    }),
    (Om.EntData_Reference.createBndBoxMaxVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addFloat32(e[n]);
      return t.endVector();
    }),
    (Om.EntData_Reference.startBndBoxMaxVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Om.EntData_Reference.addGroupID = function (t, e) {
      t.addFieldInt32(3, e, 0);
    }),
    (Om.EntData_Reference.addMatrix = function (t, e) {
      t.addFieldOffset(4, e, 0);
    }),
    (Om.EntData_Reference.createMatrixVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addFloat32(e[n]);
      return t.endVector();
    }),
    (Om.EntData_Reference.startMatrixVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Om.EntData_Reference.endEntData_Reference = function (t) {
      return t.endObject();
    }),
    (Om.EntData_Mesh = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (Om.EntData_Mesh.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (Om.EntData_Mesh.getRootAsEntData_Mesh = function (t, e) {
      return (e || new Om.EntData_Mesh()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (Om.EntData_Mesh.prototype.uuid = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Om.EntData_Mesh.prototype.bndBoxMin = function (t) {
      var e = this.bb.__offset(this.bb_pos, 6);
      return e
        ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (Om.EntData_Mesh.prototype.bndBoxMinLength = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Om.EntData_Mesh.prototype.bndBoxMinArray = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t
        ? new Float32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (Om.EntData_Mesh.prototype.bndBoxMax = function (t) {
      var e = this.bb.__offset(this.bb_pos, 8);
      return e
        ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (Om.EntData_Mesh.prototype.bndBoxMaxLength = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Om.EntData_Mesh.prototype.bndBoxMaxArray = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t
        ? new Float32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (Om.EntData_Mesh.prototype.meshID = function () {
      var t = this.bb.__offset(this.bb_pos, 10);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Om.EntData_Mesh.prototype.columnOffset = function () {
      var t = this.bb.__offset(this.bb_pos, 12);
      return t ? this.bb.readUint16(this.bb_pos + t) : 0;
    }),
    (Om.EntData_Mesh.prototype.columnCount = function () {
      var t = this.bb.__offset(this.bb_pos, 14);
      return t ? this.bb.readUint16(this.bb_pos + t) : 0;
    }),
    (Om.EntData_Mesh.prototype.rowOffset = function () {
      var t = this.bb.__offset(this.bb_pos, 16);
      return t ? this.bb.readUint16(this.bb_pos + t) : 0;
    }),
    (Om.EntData_Mesh.prototype.rowCount = function () {
      var t = this.bb.__offset(this.bb_pos, 18);
      return t ? this.bb.readUint16(this.bb_pos + t) : 0;
    }),
    (Om.EntData_Mesh.prototype.vertexColPos = function (t) {
      var e = this.bb.__offset(this.bb_pos, 20);
      return e
        ? this.bb.readUint16(this.bb.__vector(this.bb_pos + e) + 2 * t)
        : 0;
    }),
    (Om.EntData_Mesh.prototype.vertexColPosLength = function () {
      var t = this.bb.__offset(this.bb_pos, 20);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Om.EntData_Mesh.prototype.vertexColPosArray = function () {
      var t = this.bb.__offset(this.bb_pos, 20);
      return t
        ? new Uint16Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (Om.EntData_Mesh.prototype.vertexRowPos = function (t) {
      var e = this.bb.__offset(this.bb_pos, 22);
      return e
        ? this.bb.readUint16(this.bb.__vector(this.bb_pos + e) + 2 * t)
        : 0;
    }),
    (Om.EntData_Mesh.prototype.vertexRowPosLength = function () {
      var t = this.bb.__offset(this.bb_pos, 22);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Om.EntData_Mesh.prototype.vertexRowPosArray = function () {
      var t = this.bb.__offset(this.bb_pos, 22);
      return t
        ? new Uint16Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (Om.EntData_Mesh.prototype.vertexHeight = function (t) {
      var e = this.bb.__offset(this.bb_pos, 24);
      return e
        ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (Om.EntData_Mesh.prototype.vertexHeightLength = function () {
      var t = this.bb.__offset(this.bb_pos, 24);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Om.EntData_Mesh.prototype.vertexHeightArray = function () {
      var t = this.bb.__offset(this.bb_pos, 24);
      return t
        ? new Float32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (Om.EntData_Mesh.startEntData_Mesh = function (t) {
      t.startObject(11);
    }),
    (Om.EntData_Mesh.addUuid = function (t, e) {
      t.addFieldInt32(0, e, 0);
    }),
    (Om.EntData_Mesh.addBndBoxMin = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (Om.EntData_Mesh.createBndBoxMinVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addFloat32(e[n]);
      return t.endVector();
    }),
    (Om.EntData_Mesh.startBndBoxMinVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Om.EntData_Mesh.addBndBoxMax = function (t, e) {
      t.addFieldOffset(2, e, 0);
    }),
    (Om.EntData_Mesh.createBndBoxMaxVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addFloat32(e[n]);
      return t.endVector();
    }),
    (Om.EntData_Mesh.startBndBoxMaxVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Om.EntData_Mesh.addMeshID = function (t, e) {
      t.addFieldInt32(3, e, 0);
    }),
    (Om.EntData_Mesh.addColumnOffset = function (t, e) {
      t.addFieldInt16(4, e, 0);
    }),
    (Om.EntData_Mesh.addColumnCount = function (t, e) {
      t.addFieldInt16(5, e, 0);
    }),
    (Om.EntData_Mesh.addRowOffset = function (t, e) {
      t.addFieldInt16(6, e, 0);
    }),
    (Om.EntData_Mesh.addRowCount = function (t, e) {
      t.addFieldInt16(7, e, 0);
    }),
    (Om.EntData_Mesh.addVertexColPos = function (t, e) {
      t.addFieldOffset(8, e, 0);
    }),
    (Om.EntData_Mesh.createVertexColPosVector = function (t, e) {
      t.startVector(2, e.length, 2);
      for (var n = e.length - 1; n >= 0; n--) t.addInt16(e[n]);
      return t.endVector();
    }),
    (Om.EntData_Mesh.startVertexColPosVector = function (t, e) {
      t.startVector(2, e, 2);
    }),
    (Om.EntData_Mesh.addVertexRowPos = function (t, e) {
      t.addFieldOffset(9, e, 0);
    }),
    (Om.EntData_Mesh.createVertexRowPosVector = function (t, e) {
      t.startVector(2, e.length, 2);
      for (var n = e.length - 1; n >= 0; n--) t.addInt16(e[n]);
      return t.endVector();
    }),
    (Om.EntData_Mesh.startVertexRowPosVector = function (t, e) {
      t.startVector(2, e, 2);
    }),
    (Om.EntData_Mesh.addVertexHeight = function (t, e) {
      t.addFieldOffset(10, e, 0);
    }),
    (Om.EntData_Mesh.createVertexHeightVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addFloat32(e[n]);
      return t.endVector();
    }),
    (Om.EntData_Mesh.startVertexHeightVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Om.EntData_Mesh.endEntData_Mesh = function (t) {
      return t.endObject();
    }),
    (Om.FileData_MeshInfo = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (Om.FileData_MeshInfo.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (Om.FileData_MeshInfo.getRootAsFileData_MeshInfo = function (t, e) {
      return (e || new Om.FileData_MeshInfo()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (Om.FileData_MeshInfo.prototype.id = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Om.FileData_MeshInfo.prototype.meshGeoArray = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 6);
      return n
        ? (e || new Om.GeoData_Mesh()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (Om.FileData_MeshInfo.prototype.meshGeoArrayLength = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Om.FileData_MeshInfo.prototype.meshEntArr = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 8);
      return n
        ? (e || new Om.EntData_Mesh()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (Om.FileData_MeshInfo.prototype.meshEntArrLength = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Om.FileData_MeshInfo.prototype.entInfoArray = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 10);
      return n
        ? (e || new Om.EntInfo()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (Om.FileData_MeshInfo.prototype.entInfoArrayLength = function () {
      var t = this.bb.__offset(this.bb_pos, 10);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Om.FileData_MeshInfo.startFileData_MeshInfo = function (t) {
      t.startObject(4);
    }),
    (Om.FileData_MeshInfo.addId = function (t, e) {
      t.addFieldInt32(0, e, 0);
    }),
    (Om.FileData_MeshInfo.addMeshGeoArray = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (Om.FileData_MeshInfo.createMeshGeoArrayVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (Om.FileData_MeshInfo.startMeshGeoArrayVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Om.FileData_MeshInfo.addMeshEntArr = function (t, e) {
      t.addFieldOffset(2, e, 0);
    }),
    (Om.FileData_MeshInfo.createMeshEntArrVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (Om.FileData_MeshInfo.startMeshEntArrVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Om.FileData_MeshInfo.addEntInfoArray = function (t, e) {
      t.addFieldOffset(3, e, 0);
    }),
    (Om.FileData_MeshInfo.createEntInfoArrayVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (Om.FileData_MeshInfo.startEntInfoArrayVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Om.FileData_MeshInfo.endFileData_MeshInfo = function (t) {
      return t.endObject();
    }),
    (Om.EntInfo = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (Om.EntInfo.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (Om.EntInfo.getRootAsEntInfo = function (t, e) {
      return (e || new Om.EntInfo()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (Om.EntInfo.prototype.id = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Om.EntInfo.prototype.flootID = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Om.EntInfo.prototype.comtype = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Om.EntInfo.prototype.comID = function () {
      var t = this.bb.__offset(this.bb_pos, 10);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Om.EntInfo.prototype.handle = function (t) {
      var e = this.bb.__offset(this.bb_pos, 12);
      return e ? this.bb.__string(this.bb_pos + e, t) : null;
    }),
    (Om.EntInfo.prototype.selectAbility = function () {
      var t = this.bb.__offset(this.bb_pos, 14);
      return !!t && !!this.bb.readInt8(this.bb_pos + t);
    }),
    (Om.EntInfo.prototype.stageArray = function (t) {
      var e = this.bb.__offset(this.bb_pos, 16);
      return e
        ? this.bb.readInt32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (Om.EntInfo.prototype.stageArrayLength = function () {
      var t = this.bb.__offset(this.bb_pos, 16);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Om.EntInfo.prototype.stageArrayArray = function () {
      var t = this.bb.__offset(this.bb_pos, 16);
      return t
        ? new Int32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (Om.EntInfo.prototype.entDataArray = function (t) {
      var e = this.bb.__offset(this.bb_pos, 18);
      return e
        ? this.bb.readInt32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (Om.EntInfo.prototype.entDataArrayLength = function () {
      var t = this.bb.__offset(this.bb_pos, 18);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Om.EntInfo.prototype.entDataArrayArray = function () {
      var t = this.bb.__offset(this.bb_pos, 18);
      return t
        ? new Int32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (Om.EntInfo.startEntInfo = function (t) {
      t.startObject(8);
    }),
    (Om.EntInfo.addId = function (t, e) {
      t.addFieldInt32(0, e, 0);
    }),
    (Om.EntInfo.addFlootID = function (t, e) {
      t.addFieldInt32(1, e, 0);
    }),
    (Om.EntInfo.addComtype = function (t, e) {
      t.addFieldInt32(2, e, 0);
    }),
    (Om.EntInfo.addComID = function (t, e) {
      t.addFieldInt32(3, e, 0);
    }),
    (Om.EntInfo.addHandle = function (t, e) {
      t.addFieldOffset(4, e, 0);
    }),
    (Om.EntInfo.addSelectAbility = function (t, e) {
      t.addFieldInt8(5, +e, 0);
    }),
    (Om.EntInfo.addStageArray = function (t, e) {
      t.addFieldOffset(6, e, 0);
    }),
    (Om.EntInfo.createStageArrayVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addInt32(e[n]);
      return t.endVector();
    }),
    (Om.EntInfo.startStageArrayVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Om.EntInfo.addEntDataArray = function (t, e) {
      t.addFieldOffset(7, e, 0);
    }),
    (Om.EntInfo.createEntDataArrayVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addInt32(e[n]);
      return t.endVector();
    }),
    (Om.EntInfo.startEntDataArrayVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Om.EntInfo.endEntInfo = function (t) {
      return t.endObject();
    }),
    (Om.FileData_EntInfo = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (Om.FileData_EntInfo.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (Om.FileData_EntInfo.getRootAsFileData_EntInfo = function (t, e) {
      return (e || new Om.FileData_EntInfo()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (Om.FileData_EntInfo.prototype.id = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Om.FileData_EntInfo.prototype.lineArray = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 6);
      return n
        ? (e || new Om.GeoData_Line()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (Om.FileData_EntInfo.prototype.lineArrayLength = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Om.FileData_EntInfo.prototype.faceArray = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 8);
      return n
        ? (e || new Om.GeoData_Face()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (Om.FileData_EntInfo.prototype.faceArrayLength = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Om.FileData_EntInfo.prototype.entTriangleArray = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 10);
      return n
        ? (e || new Om.EntData_Triangle()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (Om.FileData_EntInfo.prototype.entTriangleArrayLength = function () {
      var t = this.bb.__offset(this.bb_pos, 10);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Om.FileData_EntInfo.prototype.entReferenceArray = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 12);
      return n
        ? (e || new Om.EntData_Reference()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (Om.FileData_EntInfo.prototype.entReferenceArrayLength = function () {
      var t = this.bb.__offset(this.bb_pos, 12);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Om.FileData_EntInfo.prototype.entInfoArray = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 14);
      return n
        ? (e || new Om.EntInfo()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (Om.FileData_EntInfo.prototype.entInfoArrayLength = function () {
      var t = this.bb.__offset(this.bb_pos, 14);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Om.FileData_EntInfo.prototype.level = function (t) {
      var e = this.bb.__offset(this.bb_pos, 16);
      return e
        ? this.bb.readInt32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (Om.FileData_EntInfo.prototype.levelLength = function () {
      var t = this.bb.__offset(this.bb_pos, 16);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Om.FileData_EntInfo.prototype.levelArray = function () {
      var t = this.bb.__offset(this.bb_pos, 16);
      return t
        ? new Int32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (Om.FileData_EntInfo.startFileData_EntInfo = function (t) {
      t.startObject(7);
    }),
    (Om.FileData_EntInfo.addId = function (t, e) {
      t.addFieldInt32(0, e, 0);
    }),
    (Om.FileData_EntInfo.addLineArray = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (Om.FileData_EntInfo.createLineArrayVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (Om.FileData_EntInfo.startLineArrayVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Om.FileData_EntInfo.addFaceArray = function (t, e) {
      t.addFieldOffset(2, e, 0);
    }),
    (Om.FileData_EntInfo.createFaceArrayVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (Om.FileData_EntInfo.startFaceArrayVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Om.FileData_EntInfo.addEntTriangleArray = function (t, e) {
      t.addFieldOffset(3, e, 0);
    }),
    (Om.FileData_EntInfo.createEntTriangleArrayVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (Om.FileData_EntInfo.startEntTriangleArrayVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Om.FileData_EntInfo.addEntReferenceArray = function (t, e) {
      t.addFieldOffset(4, e, 0);
    }),
    (Om.FileData_EntInfo.createEntReferenceArrayVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (Om.FileData_EntInfo.startEntReferenceArrayVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Om.FileData_EntInfo.addEntInfoArray = function (t, e) {
      t.addFieldOffset(5, e, 0);
    }),
    (Om.FileData_EntInfo.createEntInfoArrayVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (Om.FileData_EntInfo.startEntInfoArrayVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Om.FileData_EntInfo.addLevel = function (t, e) {
      t.addFieldOffset(6, e, 0);
    }),
    (Om.FileData_EntInfo.createLevelVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addInt32(e[n]);
      return t.endVector();
    }),
    (Om.FileData_EntInfo.startLevelVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Om.FileData_EntInfo.endFileData_EntInfo = function (t) {
      return t.endObject();
    }),
    (Om.FileIndex = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (Om.FileIndex.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (Om.FileIndex.getRootAsFileIndex = function (t, e) {
      return (e || new Om.FileIndex()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (Om.FileIndex.prototype.id = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Om.FileIndex.prototype.url = function (t) {
      var e = this.bb.__offset(this.bb_pos, 6);
      return e ? this.bb.__string(this.bb_pos + e, t) : null;
    }),
    (Om.FileIndex.prototype.fileSize = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Om.FileIndex.startFileIndex = function (t) {
      t.startObject(3);
    }),
    (Om.FileIndex.addId = function (t, e) {
      t.addFieldInt32(0, e, 0);
    }),
    (Om.FileIndex.addUrl = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (Om.FileIndex.addFileSize = function (t, e) {
      t.addFieldInt32(2, e, 0);
    }),
    (Om.FileIndex.endFileIndex = function (t) {
      return t.endObject();
    }),
    (Om.ViewInfo = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (Om.ViewInfo.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (Om.ViewInfo.getRootAsViewInfo = function (t, e) {
      return (e || new Om.ViewInfo()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (Om.ViewInfo.prototype.mPosition = function (t) {
      var e = this.bb.__offset(this.bb_pos, 4);
      return e
        ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (Om.ViewInfo.prototype.mPositionLength = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Om.ViewInfo.prototype.mPositionArray = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t
        ? new Float32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (Om.ViewInfo.prototype.mTarget = function (t) {
      var e = this.bb.__offset(this.bb_pos, 6);
      return e
        ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (Om.ViewInfo.prototype.mTargetLength = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Om.ViewInfo.prototype.mTargetArray = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t
        ? new Float32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (Om.ViewInfo.prototype.mUp = function (t) {
      var e = this.bb.__offset(this.bb_pos, 8);
      return e
        ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (Om.ViewInfo.prototype.mUpLength = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Om.ViewInfo.prototype.mUpArray = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t
        ? new Float32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (Om.ViewInfo.startViewInfo = function (t) {
      t.startObject(3);
    }),
    (Om.ViewInfo.addMPosition = function (t, e) {
      t.addFieldOffset(0, e, 0);
    }),
    (Om.ViewInfo.createMPositionVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addFloat32(e[n]);
      return t.endVector();
    }),
    (Om.ViewInfo.startMPositionVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Om.ViewInfo.addMTarget = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (Om.ViewInfo.createMTargetVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addFloat32(e[n]);
      return t.endVector();
    }),
    (Om.ViewInfo.startMTargetVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Om.ViewInfo.addMUp = function (t, e) {
      t.addFieldOffset(2, e, 0);
    }),
    (Om.ViewInfo.createMUpVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addFloat32(e[n]);
      return t.endVector();
    }),
    (Om.ViewInfo.startMUpVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Om.ViewInfo.endViewInfo = function (t) {
      return t.endObject();
    }),
    (Om.KDNode = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (Om.KDNode.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (Om.KDNode.getRootAsKDNode = function (t, e) {
      return (e || new Om.KDNode()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (Om.KDNode.prototype.bndBoxMin = function (t) {
      var e = this.bb.__offset(this.bb_pos, 4);
      return e
        ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (Om.KDNode.prototype.bndBoxMinLength = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Om.KDNode.prototype.bndBoxMinArray = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t
        ? new Float32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (Om.KDNode.prototype.bndBoxMax = function (t) {
      var e = this.bb.__offset(this.bb_pos, 6);
      return e
        ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (Om.KDNode.prototype.bndBoxMaxLength = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Om.KDNode.prototype.bndBoxMaxArray = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t
        ? new Float32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (Om.KDNode.prototype.fileID = function (t) {
      var e = this.bb.__offset(this.bb_pos, 8);
      return e
        ? this.bb.readInt32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (Om.KDNode.prototype.fileIDLength = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Om.KDNode.prototype.fileIDArray = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t
        ? new Int32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (Om.KDNode.prototype.url = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 10);
      return n
        ? this.bb.__string(this.bb.__vector(this.bb_pos + n) + 4 * t, e)
        : null;
    }),
    (Om.KDNode.prototype.urlLength = function () {
      var t = this.bb.__offset(this.bb_pos, 10);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Om.KDNode.prototype.firstChildNode = function (t) {
      var e = this.bb.__offset(this.bb_pos, 12);
      return e
        ? (t || new Om.KDNode()).__init(
            this.bb.__indirect(this.bb_pos + e),
            this.bb,
          )
        : null;
    }),
    (Om.KDNode.prototype.secondChildNode = function (t) {
      var e = this.bb.__offset(this.bb_pos, 14);
      return e
        ? (t || new Om.KDNode()).__init(
            this.bb.__indirect(this.bb_pos + e),
            this.bb,
          )
        : null;
    }),
    (Om.KDNode.startKDNode = function (t) {
      t.startObject(6);
    }),
    (Om.KDNode.addBndBoxMin = function (t, e) {
      t.addFieldOffset(0, e, 0);
    }),
    (Om.KDNode.createBndBoxMinVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addFloat32(e[n]);
      return t.endVector();
    }),
    (Om.KDNode.startBndBoxMinVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Om.KDNode.addBndBoxMax = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (Om.KDNode.createBndBoxMaxVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addFloat32(e[n]);
      return t.endVector();
    }),
    (Om.KDNode.startBndBoxMaxVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Om.KDNode.addFileID = function (t, e) {
      t.addFieldOffset(2, e, 0);
    }),
    (Om.KDNode.createFileIDVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addInt32(e[n]);
      return t.endVector();
    }),
    (Om.KDNode.startFileIDVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Om.KDNode.addUrl = function (t, e) {
      t.addFieldOffset(3, e, 0);
    }),
    (Om.KDNode.createUrlVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (Om.KDNode.startUrlVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Om.KDNode.addFirstChildNode = function (t, e) {
      t.addFieldOffset(4, e, 0);
    }),
    (Om.KDNode.addSecondChildNode = function (t, e) {
      t.addFieldOffset(5, e, 0);
    }),
    (Om.KDNode.endKDNode = function (t) {
      return t.endObject();
    }),
    (Om.FloorInfo = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (Om.FloorInfo.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (Om.FloorInfo.getRootAsFloorInfo = function (t, e) {
      return (e || new Om.FloorInfo()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (Om.FloorInfo.prototype.floorid = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Om.FloorInfo.prototype.floorName = function (t) {
      var e = this.bb.__offset(this.bb_pos, 6);
      return e ? this.bb.__string(this.bb_pos + e, t) : null;
    }),
    (Om.FloorInfo.startFloorInfo = function (t) {
      t.startObject(2);
    }),
    (Om.FloorInfo.addFloorid = function (t, e) {
      t.addFieldInt32(0, e, 0);
    }),
    (Om.FloorInfo.addFloorName = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (Om.FloorInfo.endFloorInfo = function (t) {
      return t.endObject();
    }),
    (Om.SceneTree = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (Om.SceneTree.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (Om.SceneTree.getRootAsSceneTree = function (t, e) {
      return (e || new Om.SceneTree()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (Om.SceneTree.prototype.id = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Om.SceneTree.prototype.root = function (t) {
      var e = this.bb.__offset(this.bb_pos, 6);
      return e
        ? (t || new Om.KDNode()).__init(
            this.bb.__indirect(this.bb_pos + e),
            this.bb,
          )
        : null;
    }),
    (Om.SceneTree.prototype.projectName = function (t) {
      var e = this.bb.__offset(this.bb_pos, 8);
      return e ? this.bb.__string(this.bb_pos + e, t) : null;
    }),
    (Om.SceneTree.prototype.ProjectViewInfo = function (t) {
      var e = this.bb.__offset(this.bb_pos, 10);
      return e
        ? (t || new Om.ViewInfo()).__init(
            this.bb.__indirect(this.bb_pos + e),
            this.bb,
          )
        : null;
    }),
    (Om.SceneTree.prototype.bndBoxMin = function (t) {
      var e = this.bb.__offset(this.bb_pos, 12);
      return e
        ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (Om.SceneTree.prototype.bndBoxMinLength = function () {
      var t = this.bb.__offset(this.bb_pos, 12);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Om.SceneTree.prototype.bndBoxMinArray = function () {
      var t = this.bb.__offset(this.bb_pos, 12);
      return t
        ? new Float32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (Om.SceneTree.prototype.bndBoxMax = function (t) {
      var e = this.bb.__offset(this.bb_pos, 14);
      return e
        ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (Om.SceneTree.prototype.bndBoxMaxLength = function () {
      var t = this.bb.__offset(this.bb_pos, 14);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Om.SceneTree.prototype.bndBoxMaxArray = function () {
      var t = this.bb.__offset(this.bb_pos, 14);
      return t
        ? new Float32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (Om.SceneTree.prototype.scale = function () {
      var t = this.bb.__offset(this.bb_pos, 16);
      return t ? this.bb.readFloat32(this.bb_pos + t) : 0;
    }),
    (Om.SceneTree.prototype.floorList = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 18);
      return n
        ? (e || new Om.FloorInfo()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (Om.SceneTree.prototype.floorListLength = function () {
      var t = this.bb.__offset(this.bb_pos, 18);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Om.SceneTree.startSceneTree = function (t) {
      t.startObject(8);
    }),
    (Om.SceneTree.addId = function (t, e) {
      t.addFieldInt32(0, e, 0);
    }),
    (Om.SceneTree.addRoot = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (Om.SceneTree.addProjectName = function (t, e) {
      t.addFieldOffset(2, e, 0);
    }),
    (Om.SceneTree.addProjectViewInfo = function (t, e) {
      t.addFieldOffset(3, e, 0);
    }),
    (Om.SceneTree.addBndBoxMin = function (t, e) {
      t.addFieldOffset(4, e, 0);
    }),
    (Om.SceneTree.createBndBoxMinVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addFloat32(e[n]);
      return t.endVector();
    }),
    (Om.SceneTree.startBndBoxMinVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Om.SceneTree.addBndBoxMax = function (t, e) {
      t.addFieldOffset(5, e, 0);
    }),
    (Om.SceneTree.createBndBoxMaxVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addFloat32(e[n]);
      return t.endVector();
    }),
    (Om.SceneTree.startBndBoxMaxVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Om.SceneTree.addScale = function (t, e) {
      t.addFieldFloat32(6, e, 0);
    }),
    (Om.SceneTree.addFloorList = function (t, e) {
      t.addFieldOffset(7, e, 0);
    }),
    (Om.SceneTree.createFloorListVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (Om.SceneTree.startFloorListVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Om.SceneTree.endSceneTree = function (t) {
      return t.endObject();
    }),
    (Om.Head = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (Om.Head.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (Om.Head.getRootAsHead = function (t, e) {
      return (e || new Om.Head()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (Om.Head.prototype.materialFileList = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 4);
      return n
        ? (e || new Om.FileIndex()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (Om.Head.prototype.materialFileListLength = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Om.Head.prototype.refSourceFileList = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 6);
      return n
        ? (e || new Om.FileIndex()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (Om.Head.prototype.refSourceFileListLength = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Om.Head.prototype.entFileList = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 8);
      return n
        ? (e || new Om.FileIndex()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (Om.Head.prototype.entFileListLength = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Om.Head.prototype.componentsFileList = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 10);
      return n
        ? (e || new Om.FileIndex()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (Om.Head.prototype.componentsFileListLength = function () {
      var t = this.bb.__offset(this.bb_pos, 10);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Om.Head.prototype.meshFileList = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 12);
      return n
        ? (e || new Om.FileIndex()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (Om.Head.prototype.meshFileListLength = function () {
      var t = this.bb.__offset(this.bb_pos, 12);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Om.Head.prototype.sceneTree = function (t) {
      var e = this.bb.__offset(this.bb_pos, 14);
      return e
        ? (t || new Om.SceneTree()).__init(
            this.bb.__indirect(this.bb_pos + e),
            this.bb,
          )
        : null;
    }),
    (Om.Head.startHead = function (t) {
      t.startObject(6);
    }),
    (Om.Head.addMaterialFileList = function (t, e) {
      t.addFieldOffset(0, e, 0);
    }),
    (Om.Head.createMaterialFileListVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (Om.Head.startMaterialFileListVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Om.Head.addRefSourceFileList = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (Om.Head.createRefSourceFileListVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (Om.Head.startRefSourceFileListVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Om.Head.addEntFileList = function (t, e) {
      t.addFieldOffset(2, e, 0);
    }),
    (Om.Head.createEntFileListVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (Om.Head.startEntFileListVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Om.Head.addComponentsFileList = function (t, e) {
      t.addFieldOffset(3, e, 0);
    }),
    (Om.Head.createComponentsFileListVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (Om.Head.startComponentsFileListVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Om.Head.addMeshFileList = function (t, e) {
      t.addFieldOffset(4, e, 0);
    }),
    (Om.Head.createMeshFileListVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (Om.Head.startMeshFileListVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Om.Head.addSceneTree = function (t, e) {
      t.addFieldOffset(5, e, 0);
    }),
    (Om.Head.endHead = function (t) {
      return t.endObject();
    }),
    (Om.Head.finishHeadBuffer = function (t, e) {
      t.finish(e);
    }),
    (Vm.prototype = {
      constructor: Vm,
      isPMRenderBuffer: !0,
      setUUID: function (t) {
        this.id = t;
      },
      getUUID: function () {
        return this.id;
      },
      addVertexBufferAttribute: function (t, e) {
        e &&
          (this.vertexAttributeArray || (this.vertexAttributeArray = new Sm()),
          this.vertexAttributeArray.addBufferAttribute(t, e),
          'position' === t && this.updateVertexBoundingSphere());
      },
      getVertexBufferAttribute: function (t) {
        if (this.vertexAttributeArray)
          return this.vertexAttributeArray.getBufferAttribute(t);
      },
      removeVertexBufferAttribute: function (t) {
        if (!this.vertexAttributeArray) return;
        let e = this.vertexAttributeArray.vertexAttributes.findIndex(
          (e) => e.getName() === t,
        );
        e >= 0 && this.vertexAttributeArray.vertexAttributes.splice(e, 1);
      },
      setVertexAttributeArray: function (t) {
        this.vertexAttributeArray !== t &&
          ((this.vertexAttributeArray = t), this.updateVertexBoundingSphere());
      },
      getVertexAttributeArray: function () {
        return this.vertexAttributeArray;
      },
      setVertexIndex: function (t) {
        this.vertexIndex = t;
      },
      getVertexIndex: function () {
        return this.vertexIndex;
      },
      getIndexMode: function () {
        return this.vertexIndex ? this.vertexIndex.getDrawMode() : Hf.UNKNOWN;
      },
      updateVertexBoundingSphere: function () {
        if (!this.vertexAttributeArray) return;
        let t = this.vertexAttributeArray.getBufferAttribute('position');
        if (!t) return;
        let e = t.array,
          n = new J(),
          i = new Nt();
        for (let t = 0, r = e.length; t < r; t += 3)
          n.set(e[t], e[t + 1], e[t + 2]), i.expandByPoint(n);
        i.getCenter(this.vertexBoundingSphere.center);
        let r = 0,
          o = this.vertexBoundingSphere.center;
        for (let t = 0, i = e.length; t < i; t += 3)
          n.set(e[t], e[t + 1], e[t + 2]),
            (r = Math.max(r, o.distanceToSquared(n)));
        this.vertexBoundingSphere.radius = Math.sqrt(r);
      },
      getVertexBoundingSphere: function () {
        return this.vertexBoundingSphere;
      },
      sortVertexIndex: (function () {
        let t = new J(),
          e = new J(),
          n = new J(),
          i = new J(),
          r = new J(),
          o = new J();
        function s(t, e) {
          return e.t - t.t;
        }
        function a(s, a, c, l) {
          let h = 3 * a,
            u = 3 * c,
            d = 3 * l;
          return (
            t.set(s[h], s[h + 1], s[h + 2]),
            e.set(s[u], s[u + 1], s[u + 2]),
            n.set(s[d], s[d + 1], s[d + 2]),
            i.subVectors(e, t),
            r.subVectors(n, t),
            o.crossVectors(i, r),
            { t: o.lengthSq(), v1: a, v2: c, v3: l }
          );
        }
        return function () {
          if (!this.vertexAttributeArray || !this.vertexIndex) return;
          let t =
              this.vertexAttributeArray.getBufferAttribute('position').array,
            e = this.vertexIndex.getBufferAttribute().array;
          switch (this.vertexIndex.getDrawMode()) {
            case Hf.TRIANGLES:
              !(function (t, e) {
                let n = [];
                for (let i = 0, r = e.length; i < r; i += 3)
                  n.push(a(t, e[i], e[i + 1], e[i + 2]));
                n.sort(s);
                for (let t = 0, i = n.length; t < i; t++) {
                  let i = n[t];
                  (e[3 * t] = i.v1),
                    (e[3 * t + 1] = i.v2),
                    (e[3 * t + 2] = i.v3);
                }
              })(t, e);
          }
        };
      })(),
      setMaterial: function (t) {
        this.material = t;
      },
      getMaterial: function () {
        return this.material;
      },
      update: function (t) {
        return (
          !(!this.vertexAttributeArray || !this.vertexIndex) &&
          (this.vertexAttributeArray.update(t), this.vertexIndex.update(t), !0)
        );
      },
      release: function (t) {
        this.vertexAttributeArray &&
          (this.vertexAttributeArray.release(t),
          (this.vertexAttributeArray = null)),
          this.vertexIndex &&
            (this.vertexIndex.release(t), (this.vertexIndex = null));
      },
    }),
    (Nm.prototype = Object.assign(Object.create(Vm.prototype), {
      constructor: Nm,
      isPMInstanceRenderBuffer: !0,
      addInstanceVertexBufferAttribute: function (t, e) {
        e &&
          (this.instanceVertexAttributeArray ||
            (this.instanceVertexAttributeArray = new Sm()),
          this.instanceVertexAttributeArray.addBufferAttribute(t, e));
      },
      getInstanceVertexBufferAttribute: function (t) {
        if (this.instanceVertexAttributeArray)
          return this.instanceVertexAttributeArray.getBufferAttribute(t);
      },
      getInstanceVertexAttributeArray: function () {
        return this.instanceVertexAttributeArray;
      },
      updateInstanceBoundingSphere: (function () {
        let t = new ot();
        return function () {
          this.instanceBoundingSphereArray = [];
          let e = this.instanceVertexAttributeArray.getBufferAttribute(
              _m.name,
            ).array,
            n = this.instanceVertexAttributeArray.getBufferAttribute(
              xm.name,
            ).array,
            i = this.instanceVertexAttributeArray.getBufferAttribute(
              wm.name,
            ).array,
            r = this.instanceVertexAttributeArray.getBufferAttribute(
              Am.name,
            ).array,
            o = this.instanceVertexAttributeArray.getBufferAttribute(
              _m.name,
            ).count;
          for (let s = 0; s < o; s++) {
            Xf.getInstanceMatrixByArray(e, n, i, r, s, t);
            let o = new Gt();
            this.instanceBoundingSphereArray.push(
              o.copy(this.getVertexBoundingSphere()).applyMatrix4(t),
            );
          }
        };
      })(),
      getInstanceBoundingSphereArray: function () {
        return this.instanceBoundingSphereArray;
      },
      release: function (t) {
        this.instanceVertexAttributeArray &&
          (this.instanceVertexAttributeArray.release(t),
          (this.instanceVertexAttributeArray = null));
      },
    })),
    (km.prototype = {
      constructor: km,
      setContentSize: function (t) {
        this.contentSize = t;
      },
      getContentSize: function () {
        return this.contentSize;
      },
      addBufferGeometryFile: function (t) {
        this.bufferGeometryFileList.push(t);
      },
      getBufferGeometryFileList: function () {
        return this.bufferGeometryFileList;
      },
      addEntDataFileList: function (t) {
        this.entDataFileList.push(t);
      },
      getEntDataFileList: function () {
        return this.entDataFileList;
      },
      setUsage: function (t) {
        this.usage = t;
      },
      getUsage: function () {
        return this.usage;
      },
    }),
    (Um.prototype = {
      constructor: Um,
      isRefDefinitoin: !0,
      setUUID: function (t) {
        this.uuid = t;
      },
      getUUID: function () {
        return this.uuid;
      },
      addRefObject: function (t) {
        this.refObjectArray.push(t);
      },
      getRefObjectArray: function () {
        return this.refObjectArray;
      },
      getBndBox: function () {
        return this.bndBox;
      },
    }),
    (Gm.prototype = Object.assign(Object.create(bm.prototype), {
      constructor: Gm,
      createHeadDataFile: function (t) {
        let e = new lm.ByteBuffer(new Uint8Array(t));
        return Om.Head.getRootAsHead(e);
      },
      getHeadFileVersion: function () {
        return -1;
      },
      getBasicFileTotal: (t) =>
        t.materialFileListLength() +
        t.refSourceFileListLength() +
        t.componentsFileListLength() +
        1 +
        1,
      getMaterialDataFileIndexArray: function (t) {
        if (!t) return null;
        let e = [];
        for (let n = 0, i = t.materialFileListLength(); n < i; n++) {
          let i = this.createFileIndex(t.materialFileList(n));
          i && e.push(i);
        }
        return e;
      },
      getRefDefinitionDataFileIndexArray: function (t) {
        if (!t) return null;
        let e = [];
        for (let n = 0, i = t.refSourceFileListLength(); n < i; n++) {
          let i = this.createFileIndex(t.refSourceFileList(n));
          i && e.push(i);
        }
        return e;
      },
      createSceneTree: function (t, e) {
        t && e && (this.groupUserData(t, e), this.perOrderKDNode(t, e));
      },
      groupUserData: function (t, e) {
        let n = t.bndBoxMinArray(),
          i = t.bndBoxMaxArray(),
          r = new J(n[0], n[1], n[2]),
          o = new J(i[0], i[1], i[2]);
        e.setBndBox(new Nt(r, o));
        let s = this.createPageData(t);
        s && (s.setUsage(-1), e.setPageData(s));
      },
      perOrderKDNode: function (t, e) {
        if (null === t) return !1;
        if (t.firstChildNode()) {
          let n = new Pm(this);
          e.add(n),
            this.groupUserData(t.firstChildNode(), n),
            this.perOrderKDNode(t.firstChildNode(), n);
        }
        if (t.secondChildNode()) {
          let n = new Pm(this);
          e.add(n),
            this.groupUserData(t.secondChildNode(), n),
            this.perOrderKDNode(t.secondChildNode(), n);
        }
        return !0;
      },
      createPageData: function (t) {
        if (!t) return null;
        let e = new km();
        e.setContentSize(419430400);
        for (let n = 0, i = t.urlLength(); n < i; n++) {
          let i = this.createSceneFileIndex(t.url(n));
          i && e.addBufferGeometryFile(i);
        }
        return e;
      },
      createFileIndex: function (t) {
        if (!t) return null;
        let e = new gm();
        return (
          e.setID(t.id()), e.setURL(t.url()), e.setFileSize(t.fileSize()), e
        );
      },
      createSceneFileIndex: function (t) {
        if (!t) return null;
        let e = new gm();
        return e.setURL(t), e;
      },
      getSceneDataFile: function (t) {
        return new Promise((e, n) => {
          t ? e(t.sceneTree()) : n();
        });
      },
      getDefaultCamera: function (t) {
        let e = t.ProjectViewInfo();
        return {
          position: e.mPositionArray(),
          target: e.mTargetArray(),
          up: e.mUpArray(),
        };
      },
      getSceneTreeBndBox: function (t) {
        return { bndBoxMin: t.bndBoxMinArray(), bndBoxMax: t.bndBoxMaxArray() };
      },
      getRootNode: function (t) {
        return t.root();
      },
      getSceneScale: function (t) {
        return t.scale();
      },
      createMaterialMap: function (t, e, n) {
        let i = new lm.ByteBuffer(new Uint8Array(t)),
          r = Om.FileData_Material.getRootAsFileData_Material(i);
        for (let t = 0, i = r.materialArrayLength(); t < i; t++) {
          let i = r.materialArray(t),
            o = null;
          (o = new ea()),
            (o.smoothLighting = !0),
            (o.shininess = 1),
            i.enablePolygonOffset() &&
              o.setVertexOffset(i.polygonOffsetFactor() * this.sceneScale),
            (o.map = this.getImageData(i.image(), e)),
            (o.transparent = i.enableTransparent()),
            (o.opacity = i.transparency()),
            o.opacity > 0.999999 && !o.map && (o.transparent = !1),
            o.transparent && 1 === o.opacity && (o.blending = 1),
            o.map || (o.color = new fe(i.color())),
            (o.colorCopy = new fe(i.color())),
            (o.flatShading = !1),
            (o.depthFunc = void 0 === i.depthFunc() ? 2 : i.depthFunc()),
            (o.blending = 1),
            (o.polygonOffset = i.enablePolygonOffset()),
            (o.polygonOffsetUnits = i.polygonOffsetUnits() / 10),
            (o.polygonOffsetFactor = i.polygonOffsetFactor() / 10),
            this.isPhone
              ? (o.side = !0 === i.doubleSide() ? 2 : 0)
              : ((o.side = 2), (o.precision = 'highp')),
            n.set(i.uuid(), o);
        }
      },
      getImageData: function (t, e) {
        if (!t) return null;
        let n = e.get(t.uuid());
        if (n) return n;
        let i = `${this.fileLoader.getCloudURL()}IMG${t.url()}`;
        if (t.isUserImage()) {
          let e = this.fileLoader.getFileIndex(t.url());
          e && (i = e.getURL());
        }
        return (
          i.includes('.tga')
            ? (n = this.TGALoader.load(
                i,
                () => {
                  console.log('tga贴图加载成功');
                },
                void 0,
                () => {
                  console.log('tga贴图加载失败');
                },
              ))
            : ((n = this.textureLoader.load(
                i,
                () => {
                  console.log('贴图加载成功');
                },
                void 0,
                () => {
                  console.log('贴图加载失败');
                },
              )),
              (n.format = v)),
          (n.wrapS = this.textureWrapS),
          (n.wrapT = this.textureWrapT),
          (n.anisotropy = this.texturemaxAnisotropy),
          e.set(t.uuid(), n),
          n
        );
      },
      createRefDefinitionMap: function (t, e, n) {
        let i = new lm.ByteBuffer(new Uint8Array(t)),
          r = Om.FileData_RefSource.getRootAsFileData_RefSource(i),
          o = new Map();
        for (let t = 0, n = r.faceArrayLength(); t < n; t++) {
          let n = r.faceArray(t),
            i = this.addGeometry(n);
          i &&
            (i.setMaterial(e.get(n.material())),
            i.sortVertexIndex(),
            o.set(i.getUUID(), i));
        }
        for (let t = 0, e = r.groupArrayLength(); t < e; t++) {
          let e = r.groupArray(t),
            i = new Um();
          i.setUUID(e.uuid());
          for (let t = 0, n = e.geoDataArrayLength(); t < n; t++) {
            let n = o.get(e.geoDataArray(t));
            n && i.addRefObject(n);
          }
          i.getRefObjectArray().length > 0 && n.set(i.getUUID(), i);
        }
      },
      addGeometry(t) {
        let e = new Vm(),
          n = new Wf(Hf.TRIANGLES);
        n.setIndex(t.trianglesArray()),
          e.setVertexIndex(n),
          e.addVertexBufferAttribute('position', new Fe(t.vertexsArray(), 3)),
          e.addVertexBufferAttribute('normal', new Fe(t.normalsArray(), 3));
        let i = t.vertexParamsArray();
        return (
          i && i.length > 0 && e.addVertexBufferAttribute('uv', new Fe(i, 2)),
          e.setUUID(t.uuid()),
          e
        );
      },
      createBufferGeometryDataFile: function (t) {
        let e = new lm.ByteBuffer(new Uint8Array(t));
        return Om.FileData_EntInfo.getRootAsFileData_EntInfo(e);
      },
      createGeometryArray: function (t, e, n, i) {
        for (let n = 0, r = t.faceArrayLength(); n < r; n++) {
          let r = t.faceArray(n),
            o = this.addGeometry(r);
          if (!o) continue;
          let s = e.get(r.material());
          o.setMaterial(s || new xe({ color: 16711680 })), i.push(o);
        }
        let r = new Map();
        for (let e = 0, i = t.entReferenceArrayLength(); e < i; e++) {
          let i = t.entReferenceArray(e),
            o = n.get(i.groupID());
          if (!o) continue;
          let s = o.getRefObjectArray();
          for (let t = 0, e = s.length; t < e; t++) {
            let e = s[t],
              n = e.getUUID(),
              o = r.get(n);
            o ||
              ((o = new zm()),
              (o.refObject = e),
              (o.refInstanceID = n.toString() + i.uuid().toString()),
              r.set(n, o)),
              o.pushMatrix(i.matrixArray());
          }
        }
        for (let [t, e] of r) {
          let t = new Nm();
          t.setVertexAttributeArray(e.refObject.getVertexAttributeArray()),
            t.setVertexIndex(e.refObject.getVertexIndex()),
            t.setUUID(e.refInstanceID),
            t.setMaterial(e.refObject.getMaterial());
          let n = new _c(e.getInstanceMatR1(), 4, !1, 1);
          t.addInstanceVertexBufferAttribute(_m.name, n);
          let r = new _c(e.getInstanceMatR2(), 4, !1, 1);
          t.addInstanceVertexBufferAttribute(xm.name, r);
          let o = new _c(e.getInstanceMatR3(), 4, !1, 1);
          t.addInstanceVertexBufferAttribute(wm.name, o);
          let s = new _c(e.getInstanceMatR4(), 4, !1, 1);
          t.addInstanceVertexBufferAttribute(Am.name, s),
            t.updateInstanceBoundingSphere(),
            i.push(t);
        }
      },
      createEntInfoEntDataArray: function (t, e, n) {
        let i = new Map(),
          r = this.getModel().getModelTree();
        for (let e = 0, o = t.entInfoArrayLength(); e < o; e++) {
          let o = t.entInfoArray(e),
            s = n.get(o.id());
          s || ((s = new $f(o.id())), n.set(o.id(), s)),
            s.setEntInfo(
              o.id(),
              o.flootID(),
              o.comtype(),
              o.comID(),
              o.handle(),
            );
          for (let t = 0, e = o.stageArrayLength(); t < e; t++)
            s.addLayerID(o.stageArray(t));
          for (let t = 0, e = o.entDataArrayLength(); t < e; t++)
            i.set(o.entDataArray(t), s.getID());
          let a = r.getRootNode().findChildByTypeValue(nm, s.getFloorID());
          for (let t = 0, e = a.length; t < e; ++t) {
            let e = a[t].findChildByTypeValue(im, s.getComtype());
            if (e.length > 0) {
              e[0].insertEntity(s);
              break;
            }
          }
          s.getModelNode() ||
            console.warn(
              'Invalid model-node at floorid:' +
                s.getFloorID().toString() +
                ' comtype:' +
                s.getComtype().toString(),
            );
        }
        let o = new J(),
          s = new J();
        for (let e = 0, r = t.entTriangleArrayLength(); e < r; e++) {
          let r = t.entTriangleArray(e),
            a = i.get(r.uuid());
          if (!a) continue;
          let c = n.get(a);
          c &&
            (c.addGeoData(
              new Yf(
                r.faceID(),
                new vm(3 * r.trianglesOffset(), 3 * r.trianglesCount(), 0, 0),
              ),
            ),
            o.set(r.bndBoxMin(0), r.bndBoxMin(1), r.bndBoxMin(2)),
            s.set(r.bndBoxMax(0), r.bndBoxMax(1), r.bndBoxMax(2)),
            c.expandBoundingBoxByPoint(o),
            c.expandBoundingBoxByPoint(s));
        }
        let a = new Map(),
          c = new ot();
        for (let r = 0, l = t.entReferenceArrayLength(); r < l; r++) {
          let l = t.entReferenceArray(r),
            h = n.get(i.get(l.uuid()));
          if (!h) continue;
          let u = e.get(l.groupID());
          if (!u) continue;
          o.set(l.bndBoxMin(0), l.bndBoxMin(1), l.bndBoxMin(2)),
            s.set(l.bndBoxMax(0), l.bndBoxMax(1), l.bndBoxMax(2)),
            h.expandBoundingBoxByPoint(o),
            h.expandBoundingBoxByPoint(s);
          let d = l.matrixArray();
          c.set(
            d[0],
            d[4],
            d[8],
            d[12],
            d[1],
            d[5],
            d[9],
            d[13],
            d[2],
            d[6],
            d[10],
            d[14],
            d[3],
            d[7],
            d[11],
            d[15],
          );
          let p = u.getRefObjectArray();
          for (let t = 0, e = p.length; t < e; t++) {
            let e = p[t].getUUID(),
              n = a.get(e);
            n ||
              ((n = new zm()),
              (n.refInstanceID = e.toString() + l.uuid().toString()),
              a.set(e, n)),
              h.addGeoData(
                new Yf(n.refInstanceID, new vm(n.curMatrixIndex, 1, 0, 0)),
              ),
              n.curMatrixIndex++;
          }
        }
        i = null;
      },
      getProjectFileIndex: function (t) {
        if (!t) return null;
        let e = null;
        for (let n = 0, i = t.componentsFileListLength(); n < i; n++) {
          let i = this.createFileIndex(t.componentsFileList(n));
          if (i && 'Components.bin' === i.url) {
            e = i;
            break;
          }
        }
        return e ? this.fileLoader.getFileIndex(e.getURL()) : null;
      },
      createFloorAxisFileIndexArray: function (t, e) {
        if (!t) return null;
        for (let n = 0, i = t.componentsFileListLength(); n < i; n++) {
          let i = this.createFileIndex(t.componentsFileList(n));
          i && 'floorCrossLine.bin' === i.url && e.push(i);
        }
      },
      getTerrainFileIndexArray: function (t) {
        if (!t) return null;
        let e = [];
        for (let n = 0, i = t.meshFileListLength(); n < i; n++) {
          let i = this.createFileIndex(t.meshFileList(n));
          i && e.push(i);
        }
        return e;
      },
      addTerrainGeometry: function (t, e) {
        let n = new ym(t, e).getAttribute(),
          i = new Vm(),
          r = new Wf(Hf.TRIANGLES),
          o = new Uint32Array(n.index.length / 3);
        for (let t = 0, e = o.length; t < e; t++) o[t] = t;
        return (
          r.setIndex(o),
          i.setVertexIndex(r),
          i.addVertexBufferAttribute(
            'position',
            new Fe(new Uint32Array(n.position), 3),
          ),
          i.addVertexBufferAttribute('uv', new Fe(new Uint32Array(n.uv), 2)),
          i.setUUID(e.meshID),
          i
        );
      },
      addTerrainOtherGeometry: function (t) {
        let e = new Vm(),
          n = new Wf(Hf.TRIANGLES),
          i = new Uint32Array(t.triangles.length / 3);
        for (let t = 0, e = i.length; t < e; t++) i[t] = t;
        n.setIndex(i),
          e.setVertexIndex(n),
          e.addVertexBufferAttribute(
            'position',
            new Fe(new Uint32Array(t.vertexs), 3),
          ),
          e.addVertexBufferAttribute(
            'normal',
            new Fe(new Uint32Array(t.normals), 3),
          );
        let r = t.vertexParams;
        return (
          r &&
            r.length > 0 &&
            e.addVertexBufferAttribute('uv', new Fe(new Uint32Array(r), 2)),
          e.setUUID(t.uuid),
          e
        );
      },
      createTerrainDataFile: function (t) {
        this.gridMeshGeoMap.clear(),
          this.gridMeshEntMap.clear(),
          this.gridMeshInfoMap.clear();
        let e = new lm.ByteBuffer(new Uint8Array(t));
        return Om.FileData_MeshInfo.getRootAsFileData_MeshInfo(e);
      },
      setTerrainDataMap: function (t) {
        let e = [];
        for (let n = 0, i = t.meshGeoArrayLength(); n < i; n++) {
          let i = t.meshGeoArray(n),
            r = [];
          for (let t = 0, e = i.otherFaceLength(); t < e; t++) {
            let e = i.otherFace(t),
              n = {
                uuid: e.uuid(),
                vertexs: e.vertexsArray(),
                triangles: e.trianglesArray(),
                normals: e.normalsArray(),
                vertexParams: e.vertexParamsArray(),
                material: e.material(),
              };
            r.push(n);
          }
          let o = {
            uuid: i.uuid(),
            origin: i.originArray(),
            columnCount: i.columnCount(),
            rowCount: i.rowCount(),
            gridSize: i.gridSize(),
            material: i.material(),
            otherFace: r,
          };
          e.push(o);
        }
        for (let t = 0; t < e.length; t++)
          this.gridMeshGeoMap.set(e[t].uuid, e[t]);
        let n = [];
        for (let e = 0, i = t.meshEntArrLength(); e < i; e++) {
          let i = t.meshEntArr(e),
            r = {
              uuid: i.uuid(),
              bndBoxMin: i.bndBoxMinArray(),
              bndBoxMax: i.bndBoxMaxArray(),
              meshID: i.meshID(),
              columnOffset: i.columnOffset(),
              columnCount: i.columnCount(),
              rowOffset: i.rowOffset(),
              rowCount: i.rowCount(),
              vertexColPos: i.vertexColPosArray(),
              vertexRowPos: i.vertexRowPosArray(),
              vertexHeight: i.vertexHeightArray(),
            };
          n.push(r);
        }
        for (let t = 0; t < n.length; t++)
          this.gridMeshEntMap.set(n[t].uuid, n[t]);
        let i = [];
        for (let e = 0, n = t.entInfoArrayLength(); e < n; e++) {
          let n = t.entInfoArray(e),
            r = {
              id: n.id(),
              floorId: n.flootID(),
              comtype: n.comtype(),
              comID: n.comID(),
              handle: n.handle(),
              selectAbility: n.selectAbility(),
              stageArray: Array.prototype.slice.call(n.stageArrayArray()),
              entDataArray: Array.prototype.slice.call(n.entDataArrayArray()),
            };
          i.push(r);
        }
        for (let t = 0; t < i.length; t++) {
          let e = i[t];
          for (let t = 0, n = e.entDataArray.length; t < n; t++)
            this.gridMeshInfoMap.set(e.entDataArray[t], e);
        }
      },
      getGridMeshEntMap: function () {
        return this.gridMeshEntMap;
      },
      getGridMeshInfoMap: function () {
        return this.gridMeshInfoMap;
      },
      getGridMeshGeoMap: function () {
        return this.gridMeshGeoMap;
      },
      createGridEntInfoEntDataArray: function (t, e, n, i, r) {
        let o,
          s,
          a = new Map();
        for (let e = 0, n = t.length; e < n; e++) {
          let n = t[e],
            r = new $f(n.id);
          r.setEntInfo(n.id, n.floorId, n.comtype, n.comID, n.handle),
            r.setSelectVisible(n.selectAbility);
          for (let t = 0, e = n.stageArray.length; t < e; t++)
            r.addLayerID(n.stageArray[t]);
          for (let t = 0, e = n.entDataArray.length; t < e; t++)
            a.set(n.entDataArray[t], r.getID());
          i.push(r);
        }
        for (let t = 0, n = e.length; t < n; t++) {
          let n = e[t],
            i = new ym(
              this.getGridMeshGeoMap().get(n.meshID),
              n,
            ).getAttribute(),
            c = new MeshData(),
            l = a.get(n.uuid);
          l && c.setEntID(l),
            o ||
              ((o = new J(n.bndBoxMin[0], n.bndBoxMin[1], n.bndBoxMin[2])),
              (s = new J(n.bndBoxMax[0], n.bndBoxMax[1], n.bndBoxMax[2]))),
            c.setBndBox(o, s),
            c.setGeoID(n.meshID),
            c.setPosition(0, i.position.length),
            c.setTriangle(0, i.index.length / 3),
            r.push(c);
        }
        for (let t = 0, e = n.length; t < e; t++)
          for (let e = 0, i = n[t].otherFace.length; e < i; e++) {
            let i = n[t].otherFace[e],
              a = new MeshData();
            a.setBndBox(o, s),
              a.setGeoID(i.uuid),
              a.setPosition(0, i.vertexs.length / 3),
              a.setTriangle(0, i.triangles.length / 3),
              r.push(a);
          }
      },
      createProjectDataFile: function (t) {
        let e = this.getProjectFileIndex(t);
        return new Promise((t) => {
          this.fileLoader.loadFile(e).then((e) => {
            let n = new lm.ByteBuffer(new Uint8Array(e.data));
            t(
              cm.CComponentsInfoAddBuildinfo.getRootAsCComponentsInfoAddBuildinfo(
                n,
              ),
            );
          });
        });
      },
      createModelTree: function (t, e) {
        let n = e.getModelTree(),
          i = t.mPBuildproject();
        for (let t = 0, e = i.buildsLength(); t < e; t++) {
          let e = this.createBuildingNode(i.builds(t), n);
          n.insertNode(e);
        }
        for (let t = 0, e = i.stagesLength(); t < e; t++) {
          let e = i.stages(t),
            r = new sm(e.stagename(), e.stageid());
          n.addLayer(r);
        }
      },
      createBuildingNode: function (t, e) {
        let n = new om(em, t.buildname(), t.buildid(), e);
        for (let i = 0, r = t.floorsLength(); i < r; i++) {
          let r = this.createFloorNode(t.floors(i), e);
          n.addChild(r);
        }
        return n;
      },
      createFloorNode: function (t, e) {
        let n = new om(nm, t.floorname(), t.floorid(), e);
        for (let i = 0, r = t.comtypeGroupInfoLength(); i < r; i++) {
          let r = this.createBaseComtypeNode(t.comtypeGroupInfo(i), e);
          n.addChild(r);
        }
        return n;
      },
      createBaseComtypeNode: function (t, e) {
        let n = new om(im, t.bName(), t.bId(), e);
        for (let i = 0, r = t.subcomtypeInfoLength(); i < r; i++) {
          let r = this.createComtypeNode(t.subcomtypeInfo(i), e);
          n.addChild(r);
        }
        return n;
      },
      createComtypeNode: function (t, e) {
        let n = new om(im, t.name(), t.id(), e);
        for (let e = 0, n = t.gjInfoLength(); e < n; e++);
        for (let i = 0, r = t.subcomtypeInfoLength(); i < r; i++) {
          let r = this.createComtypeInfo(t.subcomtypeInfo(i), e);
          n.addChild(r);
        }
        return n;
      },
      async loadModel(t, e, n) {
        let i = this.createHeadDataFile(t);
        if (!i) return;
        let r = this.getFileLoader();
        r.setBasicFileTotal(this.getBasicFileTotal(i)),
          await this.getSceneDataFile(i).then((t) => {
            r.setBasicProgress(1),
              n(r.getBasicProgress()),
              this.createSceneTree(this.getRootNode(t), e.getSceneNode()),
              (this.viewer.scale = this.getSceneScale(t));
          });
        let o = this.getMaterialDataFileIndexArray(i),
          s = [],
          a = e.getTextureImageMap(),
          c = e.getMaterialMap();
        for (let t = 0, e = o.length; t < e; t++) {
          let e = r.getFileIndex(o[t].getURL());
          e &&
            s.push(
              r.loadFile(e).then((t) => {
                r.setBasicProgress(1),
                  s.push(
                    r.loadFile(e).then((t) => {
                      r.setBasicProgress(1),
                        n(r.getBasicProgress()),
                        this.createMaterialMap(t.data, a, c);
                    }),
                  );
              }),
            );
        }
        await Promise.all(s);
        let l = this.getRefDefinitionDataFileIndexArray(i),
          h = [],
          u = e.getRefDefinitionMap();
        for (let t = 0, e = l.length; t < e; t++) {
          let e = r.getFileIndex(l[t].getURL());
          e &&
            h.push(
              r.loadFile(e).then((t) => {
                r.setBasicProgress(1),
                  n(r.getBasicProgress()),
                  this.createRefDefinitionMap(t.data, c, u);
              }),
            );
        }
        await Promise.all(h),
          await this.createProjectDataFile(i).then((t) => {
            r.setBasicProgress(1),
              n(r.getBasicProgress()),
              this.createModelTree(t, e);
          });
        let d = [];
        this.createFloorAxisFileIndexArray(i, d);
        let p = [];
        for (let t = 0, i = d.length; t < i; t++) {
          let i = r.getFileIndex(d[t].getURL());
          i &&
            p.push(
              r.loadFile(i).then((t) => {
                r.setBasicProgress(1),
                  n(r.getBasicProgress()),
                  this.createFloorAxisArray(t.data, e);
              }),
            );
        }
        await Promise.all(p);
        let f = this.getTerrainFileIndexArray(i);
        if (f) {
          let t = [];
          for (let e = 0, i = f.length; e < i; e++) {
            let i = r.getFileIndex(f[e].getURL());
            i &&
              t.push(
                r.loadFile(i).then((t) => {
                  r.setBasicProgress(1), n(r.getBasicProgress());
                  let e = this.createTerrainDataFile(t.data);
                  this.setTerrainDataMap(e);
                }),
              );
          }
          await Promise.all(t).then(() => {
            if (t.length > 0) {
              let t = this.getGridMeshEntMap();
              this.getGridMeshInfoMap();
              let e = this.getGridMeshGeoMap();
              t.forEach((t) => {
                let n = e.get(t.meshID),
                  i = this.addTerrainGeometry(n, t),
                  r = new Yf(
                    i.getUUID(),
                    new vm(0, i.vertexIndex.bufferAttribute.count, 0, 0),
                  );
                new $f(i.getUUID()).addGeoData(r);
                for (let t = 0; t < n.otherFace.length; t++) {
                  let e = n.otherFace[t],
                    i = this.addTerrainOtherGeometry(e),
                    r = new Yf(
                      i.getUUID(),
                      new vm(0, i.vertexIndex.bufferAttribute.count, 0, 0),
                    );
                  new $f(i.getUUID()).addGeoData(r);
                }
              });
            }
          });
        }
        if (this.cancelCreateModel) throw new Error('取消了加载');
      },
      createFloorAxisArray: function (t, e) {
        const n = new hm().createFloorCrossLine(t);
        e.setFloorAxisArray(n);
      },
      createModel: function (t, e) {
        return new Promise((n, i) => {
          this.model
            ? this.cancelCreateModel
              ? i('取消加载')
              : n(this.model)
            : this.fileLoader.loadFile(t.headFile).then((r) => {
                (this.model = new Bm(t.version, this)),
                  this.loadModel(r.data, this.model, e)
                    .then((t) => {
                      this.cancelCreateModel ? i('取消加载') : n(this.model);
                    })
                    .catch(() => {
                      i('.9 catch取消加载');
                    });
              });
        });
      },
      cancelCreateModelAsync: function () {
        this.cancelCreateModel = !0;
      },
      loadSceneNode: function (t, e, n) {
        if (!t || !e) return;
        const i = e.getBufferGeometryFileList(),
          r = e.getEntDataFileList(),
          o = t.getEntInfoFileList();
        let s = this.getFileLoader();
        const a = s.entInfoFileTotal + i.length + r.length + o.length;
        s.setEntInfoFileTotal(a);
        let c = this.getModel(),
          l = c.getMaterialMap(),
          h = c.getRefDefinitionMap();
        for (let e = 0, r = i.length; e < r; e++) {
          let r = s.getFileIndex(i[e].getURL());
          if (!r) continue;
          let o = s.loadFile(r).then((e) => {
            let n = [],
              i = this.createBufferGeometryDataFile(e.data);
            this.createGeometryArray(i, l, h, n);
            for (let e = 0, i = n.length; e < i; e++)
              t.renderBufferMap.set(n[e].getUUID(), n[e]);
            this.createEntInfoEntDataArray(i, h, t.entityMap),
              this.samllProgress(s);
          });
          o && n.push(o);
        }
        for (let e = 0, i = r.length; e < i; e++) {
          let i = s.getFileIndex(r[e].getURL());
          if (!i) continue;
          let o = s.loadFile(i).then((e) => {
            this.loadBIMEntData(e.data, t), this.samllProgress(s);
          });
          o && n.push(o);
        }
        for (let e = 0, i = o.length; e < i; e++) {
          let i = s.getFileIndex(o[e].getURL());
          if (!i) continue;
          let r = s.loadFile(i).then((e) => {
            this.loadBIMEntInfo(e.data, t), this.samllProgress(s);
          });
          r && n.push(r);
        }
      },
      samllProgress: function (t) {
        if (this.cancelCreateModel) return;
        t.setEntInfoProgress(1);
        const e = t.getEntInfoProgress();
        let n = document.getElementById(
            this.viewer.parentElementId + '__ccbim__small__progress__div',
          ),
          i = document.getElementById(
            this.viewer.parentElementId + '__ccbim__small__progress',
          );
        i && (i.style.display = 'block'),
          n && (n.style.width = e + '%'),
          e >= 100 &&
            (i && (i.style.display = 'none'),
            this.hasloadOnce ||
              setTimeout(() => {
                this.viewer.renderFinish(),
                  this.viewer.dispatchEvent({
                    type: 'renderFinish',
                    object: !0,
                  }),
                  (this.hasloadOnce = !0);
              }));
      },
    })),
    (zm.prototype = {
      constructor: zm,
      getInstanceMatR1() {
        return this.getFloat32Array(this.instanceMatR1);
      },
      getInstanceMatR2() {
        return this.getFloat32Array(this.instanceMatR2);
      },
      getInstanceMatR3() {
        return this.getFloat32Array(this.instanceMatR3);
      },
      getInstanceMatR4() {
        return this.getFloat32Array(this.instanceMatR4);
      },
      getInstanceColorKey() {
        return this.instanceColorKey;
      },
      getFloat32Array(t) {
        let e = t.length,
          n = new Float32Array(e);
        for (let i = 0; i < e; i++) n[i] = t[i];
        return n;
      },
      clearInstanceMat() {
        (this.instanceMatR1 = null),
          (this.instanceMatR2 = null),
          (this.instanceMatR3 = null),
          (this.instanceMatR4 = null);
      },
      pushMatrix: function (t) {
        this.instanceMatR1.push(t[0]),
          this.instanceMatR1.push(t[1]),
          this.instanceMatR1.push(t[2]),
          this.instanceMatR1.push(t[3]),
          this.instanceMatR2.push(t[4]),
          this.instanceMatR2.push(t[5]),
          this.instanceMatR2.push(t[6]),
          this.instanceMatR2.push(t[7]),
          this.instanceMatR3.push(t[8]),
          this.instanceMatR3.push(t[9]),
          this.instanceMatR3.push(t[10]),
          this.instanceMatR3.push(t[11]),
          this.instanceMatR4.push(t[12]),
          this.instanceMatR4.push(t[13]),
          this.instanceMatR4.push(t[14]),
          this.instanceMatR4.push(t[15]);
      },
    }),
    (jm.prototype = Object.assign(Object.create(Pr.prototype), {
      constructor: jm,
      blitRenderTarget: (function () {
        function t(t, e) {
          e && !e.getFrameBuffer() && t.setRenderTarget(e);
        }
        return function (e, n) {
          if (!e || !n) return;
          let i = this.getRenderTarget();
          t(this, e), t(this, n);
          let r = this.getContext();
          r.bindFramebuffer(r.READ_FRAMEBUFFER, e.getFrameBuffer()),
            r.bindFramebuffer(r.DRAW_FRAMEBUFFER, n.getFrameBuffer()),
            r.blitFramebuffer(
              0,
              0,
              e.width,
              e.height,
              0,
              0,
              n.width,
              n.height,
              r.COLOR_BUFFER_BIT | r.DEPTH_BUFFER_BIT | r.STENCIL_BUFFER_BIT,
              r.NEAREST,
            );
          let o = i ? i.getFrameBuffer() : null;
          r.bindFramebuffer(r.FRAMEBUFFER, o);
        };
      })(),
      renderPMScene: function (t) {
        t && t.isPMScene && t.render(this);
      },
      flush: function () {
        this.getContext().flush();
      },
    })),
    (Hm.prototype = {
      constructor: Hm,
      setNext: function (t) {
        this.next = t;
      },
      toString: function () {
        return 'execute default command';
      },
      execute: function (t) {
        console.log(this.toString());
      },
    }),
    (Wm.prototype = {
      constructor: Wm,
      push_back: function (t) {
        this.head || (this.head = t),
          this.tail && this.tail.setNext(t),
          (this.tail = t),
          this.size++;
      },
      take_front: function () {
        if (!this.head) return;
        let t = this.head;
        return (
          (this.head = this.head.next),
          this.head || (this.tail = null),
          (t.next = null),
          this.size--,
          t
        );
      },
      length: function () {
        return this.size;
      },
      clear: function () {
        (this.head = null), (this.tail = null), (this.size = 0);
      },
    }),
    (Xm.prototype = Object.assign(Object.create(Hm.prototype), {
      constructor: Xm,
      toString: function () {
        return (
          'execute set frame buffer' +
          (this.renderTarget ? '' : ', and target frame buffer is null')
        );
      },
      execute: function (t) {
        t.setRenderTarget(this.renderTarget);
      },
    })),
    (Zm.prototype = Object.assign(Object.create(Hm.prototype), {
      constructor: Zm,
      toString: function () {
        return 'execute set scissor to ' + this.scissorTest.toString();
      },
      execute: function (t) {
        t.setScissorTest(this.scissorTest);
      },
    })),
    (Ym.prototype = Object.assign(Object.create(Hm.prototype), {
      constructor: Ym,
      toString: function () {
        return (
          'execute set viewport, x:' +
          this.viewPort.x.toString() +
          ' y:' +
          this.viewPort.y.toString() +
          ' width:' +
          this.viewPort.z +
          ' height:' +
          this.viewPort.w
        );
      },
      execute: function (t) {
        t.setViewport(this.viewPort), t.setScissor(this.viewPort);
      },
    })),
    (qm.prototype = Object.assign(Object.create(Hm.prototype), {
      constructor: qm,
      toString: function () {
        return (
          'execute clear, color:' +
          this.clearColor.toString() +
          ' depth:' +
          this.clearDepth.toString() +
          ' stencil:' +
          this.clearStencil.toString()
        );
      },
      execute: function (t) {
        t.clear(this.clearColor, this.clearDepth, this.clearStencil);
      },
    })),
    (Qm.prototype = Object.assign(Object.create(Hm.prototype), {
      constructor: Qm,
      toString: function () {
        return 'execute reset render state';
      },
      execute: function (t) {
        t.resetRenderingState(this.scene, this.camera);
        let e = t.getRenderStateInternal(this.scene, this.camera);
        e.pushLight(this.scene.ambientLight),
          e.pushLight(this.scene.directionLight),
          t.renderShadow(this.scene, this.camera);
      },
    })),
    (Jm.prototype = Object.assign(Object.create(Hm.prototype), {
      constructor: Jm,
      toString: function () {
        return 'execute clear render state';
      },
      execute: function (t) {
        t.clearRenderState(this.scene, this.camera);
      },
    })),
    ($m.prototype = Object.assign(Object.create(Hm.prototype), {
      constructor: $m,
      toString: function () {
        return 'execute render item';
      },
      execute: function (t) {
        t.drawRenderListItem(this.item, this.scene, this.camera);
      },
    })),
    (Km.prototype = Object.assign(Object.create(An.prototype), {
      constructor: Km,
      isPMCamera: !0,
      setAsPerspective: function (t) {
        (this.isPerspectiveCamera = !0),
          (this.isOrthographicCamera = !1),
          void 0 !== t && ((this.fov = t), this.updateProjectionMatrix());
      },
      setAsOrthographic: function () {
        (this.isPerspectiveCamera = !1),
          (this.isOrthographicCamera = !0),
          this.updateProjectionMatrix();
      },
      setViewSize: function (t, e) {
        (this.viewWidth = t),
          (this.viewHeight = e),
          this.updateProjectionMatrix();
      },
      setNearFar: function (t, e) {
        (this.near = t), (this.far = e), this.updateProjectionMatrix();
      },
      updateProjectionMatrix: function () {
        if (this.isPerspectiveCamera) {
          let t = this.near,
            e = t * Math.tan(0.5 * k.DEG2RAD * this.fov),
            n = 2 * e,
            i = (this.viewWidth / this.viewHeight) * n,
            r = -0.5 * i;
          this.projectionMatrix.makePerspective(
            r,
            r + i,
            e,
            e - n,
            t,
            this.far,
          ),
            this.projectionMatrixInverse.getInverse(this.projectionMatrix);
        } else {
          let s = this.computeFieldSize();
          var t = 0.5 * s.width,
            e = 0.5 * s.height,
            n = 0 - t,
            i = 0 + t,
            r = 0 + e,
            o = 0 - e;
          this.projectionMatrix.makeOrthographic(
            n,
            i,
            r,
            o,
            this.near,
            this.far,
          ),
            this.projectionMatrixInverse.getInverse(this.projectionMatrix);
        }
      },
      computeFieldSize: function () {
        if (this.isPerspectiveCamera) {
          let t = this.position.distanceTo(this.target),
            e = Math.tan(0.5 * k.DEG2RAD * this.fov) * t;
          return {
            width: 2 * ((this.viewWidth / this.viewHeight) * e),
            height: 2 * e,
          };
        }
        {
          let t = this.position.distanceTo(this.target);
          return { width: (this.viewWidth / this.viewHeight) * t, height: t };
        }
      },
      lookAt: function (t, e, n) {
        t.isVector3 ? this.target.copy(t) : this.target.set(t, e, n),
          An.prototype.lookAt.call(this, this.target);
      },
      copy: function (t, e) {
        return (
          An.prototype.copy.call(this, t, e),
          this.target.copy(t.target),
          this.pixelVector.copy(t.pixelVector),
          (this.near = t.near),
          (this.far = t.far),
          (this.viewWidth = t.viewWidth),
          (this.viewHeight = t.viewHeight),
          (this.isPerspectiveCamera = t.isPerspectiveCamera),
          (this.isOrthographicCamera = t.isOrthographicCamera),
          this
        );
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      update: function () {
        this.lookAt(this.target),
          this.isOrthographicCamera && this.updateProjectionMatrix();
      },
      makePan: function (t) {
        this.position.add(t), this.target.add(t), this.update();
      },
      makeRotate: function (t) {
        this.up.transformDirection(t).normalize(),
          this.position.applyMatrix4(t),
          this.target.applyMatrix4(t),
          this.update();
      },
      makeZoom: (function () {
        let t = new J();
        return function (e) {
          t.subVectors(this.position, this.target).normalize(),
            this.position.addVectors(
              this.target,
              t.multiplyScalar(this.position.distanceTo(this.target) * e),
            ),
            this.update();
        };
      })(),
      makeLookAt: (function () {
        let t = new J(),
          e = new J(),
          n = new J();
        return function (i, r, o) {
          t.subVectors(r, i).normalize(),
            e.crossVectors(o, t).normalize(),
            n.crossVectors(t, e),
            Math.abs(n.length()) < 1e-6 ||
              (this.position.copy(i),
              this.target.copy(r),
              this.up.copy(n).normalize(),
              this.update());
        };
      })(),
      makeLookAtBoundingBox: (function () {
        let t = new J(),
          e = new J(),
          n = new J(),
          i = new Nt();
        return function (r) {
          if (!r || r.isEmpty()) return;
          r.getCenter(t),
            e.subVectors(t, this.target),
            this.makePan(e),
            i.makeEmpty();
          for (let t = 0; t < 8; ++t)
            n.set(
              1 & t ? r.max.x : r.min.x,
              2 & t ? r.max.y : r.min.y,
              4 & t ? r.max.z : r.min.z,
            ),
              n.applyMatrix4(this.matrixWorldInverse),
              i.expandByPoint(n);
          let o = this.target.distanceTo(this.position),
            s = 0.5 * i.min.distanceTo(i.max);
          this.makeZoom((s / o) * 1.732);
        };
      })(),
      makeLookAtBoundingBoxDwg: (function () {
        let t = new J(),
          e = new J();
        return function (n) {
          if (!n || n.isEmpty()) return;
          n.getCenter(t), e.subVectors(t, this.target), this.makePan(e);
          let i = n.max.y - n.min.y,
            r = this.target.distanceTo(this.position);
          this.makeZoom(i / r);
        };
      })(),
      makeYaw: (function () {
        let t = new J(),
          e = new Y();
        return function (n) {
          if (Xf.isZeroNumber(n)) return;
          e.setFromAxisAngle(this.up, (n / 180) * Math.PI),
            t.subVectors(this.target, this.position),
            t.applyQuaternion(e);
          let i = this.target.distanceTo(this.position);
          this.target.copy(this.position),
            this.target.addScaledVector(t.normalize(), i),
            this.update();
        };
      })(),
      makePitch: (function () {
        let t = new J(),
          e = new J(),
          n = new Y();
        return function (i) {
          if (Xf.isZeroNumber(i)) return;
          t.subVectors(this.target, this.position).normalize(),
            e.crossVectors(this.up, t).normalize(),
            n.setFromAxisAngle(e, (i / 180) * Math.PI),
            t.applyQuaternion(n);
          let r = this.target.distanceTo(this.position);
          this.target.copy(this.position),
            this.target.addScaledVector(t.normalize(), r),
            this.up.crossVectors(t, e).normalize(),
            this.update();
        };
      })(),
      makeRoll: (function () {
        let t = new J(),
          e = new Y();
        return function (n) {
          Xf.isZeroNumber(n) ||
            (t.subVectors(this.target, this.position).normalize(),
            e.setFromAxisAngle(t.normalize(), (n / 180) * Math.PI),
            this.up.applyQuaternion(e),
            this.update());
        };
      })(),
      makeCameraUp: (function () {
        let t = new J(),
          e = new J();
        return function (n) {
          t.subVectors(this.target, this.position).normalize(),
            e.crossVectors(n.normalize(), t).normalize(),
            this.up.crossVectors(t, e).normalize(),
            this.update();
        };
      })(),
      updatePixelVector: (function () {
        let t = new J(),
          e = new J();
        return function (n, i) {
          let r = n || this.viewWidth,
            o = i || this.viewHeight,
            s = this.projectionMatrix.elements,
            a = this.matrixWorldInverse.elements,
            c = s[0] * r * 0.5,
            l = s[8] * r * 0.5 + s[11] * r * 0.5;
          t.set(a[0] * c + a[2] * l, a[4] * c + a[6] * l, a[8] * c + a[10] * l);
          let h = s[5] * o * 0.5,
            u = s[9] * o * 0.5 + s[11] * o * 0.5;
          e.set(a[1] * h + a[2] * u, a[5] * h + a[6] * u, a[9] * h + a[10] * u);
          let d = s[11],
            p = s[15],
            f = this.pixelVector;
          f.set(a[2] * d, a[6] * d, a[10] * d, a[14] * d + a[15] * p);
          let m = 0.7071067811 / Math.sqrt(t.lengthSq() + e.lengthSq());
          f.multiplyScalar(m);
        };
      })(),
      getPixelScale: function (t) {
        let e = this.pixelVector;
        return 1 / (0.48 / (t.x * e.x + t.y * e.y + t.z * e.z + e.w));
      },
      getFrustum: (function () {
        let t = new ot();
        return function (e) {
          t.multiplyMatrices(this.projectionMatrix, this.matrixWorldInverse),
            e.setFromProjectionMatrix(t);
        };
      })(),
      getAsymmetricFrustum: (function () {
        let t = new ot(),
          e = new ot();
        return function (n, i, r, o, s) {
          if ((t.identity(), this.isPerspectiveCamera)) {
            let e = this.near / this.position.distanceTo(this.target),
              s = n * e,
              a = i * e,
              c = r * e,
              l = o * e;
            t.makePerspective(s, a, l, c, this.near, this.far);
          } else t.makeOrthographic(n, i, o, r, this.near, this.far);
          e.multiplyMatrices(t, this.matrixWorldInverse),
            s.setFromProjectionMatrix(e);
        };
      })(),
      cullPoint: (function () {
        let t = new Ln();
        return function (e) {
          return this.getFrustum(t), !t.containsPoint(e);
        };
      })(),
    }));
  let tb = 0,
    eb = 1,
    nb = 2,
    ib = 4,
    rb = 8;
  function ob(t, e, n, i) {
    Mt.call(this),
      (this.ambientLight = new mc(16777215, 0.2)),
      this.add(this.ambientLight),
      (this.directionLight = new fc(16777215, 1)),
      this.directionLight.position.set(1, -1.3, 1.3),
      this.directionLight.position.normalize(),
      this.directionLight.updateMatrix(),
      this.add(this.directionLight),
      (this.viewPort = new W(0, 0, t, e)),
      (this.layoutMode = tb),
      (this.layoutPadding = new U()),
      (this.camera = n || new Km()),
      (this.name = i || ''),
      (this.visible = !0);
  }
  ob.prototype = Object.assign(Object.create(Mt.prototype), {
    constructor: ob,
    isPMScene: !0,
    getName: function () {
      return this.name;
    },
    getViewPort: function () {
      return this.viewPort;
    },
    getCamera: function () {
      return this.camera;
    },
    setVisible: function (t) {
      this.visible = t;
    },
    getVisible: function () {
      return this.visible;
    },
    setLayout: function (t, e, n) {
      (this.layoutMode = t), this.layoutPadding.set(e, n);
    },
    onAttached: function (t, e) {
      let n = t.getSize();
      this.onMainWindowSizeChanged(n.x, n.y),
        this.onMainCameraChanged(t.getMainCamera());
    },
    onDetach: function (t, e) {},
    onMainWindowSizeChanged: function (t, e) {
      0 === this.layoutMode
        ? (this.viewPort.set(0, 0, t, e),
          this.camera.isPerspectiveCamera &&
            ((this.camera.aspect = t / e),
            this.camera.updateProjectionMatrix()))
        : (this.layoutMode & eb && (this.viewPort.x = this.layoutPadding.x),
          this.layoutMode & nb &&
            (this.viewPort.x = t - this.viewPort.z - this.layoutPadding.x),
          this.layoutMode & ib && (this.viewPort.y = this.layoutPadding.y),
          this.layoutMode & rb &&
            (this.viewPort.y = e - this.viewPort.w - this.layoutPadding.y));
    },
    onMainCameraChanged: function (t) {
      this.camera.type === t.type && this.camera.copy(t);
    },
    buildRenderCommand: (function () {
      function t(t, e, n, i) {
        for (let r = 0, o = t.length; r < o; ++r)
          i.push_back(new $m(t[r], e, n));
      }
      return function (e, n) {
        if (!this.getVisible()) return;
        let i = this.getCamera();
        n.push_back(new Qm(this, i));
        let r = e.getRenderListInternal(this, i),
          o = e.getRenderStateInternal(this, i);
        e.rebuildRenderList(this, i, r, o),
          t(r.opaque, this, i, n),
          t(r.transparent, this, i, n),
          n.push_back(new Jm(this, i));
      };
    })(),
    render: function (t) {
      this.getVisible() && t.render(this, this.getCamera());
    },
  });
  let sb = { type: 'modelAdded', model: void 0 },
    ab = { type: 'modelRemoved', model: void 0 };
  function cb(t, e, n, i) {
    n && (i ? t.addEventListener(e, n) : t.removeEventListener(e, n));
  }
  let lb = 1048576;
  function hb(t, e, n, i) {
    ob.call(this, t, e, n, i),
      (this.lightFollowCamera = !0),
      (this.modelArray = []),
      (this.clippingPlanes = []),
      (this.isLoading = !1),
      (this.promiseArr = []),
      (this.glContext = void 0),
      (this.memoryLimitBytes = 2147483648),
      (this.dynamicRenderLevel = !1),
      (this.dynamicRenderLevelScale = 50);
  }
  function ub(t, e) {
    Em.call(this, t, e || new bo({ color: 16777215 })),
      (this.lineSegment = new vm(0, 0, 0, 0)),
      this.drawSegmentArray.push(this.lineSegment),
      (this.lineSegmentIndex = new Wf(Hf.LINES));
  }
  (hb.prototype = Object.assign(Object.create(ob.prototype), {
    constructor: hb,
    isModelScene: !0,
    addModel: function (t) {
      t &&
        t.isPMModel &&
        (this.modelArray.indexOf(t) >= 0 ||
          (this.add(t.getSceneNode()),
          this.modelArray.push(t),
          (sb.model = t),
          this.dispatchEvent(sb)));
    },
    removeModel: function (t) {
      if (!t || !t.isPMModel) return;
      let e = this.modelArray.indexOf(t);
      e < 0 ||
        (t.clear(this.glContext),
        this.remove(t.getSceneNode()),
        this.modelArray.splice(e, 1),
        (ab.model = t),
        this.dispatchEvent(ab));
    },
    getModelArray: function () {
      return this.modelArray;
    },
    getBoundingBox: function () {
      let t = new Nt();
      for (let e = 0, n = this.modelArray.length; e < n; ++e)
        t.union(this.modelArray[e].getBoundingBox());
      return t;
    },
    setClippingPlanes: function (t) {
      this.clippingPlanes = t;
      for (let t = 0, e = this.modelArray.length; t < e; ++t) {
        this.modelArray[t].getMaterialMap().forEach((t) => {
          t.clippingPlanes = this.clippingPlanes;
        }),
          this.modelArray[t].getMaterialMap_CCY().forEach((t) => {
            t.clippingPlanes = this.clippingPlanes;
          });
      }
    },
    getClippingPlanes: function () {
      return this.clippingPlanes;
    },
    setLightFollowCamera: function (t) {
      this.lightFollowCamera = t;
    },
    getLightFollowCamera: function () {
      return this.lightFollowCamera;
    },
    pickSelectEntity: (function () {
      let t = new gl(),
        e = new J(),
        n = new Nt(),
        i = new J(),
        r = new J();
      function o(t, e) {
        return t.distance - e.distance;
      }
      return function (s) {
        if (
          !(function (t, o, s, a) {
            if (
              (a.setFromCamera(t, o),
              (a.near = o.near),
              (a.far = o.far),
              1 === s.length)
            ) {
              if (a.ray.intersectPlane(s[0], e)) {
                let t = e.distanceTo(a.ray.origin);
                return (
                  a.ray.direction.dot(s[0].normal) > 0
                    ? (a.near = t)
                    : (a.far = t),
                  !0
                );
              }
            } else {
              if (6 === s.length) {
                i.set(1 / 0, 1 / 0, 1 / 0), r.set(-1 / 0, -1 / 0, -1 / 0);
                for (let t = 0; t < 6; ++t)
                  s[t].coplanarPoint(e),
                    Xf.isParallelVector3(e, Xf.xAxis)
                      ? ((i.x = Math.min(i.x, e.x)), (r.x = Math.max(r.x, e.x)))
                      : Xf.isParallelVector3(e, Xf.yAxis)
                      ? ((i.y = Math.min(i.y, e.y)), (r.y = Math.max(r.y, e.y)))
                      : Xf.isParallelVector3(e, Xf.zAxis) &&
                        ((i.z = Math.min(i.z, e.z)),
                        (r.z = Math.max(r.z, e.z)));
                if (
                  (n.makeEmpty(),
                  n.expandByPoint(i),
                  n.expandByPoint(r),
                  n.isEmpty())
                )
                  return !1;
                let t = Xf.computeIntersectionRayBox3(a.ray, n);
                return void 0 !== t && ((a.near = t.near), (a.far = t.far), !0);
              }
              a.far = 1 / 0;
            }
            return !0;
          })(s, this.getCamera(), this.clippingPlanes, t)
        )
          return null;
        let a = [],
          c = [];
        for (let t = 0, e = this.modelArray.length; t < e; ++t)
          c.push(this.modelArray[t].getSceneNode());
        for (let e = 0; e < c.length; ++e) {
          let n = c[e].children;
          for (let t = 0, e = n.length; t < e; ++t) {
            let e = n[t];
            e.isPMSceneNode && c.push(e);
          }
          let i = c[e].getEntityArray();
          for (let e = 0, n = i.length; e < n; ++e) {
            let n = i[e].raycast(t);
            n && ((n.entity = i[e]), a.push(n));
          }
        }
        return a.sort(o), a.length > 0 ? a[0] : null;
      };
    })(),
    onAttached: function (t, e) {
      ob.prototype.onAttached.call(this, t, e),
        (this.glContext = e.getRenderer().getContext());
    },
    setDynamicRenderLevel: (function () {
      function t(e, n) {
        let i = e.children;
        for (let e = 0, r = i.length; e < r; ++e) {
          let r = i[e];
          r.isPMRenderObject ? r.setDynamicRenderingEnable(n) : t(r, n);
        }
      }
      return function (e, n) {
        let i = !!e;
        if (this.dynamicRenderLevel !== i) {
          (this.dynamicRenderLevel = i), (this.dynamicRenderLevelScale = n);
          for (let e = 0, n = this.modelArray.length; e < n; ++e)
            t(this.modelArray[e].getSceneNode(), this.dynamicRenderLevel);
        }
      };
    })(),
    setMemoryLimit: function (t) {
      t && (this.memoryLimitBytes = lb * t);
    },
    onMainCameraChanged: (function () {
      let t = new J(),
        e = new J();
      function n(i, r, o, s) {
        if (!i) return;
        let a = i.getBndBox();
        e.subVectors(o.position, o.target), Xf.getBox3MaxCorner(a, t);
        let c = r.planes[5].distanceToPoint(t),
          l = null;
        if (a && r.intersectsBox(a) && ((l = i.getPageData()), !l)) {
          let t = i.getPageLODArray();
          for (let e = 0, n = t.length; e < n; e++) {
            let n = t[e];
            if (c < n.getMaxLoadDistance()) {
              l = n.getPageData();
              break;
            }
          }
        }
        s.push({ node: i, distance: c, curPage: i.getCurPage(), nextPage: l });
        for (let t = 0, e = i.children.length; t < e; t++) {
          let e = i.children[t];
          e.isPMSceneNode && n(e, r, o, s);
        }
      }
      function i(t, e) {
        return t.distance - e.distance;
      }
      function r(t, e, n) {
        let i = t.children;
        for (let t = 0, o = i.length; t < o; ++t) {
          let o = i[t];
          o.isPMRenderObject
            ? o.computeRenderingLevelByCameraPosition(e, n)
            : r(o, e, n);
        }
      }
      let o = new Ln();
      return function (t) {
        if (
          (ob.prototype.onMainCameraChanged.call(this, t),
          this.lightFollowCamera &&
            (this.directionLight.position.subVectors(t.position, t.target),
            this.directionLight.position.normalize()),
          this.isLoading)
        )
          return;
        if ((this.getCamera().getFrustum(o), this.dynamicRenderLevel))
          for (let t = 0, e = this.modelArray.length; t < e; ++t)
            r(
              this.modelArray[t].getSceneNode(),
              this.getCamera().position,
              this.dynamicRenderLevelScale,
            );
        let e = [];
        if (
          (function (t, e, r, o, s) {
            let a = 0,
              c = 0;
            for (a = 0, c = t.length; a < c; ++a)
              n(t[a].getSceneNode(), e, r, s);
            for (s.sort(i), a = s.length - 1; a >= 0; --a) {
              let t = s[a];
              t.curPage || t.nextPage || s.splice(a, 1);
            }
            let l = 0,
              h = 0,
              u = !1;
            for (a = 0, c = s.length; a < c; ++a) {
              let t = s[a],
                e = t.curPage ? t.curPage.getContentSize() : 0,
                n = t.nextPage ? t.nextPage.getContentSize() : 0;
              (l += e), (h += n), n > e && (u = !0);
            }
            if (!u && l < o) return !1;
            let d = o - h;
            if (d > 0)
              for (a = 0; a < s.length; a++) {
                let t = s[a],
                  e = t.curPage ? t.curPage.getContentSize() : 0,
                  n = (t.nextPage ? t.nextPage.getContentSize() : 0) - e;
                if (n >= 0) continue;
                let i = d + n;
                if (i < 0) break;
                s.splice(a, 1), a--, (d = i);
              }
            return s.length > 0;
          })(this.modelArray, o, this.getCamera(), this.memoryLimitBytes, e)
        ) {
          this.isLoading = !0;
          for (let t = 0, n = e.length; t < n; ++t) {
            let n = e[t];
            n.node.loadRenderData(this.glContext, n.nextPage, this.promiseArr);
          }
          this.promiseArr.length > 0
            ? Promise.all(this.promiseArr).then(() => {
                for (let t = 0, e = this.promiseArr.length; t < e; t++)
                  this.promiseArr[t] = null;
                (this.promiseArr = []), (this.isLoading = !1);
              })
            : (this.isLoading = !1);
        }
      };
    })(),
    bindAddModelEvent: function (t, e) {
      cb(this, sb.type, t, e);
    },
    bindRemoveModelEvent: function (t, e) {
      cb(this, ab.type, t, e);
    },
  })),
    (ub.prototype = Object.assign(Object.create(Em.prototype), {
      constructor: ub,
      isPMWireframeObject: !0,
      setLineSegmentIndices: function (t) {
        this.lineSegmentIndex.setIndex(t),
          this.lineSegment.set(0, t.length),
          (this.needUpdate = !0);
      },
      setInstanceDrawing: function (t, e) {
        (this.currentInstanceVertexArray = t),
          (this.numInstance = e),
          (this.needUpdate = !0);
      },
      getCurrentIndex: function () {
        return this.lineSegmentIndex;
      },
      release: function (t) {
        this.lineSegmentIndex &&
          (this.lineSegmentIndex.release(t), (this.lineSegmentIndex = null));
      },
      updateInstanceDrawing: function (t) {
        return (
          !!this.currentInstanceVertexArray &&
          ((this.validDraw = this.numInstance > 0), !0)
        );
      },
    }));
  let db = 0;
  function pb(t, e) {
    (this.workID = ++db), (this.target = t), (this.callback = e);
  }
  function fb() {
    let t =
      window.CcbimSDKLoaderConfig.staticHost +
      '/ccbimSDK@' +
      window.CcbimSDKLoaderConfig.version;
    (this.computeWireframe = new Worker(
      t + '/ccbim/resources/ComputeWireframe.js',
    )),
      (this.refIndicesMap = new Map()),
      (this.workMap = new Map());
  }
  function mb(t, e, n, i, r, o) {
    ob.call(this, t, e, n, i),
      (this.wireframeWorker = r || new fb()),
      (this.wireMaterial = new bo()),
      (this.wireMaterial.color = new fe(0.4, 0.4, 0.4)),
      (this.objectMap = new Map()),
      (this.RenderContext = o);
  }
  function bb() {
    (this.meshMaterial = new ra()),
      (this.meshMaterial.color = new fe(255, 255, 255)),
      (this.meshMaterial.precision = 'highp'),
      (this.lineMaterial = new bo()),
      (this.lineMaterial.color = new fe(255, 255, 255)),
      (this.wireMaterial = null),
      (this.ccyMaterial = new oa({ color: 16777215 })),
      (this.ccyMaterial.side = 2),
      (this.ccyMaterial.needOffsetZ = !0);
  }
  function gb(t, e, n, i, r, o) {
    mb.call(this, t, e, n, i, r, o),
      this.wireMaterial.color.setRGB(0, 251 / 255, 191 / 255),
      (this.highlightStyle = new bb()),
      this.highlightStyle.setMeshColor(0, 251 / 255, 191 / 255),
      this.highlightStyle.setMeshOpacity(0.4),
      this.highlightStyle.setMeshDoubleSide(!0),
      this.highlightStyle.setMeshVertexOffset(-1.1),
      this.highlightStyle.setLineColor(0, 251 / 255, 191 / 255),
      (this.selectionMap = new Map()),
      (this.maskMaterial = new xe()),
      (this.maskMaterial.side = 2),
      (this.maskMaterial.visible = !1),
      this.maskMaterial.setOpacity(0),
      (this.maskObjectMap = new Map());
  }
  function yb(t, e, n, i) {
    ob.call(this, t, e, n, i);
  }
  function vb(t, e, n) {
    (this.enable = void 0 !== t && t),
      (this.minDepth = void 0 !== e ? e : 0),
      (this.maxDepth = void 0 !== n ? n : 1);
  }
  (pb.prototype = {
    constructor: pb,
    getID: function () {
      return this.workID;
    },
    getRenderBuffer: function () {
      return this.target.getRenderBuffer();
    },
    finish: function (t) {
      this.callback && this.callback(this.target.id, t);
    },
  }),
    (fb.prototype = {
      constructor: fb,
      getWireframe: function (t, e) {
        if (!t || !t.isPMRenderObject || !e) return;
        let n = t.getRenderBuffer();
        if (!n) return;
        let i = n
          .getVertexAttributeArray()
          .getBufferAttribute('position').array;
        if (!i) return;
        let r,
          o,
          s = 0 !== t.renderBuffer.CycleSegCount;
        if (
          ((r = s
            ? n.getVertexAttributeArray().getBufferAttribute('oldIndex').array
            : n.getVertexIndex().getBufferAttribute().array),
          !r)
        )
          return;
        if (n.isPMInstanceRenderBuffer) {
          let i = this.refIndicesMap.get(n.getUUID());
          if (i) return void e(t.id, i);
          o = r;
        } else {
          let e = t.getCurrentSegmentArray(),
            n = 0;
          if (s) for (let t = 0, i = e.length; t < i; ++t) n += e[t].count_old;
          else for (let t = 0, i = e.length; t < i; ++t) n += e[t].count;
          o = new Uint32Array(n);
          let i = 0;
          if (s)
            for (let t = 0, n = e.length; t < n; ++t) {
              let n = e[t];
              {
                let t = r.subarray(n.offset_old, n.offset_old + n.count_old);
                o.set(t, i), (i += n.count_old);
              }
            }
          else
            for (let t = 0, n = e.length; t < n; ++t) {
              let n = e[t],
                s = r.subarray(n.start(), n.end());
              o.set(s, i), (i += n.count);
            }
        }
        let a = new pb(t, e);
        this.workMap.set(a.getID(), a),
          this.computeWireframe.postMessage({
            workID: a.getID(),
            positions: i,
            face: o,
            isccy: s,
          }),
          (this.computeWireframe.onmessage = (t) => {
            let e = this.workMap.get(t.data.workID);
            if (e) {
              let n = t.data.indices,
                i = e.getRenderBuffer();
              i &&
                i.isPMInstanceRenderBuffer &&
                this.refIndicesMap.set(i.getUUID(), n),
                e.finish(n),
                this.workMap.delete(t.data.workID);
            }
          });
      },
    }),
    (mb.prototype = Object.assign(Object.create(ob.prototype), {
      constructor: mb,
      isWireframeScene: !0,
      bindModelEvent: function (t) {
        t &&
          t.isModelScene &&
          (t.bindAddModelEvent((t) => this.onModelAdded(t), !0),
          t.bindRemoveModelEvent((t) => this.onModelRemoved(t), !0));
      },
      onModelAdded: function (t) {
        let e = t.model;
        e && this.bindNodeEvent(e.getSceneNode(), !0);
      },
      onModelRemoved: function (t) {
        let e = t.model;
        e && this.bindNodeEvent(e.getSceneNode(), !1);
      },
      bindNodeEvent: function (t, e) {
        if (t && t.isPMSceneNode) {
          t.bindFlushObjectEvent((t) => this.onSetupObject(t), e),
            t.bindRemoveObjectEvent((t) => this.onRemoveObject(t), e);
          for (let n = 0, i = t.children.length; n < i; ++n)
            this.bindNodeEvent(t.children[n], e);
        }
      },
      onSetupObject: function (t) {
        let e = t.renderObject;
        if (!e || !e.isPMRenderObject) return;
        let n = t.entity;
        (n && !n.getWireVisible()) || this.setupObject(e);
      },
      onRemoveObject: function (t) {
        let e = t.renderObject;
        if (!e || !e.isPMRenderObject) return;
        let n = this.objectMap.get(e.id);
        if (void 0 === n) return;
        let i = n.wireObject;
        i && (i.release(t.gl), this.remove(i)), this.objectMap.delete(e.id);
      },
      setupObject: function (t) {
        void 0 === this.objectMap.get(t.id) &&
          (this.objectMap.set(t.id, {
            renderObject: t,
            wireObject: void 0,
            dirty: !0,
          }),
          t.bindUpdateEvent((t) => this.onUpdateWireframe(t), !0));
      },
      onUpdateWireframe: function (t) {
        let e = t.target;
        if (this.getVisible()) this.updateObjectWireframe(e);
        else {
          let t = this.objectMap.get(e.id);
          void 0 !== t && (t.dirty = !0);
        }
      },
      updateObjectWireframe: function (t) {
        this.wireframeWorker.getWireframe(t, (t, e) => {
          let n = this.objectMap.get(t);
          if (void 0 === n) return;
          let i = n.renderObject,
            r = n.wireObject;
          void 0 === r &&
            ((r = new ub(i.getRenderBuffer(), this.wireMaterial)),
            this.add(r),
            (n.wireObject = r)),
            r.setLineSegmentIndices(e);
          let o = i.getCurrentInstanceVertexArray();
          o && r.setInstanceDrawing(o, i.getNuminstance()),
            (n.dirty = !1),
            this.RenderContext && this.RenderContext.setRequestUpdate(!0);
        });
      },
      setVisible: function (t) {
        t !== this.getVisible() &&
          (ob.prototype.setVisible.call(this, t),
          this.getVisible() &&
            this.objectMap.forEach((t) => {
              t.dirty && this.updateObjectWireframe(t.renderObject);
            }));
      },
    })),
    (bb.prototype = {
      constructor: bb,
      setMeshVisible: function (t) {
        this.meshMaterial.visible = t;
      },
      setColor: function (t, e, n) {
        this.setMeshColor(t, e, n), this.setLineColor(t, e, n);
      },
      setMeshColor: function (t, e, n) {
        this.meshMaterial.color.setRGB(t, e, n),
          this.ccyMaterial.color.setRGB(t, e, n);
      },
      setMeshOpacity: function (t) {
        this.meshMaterial.setOpacity(t);
      },
      setMeshDoubleSide: function (t) {
        this.meshMaterial.side = t ? 2 : 0;
      },
      setMeshVertexOffset: function (t) {
        this.meshMaterial.setVertexOffset(t),
          0 !== t
            ? ((this.meshMaterial.polygonOffset = !0),
              (this.meshMaterial.polygonOffsetFactor = t),
              (this.meshMaterial.polygonOffsetUnits = t))
            : (this.meshMaterial.polygonOffset = !1);
      },
      setLineVisible: function (t) {
        this.lineMaterial.visible = t;
      },
      setLineColor: function (t, e, n) {
        this.lineMaterial.color.setRGB(t, e, n);
      },
      setLineOpacity: function (t) {
        this.lineMaterial.setOpacity(t);
      },
      setLineVertexOffset: function (t, e) {
        this.lineMaterial.setVertexOffset(t, e);
      },
      setClippingPlanes: function (t) {
        (this.meshMaterial.clippingPlanes = t),
          (this.lineMaterial.clippingPlanes = t),
          this.wireMaterial && (this.wireMaterial.clippingPlanes = t);
      },
    }),
    (gb.prototype = Object.assign(Object.create(mb.prototype), {
      constructor: gb,
      isHighlightScene: !0,
      getHighlightStyle: function () {
        return this.highlightStyle;
      },
      insertSelection: function (t) {
        if (!t || !t.isPMEntity) return !1;
        if (void 0 !== this.selectionMap.get(t.getID())) return !1;
        let e = t.clone();
        return (
          this.selectionMap.set(e.getID(), e),
          e.setSelectVisible(!1),
          e.setWireVisible(!1),
          e.setStyle(this.highlightStyle),
          !0
        );
      },
      removeSelection: function (t) {
        let e = this.selectionMap.get(t);
        return !!e && (e.setRenderVisible(!1), this.selectionMap.delete(t), !0);
      },
      clearSelection: function () {
        return (
          0 !== this.selectionMap.size &&
          (this.selectionMap.forEach((t) => {
            t.setRenderVisible(!1);
          }),
          this.selectionMap.clear(),
          !0)
        );
      },
      setMaskObject: function (t) {
        this.maskMaterial.visible = t;
      },
      setWireVisible: function (t) {
        this.wireMaterial.visible = t;
      },
      onSetupObject: function (t) {
        let e = t.renderObject;
        if (!e || !e.isPMRenderObject) return;
        let n = t.entity;
        if (!n)
          return void console.warn('Highlight object need a Entity object.');
        let i = this.selectionMap.get(n.getID());
        if (
          void 0 !== i &&
          i === n &&
          (this.setupObject(e), void 0 === this.maskObjectMap.get(e))
        ) {
          let t = e.clone();
          (t.material = this.maskMaterial),
            this.maskObjectMap.set(e, t),
            e.bindUpdateEvent((t) => this.onUpdateMaskObject(t), !0),
            this.add(t);
        }
      },
      onUpdateMaskObject: function (t) {
        let e = t.target,
          n = this.maskObjectMap.get(e);
        void 0 !== n && (n.copy(e), (n.material = this.maskMaterial));
      },
      onMainCameraChanged: function (t) {
        ob.prototype.onMainCameraChanged.call(this, t),
          this.directionLight.position.subVectors(t.position, t.target),
          this.directionLight.position.normalize();
      },
      render: function (t) {
        t.clearDepth(),
          this.setMaskObject(!0),
          this.setWireVisible(!1),
          t.render(this, this.getCamera()),
          this.setMaskObject(!1),
          this.setWireVisible(!0),
          t.render(this, this.getCamera());
      },
    })),
    (yb.prototype = Object.assign(Object.create(ob.prototype), {
      constructor: yb,
      isIncrementalScene: !0,
      onMainCameraChanged: function (t) {
        ob.prototype.onMainCameraChanged.call(this, t),
          this.directionLight.position.subVectors(t.position, t.target),
          this.directionLight.position.normalize();
      },
    })),
    (vb.prototype = {
      constructor: vb,
      setEnable: function (t) {
        this.enable = t;
      },
      setDepthRange: function (t, e) {
        (this.minDepth = t), (this.maxDepth = e);
      },
    });
  let _b =
      'data:image/jpeg;base64,/9j/4AAQSkZJRgABAgAAZABkAAD/7AARRHVja3kAAQAEAAAAMgAA/+EDL2h0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8APD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo1NjQ2RTdGMjIyOTQxMUU4QTFCNDhCNkI1OTVFM0M0NSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo1NjQ2RTdGMTIyOTQxMUU4QTFCNDhCNkI1OTVFM0M0NSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNyAoV2luZG93cykiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo3MUI3QkYzQkM0MjcxMUU3ODBBNkZDMjZFN0M3MzU1QiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo3MUI3QkYzQ0M0MjcxMUU3ODBBNkZDMjZFN0M3MzU1QiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pv/uAA5BZG9iZQBkwAAAAAH/2wCEAAgGBgYGBggGBggMCAcIDA4KCAgKDhANDQ4NDRARDA4NDQ4MEQ8SExQTEg8YGBoaGBgjIiIiIycnJycnJycnJycBCQgICQoJCwkJCw4LDQsOEQ4ODg4REw0NDg0NExgRDw8PDxEYFhcUFBQXFhoaGBgaGiEhICEhJycnJycnJycnJ//AABEIAIAAgAMBIgACEQEDEQH/xAB9AAEAAgMBAQAAAAAAAAAAAAAAAwQBBgcFAgEBAAAAAAAAAAAAAAAAAAAAABAAAAUBBQQECgkEAwAAAAAAAAECAwQFEXESFAYhUzQHMUEiE1FhMnKyc5OzNTaBkbFS4jN0VRfhQiMWQ1QVEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwDoMOHGOM2ZtkZmQnyUXdEELhWrhOAgyUXdEGSi7ohOACDJRd0QZKLuiE4AIMlF3RBkou6ITgAgyUXdEGSi7ohOACDJRd0QZKLuiE4AIMlF3RBkou6ITgAgyUXdEIJkOMUVwybIjIheFebwrtwDMLhWrhOIIXCtXCcAAAAAAAABmw7LbNnhGAAAGbDsts2H1gMAAAAAAAK83hXbhYFebwrtwDMLhWrhOIIXCtXCcAAAABkunaWwc/1GnmSdalHQVOFS+zlySbJF5Pa8vtdI8vBzg++79ccAquoNSaR1kuRVnlS6ZJ8hsiwtnHt/409S0dfhHT40hiZHalxV95HfSS2nC60n0DkVSofMysJZRVGFSksL7xklmx2VfRZ9QuIZ5utoS22biEJKxKE5ciIi6iIgHTahPiUqE9UJ7hNRmE4lqPr8CS8ZjnOj6zqjUmqZVSZeU1SLbZTCyxNEgtjbTZdS/CZCjOpnNOpxlQ6g2uRHXtU0s45laXQfiMYp9K5pUmImDTW1x4yDM0toNjpPpMzO0zO8B16zxDA5Zg5wffd+uONl0cnWpSJX+1qWbOBOWxm2fat7X5XiAbcAAACvN4V24WBXm8K7cAzC4Vq4TiCFwrVwnAAAAHmairH/AIFHkVbucx3GEu5xYbcR2eVtGifzAn9mP2/4Rs3MT5OqF7fpENf0RqTSlO05HiVWUw1LQtZrQ43iURGey08JgIf5hT+zn7f8IyXOAjMiKjHtMi/P8J2fdGzf7loT/vRfY/hHP+ZFXolXmUpdEeaeQyk0vmyjARKNwjK3YQDsT8hMeIuWsjNDbXfKSnpsw47CHj6a1ZT9VNyHIDLzJRjSSyfIiM8XRhwn4h6FT+Cyf0h+7IaDyf4aree19hgL/MLVNa07NpjFKdbbblNrU8TjaVmZktKSsxdGwxvLSjWy2tXlKQlR3mVo5bze+JUT1TnvEjqMfh2fVo9EgEgAAAK83hXbhYFebwrtwDMLhWrhOIIXCtXCcAAAAavzE+Tqhe36RDWdGaDoNd09Hqc5DxyHFLSo23cKbEnYWywbPzE+Tqhe36RDnuntFahrVJaqFPqaY0Zw1JSybjqTI0nYexGwBvP8WaW3cn239BonMLTNM0zLpjVMS4lMojW73q8e1LhEVngHrfxtq397R7Z8axqvT1V07IhNVWYUxcjtNKJa14SSsiMv8nR9ADt9T+Cyf0h+7IaDyf4aree19hjfqn8Flfoz92Q0Dk8ZHGq1n32vsMBW5vfEqJ6pz3iR1GPw7Pq0eiQ5dze+JUT1TnvEjqMfh2fVo9EgEgAAAK83hXbhYFebwrtwDMLhWrhOIIXCtXCcAAAAavzE+Tqhe36RCPlt8oRPPc9Ie5XKQzXqW/SZDi2Wn8OJxuw1FhO3ZitIfNBorGn6Y1Sozq3mmjUonHLCUeI7duGwgENS1Vp6jyjhVOcmPIJJL7tSVn2VdB2pSZDmHMeu0zUFRpZUd7NJYTgWtKTIjUtwjJKcREZjpNb0bQNQykTao06p9CO7Sppw0FhI7dpEIaboHStKlImxoinH2zxNKfcNwkKL+5KT2WgNkSk8DaDLbgQRkfmlsGtHrrSUd96K7KTEeZUaHUKaNHaSdhl2EnaNmtO23r6Rq07l5pWozH58pl85ElZuOmh5SU4j6bEl0AOf8wK9A1LWKc1R1HIRHT3JOERkS1uLI7EEe3ZYOzNJNDTaFeUlCUneREQ8Gk6J0zRJBS4MQ1SU7W3X1m4aPMxdA2AAAAABXm8K7cLArzeFduAZhcK1cJxBC4Vq4TgAAAAAAAAAAAAAAAAAAAAArzeFduFgV5vCu3AMwuFauE4ow5kUozZG4RGRCbOxd6QCwAr52LvSDOxd6QCwAr52LvSDOxd6QCwAr52LvSDOxd6QCwAr52LvSDOxd6QCwAr52LvSDOxd6QCwAr52LvSDOxd6QCwK83hXbgzsXekIJkyMqM4ROEZmQD//2Q==',
    xb =
      'data:image/jpeg;base64,/9j/4AAQSkZJRgABAgAAZABkAAD/7AARRHVja3kAAQAEAAAAMgAA/+EDL2h0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8APD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo2NzE5RDE2OTIyOTMxMUU4OTIzNzlDRDUwRTQ4NTZDOCIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo2NzE5RDE2ODIyOTMxMUU4OTIzNzlDRDUwRTQ4NTZDOCIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNyAoV2luZG93cykiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo1MkUyM0JCQUM0NDExMUU3QkMyQkE1QjQ3MUZERUEwMSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo1MkUyM0JCQkM0NDExMUU3QkMyQkE1QjQ3MUZERUEwMSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pv/uAA5BZG9iZQBkwAAAAAH/2wCEAAgGBgYGBggGBggMCAcIDA4KCAgKDhANDQ4NDRARDA4NDQ4MEQ8SExQTEg8YGBoaGBgjIiIiIycnJycnJycnJycBCQgICQoJCwkJCw4LDQsOEQ4ODg4REw0NDg0NExgRDw8PDxEYFhcUFBQXFhoaGBgaGiEhICEhJycnJycnJycnJ//AABEIAIAAgAMBIgACEQEDEQH/xAB/AAEBAQEBAQEAAAAAAAAAAAAAAwcGBAUBAQEAAAAAAAAAAAAAAAAAAAAAEAABAwEFBQQHAwgLAAAAAAABAAIDBBESFAUGIXJTNAcxURNVQZHRItKUFXGyFoEyUoKTJBc3YaGxQpKiIzNDc4QRAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhEDEQA/ANBo6OlNLETECSNpV8FScJqUXKRbqughgqThNTBUnCaroghgqThNTBUnCaroghgqThNTBUnCaroghgqThNTBUnCaroghgqThNTBUnCaroghgqThNTBUnCaroghgqThNUKyjpRSykRAEDYV7lCt5SXdQKLlIt1XUKLlIt1XQEREBERAREQEREBERAREQFCt5SXdV1Ct5SXdQKLlIt1XUKLlIt1XQEREAbSuPyrXEmZ6on04aBsTYXzx4kSlxPgEi25cH51neuxHaFhIySbUOtMxyuCobSySVNU8TPDnAXHuNljCDtQbtYUsKyr+EeZ+eQ/spvjT+EeZ+eQ/spvjQas1pc4N7LSB61xuQa4kzvUNRkTqBsDYPG/eBKXk+C67+YWDt+1c43pDmbnBv1yEWmy3wpvT+uvn9N4DS60npXOvugiqYi8bA4sN29t77EGxr4R1ZlI1I7TLpLtUGAiUkXDMduHt/Tu7f6l68/zZmR5PV5o+wmBlsTT/ekd7rG/wCIrOummSOzTManU+YDxfAkIgc/beqX+8+T9QH1oNXREQFCt5SXdV1Ct5SXdQKLlIt1XUKLlIt1XQEREH6O0LItLfzMrf8AvrfvOWujtCxKT8SZLq3MM3y3LJ5X4mpEbn00r43Nke73hdAt2dm1BtiLK/xz1C8mHyVR8SfjnqF5MPkqj4kGrR/7jN4f2rINB/zAr/8A2ffK9TdddQmkOGTC0G0fuVR8Sh09os1bq6Wvr6KenE0VQ975IZI2X5DesBeO87NqD6vV2tdFlmXUDT7s8z55R3iJtjf8zl1Wj8vblmmMspWixzoRPKey183+oSfyELgurjy/Nsph9Dad+zfkHsWqQMEUEUQ2BjGsA3WgIKIiIChW8pLuq6hW8pLuoFFykW6rqFFykW6roCIiAv287vK5DWNBrWsqKV2lap1PCxjhUhs7IbXki6bH9uxc19E6v+ZSfOxexBql53efWl53efWsr+idX/MpPnYvYn0Tq/5lJ87F7EGqXnd59aFxPaSVlf0Tq/5lJ87F7E+idX/MpPnYvYg8/VQX9R5bHb/wMH2XpVrZ7VgmoKXUtJnFHHqmd1RWkRuie6VsxEV/YLzP6fQt7PagIiIChW8pLuq6hW8pLuoFFykW6rqFFykW6roCIiB27AhFltuyztt2Kc8LKiCSnkLgyVpY4sJa4Bwsta5thBHoWSS9O9ZSzzxYu9T33MZLPUvPiR+h7mi8do7QUGtyVFPEA6WaNgOwFz2gW+teabOcnpi0VGYU0RdaWh8zG22dtlrlmMHSTNXNBqMwponW7Qxr5AB32m4vfD0giF7E5sXfoeFAG/bbfc5B20mqNOREB+a0tp2i7K133SVCbWmlKdodLm0FhNgulzzb9kbXLmW9Icnui/mdXf8ASWsiA/IC0r2DpVpcAAyVZNm0+KBae/YEHG67zjLM61FQVWVVDamBkcUbntDgA4SW2e+GlbSe1cfF0x0lEWO8OqfIwhwcahwtINo2AWLsEBERAUK3lJd1XUK3lJd1AouUi3VdQouUi3VdAREQEREBERAREQEREBERAUK3lJd1XUK3lJd1AouUi3VdeGjrKUUsQMoBA2hXxtJxWoLooY2k4rUxtJxWoLooY2k4rUxtJxWoLooY2k4rUxtJxWoLooY2k4rUxtJxWoLooY2k4rUxtJxWoLooY2k4rUxtJxWoLqFbyku6mNpOK1QrKylNLKBKCSNgQf/Z',
    wb =
      'data:image/jpeg;base64,/9j/4AAQSkZJRgABAgAAZABkAAD/7AARRHVja3kAAQAEAAAAMgAA/+EDL2h0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8APD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo2NDM0NTlERDIyOTMxMUU4OTIxMDhENEU2OTEzNkI2QyIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo2NDM0NTlEQzIyOTMxMUU4OTIxMDhENEU2OTEzNkI2QyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNyAoV2luZG93cykiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDoyRURCNTg2NEM0NDExMUU3OURCQUE5NEE2OUNCNjRGOSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDoyRURCNTg2NUM0NDExMUU3OURCQUE5NEE2OUNCNjRGOSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pv/uAA5BZG9iZQBkwAAAAAH/2wCEAAgGBgYGBggGBggMCAcIDA4KCAgKDhANDQ4NDRARDA4NDQ4MEQ8SExQTEg8YGBoaGBgjIiIiIycnJycnJycnJycBCQgICQoJCwkJCw4LDQsOEQ4ODg4REw0NDg0NExgRDw8PDxEYFhcUFBQXFhoaGBgaGiEhICEhJycnJycnJycnJ//AABEIAIAAgAMBIgACEQEDEQH/xAB4AAEBAAMBAQEAAAAAAAAAAAAAAwUGBwQCAQEBAAAAAAAAAAAAAAAAAAAAABAAAAUBBQQFCgUFAAAAAAAAAAECAwQFEXJTFAYhEjQHUTITdDYxQXGxIsJzs8M1YZFCFRaBUmKSVBEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEQMRAD8A6DDhxTitGbRGZltMXyUTCSELhGrouAhkomEkMlEwki4AIZKJhJDJRMJIuACGSiYSQyUTCSLgAhkomEkMlEwki4AIZKJhJDJRMJIuACGSiYSQyUTCSLgAhkomEkQmQ4pRXTJoiMi2GPcITeEdugELhGrouIQuEaui4AAAAAAAAAAAAAAAAAAAAAITeEdui4hN4R26AQuEaui4hC4Rq6LgAAAAOX6k1XrHTuoiflsIRTjI0R46fajvN2273aWW9r6uiwb/AKgqblFoc+rNNJechtdqhlZmlKj3kpsUadpdYYvT1Sa1xp1cirwWUtOPOMLipNS0WN7tiyUv2iV7XmAevT2qaRqVjfgO7khJWvQ3bCdR+Nn6k/5EM0OTV/lxUqQ/+56YdcfabPfSySrJLVxSbN8i/MfdC5pzIqih6kjm+lHsqlNFuPpsxWjsJX9LDAdWH6krVEXSdgx9KrdKrbXa0uW3I6UJOxxN5CrFF+QyKOun0kA0zResZep59RiSYzbCYTZLQps1GajNw29u96BuI5Vyl+8134KPnqHVQAAAAEJvCO3RcQm8I7dAIXCNXRcQhcI1dFwAAABgNc+Dq33b6iBiuVnhIu+SPcGV1z4OrfdvqIGL5WEf8SLvkj3AG5jT+YdGpcnT1QqzsVH7hEbJbMpPsrt30JsWZdYrD843Gw+ga7rwj/h1Z+An5rYDlNH0ZXqtSm67RVpUonXGuyS4bTyTaMtqVbC229IybOs9eaZcJmrtOPNt/pntH5CPGRZ6xuXK7wg33uT60jcyIl2NuES0Ge1CiJSfyPYA4doTU8DTdRnyag24puc2lCTZIlbhk4bhmojMtm3zDqVI1lp2uSERKfKUqUsjNLDjakKMklvK8pWbCIc35fUKl1+pVmNVGO2bZbStmxSkGhRvKSZpNJl5h0Ci6GpFAqZ1OnuPEs0Kb7JxRLSRKs8h7pH5gGzAAAAhN4R26LiE3hHboBC4Rq6LiELhGrouAAAAMBrnwdW+7fUQOVafY1y5Tt7TqpJU/tVlYypJI7XZv7FbbfIOq658HVvu31EDFcrPCRd8ke4A1LK81v75v+7Y8dXj8xEUySqsqlHTiQWaJxaDRubxWbxFt61g7aNe134OrPwE/NbAY7ld4Qb73J9aRuiOun0kNL5XeEG+9yfWkbojrp9JAOUcpfvNd+Cj56h1Ucq5S/ea78FHz1DqoAAAACE3hHbouITeEdugELhGrouIQuEaui4AAAAwGufB1b7t9RAxXKzwkXfJHuDY6/TV1miT6S24TS5jXZJdURmST3kqtMiujx6RoDumqN+1vPpkL7d17tEEaSsc3dlh2+TdAZ0a7rzZo2smeAn5rY2IfLjbbqFNPIS42rYpCyJSTL8UqtIwGn8rTI9Ht2f9cn1pG6I66fSQk0yzHR2cdpDLdpnuNpJCbT8p2JIiFEnYoj6DtAcp5S/ea78FHz1Dqo1DRujZOl51Qlvy25KZqCQlKEmk02OG5ae8Z9I28AAAABCbwjt0XEJvCO3QCFwjV0XEIXCNXRcAAAAAAAAAAAAAAAAAAAAAEJvCO3RcQm8I7dAIXCNXRceGHMilFaI3SIyLaQvnYmKkBcBDOxMVIZ2JipAXAQzsTFSGdiYqQFwEM7ExUhnYmKkBcBDOxMVIZ2JipAXAQzsTFSGdiYqQFwEM7ExUhnYmKkBcQm8I7dDOxMVIhMmRTiukTpGZlsIB/9k=',
    Ab =
      'data:image/jpeg;base64,/9j/4AAQSkZJRgABAgAAZABkAAD/7AARRHVja3kAAQAEAAAAMgAA/+EDL2h0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8APD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo2MEM1REEzMDIyOTMxMUU4OEU0MkM5RTVDNzEwRTQ2QiIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo2MEM1REEyRjIyOTMxMUU4OEU0MkM5RTVDNzEwRTQ2QiIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNyAoV2luZG93cykiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo0MDE1NzE1Q0M0NDExMUU3QTIyMEE2QzU5RUQxREZBRCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo0MDE1NzE1REM0NDExMUU3QTIyMEE2QzU5RUQxREZBRCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pv/uAA5BZG9iZQBkwAAAAAH/2wCEAAgGBgYGBggGBggMCAcIDA4KCAgKDhANDQ4NDRARDA4NDQ4MEQ8SExQTEg8YGBoaGBgjIiIiIycnJycnJycnJycBCQgICQoJCwkJCw4LDQsOEQ4ODg4REw0NDg0NExgRDw8PDxEYFhcUFBQXFhoaGBgaGiEhICEhJycnJycnJycnJ//AABEIAIAAgAMBIgACEQEDEQH/xAB6AAEBAQEBAQEAAAAAAAAAAAAAAwcGAQQFAQEAAAAAAAAAAAAAAAAAAAAAEAABBAADBQQHBQUJAAAAAAAAAQIDBBEFBhJyUxQ0ITETs0FRcSIyBzex0XOEFmHSkxVVkcFCUjNUZJQXEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwDQadOqtWJViRVVO1S/JVOE0Uuki3S4EOSqcJo5KpwmlwBDkqnCaOSqcJpcAQ5KpwmjkqnCaXAEOSqcJo5KpwmlwBDkqnCaOSqcJpcAQ5KpwmjkqnCaXAEOSqcJpC5TqpVlVIkRUTsU+4hd6SXdAUuki3S5Cl0kW6XAAAAAAAAAAAAAAAAAELvSS7pchd6SXdAUuki3S5Cl0kW6XAAAAclnGsp8r1ZT02yoyWO1y+NhXqjm+O5Wrg1Ew93D1nWmV6t+qGU/kPMcBqgwVe4GbfNTMsxoWsobQtzVUlinWRIZHRo5UexEV2wqY4YgaVgvqGC+oyL9L/Mzv52ft/5rv3h+lvmZ/vZ/+6794DXcF9R5gqGFX01rluawZLbzGy27Z8PwmNtPc1fGcrGYu2vWhouiMp1Rlkl9dRzvmbK2JK3iTrPgrVft4Yquz3oB2AAAELvSS7pchd6SXdAUuki3S5Cl0kW6XAAAAZXq36oZT+Q8xxqKSxOldA2RqzNRHOiRybaIvcqt78FMu1b9UMp/IeY4DVDLPm91uSfhT+ZGamZZ83utyT8KfzIwNST4U9ifYenifCnsT7D0DK9Z/UnJ/ZR85xqq96mVaz+pOT+yj5zjVV71A8AAAhd6SXdLkLvSS7oCl0kW6XIUuki3S4AAAZtq/RmpLOcTaiyez40rtnw4Y3LDNG1jUajWOxRHd3rQ4t+cZmmpqGZalSXmaEldJ0fHsS+FC7aTFvu4uwVe30m+mS65qw3/AJjZfSsoroLEdKGVEXBdh73tXBfR3gaZlWc5ZncHMZXZZYYnxtauD2b7F95pnXze63JPwp/MjPmzjQGe6dnXNtMWJZ2RYuRIl2bMbU7e5OyRvs/sOb1Dqe/qRKH8yjY2zQbJG6RibPibbmuxcz/C5NkDf0+FPYn2HpnCfNykiIn8rl7Ew/1G/cP/AF2l/S5f4jfuA+LWf1Jyf2UfOcaqvephOearhzfVFLULKzoo6nL7UDnIrneA9ZFwcnZ24moaV1jBquS42Go+tyiRucr3I7a8RXJ2bPq2QOlAAAhd6SXdLkLvSS7oCl0kW6XIUuki3S4AAADK9W/VDKfyHmONUOKz3SOZ5lrOjqGvJClOtyviNe5ySL4Dlc/BEaqens7QO17lxQ5XVOhcs1E19iHCnmeGLbLE916+qZqd/t7zqgBhdN8mjM1dl+psnhuQPVHSMkja9+z3eLWlXvT9n2Gp5blGjM3px38uy6nPWl+F6QtRUX0tc3DFrk9KKfoZ1keW6gpOo5lFts7Vilb2SRO/zxu9H95yGjdHZ9p3O7Uk1xG5Y33UYztS1inuuVi/ArfSveB1X6W01/SKn8Fv3H1UcqyzLFkXLqcNVZURJFhYjNpG44bWHfhifYAAAAELvSS7pchd6SXdAUuki3S5Cl0kW6XAAAAAAAAAAAAAAAAAELvSS7pchd6SXdAUuki3S58NO5VSrEiyoionahfnanFaBcEOdqcVo52pxWgXBDnanFaOdqcVoFwQ52pxWjnanFaBcEOdqcVo52pxWgXBDnanFaOdqcVoFwQ52pxWjnanFaBchd6SXdHO1OK0hcuVVqyokqKqp2IB/9k=',
    Mb =
      'data:image/jpeg;base64,/9j/4AAQSkZJRgABAgAAZABkAAD/7AARRHVja3kAAQAEAAAAMgAA/+EDL2h0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8APD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo1RDZEMDVCNDIyOTMxMUU4QkU3Qzk5M0YyQkUzNzg3MyIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo1RDZEMDVCMzIyOTMxMUU4QkU3Qzk5M0YyQkUzNzg3MyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNyAoV2luZG93cykiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5RDJEREYyNEM0MjcxMUU3OUU0REIxMThFMzRDRTQ2OSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo5RDJEREYyNUM0MjcxMUU3OUU0REIxMThFMzRDRTQ2OSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pv/uAA5BZG9iZQBkwAAAAAH/2wCEAAgGBgYGBggGBggMCAcIDA4KCAgKDhANDQ4NDRARDA4NDQ4MEQ8SExQTEg8YGBoaGBgjIiIiIycnJycnJycnJycBCQgICQoJCwkJCw4LDQsOEQ4ODg4REw0NDg0NExgRDw8PDxEYFhcUFBQXFhoaGBgaGiEhICEhJycnJycnJycnJ//AABEIAIAAgAMBIgACEQEDEQH/xABzAAEBAQEBAQEAAAAAAAAAAAAAAwcGAQUEAQEAAAAAAAAAAAAAAAAAAAAAEAABAwEFBQUGBQUAAAAAAAAAAQMEAhFyUxQ0IRLSBQaUFVUHFzFxwhOFN1GSk9MWIkIjVCURAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhEDEQA/ANBhw4qxWlVpFVU2qXyUTCpELSNXS4EMlEwqRkomFSXAEMlEwqRkomFSXAEMlEwqRkomFSXAEMlEwqRkomFSXAEMlEwqRkomFSXAEMlEwqRkomFSXAEMlEwqSEyHFSK6qNIiomxT9xCbpHboCFpGrpchC0jV0uAAAAAAAAAAAAAAAAAITdI7dLkJukdugIWkaulyELSNXS4AAAAAAM+k9dc3Z6y/j1LMdYmaoj7601/M3arLVt37Ldv4GgmMT/uf9Qb+EDZ12KqA9X2r7zwAAAAAAEJukdulyE3SO3QELSNXS5CFpGrpcAAAAAAGH8+mN8u8wZE96mqpqNModrpos3lSlEVUptsS03AxLnMZib5jOw5NO+w/NobdotVLaarLUtSxQOxXzZ6fVVXJzPytfuD1Z5B/pzPytfuH1V8u+j7V/wCcv6z3GPTzo/w5f1nuMD5rXmpyF51tmmHMSpyqmhFVGrLals2/5DuTmW/L/pFqulyjl6pXQqVUr853YqLan950wAAACE3SO3S5CbpHboCFpGrpchC0jV0uAAAAAADGJ/3P+oN/CbOYxP8Auf8AUG/hA2hfavvPD1favvPAAAAAAAQm6R26XITdI7dAQtI1dLkIWkaulwAAAz7qbzKk9P8AO5PKG+XMP0sJQqOuPV0VLv0JXtpppVNlp8n1jmeERu0OcJpzvLeWyHFdkQo7ztVm844y3XUtmxLaqqVUn3Pyfw2J2drgAzX1jmeERu0OcJyD/UlT/Un8kVlul359MnLJWq0W02f079ltmw3nufk/hsTs7XAO5+T+GxOztcAGar5xzFW3uiL2hzhHrHM8Ijdoc4TSu5+T+GxOztcA7n5P4bE7O1wAZr6xzPCI3aHOE6jovrZ/qx+Yy7DaipFoorRWnKnFq31Wmxd5Es9h0Xc/J/DYnZ2uAtHhQoi1LEisx1q2VKy3Q2qon47iJaBcAACE3SO3S5CbpHboCFpGrpchC0jV0uAAAAAAAAAAAAAAAAAITdI7dLkJukdugIWkaulz8MOZFSK0iuoiom1C+diYtIFwQzsTFpGdiYtIFwQzsTFpGdiYtIFwQzsTFpGdiYtIFwQzsTFpGdiYtIFwQzsTFpGdiYtIFwQzsTFpGdiYtIFyE3SO3RnYmLSQmTIqxXUR1FVU2IB//9k=',
    Sb =
      'data:image/jpeg;base64,/9j/4AAQSkZJRgABAgAAZABkAAD/7AARRHVja3kAAQAEAAAAMgAA/+EDL2h0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8APD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo1ODFDNzg4ODIyOTMxMUU4OUE3QUQ1NjRGMkM0NEVGRiIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo1ODFDNzg4NzIyOTMxMUU4OUE3QUQ1NjRGMkM0NEVGRiIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNyAoV2luZG93cykiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo3QTQ0Qzk1NEM0NDExMUU3ODk2M0FCOUM4MUQwRDQ5RSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo3QTQ0Qzk1NUM0NDExMUU3ODk2M0FCOUM4MUQwRDQ5RSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pv/uAA5BZG9iZQBkwAAAAAH/2wCEAAgGBgYGBggGBggMCAcIDA4KCAgKDhANDQ4NDRARDA4NDQ4MEQ8SExQTEg8YGBoaGBgjIiIiIycnJycnJycnJycBCQgICQoJCwkJCw4LDQsOEQ4ODg4REw0NDg0NExgRDw8PDxEYFhcUFBQXFhoaGBgaGiEhICEhJycnJycnJycnJ//AABEIAIAAgAMBIgACEQEDEQH/xAB2AAEBAAIDAQEAAAAAAAAAAAAABwUGAgMEAQgBAQAAAAAAAAAAAAAAAAAAAAAQAAEDAgMCCwcDBQAAAAAAAAABAgMEBhEhBRIWMWHSk9NUlLRVdRdBUXEiMhM2sTMHweFScmMRAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhEDEQA/AKeAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkdTetzR3XNprK7CkbqDqdsX2of2knWNG7X29r6fbjiVwglZ+cz+bP7ypewAAAAAAAAAAAAAADUr4u7dyljgola7U6hUWNrk2kZGi/M9ycfAn9jsta99OuJraeXCl1JE+ancuT8EzdCq8Pw4f1A2kAAQSs/OZ/Nn95UvZBKz85n82f3lS9gAAAAAAAAAAAAAGL1u39MuCmWm1GFHKiL9qduUkar7WO/pwEguOytXtuRaqLaqaFrtqOriRUczDNFkambFT38HGXM+KiORWuTFFyVF4FQCWWt/JckCMobiVZY0yZXomL2p/1an1f7Jn8SoU9RBVQsqKaRs0MibTJGKjmqnvRUNGuX+NaHUNur0RW0VUuKup1/YevEifQvwy4jSNLr7qs7VEoI4pGySvRq0EiK6OZVXZTYwyVV/yaoHRWfnM/mz+8qXsgErpX3k99QxI5namqyxtdtI161HzNR2CY4L7cC/gAAAAAAAAAAAAPFrNZLp+k11fCjXS00Ek0bX4q1XMarkR2CouGXvA9oI76r3F1ai5uXph6r3F1ai5uXpgLEdckEEr45JYmPfCquhe5qKrHKmyrmKvAuC4ZEh9V7i6tRc3L0w9V7i6tRc3L0wGGrPzmfzZ/eVL2fm+TUp5dVfrDmsSofULVqxEXY21f93DDHHZx4zbvVe4urUXNy9MBYgR31XuLq1FzcvTD1XuLq1FzcvTAWIGsWRcddcunVFXXRxRyRTLE1IEc1uzsNdntufn8xs4AAAAAAOEsUU8b4ZmNkikRWyRvRHNc1cla5FyVFOYAxm7du+EUXZouQN27d8IouzRcgyYAxm7du+EUXZouQN27d8IouzRcgyYAxm7du+EUXZouQN27d8IouzRcgyYAxm7du+EUXZouQN27d8IouzRcgyYA89JQ0NAx0VDTRUsbl2nMgjbG1XYYYqjETPI9AAAAAAAAAAAAAAAAAAAAAAAAAAH/9k=';
  function Ib(t, e, n, i) {
    let r = new Km();
    r.setAsPerspective(30),
      r.setNearFar(0.1, 1e3),
      ob.call(this, t, e, r, i),
      (this.ambientLight.intensity = 0.5),
      this.camera.setViewSize(this.viewPort.z, this.viewPort.w),
      this.camera.makeLookAt(new J(0, -1, 0), new J(0, 0, 0), new J(0, 0, 1)),
      (this.boxSize = 100),
      (this.boxMesh = void 0),
      (this.highlightFace = { index: -1, mesh: void 0 }),
      (this.viewer = void 0);
  }
  function Eb(t, e, n, i) {
    let r = new Km();
    r.setAsOrthographic(),
      ob.call(this, t, e, r, i),
      (this.directionLight.intensity = 0.5),
      this.directionLight.position.set(0, 0, 1),
      (this.matrixAutoUpdate = !1),
      this.camera.setViewSize(this.viewPort.z, this.viewPort.w),
      this.camera.makeLookAt(new J(0, 0, 1), new J(0, 0, 0), new J(0, 1, 0)),
      (this.sceneData = void 0),
      (this.backgroundColor = new J(1, 1, 1)),
      (this.useMainBackground = !1),
      (this.showCameraType = 0),
      (this.cameraFieldRect = void 0);
    let o = new vb(!0, 0, 0.01);
    (this.cameraFiledMaterial = new xe({
      color: 16711680,
      opacity: 0.3,
      transparent: !0,
    })),
      this.cameraFiledMaterial.setDepthRange(o),
      (this.viewer = void 0);
  }
  (Ib.prototype = Object.assign(Object.create(ob.prototype), {
    constructor: Ib,
    isViewBoxScene: !0,
    onAttached: function (t, e) {
      ob.prototype.onAttached.call(this, t, e);
      let n = e.getTextureLoader().textureLoader,
        i = [
          new ea({ map: n.load(Ab) }),
          new ea({ map: n.load(wb) }),
          new ea({ map: n.load(xb) }),
          new ea({ map: n.load(_b) }),
          new ea({ map: n.load(Mb) }),
          new ea({ map: n.load(Sb) }),
        ];
      (this.boxMesh = new ln(
        new gn(this.boxSize, this.boxSize, this.boxSize),
        i,
      )),
        (this.boxMesh.frustumCulled = !1),
        this.add(this.boxMesh);
      let r = new ea({ color: 10079487 });
      (r.depthRange = new vb(!0, 0, 0.01)),
        (r.opacity = 0.3),
        (r.transparent = !0),
        (this.highlightFace.mesh = new ln(
          new On(this.boxSize, this.boxSize),
          r,
        )),
        (this.highlightFace.mesh.matrixAutoUpdate = !1);
      let o = t.dom;
      o.addEventListener('mousemove', (t) => this.onHover(t), !1),
        o.addEventListener('mousedown', (t) => this.onClick(t), !1),
        (this.viewer = t);
    },
    onDetached: function (t, e) {
      let n = t.dom;
      n.removeEventListener('mousemove', (t) => this.onHover(t), !1),
        n.removeEventListener('mousedown', (t) => this.onClick(t), !1);
    },
    onClick: function (t) {
      this.handleBox(t, !0);
    },
    onHover: function (t) {
      this.handleBox(t, !1);
    },
    onMainCameraChanged: (function () {
      let t = new J();
      return function (e) {
        t.subVectors(e.position, e.target).normalize(),
          this.camera.up.copy(e.up),
          this.camera.position.set(0, 0, 0),
          this.camera.position.addScaledVector(t, 4 * this.boxSize),
          this.camera.update(),
          this.camera.updatePixelVector(),
          this.directionLight.position.copy(this.camera.position).normalize();
      };
    })(),
    render: (function () {
      let t = new W();
      return function (e) {
        if (!this.getVisible()) return;
        e.getViewport(t);
        let n = this.getViewPort();
        e.setViewport(n),
          e.setScissor(n),
          e.clearDepth(),
          e.render(this, this.getCamera()),
          e.setViewport(t),
          e.setScissor(t);
      };
    })(),
    getFaceMatrix: (function () {
      let t = new J();
      return function (e, n) {
        t.set(0, 0, 0),
          t.addScaledVector(e.normalize(), 0.5 * this.boxSize),
          Xf.getCoordinateByRefAxis(t, e, n);
      };
    })(),
    getTargetFace: (function () {
      let t = new U(),
        e = new gl();
      return function (n) {
        let i = this.viewer.getSize(),
          r = this.viewPort,
          o = n.offsetX - r.x,
          s = i.y - n.offsetY - r.y;
        if (o < 0 || o > r.z || s < 0 || s > r.w) return;
        t.set((2 * o) / r.z - 1, (2 * s) / r.w - 1);
        let a = this.getCamera();
        e.setFromCamera(t, a), (e.near = a.near), (e.far = a.far);
        let c = [];
        return (
          this.boxMesh.raycast(e, c),
          0 !== c.length
            ? { index: c[0].face.materialIndex, normal: c[0].face.normal }
            : void 0
        );
      };
    })(),
    handleBox: (function () {
      let t = new J();
      return function (e, n) {
        let i = this.highlightFace,
          r = this.getTargetFace(e);
        if (void 0 !== r) {
          if (
            (r.index !== this.highlightFace.index &&
              ((i.index = r.index),
              this.getFaceMatrix(r.normal, i.mesh.matrix),
              this.add(i.mesh)),
            n)
          ) {
            let e = r.normal,
              n = this.viewer.getMainCamera();
            Xf.isParallelVector3(e, Xf.zAxis)
              ? n.up.set(0, e.dot(Xf.zAxis), 0)
              : (t.crossVectors(Xf.zAxis, e), n.up.crossVectors(e, t)),
              n.position.copy(n.target),
              n.position.addScaledVector(e, 1),
              n.update();
            let i = this.viewer.getModelScene().getBoundingBox();
            n.makeLookAtBoundingBox(i), this.viewer.cameraChanged();
          }
        } else -1 !== i.index && (this.remove(i.mesh), (i.index = -1));
      };
    })(),
  })),
    (Eb.prototype = Object.assign(Object.create(ob.prototype), {
      constructor: Eb,
      isMinimapScene: !0,
      setSceneData: function (t) {
        this.sceneData &&
          (this.remove(this.sceneData), (this.sceneData = void 0)),
          t && t.isModelScene && (this.sceneData = t),
          (this.sceneData = t),
          this.sceneData && this.add(this.sceneData);
      },
      setUseMainBackground: function (t) {
        this.useMainBackground = t;
      },
      setBackgroundColor: function (t, e, n) {
        this.backgroundColor.set(t, e, n);
      },
      isValidSceneData: function () {
        return this.sceneData && this.sceneData.isModelScene;
      },
      setShowCameraType: function (t) {
        t !== this.showCameraType &&
          ((this.showCameraType = t),
          this.cameraFieldRect &&
            1 !== this.showCameraType &&
            (this.remove(this.cameraFieldRect),
            (this.cameraFieldRect = void 0)));
      },
      setCameraFiledColor: function (t, e, n) {
        this.cameraFiledMaterial.color.setRGB(t, e, n);
      },
      onMainCameraChanged: function (t) {
        if (!this.isValidSceneData) return;
        let e = this.sceneData.getBoundingBox();
        if (!e.isEmpty())
          switch (
            (this.camera.makeLookAtBoundingBox(e),
            this.camera.setNearFar(
              this.camera.position.z - e.max.z,
              this.camera.position.z - e.min.z,
            ),
            this.showCameraType)
          ) {
            case 1: {
              if (!this.cameraFieldRect) {
                let t = new Re(
                    new Float32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
                    3,
                  ),
                  e = new He();
                e.setAttribute('position', t),
                  e.setIndex([0, 1, 3, 1, 2, 3]),
                  (this.cameraFieldRect = new ln(e, this.cameraFiledMaterial)),
                  this.add(this.cameraFieldRect);
              }
              let n = 0.5 * (e.max.z + e.min.z),
                i = t.target,
                r = t.computeFieldSize(),
                o = 0.5 * r.width,
                s = 0.5 * r.height,
                a = this.cameraFieldRect.geometry.attributes.position,
                c = a.array;
              (c[0] = -o + i.x),
                (c[1] = -s + i.y),
                (c[2] = n),
                (c[3] = o + i.x),
                (c[4] = -s + i.y),
                (c[5] = n),
                (c[6] = o + i.x),
                (c[7] = s + i.y),
                (c[8] = n),
                (c[9] = -o + i.x),
                (c[10] = s + i.y),
                (c[11] = n),
                (a.needsUpdate = !0);
            }
          }
      },
      render: (function () {
        let t = new W(),
          e = new J(),
          n = new fe();
        return function (i) {
          if (!this.getVisible() || !this.isValidSceneData) return;
          i.getViewport(t);
          let r = this.getViewPort();
          i.setViewport(r),
            i.setScissor(r),
            this.useMainBackground
              ? i.clearDepth()
              : (n.setRGB(
                  255 * this.backgroundColor.x,
                  255 * this.backgroundColor.y,
                  255 * this.backgroundColor.z,
                ),
                i.setClearColor(n),
                i.clear(!0, !0, !1)),
            e.copy(this.sceneData.directionLight.position),
            this.sceneData.directionLight.position.set(0, 0, 1),
            i.render(this.sceneData, this.getCamera()),
            this.cameraFieldRect &&
              i.render(this.cameraFieldRect, this.getCamera()),
            i.setViewport(t),
            i.setScissor(t),
            this.sceneData.directionLight.position.copy(e);
        };
      })(),
      onAttached: function (t, e) {
        ob.prototype.onAttached.call(this, t, e),
          (this.viewer = t),
          this.viewer.dom.addEventListener(
            'mousedown',
            (t) => this.onClick(t),
            !1,
          );
      },
      onDetached: function (t, e) {
        this.viewer.dom.removeEventListener(
          'mousedown',
          (t) => this.onClick(t),
          !1,
        ),
          (this.viewer = void 0);
      },
      onClick: (function () {
        let t = new U(),
          e = new gl(),
          n = new J(),
          i = new Kt(new J(0, 0, 1), 0),
          r = new J();
        return function (o) {
          if (!this.getVisible()) return;
          let s = this.viewer.getSize(),
            a = this.viewPort,
            c = o.offsetX - a.x,
            l = s.y - o.offsetY - a.y;
          if (c < 0 || c > a.z || l < 0 || l > a.w) return;
          t.set((2 * c) / a.z - 1, (2 * l) / a.w - 1);
          let h = this.getCamera();
          if ((e.setFromCamera(t, h), e.ray.intersectPlane(i, n))) {
            let t = this.viewer.getMainCamera();
            r.set(n.x - t.target.x, n.y - t.target.y, 0),
              t.makePan(r),
              this.viewer.cameraChanged();
          }
        };
      })(),
    }));
  let Db = {
      uniforms: { tDiffuse: { value: null }, exposure: { value: 1 } },
      vertexShader: [
        'varying vec2 vUv;',
        'void main() {',
        'vUv = uv;',
        'gl_Position = vec4( position, 1.0 );',
        '}',
      ].join('\n'),
      fragmentShader: [
        'uniform sampler2D tDiffuse;',
        'uniform float exposure;',
        'varying vec2 vUv;',
        'void main( void ) {',
        'gl_FragColor = texture2D( tDiffuse, vUv ) * exposure;',
        '}',
      ].join('\n'),
    },
    Cb = {
      uniforms: {
        tDiffuse: { value: null },
        dDiffuse: { value: null },
        exposure: { value: 1 },
      },
      vertexShader: [
        'varying vec2 vUv;',
        'void main() {',
        'vUv = uv;',
        'gl_Position = vec4( position, 1.0 );',
        '}',
      ].join('\n'),
      fragmentShader: [
        'uniform sampler2D tDiffuse;',
        'uniform sampler2D dDiffuse;',
        'uniform float exposure;',
        'varying vec2 vUv;',
        'void main( void ) {',
        'gl_FragColor = texture2D( tDiffuse, vUv ) * exposure;',
        'gl_FragDepthEXT = texture2D( dDiffuse, vUv ).r;',
        '}',
      ].join('\n'),
    },
    Tb = {
      uniforms: {
        resolution: { value: new U(512, 512) },
        topColor: { value: new J(0.6, 0.8, 1) },
        bottomColor: { value: new J(1, 1, 1) },
      },
      vertexShader: [
        'void main() {',
        'gl_Position = vec4( position, 1.0 );',
        '}',
      ].join('\n'),
      fragmentShader: [
        'uniform vec2 resolution;',
        'uniform vec3 topColor;',
        'uniform vec3 bottomColor;',
        'void main( void ) {',
        'gl_FragColor = vec4(mix(bottomColor, topColor, gl_FragCoord.y / resolution.y), 1.0);',
        '}',
      ].join('\n'),
    },
    Lb = {
      uniforms: { sunPosition: { value: new J(1, 1, 1) }, G: { value: 0.85 } },
      vertexShader: [
        'varying vec3 vPosition;',
        'void main() {',
        'vPosition = vec3(position);',
        'gl_Position = projectionMatrix * mat4(mat3(viewMatrix)) * vec4( position, 1.0 );',
        '}',
      ].join('\n'),
      fragmentShader: [
        'uniform vec3 sunPosition;',
        'uniform float G;',
        'varying vec3 vPosition;',
        'float turbidity = 1.0;',
        'const float mieCoefficient = 0.005;',
        '#define pi 3.141592653589793238462643383279502884197169',
        'const float n = 1.0003;',
        'const float N = 2.545E25;',
        'const vec3 primaryWavelengths = vec3(680E-9, 550E-9, 450E-9);',
        'const vec3 K = vec3(0.686, 0.678, 0.666);',
        'const float v = 4.0;',
        'const float rayleighZenithLength = 8.4E3;',
        'const float mieZenithLength = 1.25E3;',
        'const float sunIntensity = 1000.0;',
        'const float sunAngularDiameterCos = 0.99983194915;',
        'const float cutoffAngle = pi/1.95;',
        'const float steepness = 1.5;',
        'float RayleighPhase(float cosViewSunAngle)',
        '{',
        'return (3.0 / (16.0*pi)) * (1.0 + pow(cosViewSunAngle, 2.0));',
        '}',
        'vec3 totalMie(vec3 primaryWavelengths, vec3 K, float T)',
        '{',
        'float c = (0.2 * T ) * 10E-18;',
        'return 0.434 * c * pi * pow((2.0 * pi) / primaryWavelengths, vec3(v - 2.0)) * K;',
        '}',
        'float hgPhase(float cosViewSunAngle, float g)',
        '{',
        'return (1.0 / (4.0*pi)) * ((1.0 - pow(g, 2.0)) / pow(1.0 - 2.0*g*cosViewSunAngle + pow(g, 2.0), 1.5));',
        '}',
        'float SunIntensity(float zenithAngleCos)',
        '{',
        'return sunIntensity * max(0.0, 1.0 - exp(-((cutoffAngle - acos(zenithAngleCos))/steepness)));',
        '}',
        'vec3 calculateAtmosphericScattering()',
        '{',
        'vec3 sunPos = normalize(sunPosition);',
        'vec3 viewDir = normalize(vec3(vPosition.x, vPosition.y, vPosition.z));',
        'vec3 up = vec3(0.0, 0.0, 1.0);',
        'float cosViewSunAngle = dot(viewDir, sunPos);',
        'float cosSunUpAngle = dot(sunPos, up);',
        'vec3 rayleighAtX = vec3(5.176821E-6, 1.2785348E-5, 4.8530756E-5);',
        'vec3 mieAtX = totalMie(primaryWavelengths, K, turbidity) * mieCoefficient;',
        'float zenithAngle = max(0.0, vPosition.z);',
        'float rayleighOpticalLength = rayleighZenithLength / zenithAngle;',
        'float mieOpticalLength = mieZenithLength / zenithAngle;',
        'float sunAngle = max(0.0, cosSunUpAngle * 0.8 + 0.2);',
        'float rayleighOpticalLength0 = rayleighZenithLength / sunAngle;',
        'float mieOpticalLength0 = mieZenithLength / sunAngle;',
        'vec3 Fex = exp(-(rayleighAtX * rayleighOpticalLength + mieAtX * mieOpticalLength));',
        'vec3 Fex0 = exp(-(rayleighAtX * rayleighOpticalLength0 + mieAtX * mieOpticalLength0));',
        'vec3 rayleighXtoEye = rayleighAtX * RayleighPhase(cosViewSunAngle);',
        'vec3 mieXtoEye = mieAtX * hgPhase(cosViewSunAngle, G) * Fex0;',
        'vec3 totalLightAtX = rayleighAtX + mieAtX;',
        'vec3 lightFromXtoEye = rayleighXtoEye + mieXtoEye;',
        'float sunE = SunIntensity(cosSunUpAngle);',
        'vec3 somethingElse = sunE * (lightFromXtoEye / totalLightAtX);',
        'vec3 sky = somethingElse * (1.0 - Fex);',
        'sky *= mix(vec3(1.0),pow(somethingElse * Fex,vec3(0.5)),clamp(pow(1.0-dot(up, sunPos),5.0),0.0,1.0));',
        'float sundisk = smoothstep(sunAngularDiameterCos,sunAngularDiameterCos+0.00002,cosViewSunAngle);',
        'vec3 sun = (sunE * 19000.0 * Fex)*sundisk;',
        'vec3 finalColor = pow(0.02 * (sky+sun), vec3(1.0/2.4));',
        'return finalColor;',
        '}',
        'void main( void ) {',
        'gl_FragColor = vec4(calculateAtmosphericScattering(), 1.0);',
        '}',
      ].join('\n'),
    };
  function Rb() {
    (this.enabled = !0),
      (this.needsSwap = !0),
      (this.clear = !1),
      (this.renderToScreen = !1);
  }
  var Fb, Pb, Bb;
  function Ob(t, e, n, i) {
    ob.call(this, t, e, n, i),
      (this.camera = n.clone()),
      (this.camera.near = 0.001),
      (this.camera.far = 10),
      this.camera.updateProjectionMatrix(),
      (this.uniforms = xn.clone(Tb.uniforms)),
      this.uniforms.resolution.value.set(t, e);
    let r = new wn({
      uniforms: this.uniforms,
      vertexShader: Tb.vertexShader,
      fragmentShader: Tb.fragmentShader,
    });
    (this.gradient = new ln(new On(2, 2), r)),
      (this.gradient.name = 'pm_background_gradient'),
      (this.gradient.frustumCulled = !1);
    let o = new wn({
      uniforms: xn.clone(Lb.uniforms),
      vertexShader: Lb.vertexShader,
      fragmentShader: Lb.fragmentShader,
    });
    (o.side = 2),
      (this.atmosphericScattering = new ln(new Ps(1, 20, 20), o)),
      (this.atmosphericScattering.frustumCulled = !1);
  }
  Object.assign(Rb.prototype, {
    setSize: function () {},
    render: function () {
      console.error(
        'THREE.Pass: .render() must be implemented in derived pass.',
      );
    },
  }),
    (Rb.FullScreenQuad =
      ((Fb = new dc(-1, 1, 1, -1, 0, 1)),
      (Pb = new On(2, 2)),
      (Bb = function (t) {
        this._mesh = new ln(Pb, t);
      }),
      Object.defineProperty(Bb.prototype, 'material', {
        get: function () {
          return this._mesh.material;
        },
        set: function (t) {
          this._mesh.material = t;
        },
      }),
      Object.assign(Bb.prototype, {
        dispose: function () {
          this._mesh.geometry.dispose();
        },
        render: function (t) {
          t.render(this._mesh, Fb);
        },
      }),
      Bb)),
    (Ob.prototype = Object.assign(Object.create(ob.prototype), {
      constructor: Ob,
      onMainWindowSizeChanged: function (t, e) {
        ob.prototype.onMainWindowSizeChanged.call(this, t, e),
          this.uniforms.resolution.value.set(t, e);
      },
      onMainCameraChanged: (function () {
        let t = new J();
        return function (e) {
          t.subVectors(e.target, e.position).normalize(),
            this.camera.up.copy(e.up),
            this.camera.position.set(0, 0, 0),
            this.camera.lookAt(t);
        };
      })(),
      setColor: function (t, e) {
        this.getObjectByName('pm_background_gradient') ||
          this.add(this.gradient),
          this.uniforms.topColor.value.copy(t),
          this.uniforms.bottomColor.value.copy(e);
      },
      buildRenderCommand: function (t, e) {
        e.push_back(new qm(!0, !0, !0)),
          ob.prototype.buildRenderCommand.call(this, t, e),
          e.push_back(new qm(!1, !0, !0));
      },
      render: function (t) {
        t.clear(!0, !0, !0),
          t.setClearAlpha(0),
          ob.prototype.render.call(this, t),
          t.clear(!1, !0, !0);
      },
    }));
  var Vb = Vb || {};
  (Vb.EntInfo = function () {
    (this.bb = null), (this.bb_pos = 0);
  }),
    (Vb.EntInfo.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (Vb.EntInfo.getRootAsEntInfo = function (t, e) {
      return (e || new Vb.EntInfo()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (Vb.EntInfo.prototype.id = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Vb.EntInfo.prototype.flootID = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Vb.EntInfo.prototype.comtype = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Vb.EntInfo.prototype.comID = function () {
      var t = this.bb.__offset(this.bb_pos, 10);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Vb.EntInfo.prototype.handle = function (t) {
      var e = this.bb.__offset(this.bb_pos, 12);
      return e ? this.bb.__string(this.bb_pos + e, t) : null;
    }),
    (Vb.EntInfo.prototype.selectAbility = function () {
      var t = this.bb.__offset(this.bb_pos, 14);
      return !!t && !!this.bb.readInt8(this.bb_pos + t);
    }),
    (Vb.EntInfo.prototype.stageArray = function (t) {
      var e = this.bb.__offset(this.bb_pos, 16);
      return e
        ? this.bb.readInt32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (Vb.EntInfo.prototype.stageArrayLength = function () {
      var t = this.bb.__offset(this.bb_pos, 16);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Vb.EntInfo.prototype.stageArrayArray = function () {
      var t = this.bb.__offset(this.bb_pos, 16);
      return t
        ? new Int32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (Vb.EntInfo.startEntInfo = function (t) {
      t.startObject(7);
    }),
    (Vb.EntInfo.addId = function (t, e) {
      t.addFieldInt32(0, e, 0);
    }),
    (Vb.EntInfo.addFlootID = function (t, e) {
      t.addFieldInt32(1, e, 0);
    }),
    (Vb.EntInfo.addComtype = function (t, e) {
      t.addFieldInt32(2, e, 0);
    }),
    (Vb.EntInfo.addComID = function (t, e) {
      t.addFieldInt32(3, e, 0);
    }),
    (Vb.EntInfo.addHandle = function (t, e) {
      t.addFieldOffset(4, e, 0);
    }),
    (Vb.EntInfo.addSelectAbility = function (t, e) {
      t.addFieldInt8(5, +e, 0);
    }),
    (Vb.EntInfo.addStageArray = function (t, e) {
      t.addFieldOffset(6, e, 0);
    }),
    (Vb.EntInfo.createStageArrayVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addInt32(e[n]);
      return t.endVector();
    }),
    (Vb.EntInfo.startStageArrayVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Vb.EntInfo.endEntInfo = function (t) {
      return t.endObject();
    }),
    (Vb.EntInfoDataFile = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (Vb.EntInfoDataFile.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (Vb.EntInfoDataFile.getRootAsEntInfoDataFile = function (t, e) {
      return (e || new Vb.EntInfoDataFile()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (Vb.EntInfoDataFile.prototype.entInfoArray = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 4);
      return n
        ? (e || new Vb.EntInfo()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (Vb.EntInfoDataFile.prototype.entInfoArrayLength = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Vb.EntInfoDataFile.startEntInfoDataFile = function (t) {
      t.startObject(1);
    }),
    (Vb.EntInfoDataFile.addEntInfoArray = function (t, e) {
      t.addFieldOffset(0, e, 0);
    }),
    (Vb.EntInfoDataFile.createEntInfoArrayVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (Vb.EntInfoDataFile.startEntInfoArrayVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Vb.EntInfoDataFile.endEntInfoDataFile = function (t) {
      return t.endObject();
    }),
    (Vb.MeshData = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (Vb.MeshData.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (Vb.MeshData.getRootAsMeshData = function (t, e) {
      return (e || new Vb.MeshData()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (Vb.MeshData.prototype.entID = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Vb.MeshData.prototype.bndBoxMin = function (t) {
      var e = this.bb.__offset(this.bb_pos, 6);
      return e
        ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (Vb.MeshData.prototype.bndBoxMinLength = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Vb.MeshData.prototype.bndBoxMinArray = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t
        ? new Float32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (Vb.MeshData.prototype.bndBoxMax = function (t) {
      var e = this.bb.__offset(this.bb_pos, 8);
      return e
        ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (Vb.MeshData.prototype.bndBoxMaxLength = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Vb.MeshData.prototype.bndBoxMaxArray = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t
        ? new Float32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (Vb.MeshData.prototype.geoID = function () {
      var t = this.bb.__offset(this.bb_pos, 10);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Vb.MeshData.prototype.vertexOffset = function () {
      var t = this.bb.__offset(this.bb_pos, 12);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Vb.MeshData.prototype.vertexCount = function () {
      var t = this.bb.__offset(this.bb_pos, 14);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Vb.MeshData.prototype.vertexParamsOffset = function () {
      var t = this.bb.__offset(this.bb_pos, 16);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Vb.MeshData.prototype.vertexParamsCount = function () {
      var t = this.bb.__offset(this.bb_pos, 18);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Vb.MeshData.prototype.trianglesOffset = function () {
      var t = this.bb.__offset(this.bb_pos, 20);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Vb.MeshData.prototype.trianglesCount = function () {
      var t = this.bb.__offset(this.bb_pos, 22);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Vb.MeshData.startMeshData = function (t) {
      t.startObject(10);
    }),
    (Vb.MeshData.addEntID = function (t, e) {
      t.addFieldInt32(0, e, 0);
    }),
    (Vb.MeshData.addBndBoxMin = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (Vb.MeshData.createBndBoxMinVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addFloat32(e[n]);
      return t.endVector();
    }),
    (Vb.MeshData.startBndBoxMinVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Vb.MeshData.addBndBoxMax = function (t, e) {
      t.addFieldOffset(2, e, 0);
    }),
    (Vb.MeshData.createBndBoxMaxVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addFloat32(e[n]);
      return t.endVector();
    }),
    (Vb.MeshData.startBndBoxMaxVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Vb.MeshData.addGeoID = function (t, e) {
      t.addFieldInt32(3, e, 0);
    }),
    (Vb.MeshData.addVertexOffset = function (t, e) {
      t.addFieldInt32(4, e, 0);
    }),
    (Vb.MeshData.addVertexCount = function (t, e) {
      t.addFieldInt32(5, e, 0);
    }),
    (Vb.MeshData.addVertexParamsOffset = function (t, e) {
      t.addFieldInt32(6, e, 0);
    }),
    (Vb.MeshData.addVertexParamsCount = function (t, e) {
      t.addFieldInt32(7, e, 0);
    }),
    (Vb.MeshData.addTrianglesOffset = function (t, e) {
      t.addFieldInt32(8, e, 0);
    }),
    (Vb.MeshData.addTrianglesCount = function (t, e) {
      t.addFieldInt32(9, e, 0);
    }),
    (Vb.MeshData.endMeshData = function (t) {
      return t.endObject();
    }),
    (Vb.LineData = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (Vb.LineData.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (Vb.LineData.getRootAsLineData = function (t, e) {
      return (e || new Vb.LineData()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (Vb.LineData.prototype.entID = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Vb.LineData.prototype.bndBoxMin = function (t) {
      var e = this.bb.__offset(this.bb_pos, 6);
      return e
        ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (Vb.LineData.prototype.bndBoxMinLength = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Vb.LineData.prototype.bndBoxMinArray = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t
        ? new Float32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (Vb.LineData.prototype.bndBoxMax = function (t) {
      var e = this.bb.__offset(this.bb_pos, 8);
      return e
        ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (Vb.LineData.prototype.bndBoxMaxLength = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Vb.LineData.prototype.bndBoxMaxArray = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t
        ? new Float32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (Vb.LineData.prototype.geoID = function () {
      var t = this.bb.__offset(this.bb_pos, 10);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Vb.LineData.prototype.vertexOffset = function () {
      var t = this.bb.__offset(this.bb_pos, 12);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Vb.LineData.prototype.vertexCount = function () {
      var t = this.bb.__offset(this.bb_pos, 14);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Vb.LineData.prototype.lineSegOffset = function () {
      var t = this.bb.__offset(this.bb_pos, 16);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Vb.LineData.prototype.lineSegCount = function () {
      var t = this.bb.__offset(this.bb_pos, 18);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Vb.LineData.startLineData = function (t) {
      t.startObject(8);
    }),
    (Vb.LineData.addEntID = function (t, e) {
      t.addFieldInt32(0, e, 0);
    }),
    (Vb.LineData.addBndBoxMin = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (Vb.LineData.createBndBoxMinVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addFloat32(e[n]);
      return t.endVector();
    }),
    (Vb.LineData.startBndBoxMinVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Vb.LineData.addBndBoxMax = function (t, e) {
      t.addFieldOffset(2, e, 0);
    }),
    (Vb.LineData.createBndBoxMaxVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addFloat32(e[n]);
      return t.endVector();
    }),
    (Vb.LineData.startBndBoxMaxVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Vb.LineData.addGeoID = function (t, e) {
      t.addFieldInt32(3, e, 0);
    }),
    (Vb.LineData.addVertexOffset = function (t, e) {
      t.addFieldInt32(4, e, 0);
    }),
    (Vb.LineData.addVertexCount = function (t, e) {
      t.addFieldInt32(5, e, 0);
    }),
    (Vb.LineData.addLineSegOffset = function (t, e) {
      t.addFieldInt32(6, e, 0);
    }),
    (Vb.LineData.addLineSegCount = function (t, e) {
      t.addFieldInt32(7, e, 0);
    }),
    (Vb.LineData.endLineData = function (t) {
      return t.endObject();
    }),
    (Vb.PointData = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (Vb.PointData.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (Vb.PointData.getRootAsPointData = function (t, e) {
      return (e || new Vb.PointData()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (Vb.PointData.prototype.entID = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Vb.PointData.prototype.bndBoxMin = function (t) {
      var e = this.bb.__offset(this.bb_pos, 6);
      return e
        ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (Vb.PointData.prototype.bndBoxMinLength = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Vb.PointData.prototype.bndBoxMinArray = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t
        ? new Float32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (Vb.PointData.prototype.bndBoxMax = function (t) {
      var e = this.bb.__offset(this.bb_pos, 8);
      return e
        ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (Vb.PointData.prototype.bndBoxMaxLength = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Vb.PointData.prototype.bndBoxMaxArray = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t
        ? new Float32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (Vb.PointData.prototype.geoID = function () {
      var t = this.bb.__offset(this.bb_pos, 10);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Vb.PointData.prototype.vertexOffset = function () {
      var t = this.bb.__offset(this.bb_pos, 12);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Vb.PointData.prototype.vertexCount = function () {
      var t = this.bb.__offset(this.bb_pos, 14);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Vb.PointData.prototype.pointOffset = function () {
      var t = this.bb.__offset(this.bb_pos, 16);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Vb.PointData.prototype.pointCount = function () {
      var t = this.bb.__offset(this.bb_pos, 18);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Vb.PointData.startPointData = function (t) {
      t.startObject(8);
    }),
    (Vb.PointData.addEntID = function (t, e) {
      t.addFieldInt32(0, e, 0);
    }),
    (Vb.PointData.addBndBoxMin = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (Vb.PointData.createBndBoxMinVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addFloat32(e[n]);
      return t.endVector();
    }),
    (Vb.PointData.startBndBoxMinVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Vb.PointData.addBndBoxMax = function (t, e) {
      t.addFieldOffset(2, e, 0);
    }),
    (Vb.PointData.createBndBoxMaxVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addFloat32(e[n]);
      return t.endVector();
    }),
    (Vb.PointData.startBndBoxMaxVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Vb.PointData.addGeoID = function (t, e) {
      t.addFieldInt32(3, e, 0);
    }),
    (Vb.PointData.addVertexOffset = function (t, e) {
      t.addFieldInt32(4, e, 0);
    }),
    (Vb.PointData.addVertexCount = function (t, e) {
      t.addFieldInt32(5, e, 0);
    }),
    (Vb.PointData.addPointOffset = function (t, e) {
      t.addFieldInt32(6, e, 0);
    }),
    (Vb.PointData.addPointCount = function (t, e) {
      t.addFieldInt32(7, e, 0);
    }),
    (Vb.PointData.endPointData = function (t) {
      return t.endObject();
    }),
    (Vb.InstanceMeshData = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (Vb.InstanceMeshData.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (Vb.InstanceMeshData.getRootAsInstanceMeshData = function (t, e) {
      return (e || new Vb.InstanceMeshData()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (Vb.InstanceMeshData.prototype.entID = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Vb.InstanceMeshData.prototype.bndBoxMin = function (t) {
      var e = this.bb.__offset(this.bb_pos, 6);
      return e
        ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (Vb.InstanceMeshData.prototype.bndBoxMinLength = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Vb.InstanceMeshData.prototype.bndBoxMinArray = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t
        ? new Float32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (Vb.InstanceMeshData.prototype.bndBoxMax = function (t) {
      var e = this.bb.__offset(this.bb_pos, 8);
      return e
        ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (Vb.InstanceMeshData.prototype.bndBoxMaxLength = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Vb.InstanceMeshData.prototype.bndBoxMaxArray = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t
        ? new Float32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (Vb.InstanceMeshData.prototype.geoID = function () {
      var t = this.bb.__offset(this.bb_pos, 10);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Vb.InstanceMeshData.prototype.matrixIndex = function () {
      var t = this.bb.__offset(this.bb_pos, 12);
      return t ? this.bb.readUint32(this.bb_pos + t) : 0;
    }),
    (Vb.InstanceMeshData.prototype.instancedRefDefinitionID = function () {
      var t = this.bb.__offset(this.bb_pos, 14);
      return t ? this.bb.readUint32(this.bb_pos + t) : 0;
    }),
    (Vb.InstanceMeshData.startInstanceMeshData = function (t) {
      t.startObject(6);
    }),
    (Vb.InstanceMeshData.addEntID = function (t, e) {
      t.addFieldInt32(0, e, 0);
    }),
    (Vb.InstanceMeshData.addBndBoxMin = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (Vb.InstanceMeshData.createBndBoxMinVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addFloat32(e[n]);
      return t.endVector();
    }),
    (Vb.InstanceMeshData.startBndBoxMinVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Vb.InstanceMeshData.addBndBoxMax = function (t, e) {
      t.addFieldOffset(2, e, 0);
    }),
    (Vb.InstanceMeshData.createBndBoxMaxVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addFloat32(e[n]);
      return t.endVector();
    }),
    (Vb.InstanceMeshData.startBndBoxMaxVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Vb.InstanceMeshData.addGeoID = function (t, e) {
      t.addFieldInt32(3, e, 0);
    }),
    (Vb.InstanceMeshData.addMatrixIndex = function (t, e) {
      t.addFieldInt32(4, e, 0);
    }),
    (Vb.InstanceMeshData.addInstancedRefDefinitionID = function (t, e) {
      t.addFieldInt32(5, e, 0);
    }),
    (Vb.InstanceMeshData.endInstanceMeshData = function (t) {
      return t.endObject();
    }),
    (Vb.InstanceLineData = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (Vb.InstanceLineData.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (Vb.InstanceLineData.getRootAsInstanceLineData = function (t, e) {
      return (e || new Vb.InstanceLineData()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (Vb.InstanceLineData.prototype.entID = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Vb.InstanceLineData.prototype.bndBoxMin = function (t) {
      var e = this.bb.__offset(this.bb_pos, 6);
      return e
        ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (Vb.InstanceLineData.prototype.bndBoxMinLength = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Vb.InstanceLineData.prototype.bndBoxMinArray = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t
        ? new Float32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (Vb.InstanceLineData.prototype.bndBoxMax = function (t) {
      var e = this.bb.__offset(this.bb_pos, 8);
      return e
        ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (Vb.InstanceLineData.prototype.bndBoxMaxLength = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Vb.InstanceLineData.prototype.bndBoxMaxArray = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t
        ? new Float32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (Vb.InstanceLineData.prototype.geoID = function () {
      var t = this.bb.__offset(this.bb_pos, 10);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Vb.InstanceLineData.prototype.matrixIndex = function () {
      var t = this.bb.__offset(this.bb_pos, 12);
      return t ? this.bb.readUint32(this.bb_pos + t) : 0;
    }),
    (Vb.InstanceLineData.prototype.instancedRefDefinitionID = function () {
      var t = this.bb.__offset(this.bb_pos, 14);
      return t ? this.bb.readUint32(this.bb_pos + t) : 0;
    }),
    (Vb.InstanceLineData.startInstanceLineData = function (t) {
      t.startObject(6);
    }),
    (Vb.InstanceLineData.addEntID = function (t, e) {
      t.addFieldInt32(0, e, 0);
    }),
    (Vb.InstanceLineData.addBndBoxMin = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (Vb.InstanceLineData.createBndBoxMinVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addFloat32(e[n]);
      return t.endVector();
    }),
    (Vb.InstanceLineData.startBndBoxMinVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Vb.InstanceLineData.addBndBoxMax = function (t, e) {
      t.addFieldOffset(2, e, 0);
    }),
    (Vb.InstanceLineData.createBndBoxMaxVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addFloat32(e[n]);
      return t.endVector();
    }),
    (Vb.InstanceLineData.startBndBoxMaxVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Vb.InstanceLineData.addGeoID = function (t, e) {
      t.addFieldInt32(3, e, 0);
    }),
    (Vb.InstanceLineData.addMatrixIndex = function (t, e) {
      t.addFieldInt32(4, e, 0);
    }),
    (Vb.InstanceLineData.addInstancedRefDefinitionID = function (t, e) {
      t.addFieldInt32(5, e, 0);
    }),
    (Vb.InstanceLineData.endInstanceLineData = function (t) {
      return t.endObject();
    }),
    (Vb.CenterLineCylinderData = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (Vb.CenterLineCylinderData.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (Vb.CenterLineCylinderData.getRootAsCenterLineCylinderData = function (
      t,
      e,
    ) {
      return (e || new Vb.CenterLineCylinderData()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (Vb.CenterLineCylinderData.prototype.entID = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Vb.CenterLineCylinderData.prototype.bndBoxMin = function (t) {
      var e = this.bb.__offset(this.bb_pos, 6);
      return e
        ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (Vb.CenterLineCylinderData.prototype.bndBoxMinLength = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Vb.CenterLineCylinderData.prototype.bndBoxMinArray = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t
        ? new Float32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (Vb.CenterLineCylinderData.prototype.bndBoxMax = function (t) {
      var e = this.bb.__offset(this.bb_pos, 8);
      return e
        ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (Vb.CenterLineCylinderData.prototype.bndBoxMaxLength = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Vb.CenterLineCylinderData.prototype.bndBoxMaxArray = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t
        ? new Float32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (Vb.CenterLineCylinderData.prototype.geoID = function () {
      var t = this.bb.__offset(this.bb_pos, 10);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Vb.CenterLineCylinderData.prototype.vertexOffset = function () {
      var t = this.bb.__offset(this.bb_pos, 12);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Vb.CenterLineCylinderData.prototype.vertexCount = function () {
      var t = this.bb.__offset(this.bb_pos, 14);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Vb.CenterLineCylinderData.prototype.indeciesOffset = function () {
      var t = this.bb.__offset(this.bb_pos, 16);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Vb.CenterLineCylinderData.prototype.indeciesCount = function () {
      var t = this.bb.__offset(this.bb_pos, 18);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Vb.CenterLineCylinderData.prototype.radiusOffset = function () {
      var t = this.bb.__offset(this.bb_pos, 20);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Vb.CenterLineCylinderData.prototype.radiusCount = function () {
      var t = this.bb.__offset(this.bb_pos, 22);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Vb.CenterLineCylinderData.prototype.lineCountBefore = function () {
      var t = this.bb.__offset(this.bb_pos, 24);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Vb.CenterLineCylinderData.prototype.lineCountThis = function () {
      var t = this.bb.__offset(this.bb_pos, 26);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Vb.CenterLineCylinderData.startCenterLineCylinderData = function (t) {
      t.startObject(12);
    }),
    (Vb.CenterLineCylinderData.addEntID = function (t, e) {
      t.addFieldInt32(0, e, 0);
    }),
    (Vb.CenterLineCylinderData.addBndBoxMin = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (Vb.CenterLineCylinderData.createBndBoxMinVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addFloat32(e[n]);
      return t.endVector();
    }),
    (Vb.CenterLineCylinderData.startBndBoxMinVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Vb.CenterLineCylinderData.addBndBoxMax = function (t, e) {
      t.addFieldOffset(2, e, 0);
    }),
    (Vb.CenterLineCylinderData.createBndBoxMaxVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addFloat32(e[n]);
      return t.endVector();
    }),
    (Vb.CenterLineCylinderData.startBndBoxMaxVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Vb.CenterLineCylinderData.addGeoID = function (t, e) {
      t.addFieldInt32(3, e, 0);
    }),
    (Vb.CenterLineCylinderData.addVertexOffset = function (t, e) {
      t.addFieldInt32(4, e, 0);
    }),
    (Vb.CenterLineCylinderData.addVertexCount = function (t, e) {
      t.addFieldInt32(5, e, 0);
    }),
    (Vb.CenterLineCylinderData.addIndeciesOffset = function (t, e) {
      t.addFieldInt32(6, e, 0);
    }),
    (Vb.CenterLineCylinderData.addIndeciesCount = function (t, e) {
      t.addFieldInt32(7, e, 0);
    }),
    (Vb.CenterLineCylinderData.addRadiusOffset = function (t, e) {
      t.addFieldInt32(8, e, 0);
    }),
    (Vb.CenterLineCylinderData.addRadiusCount = function (t, e) {
      t.addFieldInt32(9, e, 0);
    }),
    (Vb.CenterLineCylinderData.addLineCountBefore = function (t, e) {
      t.addFieldInt32(10, e, 0);
    }),
    (Vb.CenterLineCylinderData.addLineCountThis = function (t, e) {
      t.addFieldInt32(11, e, 0);
    }),
    (Vb.CenterLineCylinderData.endCenterLineCylinderData = function (t) {
      return t.endObject();
    }),
    (Vb.EntDataDataFile = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (Vb.EntDataDataFile.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (Vb.EntDataDataFile.getRootAsEntDataDataFile = function (t, e) {
      return (e || new Vb.EntDataDataFile()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (Vb.EntDataDataFile.prototype.meshDataArray = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 4);
      return n
        ? (e || new Vb.MeshData()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (Vb.EntDataDataFile.prototype.meshDataArrayLength = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Vb.EntDataDataFile.prototype.instanceMeshDataArray = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 6);
      return n
        ? (e || new Vb.InstanceMeshData()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (Vb.EntDataDataFile.prototype.instanceMeshDataArrayLength = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Vb.EntDataDataFile.prototype.lineDataArray = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 8);
      return n
        ? (e || new Vb.LineData()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (Vb.EntDataDataFile.prototype.lineDataArrayLength = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Vb.EntDataDataFile.prototype.InstanceLineDataArray = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 10);
      return n
        ? (e || new Vb.InstanceLineData()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (Vb.EntDataDataFile.prototype.InstanceLineDataArrayLength = function () {
      var t = this.bb.__offset(this.bb_pos, 10);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Vb.EntDataDataFile.prototype.pointDataArray = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 12);
      return n
        ? (e || new Vb.PointData()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (Vb.EntDataDataFile.prototype.pointDataArrayLength = function () {
      var t = this.bb.__offset(this.bb_pos, 12);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Vb.EntDataDataFile.prototype.centerLineCylinderDataArray = function (
      t,
      e,
    ) {
      var n = this.bb.__offset(this.bb_pos, 14);
      return n
        ? (e || new Vb.CenterLineCylinderData()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (Vb.EntDataDataFile.prototype.centerLineCylinderDataArrayLength =
      function () {
        var t = this.bb.__offset(this.bb_pos, 14);
        return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
      }),
    (Vb.EntDataDataFile.startEntDataDataFile = function (t) {
      t.startObject(6);
    }),
    (Vb.EntDataDataFile.addMeshDataArray = function (t, e) {
      t.addFieldOffset(0, e, 0);
    }),
    (Vb.EntDataDataFile.createMeshDataArrayVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (Vb.EntDataDataFile.startMeshDataArrayVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Vb.EntDataDataFile.addInstanceMeshDataArray = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (Vb.EntDataDataFile.createInstanceMeshDataArrayVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (Vb.EntDataDataFile.startInstanceMeshDataArrayVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Vb.EntDataDataFile.addLineDataArray = function (t, e) {
      t.addFieldOffset(2, e, 0);
    }),
    (Vb.EntDataDataFile.createLineDataArrayVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (Vb.EntDataDataFile.startLineDataArrayVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Vb.EntDataDataFile.addInstanceLineDataArray = function (t, e) {
      t.addFieldOffset(3, e, 0);
    }),
    (Vb.EntDataDataFile.createInstanceLineDataArrayVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (Vb.EntDataDataFile.startInstanceLineDataArrayVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Vb.EntDataDataFile.addPointDataArray = function (t, e) {
      t.addFieldOffset(4, e, 0);
    }),
    (Vb.EntDataDataFile.createPointDataArrayVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (Vb.EntDataDataFile.startPointDataArrayVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Vb.EntDataDataFile.addCenterLineCylinderDataArray = function (t, e) {
      t.addFieldOffset(5, e, 0);
    }),
    (Vb.EntDataDataFile.createCenterLineCylinderDataArrayVector = function (
      t,
      e,
    ) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (Vb.EntDataDataFile.startCenterLineCylinderDataArrayVector = function (
      t,
      e,
    ) {
      t.startVector(4, e, 4);
    }),
    (Vb.EntDataDataFile.endEntDataDataFile = function (t) {
      return t.endObject();
    });
  var Nb = Nb || {};
  (Nb.BufferType = {
    UNKNOWN: 0,
    0: 'UNKNOWN',
    INT8: 1,
    1: 'INT8',
    UINT8: 2,
    2: 'UINT8',
    INT16: 3,
    3: 'INT16',
    UINT16: 4,
    4: 'UINT16',
    INT32: 5,
    5: 'INT32',
    UINT32: 6,
    6: 'UINT32',
    FLOAT32: 7,
    7: 'FLOAT32',
  }),
    (Nb.VertexAttribute = {
      UNKNOWN: 0,
      0: 'UNKNOWN',
      INDEX: 1,
      1: 'INDEX',
      POSITION: 2,
      2: 'POSITION',
      NORMAL: 3,
      3: 'NORMAL',
      COLOR: 4,
      4: 'COLOR',
      TEXTUREPARAM: 5,
      5: 'TEXTUREPARAM',
      INSTANCEMATR1: 6,
      6: 'INSTANCEMATR1',
      INSTANCEMATR2: 7,
      7: 'INSTANCEMATR2',
      INSTANCEMATR3: 8,
      8: 'INSTANCEMATR3',
      INSTANCEMATR4: 9,
      9: 'INSTANCEMATR4',
      CENTERLINECYLINDERRADIUS: 10,
      10: 'CENTERLINECYLINDERRADIUS',
    }),
    (Nb.GeometryType = {
      UNKNOWN: 0,
      0: 'UNKNOWN',
      POINT: 1,
      1: 'POINT',
      LINES: 2,
      2: 'LINES',
      LINE_STRIP: 3,
      3: 'LINE_STRIP',
      LINE_LOOP: 4,
      4: 'LINE_LOOP',
      TRIANGLES: 5,
      5: 'TRIANGLES',
      TRIANGLE_STRIP: 6,
      6: 'TRIANGLE_STRIP',
      TRIANGLE_FAN: 7,
      7: 'TRIANGLE_FAN',
      INSTANCE_MESH: 8,
      8: 'INSTANCE_MESH',
      CENTRELINE_MESH: 9,
      9: 'CENTRELINE_MESH',
    }),
    (Nb.BufferData = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (Nb.BufferData.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (Nb.BufferData.getRootAsBufferData = function (t, e) {
      return (e || new Nb.BufferData()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (Nb.BufferData.prototype.type = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readInt8(this.bb_pos + t) : Nb.BufferType.UNKNOWN;
    }),
    (Nb.BufferData.prototype.data = function (t) {
      var e = this.bb.__offset(this.bb_pos, 6);
      return e ? this.bb.readUint8(this.bb.__vector(this.bb_pos + e) + t) : 0;
    }),
    (Nb.BufferData.prototype.dataLength = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Nb.BufferData.prototype.dataArray = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t
        ? new Uint8Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (Nb.BufferData.startBufferData = function (t) {
      t.startObject(2);
    }),
    (Nb.BufferData.addType = function (t, e) {
      t.addFieldInt8(0, e, Nb.BufferType.UNKNOWN);
    }),
    (Nb.BufferData.addData = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (Nb.BufferData.createDataVector = function (t, e) {
      t.startVector(1, e.length, 1);
      for (var n = e.length - 1; n >= 0; n--) t.addInt8(e[n]);
      return t.endVector();
    }),
    (Nb.BufferData.startDataVector = function (t, e) {
      t.startVector(1, e, 1);
    }),
    (Nb.BufferData.endBufferData = function (t) {
      return t.endObject();
    }),
    (Nb.BufferAttribute = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (Nb.BufferAttribute.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (Nb.BufferAttribute.getRootAsBufferAttribute = function (t, e) {
      return (e || new Nb.BufferAttribute()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (Nb.BufferAttribute.prototype.type = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readInt8(this.bb_pos + t) : Nb.VertexAttribute.UNKNOWN;
    }),
    (Nb.BufferAttribute.prototype.buffer = function (t) {
      var e = this.bb.__offset(this.bb_pos, 6);
      return e
        ? (t || new Nb.BufferData()).__init(
            this.bb.__indirect(this.bb_pos + e),
            this.bb,
          )
        : null;
    }),
    (Nb.BufferAttribute.prototype.elementPerVertex = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t ? this.bb.readUint8(this.bb_pos + t) : 0;
    }),
    (Nb.BufferAttribute.prototype.instanceAttribute = function () {
      var t = this.bb.__offset(this.bb_pos, 10);
      return !!t && !!this.bb.readInt8(this.bb_pos + t);
    }),
    (Nb.BufferAttribute.startBufferAttribute = function (t) {
      t.startObject(4);
    }),
    (Nb.BufferAttribute.addType = function (t, e) {
      t.addFieldInt8(0, e, Nb.VertexAttribute.UNKNOWN);
    }),
    (Nb.BufferAttribute.addBuffer = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (Nb.BufferAttribute.addElementPerVertex = function (t, e) {
      t.addFieldInt8(2, e, 0);
    }),
    (Nb.BufferAttribute.addInstanceAttribute = function (t, e) {
      t.addFieldInt8(3, +e, 0);
    }),
    (Nb.BufferAttribute.endBufferAttribute = function (t) {
      return t.endObject();
    }),
    (Nb.BufferGeometry = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (Nb.BufferGeometry.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (Nb.BufferGeometry.getRootAsBufferGeometry = function (t, e) {
      return (e || new Nb.BufferGeometry()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (Nb.BufferGeometry.prototype.uuid = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Nb.BufferGeometry.prototype.type = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t ? this.bb.readInt8(this.bb_pos + t) : Nb.GeometryType.UNKNOWN;
    }),
    (Nb.BufferGeometry.prototype.vertexAttributeArray = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 8);
      return n
        ? (e || new Nb.BufferAttribute()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (Nb.BufferGeometry.prototype.vertexAttributeArrayLength = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Nb.BufferGeometry.prototype.materialID = function () {
      var t = this.bb.__offset(this.bb_pos, 10);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Nb.BufferGeometry.prototype.backMaterialID = function () {
      var t = this.bb.__offset(this.bb_pos, 12);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Nb.BufferGeometry.startBufferGeometry = function (t) {
      t.startObject(5);
    }),
    (Nb.BufferGeometry.addUuid = function (t, e) {
      t.addFieldInt32(0, e, 0);
    }),
    (Nb.BufferGeometry.addType = function (t, e) {
      t.addFieldInt8(1, e, Nb.GeometryType.UNKNOWN);
    }),
    (Nb.BufferGeometry.addVertexAttributeArray = function (t, e) {
      t.addFieldOffset(2, e, 0);
    }),
    (Nb.BufferGeometry.createVertexAttributeArrayVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (Nb.BufferGeometry.startVertexAttributeArrayVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Nb.BufferGeometry.addMaterialID = function (t, e) {
      t.addFieldInt32(3, e, 0);
    }),
    (Nb.BufferGeometry.addBackMaterialID = function (t, e) {
      t.addFieldInt32(4, e, 0);
    }),
    (Nb.BufferGeometry.endBufferGeometry = function (t) {
      return t.endObject();
    }),
    (Nb.RefDefinition = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (Nb.RefDefinition.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (Nb.RefDefinition.getRootAsRefDefinition = function (t, e) {
      return (e || new Nb.RefDefinition()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (Nb.RefDefinition.prototype.uuid = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Nb.RefDefinition.prototype.bufferGeometryArray = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 6);
      return n
        ? (e || new Nb.BufferGeometry()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (Nb.RefDefinition.prototype.bufferGeometryArrayLength = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Nb.RefDefinition.startRefDefinition = function (t) {
      t.startObject(2);
    }),
    (Nb.RefDefinition.addUuid = function (t, e) {
      t.addFieldInt32(0, e, 0);
    }),
    (Nb.RefDefinition.addBufferGeometryArray = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (Nb.RefDefinition.createBufferGeometryArrayVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (Nb.RefDefinition.startBufferGeometryArrayVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Nb.RefDefinition.endRefDefinition = function (t) {
      return t.endObject();
    }),
    (Nb.RefDefinitionDataFile = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (Nb.RefDefinitionDataFile.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (Nb.RefDefinitionDataFile.getRootAsRefDefinitionDataFile = function (t, e) {
      return (e || new Nb.RefDefinitionDataFile()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (Nb.RefDefinitionDataFile.prototype.refDefinitionArray = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 4);
      return n
        ? (e || new Nb.RefDefinition()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (Nb.RefDefinitionDataFile.prototype.refDefinitionArrayLength = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Nb.RefDefinitionDataFile.startRefDefinitionDataFile = function (t) {
      t.startObject(1);
    }),
    (Nb.RefDefinitionDataFile.addRefDefinitionArray = function (t, e) {
      t.addFieldOffset(0, e, 0);
    }),
    (Nb.RefDefinitionDataFile.createRefDefinitionArrayVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (Nb.RefDefinitionDataFile.startRefDefinitionArrayVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Nb.RefDefinitionDataFile.endRefDefinitionDataFile = function (t) {
      return t.endObject();
    }),
    (Nb.InstanceBufferGeometry = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (Nb.InstanceBufferGeometry.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (Nb.InstanceBufferGeometry.getRootAsInstanceBufferGeometry = function (
      t,
      e,
    ) {
      return (e || new Nb.InstanceBufferGeometry()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (Nb.InstanceBufferGeometry.prototype.uuid = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Nb.InstanceBufferGeometry.prototype.type = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t ? this.bb.readInt8(this.bb_pos + t) : Nb.GeometryType.UNKNOWN;
    }),
    (Nb.InstanceBufferGeometry.prototype.vertexAttributeArray = function (
      t,
      e,
    ) {
      var n = this.bb.__offset(this.bb_pos, 8);
      return n
        ? (e || new Nb.BufferAttribute()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (Nb.InstanceBufferGeometry.prototype.vertexAttributeArrayLength =
      function () {
        var t = this.bb.__offset(this.bb_pos, 8);
        return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
      }),
    (Nb.InstanceBufferGeometry.prototype.refID = function () {
      var t = this.bb.__offset(this.bb_pos, 10);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Nb.InstanceBufferGeometry.startInstanceBufferGeometry = function (t) {
      t.startObject(4);
    }),
    (Nb.InstanceBufferGeometry.addUuid = function (t, e) {
      t.addFieldInt32(0, e, 0);
    }),
    (Nb.InstanceBufferGeometry.addType = function (t, e) {
      t.addFieldInt8(1, e, Nb.GeometryType.UNKNOWN);
    }),
    (Nb.InstanceBufferGeometry.addVertexAttributeArray = function (t, e) {
      t.addFieldOffset(2, e, 0);
    }),
    (Nb.InstanceBufferGeometry.createVertexAttributeArrayVector = function (
      t,
      e,
    ) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (Nb.InstanceBufferGeometry.startVertexAttributeArrayVector = function (
      t,
      e,
    ) {
      t.startVector(4, e, 4);
    }),
    (Nb.InstanceBufferGeometry.addRefID = function (t, e) {
      t.addFieldInt32(3, e, 0);
    }),
    (Nb.InstanceBufferGeometry.endInstanceBufferGeometry = function (t) {
      return t.endObject();
    }),
    (Nb.BufferGeometryDataFile = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (Nb.BufferGeometryDataFile.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (Nb.BufferGeometryDataFile.getRootAsBufferGeometryDataFile = function (
      t,
      e,
    ) {
      return (e || new Nb.BufferGeometryDataFile()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (Nb.BufferGeometryDataFile.prototype.bufferGeometryArray = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 4);
      return n
        ? (e || new Nb.BufferGeometry()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (Nb.BufferGeometryDataFile.prototype.bufferGeometryArrayLength =
      function () {
        var t = this.bb.__offset(this.bb_pos, 4);
        return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
      }),
    (Nb.BufferGeometryDataFile.prototype.instanceBufferGeometryArray =
      function (t, e) {
        var n = this.bb.__offset(this.bb_pos, 6);
        return n
          ? (e || new Nb.InstanceBufferGeometry()).__init(
              this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
              this.bb,
            )
          : null;
      }),
    (Nb.BufferGeometryDataFile.prototype.instanceBufferGeometryArrayLength =
      function () {
        var t = this.bb.__offset(this.bb_pos, 6);
        return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
      }),
    (Nb.BufferGeometryDataFile.startBufferGeometryDataFile = function (t) {
      t.startObject(2);
    }),
    (Nb.BufferGeometryDataFile.addBufferGeometryArray = function (t, e) {
      t.addFieldOffset(0, e, 0);
    }),
    (Nb.BufferGeometryDataFile.createBufferGeometryArrayVector = function (
      t,
      e,
    ) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (Nb.BufferGeometryDataFile.startBufferGeometryArrayVector = function (
      t,
      e,
    ) {
      t.startVector(4, e, 4);
    }),
    (Nb.BufferGeometryDataFile.addInstanceBufferGeometryArray = function (
      t,
      e,
    ) {
      t.addFieldOffset(1, e, 0);
    }),
    (Nb.BufferGeometryDataFile.createInstanceBufferGeometryArrayVector =
      function (t, e) {
        t.startVector(4, e.length, 4);
        for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
        return t.endVector();
      }),
    (Nb.BufferGeometryDataFile.startInstanceBufferGeometryArrayVector =
      function (t, e) {
        t.startVector(4, e, 4);
      }),
    (Nb.BufferGeometryDataFile.endBufferGeometryDataFile = function (t) {
      return t.endObject();
    }),
    (Nb.Image = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (Nb.Image.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (Nb.Image.getRootAsImage = function (t, e) {
      return (e || new Nb.Image()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (Nb.Image.prototype.uuid = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Nb.Image.prototype.url = function (t) {
      var e = this.bb.__offset(this.bb_pos, 6);
      return e ? this.bb.__string(this.bb_pos + e, t) : null;
    }),
    (Nb.Image.prototype.isUserImage = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return !!t && !!this.bb.readInt8(this.bb_pos + t);
    }),
    (Nb.Image.startImage = function (t) {
      t.startObject(3);
    }),
    (Nb.Image.addUuid = function (t, e) {
      t.addFieldInt32(0, e, 0);
    }),
    (Nb.Image.addUrl = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (Nb.Image.addIsUserImage = function (t, e) {
      t.addFieldInt8(2, +e, 0);
    }),
    (Nb.Image.endImage = function (t) {
      return t.endObject();
    }),
    (Nb.Material = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (Nb.Material.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (Nb.Material.getRootAsMaterial = function (t, e) {
      return (e || new Nb.Material()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (Nb.Material.prototype.uuid = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Nb.Material.prototype.image = function (t) {
      var e = this.bb.__offset(this.bb_pos, 6);
      return e
        ? (t || new Nb.Image()).__init(
            this.bb.__indirect(this.bb_pos + e),
            this.bb,
          )
        : null;
    }),
    (Nb.Material.prototype.lightType = function (t) {
      var e = this.bb.__offset(this.bb_pos, 8);
      return e ? this.bb.__string(this.bb_pos + e, t) : null;
    }),
    (Nb.Material.prototype.color = function (t) {
      var e = this.bb.__offset(this.bb_pos, 10);
      return e ? this.bb.__string(this.bb_pos + e, t) : null;
    }),
    (Nb.Material.prototype.transparency = function () {
      var t = this.bb.__offset(this.bb_pos, 12);
      return t ? this.bb.readFloat32(this.bb_pos + t) : 0;
    }),
    (Nb.Material.prototype.enableTransparent = function () {
      var t = this.bb.__offset(this.bb_pos, 14);
      return !!t && !!this.bb.readInt8(this.bb_pos + t);
    }),
    (Nb.Material.prototype.depthFunc = function () {
      var t = this.bb.__offset(this.bb_pos, 16);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Nb.Material.prototype.polygonOffsetFactor = function () {
      var t = this.bb.__offset(this.bb_pos, 18);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Nb.Material.prototype.polygonOffsetUnits = function () {
      var t = this.bb.__offset(this.bb_pos, 20);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Nb.Material.prototype.enablePolygonOffset = function () {
      var t = this.bb.__offset(this.bb_pos, 22);
      return !!t && !!this.bb.readInt8(this.bb_pos + t);
    }),
    (Nb.Material.prototype.doubleSide = function () {
      var t = this.bb.__offset(this.bb_pos, 24);
      return !!t && !!this.bb.readInt8(this.bb_pos + t);
    }),
    (Nb.Material.startMaterial = function (t) {
      t.startObject(11);
    }),
    (Nb.Material.addUuid = function (t, e) {
      t.addFieldInt32(0, e, 0);
    }),
    (Nb.Material.addImage = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (Nb.Material.addLightType = function (t, e) {
      t.addFieldOffset(2, e, 0);
    }),
    (Nb.Material.addColor = function (t, e) {
      t.addFieldOffset(3, e, 0);
    }),
    (Nb.Material.addTransparency = function (t, e) {
      t.addFieldFloat32(4, e, 0);
    }),
    (Nb.Material.addEnableTransparent = function (t, e) {
      t.addFieldInt8(5, +e, 0);
    }),
    (Nb.Material.addDepthFunc = function (t, e) {
      t.addFieldInt32(6, e, 0);
    }),
    (Nb.Material.addPolygonOffsetFactor = function (t, e) {
      t.addFieldInt32(7, e, 0);
    }),
    (Nb.Material.addPolygonOffsetUnits = function (t, e) {
      t.addFieldInt32(8, e, 0);
    }),
    (Nb.Material.addEnablePolygonOffset = function (t, e) {
      t.addFieldInt8(9, +e, 0);
    }),
    (Nb.Material.addDoubleSide = function (t, e) {
      t.addFieldInt8(10, +e, 0);
    }),
    (Nb.Material.endMaterial = function (t) {
      return t.endObject();
    }),
    (Nb.MaterialDataFile = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (Nb.MaterialDataFile.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (Nb.MaterialDataFile.getRootAsMaterialDataFile = function (t, e) {
      return (e || new Nb.MaterialDataFile()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (Nb.MaterialDataFile.prototype.materialArray = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 4);
      return n
        ? (e || new Nb.Material()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (Nb.MaterialDataFile.prototype.materialArrayLength = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Nb.MaterialDataFile.startMaterialDataFile = function (t) {
      t.startObject(1);
    }),
    (Nb.MaterialDataFile.addMaterialArray = function (t, e) {
      t.addFieldOffset(0, e, 0);
    }),
    (Nb.MaterialDataFile.createMaterialArrayVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (Nb.MaterialDataFile.startMaterialArrayVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Nb.MaterialDataFile.endMaterialDataFile = function (t) {
      return t.endObject();
    }),
    (Nb.BufferDataFile = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (Nb.BufferDataFile.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (Nb.BufferDataFile.getRootAsBufferDataFile = function (t, e) {
      return (e || new Nb.BufferDataFile()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (Nb.BufferDataFile.prototype.uuid = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Nb.BufferDataFile.prototype.buffer = function (t) {
      var e = this.bb.__offset(this.bb_pos, 6);
      return e ? this.bb.readUint8(this.bb.__vector(this.bb_pos + e) + t) : 0;
    }),
    (Nb.BufferDataFile.prototype.bufferLength = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Nb.BufferDataFile.prototype.bufferArray = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t
        ? new Uint8Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (Nb.BufferDataFile.startBufferDataFile = function (t) {
      t.startObject(2);
    }),
    (Nb.BufferDataFile.addUuid = function (t, e) {
      t.addFieldInt32(0, e, 0);
    }),
    (Nb.BufferDataFile.addBuffer = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (Nb.BufferDataFile.createBufferVector = function (t, e) {
      t.startVector(1, e.length, 1);
      for (var n = e.length - 1; n >= 0; n--) t.addInt8(e[n]);
      return t.endVector();
    }),
    (Nb.BufferDataFile.startBufferVector = function (t, e) {
      t.startVector(1, e, 1);
    }),
    (Nb.BufferDataFile.endBufferDataFile = function (t) {
      return t.endObject();
    }),
    (Nb.ModelDataFile = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (Nb.ModelDataFile.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (Nb.ModelDataFile.getRootAsModelDataFile = function (t, e) {
      return (e || new Nb.ModelDataFile()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (Nb.ModelDataFile.prototype.version = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Nb.ModelDataFile.prototype.materialArray = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 6);
      return n
        ? (e || new Nb.Material()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (Nb.ModelDataFile.prototype.materialArrayLength = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Nb.ModelDataFile.prototype.refDefinitionArray = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 8);
      return n
        ? (e || new Nb.RefDefinition()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (Nb.ModelDataFile.prototype.refDefinitionArrayLength = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Nb.ModelDataFile.prototype.bufferGeometryArray = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 10);
      return n
        ? (e || new Nb.BufferGeometry()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (Nb.ModelDataFile.prototype.bufferGeometryArrayLength = function () {
      var t = this.bb.__offset(this.bb_pos, 10);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Nb.ModelDataFile.prototype.instanceGeometryArray = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 12);
      return n
        ? (e || new Nb.InstanceBufferGeometry()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (Nb.ModelDataFile.prototype.instanceGeometryArrayLength = function () {
      var t = this.bb.__offset(this.bb_pos, 12);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Nb.ModelDataFile.prototype.bndBoxMin = function (t) {
      var e = this.bb.__offset(this.bb_pos, 14);
      return e
        ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (Nb.ModelDataFile.prototype.bndBoxMinLength = function () {
      var t = this.bb.__offset(this.bb_pos, 14);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Nb.ModelDataFile.prototype.bndBoxMinArray = function () {
      var t = this.bb.__offset(this.bb_pos, 14);
      return t
        ? new Float32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (Nb.ModelDataFile.prototype.bndBoxMax = function (t) {
      var e = this.bb.__offset(this.bb_pos, 16);
      return e
        ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (Nb.ModelDataFile.prototype.bndBoxMaxLength = function () {
      var t = this.bb.__offset(this.bb_pos, 16);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Nb.ModelDataFile.prototype.bndBoxMaxArray = function () {
      var t = this.bb.__offset(this.bb_pos, 16);
      return t
        ? new Float32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (Nb.ModelDataFile.startModelDataFile = function (t) {
      t.startObject(7);
    }),
    (Nb.ModelDataFile.addVersion = function (t, e) {
      t.addFieldInt32(0, e, 0);
    }),
    (Nb.ModelDataFile.addMaterialArray = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (Nb.ModelDataFile.createMaterialArrayVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (Nb.ModelDataFile.startMaterialArrayVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Nb.ModelDataFile.addRefDefinitionArray = function (t, e) {
      t.addFieldOffset(2, e, 0);
    }),
    (Nb.ModelDataFile.createRefDefinitionArrayVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (Nb.ModelDataFile.startRefDefinitionArrayVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Nb.ModelDataFile.addBufferGeometryArray = function (t, e) {
      t.addFieldOffset(3, e, 0);
    }),
    (Nb.ModelDataFile.createBufferGeometryArrayVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (Nb.ModelDataFile.startBufferGeometryArrayVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Nb.ModelDataFile.addInstanceGeometryArray = function (t, e) {
      t.addFieldOffset(4, e, 0);
    }),
    (Nb.ModelDataFile.createInstanceGeometryArrayVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (Nb.ModelDataFile.startInstanceGeometryArrayVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Nb.ModelDataFile.addBndBoxMin = function (t, e) {
      t.addFieldOffset(5, e, 0);
    }),
    (Nb.ModelDataFile.createBndBoxMinVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addFloat32(e[n]);
      return t.endVector();
    }),
    (Nb.ModelDataFile.startBndBoxMinVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Nb.ModelDataFile.addBndBoxMax = function (t, e) {
      t.addFieldOffset(6, e, 0);
    }),
    (Nb.ModelDataFile.createBndBoxMaxVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addFloat32(e[n]);
      return t.endVector();
    }),
    (Nb.ModelDataFile.startBndBoxMaxVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Nb.ModelDataFile.endModelDataFile = function (t) {
      return t.endObject();
    });
  var kb = kb || {};
  (kb.AxisSymbol = function () {
    (this.bb = null), (this.bb_pos = 0);
  }),
    (kb.AxisSymbol.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (kb.AxisSymbol.getRootAsAxisSymbol = function (t, e) {
      return (e || new kb.AxisSymbol()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (kb.AxisSymbol.prototype.name = function (t) {
      var e = this.bb.__offset(this.bb_pos, 4);
      return e ? this.bb.__string(this.bb_pos + e, t) : null;
    }),
    (kb.AxisSymbol.prototype.position = function (t) {
      var e = this.bb.__offset(this.bb_pos, 6);
      return e
        ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (kb.AxisSymbol.prototype.positionLength = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (kb.AxisSymbol.prototype.positionArray = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t
        ? new Float32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (kb.AxisSymbol.prototype.textHeight = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t ? this.bb.readFloat32(this.bb_pos + t) : 0;
    }),
    (kb.AxisSymbol.prototype.textRoundRadius = function () {
      var t = this.bb.__offset(this.bb_pos, 10);
      return t ? this.bb.readFloat32(this.bb_pos + t) : 0;
    }),
    (kb.AxisSymbol.startAxisSymbol = function (t) {
      t.startObject(4);
    }),
    (kb.AxisSymbol.addName = function (t, e) {
      t.addFieldOffset(0, e, 0);
    }),
    (kb.AxisSymbol.addPosition = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (kb.AxisSymbol.createPositionVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addFloat32(e[n]);
      return t.endVector();
    }),
    (kb.AxisSymbol.startPositionVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (kb.AxisSymbol.addTextHeight = function (t, e) {
      t.addFieldFloat32(2, e, 0);
    }),
    (kb.AxisSymbol.addTextRoundRadius = function (t, e) {
      t.addFieldFloat32(3, e, 0);
    }),
    (kb.AxisSymbol.endAxisSymbol = function (t) {
      return t.endObject();
    }),
    (kb.AxisLine = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (kb.AxisLine.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (kb.AxisLine.getRootAsAxisLine = function (t, e) {
      return (e || new kb.AxisLine()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (kb.AxisLine.prototype.symbol = function (t) {
      var e = this.bb.__offset(this.bb_pos, 4);
      return e
        ? (t || new kb.AxisSymbol()).__init(
            this.bb.__indirect(this.bb_pos + e),
            this.bb,
          )
        : null;
    }),
    (kb.AxisLine.prototype.start = function (t) {
      var e = this.bb.__offset(this.bb_pos, 6);
      return e
        ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (kb.AxisLine.prototype.startLength = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (kb.AxisLine.prototype.startArray = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t
        ? new Float32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (kb.AxisLine.prototype.end = function (t) {
      var e = this.bb.__offset(this.bb_pos, 8);
      return e
        ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (kb.AxisLine.prototype.endLength = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (kb.AxisLine.prototype.endArray = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t
        ? new Float32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (kb.AxisLine.startAxisLine = function (t) {
      t.startObject(3);
    }),
    (kb.AxisLine.addSymbol = function (t, e) {
      t.addFieldOffset(0, e, 0);
    }),
    (kb.AxisLine.addStart = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (kb.AxisLine.createStartVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addFloat32(e[n]);
      return t.endVector();
    }),
    (kb.AxisLine.startStartVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (kb.AxisLine.addEnd = function (t, e) {
      t.addFieldOffset(2, e, 0);
    }),
    (kb.AxisLine.createEndVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addFloat32(e[n]);
      return t.endVector();
    }),
    (kb.AxisLine.startEndVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (kb.AxisLine.endAxisLine = function (t) {
      return t.endObject();
    }),
    (kb.AxisArc = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (kb.AxisArc.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (kb.AxisArc.getRootAsAxisArc = function (t, e) {
      return (e || new kb.AxisArc()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (kb.AxisArc.prototype.symbol = function (t) {
      var e = this.bb.__offset(this.bb_pos, 4);
      return e
        ? (t || new kb.AxisSymbol()).__init(
            this.bb.__indirect(this.bb_pos + e),
            this.bb,
          )
        : null;
    }),
    (kb.AxisArc.prototype.center = function (t) {
      var e = this.bb.__offset(this.bb_pos, 6);
      return e
        ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (kb.AxisArc.prototype.centerLength = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (kb.AxisArc.prototype.centerArray = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t
        ? new Float32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (kb.AxisArc.prototype.radiu = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t ? this.bb.readFloat32(this.bb_pos + t) : 0;
    }),
    (kb.AxisArc.prototype.startAngle = function () {
      var t = this.bb.__offset(this.bb_pos, 10);
      return t ? this.bb.readFloat32(this.bb_pos + t) : 0;
    }),
    (kb.AxisArc.prototype.endAngle = function () {
      var t = this.bb.__offset(this.bb_pos, 12);
      return t ? this.bb.readFloat32(this.bb_pos + t) : 0;
    }),
    (kb.AxisArc.prototype.antiClockWise = function (t) {
      var e = this.bb.__offset(this.bb_pos, 14);
      return e ? this.bb.__string(this.bb_pos + e, t) : null;
    }),
    (kb.AxisArc.startAxisArc = function (t) {
      t.startObject(6);
    }),
    (kb.AxisArc.addSymbol = function (t, e) {
      t.addFieldOffset(0, e, 0);
    }),
    (kb.AxisArc.addCenter = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (kb.AxisArc.createCenterVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addFloat32(e[n]);
      return t.endVector();
    }),
    (kb.AxisArc.startCenterVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (kb.AxisArc.addRadiu = function (t, e) {
      t.addFieldFloat32(2, e, 0);
    }),
    (kb.AxisArc.addStartAngle = function (t, e) {
      t.addFieldFloat32(3, e, 0);
    }),
    (kb.AxisArc.addEndAngle = function (t, e) {
      t.addFieldFloat32(4, e, 0);
    }),
    (kb.AxisArc.addAntiClockWise = function (t, e) {
      t.addFieldOffset(5, e, 0);
    }),
    (kb.AxisArc.endAxisArc = function (t) {
      return t.endObject();
    }),
    (kb.AxisLineSeg = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (kb.AxisLineSeg.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (kb.AxisLineSeg.getRootAsAxisLineSeg = function (t, e) {
      return (e || new kb.AxisLineSeg()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (kb.AxisLineSeg.prototype.start = function (t) {
      var e = this.bb.__offset(this.bb_pos, 4);
      return e
        ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (kb.AxisLineSeg.prototype.startLength = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (kb.AxisLineSeg.prototype.startArray = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t
        ? new Float32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (kb.AxisLineSeg.prototype.end = function (t) {
      var e = this.bb.__offset(this.bb_pos, 6);
      return e
        ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (kb.AxisLineSeg.prototype.endLength = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (kb.AxisLineSeg.prototype.endArray = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t
        ? new Float32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (kb.AxisLineSeg.startAxisLineSeg = function (t) {
      t.startObject(2);
    }),
    (kb.AxisLineSeg.addStart = function (t, e) {
      t.addFieldOffset(0, e, 0);
    }),
    (kb.AxisLineSeg.createStartVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addFloat32(e[n]);
      return t.endVector();
    }),
    (kb.AxisLineSeg.startStartVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (kb.AxisLineSeg.addEnd = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (kb.AxisLineSeg.createEndVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addFloat32(e[n]);
      return t.endVector();
    }),
    (kb.AxisLineSeg.startEndVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (kb.AxisLineSeg.endAxisLineSeg = function (t) {
      return t.endObject();
    }),
    (kb.FloorAxisInfo = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (kb.FloorAxisInfo.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (kb.FloorAxisInfo.getRootAsFloorAxisInfo = function (t, e) {
      return (e || new kb.FloorAxisInfo()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (kb.FloorAxisInfo.prototype.id = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (kb.FloorAxisInfo.prototype.height = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t ? this.bb.readFloat32(this.bb_pos + t) : 0;
    }),
    (kb.FloorAxisInfo.prototype.elevation = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t ? this.bb.readFloat32(this.bb_pos + t) : 0;
    }),
    (kb.FloorAxisInfo.prototype.name = function (t) {
      var e = this.bb.__offset(this.bb_pos, 10);
      return e ? this.bb.__string(this.bb_pos + e, t) : null;
    }),
    (kb.FloorAxisInfo.prototype.axisLineArray = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 12);
      return n
        ? (e || new kb.AxisLine()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (kb.FloorAxisInfo.prototype.axisLineArrayLength = function () {
      var t = this.bb.__offset(this.bb_pos, 12);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (kb.FloorAxisInfo.prototype.axisArcArray = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 14);
      return n
        ? (e || new kb.AxisArc()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (kb.FloorAxisInfo.prototype.axisArcArrayLength = function () {
      var t = this.bb.__offset(this.bb_pos, 14);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (kb.FloorAxisInfo.prototype.axisLineSegArray = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 16);
      return n
        ? (e || new kb.AxisLineSeg()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (kb.FloorAxisInfo.prototype.axisLineSegArrayLength = function () {
      var t = this.bb.__offset(this.bb_pos, 16);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (kb.FloorAxisInfo.startFloorAxisInfo = function (t) {
      t.startObject(7);
    }),
    (kb.FloorAxisInfo.addId = function (t, e) {
      t.addFieldInt32(0, e, 0);
    }),
    (kb.FloorAxisInfo.addHeight = function (t, e) {
      t.addFieldFloat32(1, e, 0);
    }),
    (kb.FloorAxisInfo.addElevation = function (t, e) {
      t.addFieldFloat32(2, e, 0);
    }),
    (kb.FloorAxisInfo.addName = function (t, e) {
      t.addFieldOffset(3, e, 0);
    }),
    (kb.FloorAxisInfo.addAxisLineArray = function (t, e) {
      t.addFieldOffset(4, e, 0);
    }),
    (kb.FloorAxisInfo.createAxisLineArrayVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (kb.FloorAxisInfo.startAxisLineArrayVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (kb.FloorAxisInfo.addAxisArcArray = function (t, e) {
      t.addFieldOffset(5, e, 0);
    }),
    (kb.FloorAxisInfo.createAxisArcArrayVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (kb.FloorAxisInfo.startAxisArcArrayVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (kb.FloorAxisInfo.addAxisLineSegArray = function (t, e) {
      t.addFieldOffset(6, e, 0);
    }),
    (kb.FloorAxisInfo.createAxisLineSegArrayVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (kb.FloorAxisInfo.startAxisLineSegArrayVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (kb.FloorAxisInfo.endFloorAxisInfo = function (t) {
      return t.endObject();
    }),
    (kb.FloorAxisInfoDataFile = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (kb.FloorAxisInfoDataFile.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (kb.FloorAxisInfoDataFile.getRootAsFloorAxisInfoDataFile = function (t, e) {
      return (e || new kb.FloorAxisInfoDataFile()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (kb.FloorAxisInfoDataFile.prototype.floorAxisInfoArray = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 4);
      return n
        ? (e || new kb.FloorAxisInfo()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (kb.FloorAxisInfoDataFile.prototype.floorAxisInfoArrayLength = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (kb.FloorAxisInfoDataFile.startFloorAxisInfoDataFile = function (t) {
      t.startObject(1);
    }),
    (kb.FloorAxisInfoDataFile.addFloorAxisInfoArray = function (t, e) {
      t.addFieldOffset(0, e, 0);
    }),
    (kb.FloorAxisInfoDataFile.createFloorAxisInfoArrayVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (kb.FloorAxisInfoDataFile.startFloorAxisInfoArrayVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (kb.FloorAxisInfoDataFile.endFloorAxisInfoDataFile = function (t) {
      return t.endObject();
    }),
    (kb.ParamInfo = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (kb.ParamInfo.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (kb.ParamInfo.getRootAsParamInfo = function (t, e) {
      return (e || new kb.ParamInfo()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (kb.ParamInfo.prototype.type = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (kb.ParamInfo.prototype.nameID = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (kb.ParamInfo.prototype.valueID = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (kb.ParamInfo.startParamInfo = function (t) {
      t.startObject(3);
    }),
    (kb.ParamInfo.addType = function (t, e) {
      t.addFieldInt32(0, e, 0);
    }),
    (kb.ParamInfo.addNameID = function (t, e) {
      t.addFieldInt32(1, e, 0);
    }),
    (kb.ParamInfo.addValueID = function (t, e) {
      t.addFieldInt32(2, e, 0);
    }),
    (kb.ParamInfo.endParamInfo = function (t) {
      return t.endObject();
    }),
    (kb.ComidInfo = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (kb.ComidInfo.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (kb.ComidInfo.getRootAsComidInfo = function (t, e) {
      return (e || new kb.ComidInfo()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (kb.ComidInfo.prototype.id = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (kb.ComidInfo.prototype.name = function (t) {
      var e = this.bb.__offset(this.bb_pos, 6);
      return e ? this.bb.__string(this.bb_pos + e, t) : null;
    }),
    (kb.ComidInfo.prototype.handleArray = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 8);
      return n
        ? this.bb.__string(this.bb.__vector(this.bb_pos + n) + 4 * t, e)
        : null;
    }),
    (kb.ComidInfo.prototype.handleArrayLength = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (kb.ComidInfo.startComidInfo = function (t) {
      t.startObject(3);
    }),
    (kb.ComidInfo.addId = function (t, e) {
      t.addFieldInt32(0, e, 0);
    }),
    (kb.ComidInfo.addName = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (kb.ComidInfo.addHandleArray = function (t, e) {
      t.addFieldOffset(2, e, 0);
    }),
    (kb.ComidInfo.createHandleArrayVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (kb.ComidInfo.startHandleArrayVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (kb.ComidInfo.endComidInfo = function (t) {
      return t.endObject();
    }),
    (kb.ComtypeInfo = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (kb.ComtypeInfo.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (kb.ComtypeInfo.getRootAsComtypeInfo = function (t, e) {
      return (e || new kb.ComtypeInfo()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (kb.ComtypeInfo.prototype.id = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (kb.ComtypeInfo.prototype.name = function (t) {
      var e = this.bb.__offset(this.bb_pos, 6);
      return e ? this.bb.__string(this.bb_pos + e, t) : null;
    }),
    (kb.ComtypeInfo.prototype.comidArray = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 8);
      return n
        ? (e || new kb.ComidInfo()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (kb.ComtypeInfo.prototype.comidArrayLength = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (kb.ComtypeInfo.prototype.comtypeInfoArray = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 10);
      return n
        ? (e || new kb.ComtypeInfo()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (kb.ComtypeInfo.prototype.comtypeInfoArrayLength = function () {
      var t = this.bb.__offset(this.bb_pos, 10);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (kb.ComtypeInfo.startComtypeInfo = function (t) {
      t.startObject(4);
    }),
    (kb.ComtypeInfo.addId = function (t, e) {
      t.addFieldInt32(0, e, 0);
    }),
    (kb.ComtypeInfo.addName = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (kb.ComtypeInfo.addComidArray = function (t, e) {
      t.addFieldOffset(2, e, 0);
    }),
    (kb.ComtypeInfo.createComidArrayVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (kb.ComtypeInfo.startComidArrayVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (kb.ComtypeInfo.addComtypeInfoArray = function (t, e) {
      t.addFieldOffset(3, e, 0);
    }),
    (kb.ComtypeInfo.createComtypeInfoArrayVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (kb.ComtypeInfo.startComtypeInfoArrayVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (kb.ComtypeInfo.endComtypeInfo = function (t) {
      return t.endObject();
    }),
    (kb.BaseComtypeInfo = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (kb.BaseComtypeInfo.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (kb.BaseComtypeInfo.getRootAsBaseComtypeInfo = function (t, e) {
      return (e || new kb.BaseComtypeInfo()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (kb.BaseComtypeInfo.prototype.id = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (kb.BaseComtypeInfo.prototype.name = function (t) {
      var e = this.bb.__offset(this.bb_pos, 6);
      return e ? this.bb.__string(this.bb_pos + e, t) : null;
    }),
    (kb.BaseComtypeInfo.prototype.comtypeArray = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 8);
      return n
        ? (e || new kb.ComtypeInfo()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (kb.BaseComtypeInfo.prototype.comtypeArrayLength = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (kb.BaseComtypeInfo.prototype.baseComtypeArray = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 10);
      return n
        ? (e || new kb.BaseComtypeInfo()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (kb.BaseComtypeInfo.prototype.baseComtypeArrayLength = function () {
      var t = this.bb.__offset(this.bb_pos, 10);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (kb.BaseComtypeInfo.startBaseComtypeInfo = function (t) {
      t.startObject(4);
    }),
    (kb.BaseComtypeInfo.addId = function (t, e) {
      t.addFieldInt32(0, e, 0);
    }),
    (kb.BaseComtypeInfo.addName = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (kb.BaseComtypeInfo.addComtypeArray = function (t, e) {
      t.addFieldOffset(2, e, 0);
    }),
    (kb.BaseComtypeInfo.createComtypeArrayVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (kb.BaseComtypeInfo.startComtypeArrayVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (kb.BaseComtypeInfo.addBaseComtypeArray = function (t, e) {
      t.addFieldOffset(3, e, 0);
    }),
    (kb.BaseComtypeInfo.createBaseComtypeArrayVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (kb.BaseComtypeInfo.startBaseComtypeArrayVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (kb.BaseComtypeInfo.endBaseComtypeInfo = function (t) {
      return t.endObject();
    }),
    (kb.FloorInfo = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (kb.FloorInfo.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (kb.FloorInfo.getRootAsFloorInfo = function (t, e) {
      return (e || new kb.FloorInfo()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (kb.FloorInfo.prototype.id = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (kb.FloorInfo.prototype.name = function (t) {
      var e = this.bb.__offset(this.bb_pos, 6);
      return e ? this.bb.__string(this.bb_pos + e, t) : null;
    }),
    (kb.FloorInfo.prototype.showid = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (kb.FloorInfo.prototype.baseComtypeArray = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 10);
      return n
        ? (e || new kb.BaseComtypeInfo()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (kb.FloorInfo.prototype.baseComtypeArrayLength = function () {
      var t = this.bb.__offset(this.bb_pos, 10);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (kb.FloorInfo.startFloorInfo = function (t) {
      t.startObject(4);
    }),
    (kb.FloorInfo.addId = function (t, e) {
      t.addFieldInt32(0, e, 0);
    }),
    (kb.FloorInfo.addName = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (kb.FloorInfo.addShowid = function (t, e) {
      t.addFieldInt32(2, e, 0);
    }),
    (kb.FloorInfo.addBaseComtypeArray = function (t, e) {
      t.addFieldOffset(3, e, 0);
    }),
    (kb.FloorInfo.createBaseComtypeArrayVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (kb.FloorInfo.startBaseComtypeArrayVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (kb.FloorInfo.endFloorInfo = function (t) {
      return t.endObject();
    }),
    (kb.StageInfo = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (kb.StageInfo.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (kb.StageInfo.getRootAsStageInfo = function (t, e) {
      return (e || new kb.StageInfo()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (kb.StageInfo.prototype.id = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (kb.StageInfo.prototype.name = function (t) {
      var e = this.bb.__offset(this.bb_pos, 6);
      return e ? this.bb.__string(this.bb_pos + e, t) : null;
    }),
    (kb.StageInfo.startStageInfo = function (t) {
      t.startObject(2);
    }),
    (kb.StageInfo.addId = function (t, e) {
      t.addFieldInt32(0, e, 0);
    }),
    (kb.StageInfo.addName = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (kb.StageInfo.endStageInfo = function (t) {
      return t.endObject();
    }),
    (kb.BuildingInfo = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (kb.BuildingInfo.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (kb.BuildingInfo.getRootAsBuildingInfo = function (t, e) {
      return (e || new kb.BuildingInfo()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (kb.BuildingInfo.prototype.id = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (kb.BuildingInfo.prototype.name = function (t) {
      var e = this.bb.__offset(this.bb_pos, 6);
      return e ? this.bb.__string(this.bb_pos + e, t) : null;
    }),
    (kb.BuildingInfo.prototype.floorInfoArray = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 8);
      return n
        ? (e || new kb.FloorInfo()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (kb.BuildingInfo.prototype.floorInfoArrayLength = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (kb.BuildingInfo.startBuildingInfo = function (t) {
      t.startObject(3);
    }),
    (kb.BuildingInfo.addId = function (t, e) {
      t.addFieldInt32(0, e, 0);
    }),
    (kb.BuildingInfo.addName = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (kb.BuildingInfo.addFloorInfoArray = function (t, e) {
      t.addFieldOffset(2, e, 0);
    }),
    (kb.BuildingInfo.createFloorInfoArrayVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (kb.BuildingInfo.startFloorInfoArrayVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (kb.BuildingInfo.endBuildingInfo = function (t) {
      return t.endObject();
    }),
    (kb.HandleInfo = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (kb.HandleInfo.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (kb.HandleInfo.getRootAsHandleInfo = function (t, e) {
      return (e || new kb.HandleInfo()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (kb.HandleInfo.prototype.floorid = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (kb.HandleInfo.prototype.handle = function (t) {
      var e = this.bb.__offset(this.bb_pos, 6);
      return e ? this.bb.__string(this.bb_pos + e, t) : null;
    }),
    (kb.HandleInfo.prototype.parmInfoArray = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 8);
      return n
        ? (e || new kb.ParamInfo()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (kb.HandleInfo.prototype.parmInfoArrayLength = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (kb.HandleInfo.startHandleInfo = function (t) {
      t.startObject(3);
    }),
    (kb.HandleInfo.addFloorid = function (t, e) {
      t.addFieldInt32(0, e, 0);
    }),
    (kb.HandleInfo.addHandle = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (kb.HandleInfo.addParmInfoArray = function (t, e) {
      t.addFieldOffset(2, e, 0);
    }),
    (kb.HandleInfo.createParmInfoArrayVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (kb.HandleInfo.startParmInfoArrayVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (kb.HandleInfo.endHandleInfo = function (t) {
      return t.endObject();
    }),
    (kb.ProjectDataFile = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (kb.ProjectDataFile.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (kb.ProjectDataFile.getRootAsProjectDataFile = function (t, e) {
      return (e || new kb.ProjectDataFile()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (kb.ProjectDataFile.prototype.buildingInfoArray = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 4);
      return n
        ? (e || new kb.BuildingInfo()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (kb.ProjectDataFile.prototype.buildingInfoArrayLength = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (kb.ProjectDataFile.prototype.stageInfoArray = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 6);
      return n
        ? (e || new kb.StageInfo()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (kb.ProjectDataFile.prototype.stageInfoArrayLength = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (kb.ProjectDataFile.startProjectDataFile = function (t) {
      t.startObject(2);
    }),
    (kb.ProjectDataFile.addBuildingInfoArray = function (t, e) {
      t.addFieldOffset(0, e, 0);
    }),
    (kb.ProjectDataFile.createBuildingInfoArrayVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (kb.ProjectDataFile.startBuildingInfoArrayVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (kb.ProjectDataFile.addStageInfoArray = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (kb.ProjectDataFile.createStageInfoArrayVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (kb.ProjectDataFile.startStageInfoArrayVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (kb.ProjectDataFile.endProjectDataFile = function (t) {
      return t.endObject();
    }),
    (kb.ComponentsDataFile = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (kb.ComponentsDataFile.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (kb.ComponentsDataFile.getRootAsComponentsDataFile = function (t, e) {
      return (e || new kb.ComponentsDataFile()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (kb.ComponentsDataFile.prototype.paramTextArray = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 4);
      return n
        ? this.bb.__string(this.bb.__vector(this.bb_pos + n) + 4 * t, e)
        : null;
    }),
    (kb.ComponentsDataFile.prototype.paramTextArrayLength = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (kb.ComponentsDataFile.prototype.handleInfoArray = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 6);
      return n
        ? (e || new kb.HandleInfo()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (kb.ComponentsDataFile.prototype.handleInfoArrayLength = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (kb.ComponentsDataFile.startComponentsDataFile = function (t) {
      t.startObject(2);
    }),
    (kb.ComponentsDataFile.addParamTextArray = function (t, e) {
      t.addFieldOffset(0, e, 0);
    }),
    (kb.ComponentsDataFile.createParamTextArrayVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (kb.ComponentsDataFile.startParamTextArrayVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (kb.ComponentsDataFile.addHandleInfoArray = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (kb.ComponentsDataFile.createHandleInfoArrayVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (kb.ComponentsDataFile.startHandleInfoArrayVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (kb.ComponentsDataFile.endComponentsDataFile = function (t) {
      return t.endObject();
    });
  var Ub = Ub || {};
  (Ub.LayerInfo = function () {
    (this.bb = null), (this.bb_pos = 0);
  }),
    (Ub.LayerInfo.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (Ub.LayerInfo.getRootAsLayerInfo = function (t, e) {
      return (e || new Ub.LayerInfo()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (Ub.LayerInfo.prototype.id = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Ub.LayerInfo.prototype.name = function (t) {
      var e = this.bb.__offset(this.bb_pos, 6);
      return e ? this.bb.__string(this.bb_pos + e, t) : null;
    }),
    (Ub.LayerInfo.prototype.color = function (t) {
      var e = this.bb.__offset(this.bb_pos, 8);
      return e ? this.bb.__string(this.bb_pos + e, t) : null;
    }),
    (Ub.LayerInfo.prototype.show = function () {
      var t = this.bb.__offset(this.bb_pos, 10);
      return !!t && !!this.bb.readInt8(this.bb_pos + t);
    }),
    (Ub.LayerInfo.startLayerInfo = function (t) {
      t.startObject(4);
    }),
    (Ub.LayerInfo.addId = function (t, e) {
      t.addFieldInt32(0, e, 0);
    }),
    (Ub.LayerInfo.addName = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (Ub.LayerInfo.addColor = function (t, e) {
      t.addFieldOffset(2, e, 0);
    }),
    (Ub.LayerInfo.addShow = function (t, e) {
      t.addFieldInt8(3, +e, 0);
    }),
    (Ub.LayerInfo.endLayerInfo = function (t) {
      return t.endObject();
    }),
    (Ub.point = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (Ub.point.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (Ub.point.getRootAspoint = function (t, e) {
      return (e || new Ub.point()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (Ub.point.prototype.x = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readFloat32(this.bb_pos + t) : 0;
    }),
    (Ub.point.prototype.y = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t ? this.bb.readFloat32(this.bb_pos + t) : 0;
    }),
    (Ub.point.startpoint = function (t) {
      t.startObject(2);
    }),
    (Ub.point.addX = function (t, e) {
      t.addFieldFloat32(0, e, 0);
    }),
    (Ub.point.addY = function (t, e) {
      t.addFieldFloat32(1, e, 0);
    }),
    (Ub.point.endpoint = function (t) {
      return t.endObject();
    }),
    (Ub.lineSeg = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (Ub.lineSeg.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (Ub.lineSeg.getRootAslineSeg = function (t, e) {
      return (e || new Ub.lineSeg()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (Ub.lineSeg.prototype.startPoint = function (t) {
      var e = this.bb.__offset(this.bb_pos, 4);
      return e
        ? (t || new Ub.point()).__init(
            this.bb.__indirect(this.bb_pos + e),
            this.bb,
          )
        : null;
    }),
    (Ub.lineSeg.prototype.endPoint = function (t) {
      var e = this.bb.__offset(this.bb_pos, 6);
      return e
        ? (t || new Ub.point()).__init(
            this.bb.__indirect(this.bb_pos + e),
            this.bb,
          )
        : null;
    }),
    (Ub.lineSeg.startlineSeg = function (t) {
      t.startObject(2);
    }),
    (Ub.lineSeg.addStartPoint = function (t, e) {
      t.addFieldOffset(0, e, 0);
    }),
    (Ub.lineSeg.addEndPoint = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (Ub.lineSeg.endlineSeg = function (t) {
      return t.endObject();
    }),
    (Ub.QuadNode = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (Ub.QuadNode.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (Ub.QuadNode.getRootAsQuadNode = function (t, e) {
      return (e || new Ub.QuadNode()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (Ub.QuadNode.prototype.LeftTopNode = function (t) {
      var e = this.bb.__offset(this.bb_pos, 4);
      return e
        ? (t || new Ub.QuadNode()).__init(
            this.bb.__indirect(this.bb_pos + e),
            this.bb,
          )
        : null;
    }),
    (Ub.QuadNode.prototype.RightTopNode = function (t) {
      var e = this.bb.__offset(this.bb_pos, 6);
      return e
        ? (t || new Ub.QuadNode()).__init(
            this.bb.__indirect(this.bb_pos + e),
            this.bb,
          )
        : null;
    }),
    (Ub.QuadNode.prototype.LeftBottomNode = function (t) {
      var e = this.bb.__offset(this.bb_pos, 8);
      return e
        ? (t || new Ub.QuadNode()).__init(
            this.bb.__indirect(this.bb_pos + e),
            this.bb,
          )
        : null;
    }),
    (Ub.QuadNode.prototype.RightBottomNode = function (t) {
      var e = this.bb.__offset(this.bb_pos, 10);
      return e
        ? (t || new Ub.QuadNode()).__init(
            this.bb.__indirect(this.bb_pos + e),
            this.bb,
          )
        : null;
    }),
    (Ub.QuadNode.prototype.ptMin = function (t) {
      var e = this.bb.__offset(this.bb_pos, 12);
      return e
        ? (t || new Ub.point()).__init(
            this.bb.__indirect(this.bb_pos + e),
            this.bb,
          )
        : null;
    }),
    (Ub.QuadNode.prototype.ptMax = function (t) {
      var e = this.bb.__offset(this.bb_pos, 14);
      return e
        ? (t || new Ub.point()).__init(
            this.bb.__indirect(this.bb_pos + e),
            this.bb,
          )
        : null;
    }),
    (Ub.QuadNode.prototype.IsLeaf = function () {
      var t = this.bb.__offset(this.bb_pos, 16);
      return !!t && !!this.bb.readInt8(this.bb_pos + t);
    }),
    (Ub.QuadNode.prototype.entArr = function (t) {
      var e = this.bb.__offset(this.bb_pos, 18);
      return e
        ? this.bb.readInt32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (Ub.QuadNode.prototype.entArrLength = function () {
      var t = this.bb.__offset(this.bb_pos, 18);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Ub.QuadNode.prototype.entArrArray = function () {
      var t = this.bb.__offset(this.bb_pos, 18);
      return t
        ? new Int32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (Ub.QuadNode.startQuadNode = function (t) {
      t.startObject(8);
    }),
    (Ub.QuadNode.addLeftTopNode = function (t, e) {
      t.addFieldOffset(0, e, 0);
    }),
    (Ub.QuadNode.addRightTopNode = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (Ub.QuadNode.addLeftBottomNode = function (t, e) {
      t.addFieldOffset(2, e, 0);
    }),
    (Ub.QuadNode.addRightBottomNode = function (t, e) {
      t.addFieldOffset(3, e, 0);
    }),
    (Ub.QuadNode.addPtMin = function (t, e) {
      t.addFieldOffset(4, e, 0);
    }),
    (Ub.QuadNode.addPtMax = function (t, e) {
      t.addFieldOffset(5, e, 0);
    }),
    (Ub.QuadNode.addIsLeaf = function (t, e) {
      t.addFieldInt8(6, +e, 0);
    }),
    (Ub.QuadNode.addEntArr = function (t, e) {
      t.addFieldOffset(7, e, 0);
    }),
    (Ub.QuadNode.createEntArrVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addInt32(e[n]);
      return t.endVector();
    }),
    (Ub.QuadNode.startEntArrVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Ub.QuadNode.endQuadNode = function (t) {
      return t.endObject();
    }),
    (Ub.QuadEnt = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (Ub.QuadEnt.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (Ub.QuadEnt.getRootAsQuadEnt = function (t, e) {
      return (e || new Ub.QuadEnt()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (Ub.QuadEnt.prototype.id = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Ub.QuadEnt.prototype.intersectPointArr = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 6);
      return n
        ? (e || new Ub.point()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (Ub.QuadEnt.prototype.intersectPointArrLength = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Ub.QuadEnt.prototype.lineSegArr = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 8);
      return n
        ? (e || new Ub.lineSeg()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (Ub.QuadEnt.prototype.lineSegArrLength = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Ub.QuadEnt.startQuadEnt = function (t) {
      t.startObject(3);
    }),
    (Ub.QuadEnt.addId = function (t, e) {
      t.addFieldInt32(0, e, 0);
    }),
    (Ub.QuadEnt.addIntersectPointArr = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (Ub.QuadEnt.createIntersectPointArrVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (Ub.QuadEnt.startIntersectPointArrVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Ub.QuadEnt.addLineSegArr = function (t, e) {
      t.addFieldOffset(2, e, 0);
    }),
    (Ub.QuadEnt.createLineSegArrVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (Ub.QuadEnt.startLineSegArrVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Ub.QuadEnt.endQuadEnt = function (t) {
      return t.endObject();
    }),
    (Ub.CADIntersectionDataFile = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (Ub.CADIntersectionDataFile.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (Ub.CADIntersectionDataFile.getRootAsCADIntersectionDataFile = function (
      t,
      e,
    ) {
      return (e || new Ub.CADIntersectionDataFile()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (Ub.CADIntersectionDataFile.prototype.QuadEntArr = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 4);
      return n
        ? (e || new Ub.QuadEnt()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (Ub.CADIntersectionDataFile.prototype.QuadEntArrLength = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Ub.CADIntersectionDataFile.startCADIntersectionDataFile = function (t) {
      t.startObject(1);
    }),
    (Ub.CADIntersectionDataFile.addQuadEntArr = function (t, e) {
      t.addFieldOffset(0, e, 0);
    }),
    (Ub.CADIntersectionDataFile.createQuadEntArrVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (Ub.CADIntersectionDataFile.startQuadEntArrVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Ub.CADIntersectionDataFile.endCADIntersectionDataFile = function (t) {
      return t.endObject();
    }),
    (Ub.CADComponentsDataFile = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (Ub.CADComponentsDataFile.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (Ub.CADComponentsDataFile.getRootAsCADComponentsDataFile = function (t, e) {
      return (e || new Ub.CADComponentsDataFile()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (Ub.CADComponentsDataFile.prototype.layerInfoArray = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 4);
      return n
        ? (e || new Ub.LayerInfo()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (Ub.CADComponentsDataFile.prototype.layerInfoArrayLength = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Ub.CADComponentsDataFile.startCADComponentsDataFile = function (t) {
      t.startObject(1);
    }),
    (Ub.CADComponentsDataFile.addLayerInfoArray = function (t, e) {
      t.addFieldOffset(0, e, 0);
    }),
    (Ub.CADComponentsDataFile.createLayerInfoArrayVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (Ub.CADComponentsDataFile.startLayerInfoArrayVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Ub.CADComponentsDataFile.endCADComponentsDataFile = function (t) {
      return t.endObject();
    });
  var Gb = Gb || {};
  function zb() {
    (this.type = 'PageLOD'),
      (this.minLoadDistance = 0),
      (this.maxLoadDistance = -1),
      (this.pageData = null);
  }
  function jb(t, e, n) {
    let i = new Km();
    i.setAsOrthographic(),
      ob.call(this, 0, 0, i, t),
      (this.viewer = n),
      (this.isDwgLayoutScene = !0),
      this.setVisible(!1),
      (this.matrixAutoUpdate = !1),
      (this.dwgLayoutSceneRenderBgVisible = !1),
      this.initCamera(e);
  }
  function Hb(t, e, n, i, r, o, s) {
    om.call(this, t, e, i, o, s), (this.color = n), (this.show = r);
  }
  function Wb(t, e, n) {
    bm.call(this, t),
      (this.viewer = e),
      (this.cancelCreateModel = !1),
      (this.hasloadOnce = !1),
      (this.getBufferGeometryDataCallback = n);
  }
  (Gb.FileIndex = function () {
    (this.bb = null), (this.bb_pos = 0);
  }),
    (Gb.FileIndex.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (Gb.FileIndex.getRootAsFileIndex = function (t, e) {
      return (e || new Gb.FileIndex()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (Gb.FileIndex.prototype.id = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Gb.FileIndex.prototype.url = function (t) {
      var e = this.bb.__offset(this.bb_pos, 6);
      return e ? this.bb.__string(this.bb_pos + e, t) : null;
    }),
    (Gb.FileIndex.prototype.fileSize = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t ? this.bb.readUint32(this.bb_pos + t) : 0;
    }),
    (Gb.FileIndex.startFileIndex = function (t) {
      t.startObject(3);
    }),
    (Gb.FileIndex.addId = function (t, e) {
      t.addFieldInt32(0, e, 0);
    }),
    (Gb.FileIndex.addUrl = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (Gb.FileIndex.addFileSize = function (t, e) {
      t.addFieldInt32(2, e, 0);
    }),
    (Gb.FileIndex.endFileIndex = function (t) {
      return t.endObject();
    }),
    (Gb.PageData = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (Gb.PageData.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (Gb.PageData.getRootAsPageData = function (t, e) {
      return (e || new Gb.PageData()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (Gb.PageData.prototype.dataContentSize = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readUint32(this.bb_pos + t) : 0;
    }),
    (Gb.PageData.prototype.bufferGeometryDataFileArray = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 6);
      return n
        ? (e || new Gb.FileIndex()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (Gb.PageData.prototype.bufferGeometryDataFileArrayLength = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Gb.PageData.prototype.entDataDataFileArray = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 8);
      return n
        ? (e || new Gb.FileIndex()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (Gb.PageData.prototype.entDataDataFileArrayLength = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Gb.PageData.startPageData = function (t) {
      t.startObject(3);
    }),
    (Gb.PageData.addDataContentSize = function (t, e) {
      t.addFieldInt32(0, e, 0);
    }),
    (Gb.PageData.addBufferGeometryDataFileArray = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (Gb.PageData.createBufferGeometryDataFileArrayVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (Gb.PageData.startBufferGeometryDataFileArrayVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Gb.PageData.addEntDataDataFileArray = function (t, e) {
      t.addFieldOffset(2, e, 0);
    }),
    (Gb.PageData.createEntDataDataFileArrayVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (Gb.PageData.startEntDataDataFileArrayVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Gb.PageData.endPageData = function (t) {
      return t.endObject();
    }),
    (Gb.PageLOD = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (Gb.PageLOD.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (Gb.PageLOD.getRootAsPageLOD = function (t, e) {
      return (e || new Gb.PageLOD()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (Gb.PageLOD.prototype.level = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Gb.PageLOD.prototype.minLoadDistance = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t ? this.bb.readFloat32(this.bb_pos + t) : 0;
    }),
    (Gb.PageLOD.prototype.maxLoadDistance = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t ? this.bb.readFloat32(this.bb_pos + t) : 0;
    }),
    (Gb.PageLOD.prototype.pageData = function (t) {
      var e = this.bb.__offset(this.bb_pos, 10);
      return e
        ? (t || new Gb.PageData()).__init(
            this.bb.__indirect(this.bb_pos + e),
            this.bb,
          )
        : null;
    }),
    (Gb.PageLOD.startPageLOD = function (t) {
      t.startObject(4);
    }),
    (Gb.PageLOD.addLevel = function (t, e) {
      t.addFieldInt32(0, e, 0);
    }),
    (Gb.PageLOD.addMinLoadDistance = function (t, e) {
      t.addFieldFloat32(1, e, 0);
    }),
    (Gb.PageLOD.addMaxLoadDistance = function (t, e) {
      t.addFieldFloat32(2, e, 0);
    }),
    (Gb.PageLOD.addPageData = function (t, e) {
      t.addFieldOffset(3, e, 0);
    }),
    (Gb.PageLOD.endPageLOD = function (t) {
      return t.endObject();
    }),
    (Gb.SceneNode = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (Gb.SceneNode.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (Gb.SceneNode.getRootAsSceneNode = function (t, e) {
      return (e || new Gb.SceneNode()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (Gb.SceneNode.prototype.bndBoxMin = function (t) {
      var e = this.bb.__offset(this.bb_pos, 4);
      return e
        ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (Gb.SceneNode.prototype.bndBoxMinLength = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Gb.SceneNode.prototype.bndBoxMinArray = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t
        ? new Float32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (Gb.SceneNode.prototype.bndBoxMax = function (t) {
      var e = this.bb.__offset(this.bb_pos, 6);
      return e
        ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (Gb.SceneNode.prototype.bndBoxMaxLength = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Gb.SceneNode.prototype.bndBoxMaxArray = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t
        ? new Float32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (Gb.SceneNode.prototype.nodeData = function (t) {
      var e = this.bb.__offset(this.bb_pos, 8);
      return e
        ? (t || new Gb.PageData()).__init(
            this.bb.__indirect(this.bb_pos + e),
            this.bb,
          )
        : null;
    }),
    (Gb.SceneNode.prototype.lodData = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 10);
      return n
        ? (e || new Gb.PageLOD()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (Gb.SceneNode.prototype.lodDataLength = function () {
      var t = this.bb.__offset(this.bb_pos, 10);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Gb.SceneNode.prototype.entInfoDataFileArray = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 12);
      return n
        ? (e || new Gb.FileIndex()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (Gb.SceneNode.prototype.entInfoDataFileArrayLength = function () {
      var t = this.bb.__offset(this.bb_pos, 12);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Gb.SceneNode.prototype.childNodeArray = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 14);
      return n
        ? (e || new Gb.SceneNode()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (Gb.SceneNode.prototype.childNodeArrayLength = function () {
      var t = this.bb.__offset(this.bb_pos, 14);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Gb.SceneNode.startSceneNode = function (t) {
      t.startObject(6);
    }),
    (Gb.SceneNode.addBndBoxMin = function (t, e) {
      t.addFieldOffset(0, e, 0);
    }),
    (Gb.SceneNode.createBndBoxMinVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addFloat32(e[n]);
      return t.endVector();
    }),
    (Gb.SceneNode.startBndBoxMinVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Gb.SceneNode.addBndBoxMax = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (Gb.SceneNode.createBndBoxMaxVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addFloat32(e[n]);
      return t.endVector();
    }),
    (Gb.SceneNode.startBndBoxMaxVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Gb.SceneNode.addNodeData = function (t, e) {
      t.addFieldOffset(2, e, 0);
    }),
    (Gb.SceneNode.addLodData = function (t, e) {
      t.addFieldOffset(3, e, 0);
    }),
    (Gb.SceneNode.createLodDataVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (Gb.SceneNode.startLodDataVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Gb.SceneNode.addEntInfoDataFileArray = function (t, e) {
      t.addFieldOffset(4, e, 0);
    }),
    (Gb.SceneNode.createEntInfoDataFileArrayVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (Gb.SceneNode.startEntInfoDataFileArrayVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Gb.SceneNode.addChildNodeArray = function (t, e) {
      t.addFieldOffset(5, e, 0);
    }),
    (Gb.SceneNode.createChildNodeArrayVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (Gb.SceneNode.startChildNodeArrayVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Gb.SceneNode.endSceneNode = function (t) {
      return t.endObject();
    }),
    (Gb.Camera = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (Gb.Camera.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (Gb.Camera.getRootAsCamera = function (t, e) {
      return (e || new Gb.Camera()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (Gb.Camera.prototype.position = function (t) {
      var e = this.bb.__offset(this.bb_pos, 4);
      return e
        ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (Gb.Camera.prototype.positionLength = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Gb.Camera.prototype.positionArray = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t
        ? new Float32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (Gb.Camera.prototype.target = function (t) {
      var e = this.bb.__offset(this.bb_pos, 6);
      return e
        ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (Gb.Camera.prototype.targetLength = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Gb.Camera.prototype.targetArray = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t
        ? new Float32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (Gb.Camera.prototype.upvec = function (t) {
      var e = this.bb.__offset(this.bb_pos, 8);
      return e
        ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (Gb.Camera.prototype.upvecLength = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Gb.Camera.prototype.upvecArray = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t
        ? new Float32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (Gb.Camera.prototype.width = function () {
      var t = this.bb.__offset(this.bb_pos, 10);
      return t ? this.bb.readFloat32(this.bb_pos + t) : 0;
    }),
    (Gb.Camera.prototype.height = function () {
      var t = this.bb.__offset(this.bb_pos, 12);
      return t ? this.bb.readFloat32(this.bb_pos + t) : 0;
    }),
    (Gb.Camera.startCamera = function (t) {
      t.startObject(5);
    }),
    (Gb.Camera.addPosition = function (t, e) {
      t.addFieldOffset(0, e, 0);
    }),
    (Gb.Camera.createPositionVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addFloat32(e[n]);
      return t.endVector();
    }),
    (Gb.Camera.startPositionVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Gb.Camera.addTarget = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (Gb.Camera.createTargetVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addFloat32(e[n]);
      return t.endVector();
    }),
    (Gb.Camera.startTargetVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Gb.Camera.addUpvec = function (t, e) {
      t.addFieldOffset(2, e, 0);
    }),
    (Gb.Camera.createUpvecVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addFloat32(e[n]);
      return t.endVector();
    }),
    (Gb.Camera.startUpvecVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Gb.Camera.addWidth = function (t, e) {
      t.addFieldFloat32(3, e, 0);
    }),
    (Gb.Camera.addHeight = function (t, e) {
      t.addFieldFloat32(4, e, 0);
    }),
    (Gb.Camera.endCamera = function (t) {
      return t.endObject();
    }),
    (Gb.Viewport = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (Gb.Viewport.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (Gb.Viewport.getRootAsViewport = function (t, e) {
      return (e || new Gb.Viewport()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (Gb.Viewport.prototype.viewMatrix = function (t) {
      var e = this.bb.__offset(this.bb_pos, 4);
      return e
        ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (Gb.Viewport.prototype.viewMatrixLength = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Gb.Viewport.prototype.viewMatrixArray = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t
        ? new Float32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (Gb.Viewport.prototype.width = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t ? this.bb.readFloat32(this.bb_pos + t) : 0;
    }),
    (Gb.Viewport.prototype.height = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t ? this.bb.readFloat32(this.bb_pos + t) : 0;
    }),
    (Gb.Viewport.prototype.startPt = function (t) {
      var e = this.bb.__offset(this.bb_pos, 10);
      return e
        ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (Gb.Viewport.prototype.startPtLength = function () {
      var t = this.bb.__offset(this.bb_pos, 10);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Gb.Viewport.prototype.startPtArray = function () {
      var t = this.bb.__offset(this.bb_pos, 10);
      return t
        ? new Float32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (Gb.Viewport.prototype.endPt = function (t) {
      var e = this.bb.__offset(this.bb_pos, 12);
      return e
        ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (Gb.Viewport.prototype.endPtLength = function () {
      var t = this.bb.__offset(this.bb_pos, 12);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Gb.Viewport.prototype.endPtArray = function () {
      var t = this.bb.__offset(this.bb_pos, 12);
      return t
        ? new Float32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (Gb.Viewport.startViewport = function (t) {
      t.startObject(5);
    }),
    (Gb.Viewport.addViewMatrix = function (t, e) {
      t.addFieldOffset(0, e, 0);
    }),
    (Gb.Viewport.createViewMatrixVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addFloat32(e[n]);
      return t.endVector();
    }),
    (Gb.Viewport.startViewMatrixVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Gb.Viewport.addWidth = function (t, e) {
      t.addFieldFloat32(1, e, 0);
    }),
    (Gb.Viewport.addHeight = function (t, e) {
      t.addFieldFloat32(2, e, 0);
    }),
    (Gb.Viewport.addStartPt = function (t, e) {
      t.addFieldOffset(3, e, 0);
    }),
    (Gb.Viewport.createStartPtVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addFloat32(e[n]);
      return t.endVector();
    }),
    (Gb.Viewport.startStartPtVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Gb.Viewport.addEndPt = function (t, e) {
      t.addFieldOffset(4, e, 0);
    }),
    (Gb.Viewport.createEndPtVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addFloat32(e[n]);
      return t.endVector();
    }),
    (Gb.Viewport.startEndPtVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Gb.Viewport.endViewport = function (t) {
      return t.endObject();
    }),
    (Gb.SceneDataFile = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (Gb.SceneDataFile.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (Gb.SceneDataFile.getRootAsSceneDataFile = function (t, e) {
      return (e || new Gb.SceneDataFile()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (Gb.SceneDataFile.prototype.version = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Gb.SceneDataFile.prototype.rootNode = function (t) {
      var e = this.bb.__offset(this.bb_pos, 6);
      return e
        ? (t || new Gb.SceneNode()).__init(
            this.bb.__indirect(this.bb_pos + e),
            this.bb,
          )
        : null;
    }),
    (Gb.SceneDataFile.prototype.defaultCamera = function (t) {
      var e = this.bb.__offset(this.bb_pos, 8);
      return e
        ? (t || new Gb.Camera()).__init(
            this.bb.__indirect(this.bb_pos + e),
            this.bb,
          )
        : null;
    }),
    (Gb.SceneDataFile.prototype.scale = function () {
      var t = this.bb.__offset(this.bb_pos, 10);
      return t ? this.bb.readFloat32(this.bb_pos + t) : 0;
    }),
    (Gb.SceneDataFile.startSceneDataFile = function (t) {
      t.startObject(4);
    }),
    (Gb.SceneDataFile.addVersion = function (t, e) {
      t.addFieldInt32(0, e, 0);
    }),
    (Gb.SceneDataFile.addRootNode = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (Gb.SceneDataFile.addDefaultCamera = function (t, e) {
      t.addFieldOffset(2, e, 0);
    }),
    (Gb.SceneDataFile.addScale = function (t, e) {
      t.addFieldFloat32(3, e, 0);
    }),
    (Gb.SceneDataFile.endSceneDataFile = function (t) {
      return t.endObject();
    }),
    (Gb.LayoutInfo = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (Gb.LayoutInfo.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (Gb.LayoutInfo.getRootAsLayoutInfo = function (t, e) {
      return (e || new Gb.LayoutInfo()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (Gb.LayoutInfo.prototype.id = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Gb.LayoutInfo.prototype.name = function (t) {
      var e = this.bb.__offset(this.bb_pos, 6);
      return e ? this.bb.__string(this.bb_pos + e, t) : null;
    }),
    (Gb.LayoutInfo.prototype.node = function (t) {
      var e = this.bb.__offset(this.bb_pos, 8);
      return e
        ? (t || new Gb.SceneNode()).__init(
            this.bb.__indirect(this.bb_pos + e),
            this.bb,
          )
        : null;
    }),
    (Gb.LayoutInfo.prototype.subViewPortArray = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 10);
      return n
        ? (e || new Gb.Viewport()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (Gb.LayoutInfo.prototype.subViewPortArrayLength = function () {
      var t = this.bb.__offset(this.bb_pos, 10);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Gb.LayoutInfo.prototype.basePoint = function (t) {
      var e = this.bb.__offset(this.bb_pos, 12);
      return e
        ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (Gb.LayoutInfo.prototype.basePointLength = function () {
      var t = this.bb.__offset(this.bb_pos, 12);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Gb.LayoutInfo.prototype.basePointArray = function () {
      var t = this.bb.__offset(this.bb_pos, 12);
      return t
        ? new Float32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (Gb.LayoutInfo.startLayoutInfo = function (t) {
      t.startObject(5);
    }),
    (Gb.LayoutInfo.addId = function (t, e) {
      t.addFieldInt32(0, e, 0);
    }),
    (Gb.LayoutInfo.addName = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (Gb.LayoutInfo.addNode = function (t, e) {
      t.addFieldOffset(2, e, 0);
    }),
    (Gb.LayoutInfo.addSubViewPortArray = function (t, e) {
      t.addFieldOffset(3, e, 0);
    }),
    (Gb.LayoutInfo.createSubViewPortArrayVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (Gb.LayoutInfo.startSubViewPortArrayVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Gb.LayoutInfo.addBasePoint = function (t, e) {
      t.addFieldOffset(4, e, 0);
    }),
    (Gb.LayoutInfo.createBasePointVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addFloat32(e[n]);
      return t.endVector();
    }),
    (Gb.LayoutInfo.startBasePointVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Gb.LayoutInfo.endLayoutInfo = function (t) {
      return t.endObject();
    }),
    (Gb.LayoutDataFile = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (Gb.LayoutDataFile.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (Gb.LayoutDataFile.getRootAsLayoutDataFile = function (t, e) {
      return (e || new Gb.LayoutDataFile()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (Gb.LayoutDataFile.prototype.layoutArray = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 4);
      return n
        ? (e || new Gb.LayoutInfo()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (Gb.LayoutDataFile.prototype.layoutArrayLength = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Gb.LayoutDataFile.startLayoutDataFile = function (t) {
      t.startObject(1);
    }),
    (Gb.LayoutDataFile.addLayoutArray = function (t, e) {
      t.addFieldOffset(0, e, 0);
    }),
    (Gb.LayoutDataFile.createLayoutArrayVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (Gb.LayoutDataFile.startLayoutArrayVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Gb.LayoutDataFile.endLayoutDataFile = function (t) {
      return t.endObject();
    }),
    (Gb.HeadDataFile = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (Gb.HeadDataFile.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (Gb.HeadDataFile.getRootAsHeadDataFile = function (t, e) {
      return (e || new Gb.HeadDataFile()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (Gb.HeadDataFile.prototype.version = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (Gb.HeadDataFile.prototype.sceneDataFile = function (t) {
      var e = this.bb.__offset(this.bb_pos, 6);
      return e
        ? (t || new Gb.FileIndex()).__init(
            this.bb.__indirect(this.bb_pos + e),
            this.bb,
          )
        : null;
    }),
    (Gb.HeadDataFile.prototype.materialDataFileArray = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 8);
      return n
        ? (e || new Gb.FileIndex()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (Gb.HeadDataFile.prototype.materialDataFileArrayLength = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Gb.HeadDataFile.prototype.refDefinitionDataFileArray = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 10);
      return n
        ? (e || new Gb.FileIndex()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (Gb.HeadDataFile.prototype.refDefinitionDataFileArrayLength = function () {
      var t = this.bb.__offset(this.bb_pos, 10);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Gb.HeadDataFile.prototype.projectFileIndex = function (t) {
      var e = this.bb.__offset(this.bb_pos, 12);
      return e
        ? (t || new Gb.FileIndex()).__init(
            this.bb.__indirect(this.bb_pos + e),
            this.bb,
          )
        : null;
    }),
    (Gb.HeadDataFile.prototype.floorAxisFileArray = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 14);
      return n
        ? (e || new Gb.FileIndex()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (Gb.HeadDataFile.prototype.floorAxisFileArrayLength = function () {
      var t = this.bb.__offset(this.bb_pos, 14);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Gb.HeadDataFile.prototype.cadComponentsDataFile = function (t) {
      var e = this.bb.__offset(this.bb_pos, 16);
      return e
        ? (t || new Gb.FileIndex()).__init(
            this.bb.__indirect(this.bb_pos + e),
            this.bb,
          )
        : null;
    }),
    (Gb.HeadDataFile.prototype.layoutDataFile = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 18);
      return n
        ? (e || new Gb.FileIndex()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (Gb.HeadDataFile.prototype.layoutDataFileLength = function () {
      var t = this.bb.__offset(this.bb_pos, 18);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (Gb.HeadDataFile.startHeadDataFile = function (t) {
      t.startObject(8);
    }),
    (Gb.HeadDataFile.addVersion = function (t, e) {
      t.addFieldInt32(0, e, 0);
    }),
    (Gb.HeadDataFile.addSceneDataFile = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (Gb.HeadDataFile.addMaterialDataFileArray = function (t, e) {
      t.addFieldOffset(2, e, 0);
    }),
    (Gb.HeadDataFile.createMaterialDataFileArrayVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (Gb.HeadDataFile.startMaterialDataFileArrayVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Gb.HeadDataFile.addRefDefinitionDataFileArray = function (t, e) {
      t.addFieldOffset(3, e, 0);
    }),
    (Gb.HeadDataFile.createRefDefinitionDataFileArrayVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (Gb.HeadDataFile.startRefDefinitionDataFileArrayVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Gb.HeadDataFile.addProjectFileIndex = function (t, e) {
      t.addFieldOffset(4, e, 0);
    }),
    (Gb.HeadDataFile.addFloorAxisFileArray = function (t, e) {
      t.addFieldOffset(5, e, 0);
    }),
    (Gb.HeadDataFile.createFloorAxisFileArrayVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (Gb.HeadDataFile.startFloorAxisFileArrayVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Gb.HeadDataFile.addCadComponentsDataFile = function (t, e) {
      t.addFieldOffset(6, e, 0);
    }),
    (Gb.HeadDataFile.addLayoutDataFile = function (t, e) {
      t.addFieldOffset(7, e, 0);
    }),
    (Gb.HeadDataFile.createLayoutDataFileVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (Gb.HeadDataFile.startLayoutDataFileVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (Gb.HeadDataFile.endHeadDataFile = function (t) {
      return t.endObject();
    }),
    (zb.prototype = {
      constructor: zb,
      setLoadRange: function (t, e) {
        (this.minLoadDistance = t), (this.maxLoadDistance = e);
      },
      getMinLoadDistance: function () {
        return this.minLoadDistance;
      },
      getMaxLoadDistance: function () {
        return this.maxLoadDistance;
      },
      setPageData: function (t) {
        this.pageData = t;
      },
      getPageData: function () {
        return this.pageData;
      },
    }),
    (jb.prototype = Object.assign(Object.create(ob.prototype), {
      constructor: jb,
      initCamera(t) {
        this.camera.makeLookAt(new J(0, 0, 1), new J(0, 0, 0), new J(0, 1, 0));
        const e = new ot();
        (e.elements = t.viewMatrix), e.transpose();
        const n = new ot();
        let i = this.viewer.dwgDefaultView.Target;
        n.makeTranslation(i[0], i[1], i[2]), e.multiply(n);
        const r = new ot();
        r.getInverse(e),
          r.decompose(
            this.camera.position,
            this.camera.quaternion,
            this.camera.scale,
          ),
          this.camera.projectionMatrix.makeOrthographic(
            -t.Width / 2,
            t.Width / 2,
            t.Height / 2,
            -t.Height / 2,
            -1e4,
            1e4,
          ),
          this.camera.projectionMatrixInverse.getInverse(
            this.camera.projectionMatrix,
          ),
          (this.viewStartPtVec = new J(
            t.startPt[0],
            t.startPt[1],
            t.startPt[2],
          )),
          (this.viewEndPtVec = new J(t.endPt[0], t.endPt[1], t.endPt[2]));
        const o = this.viewStartPtVec.clone(),
          s = this.viewEndPtVec.clone(),
          a = s.x - o.x,
          c = s.y - o.y;
        let l = new ot();
        l.set(
          a / 2,
          0,
          0,
          o.x + a / 2,
          0,
          c / 2,
          0,
          o.y + c / 2,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
        );
        let h = new ot();
        h.copy(l),
          h.multiply(this.camera.projectionMatrix),
          h.multiply(e),
          (this.mvpInverse = new ot()),
          this.mvpInverse.getInverse(h);
      },
      onMainCameraChanged() {},
      render: (function () {
        let t = new W();
        return function (e) {
          if (!this.getVisible()) return;
          e.getViewport(t);
          let n = this.viewer.bimViewer.getMainCamera(),
            i = this.viewer.bimViewer.getModelScene(),
            {
              wHalf: r,
              hHalf: o,
              h: s,
            } = this.viewer.viewDevices.getDevicesWidthHeight(),
            a = this.viewStartPtVec.clone();
          a.project(n), (a.x = a.x * r + r), (a.y = -a.y * o + o);
          let c = this.viewEndPtVec.clone();
          c.project(n), (c.x = c.x * r + r), (c.y = -c.y * o + o);
          const l = c.x - a.x,
            h = a.y - c.y,
            u = a.x,
            d = s - a.y;
          e.setScissor(u, d, l, h),
            e.setViewport(u, d, l, h),
            (this.userData.bndBox = {
              min: this.viewStartPtVec,
              max: this.viewEndPtVec,
            }),
            this.dwgLayoutSceneRenderBgVisible &&
              this.setDwgLayoutSceneRenderBg(e),
            e.render(this, this.getCamera()),
            i.setVisible(!0),
            e.render(i, this.getCamera()),
            i.setVisible(!1),
            e.setViewport(t),
            e.setScissor(t);
        };
      })(),
      setDwgLayoutSceneRenderBg: (function () {
        let t = new fe();
        return function (e) {
          t.setRGB(0, 0, 0), e.setClearColor(t), e.clear(!0, !0, !1);
        };
      })(),
      setDwgLayoutSceneRenderBgVisible(t) {
        this.dwgLayoutSceneRenderBgVisible = t;
      },
    })),
    (Hb.prototype = Object.assign(Object.create(om.prototype))),
    (Wb.prototype = Object.assign(Object.create(bm.prototype), {
      constructor: Wb,
      createBufferData: function (t) {
        let e = 0;
        switch (t.type()) {
          case Nb.BufferType.INT8:
            return (
              (e = t.bb.__offset(t.bb_pos, 6)),
              e
                ? new Int8Array(
                    t.bb.bytes().buffer,
                    t.bb.bytes().byteOffset + t.bb.__vector(t.bb_pos + e),
                    t.bb.__vector_len(t.bb_pos + e),
                  )
                : null
            );
          case Nb.BufferType.UINT8:
            return (
              (e = t.bb.__offset(t.bb_pos, 6)),
              e
                ? new Uint8Array(
                    t.bb.bytes().buffer,
                    t.bb.bytes().byteOffset + t.bb.__vector(t.bb_pos + e),
                    t.bb.__vector_len(t.bb_pos + e),
                  )
                : null
            );
          case Nb.BufferType.INT16:
            return (
              (e = t.bb.__offset(t.bb_pos, 6)),
              e
                ? new Int16Array(
                    t.bb.bytes().buffer,
                    t.bb.bytes().byteOffset + t.bb.__vector(t.bb_pos + e),
                    t.bb.__vector_len(t.bb_pos + e) / 2,
                  )
                : null
            );
          case Nb.BufferType.UINT16:
            return (
              (e = t.bb.__offset(t.bb_pos, 6)),
              e
                ? new Uint16Array(
                    t.bb.bytes().buffer,
                    t.bb.bytes().byteOffset + t.bb.__vector(t.bb_pos + e),
                    t.bb.__vector_len(t.bb_pos + e) / 2,
                  )
                : null
            );
          case Nb.BufferType.INT32:
            return (
              (e = t.bb.__offset(t.bb_pos, 6)),
              e
                ? new Int32Array(
                    t.bb.bytes().buffer,
                    t.bb.bytes().byteOffset + t.bb.__vector(t.bb_pos + e),
                    t.bb.__vector_len(t.bb_pos + e) / 4,
                  )
                : null
            );
          case Nb.BufferType.UINT32:
            return (
              (e = t.bb.__offset(t.bb_pos, 6)),
              e
                ? new Uint32Array(
                    t.bb.bytes().buffer,
                    t.bb.bytes().byteOffset + t.bb.__vector(t.bb_pos + e),
                    t.bb.__vector_len(t.bb_pos + e) / 4,
                  )
                : null
            );
          case Nb.BufferType.FLOAT32:
            return (
              (e = t.bb.__offset(t.bb_pos, 6)),
              e
                ? new Float32Array(
                    t.bb.bytes().buffer,
                    t.bb.bytes().byteOffset + t.bb.__vector(t.bb_pos + e),
                    t.bb.__vector_len(t.bb_pos + e) / 4,
                  )
                : null
            );
        }
        return null;
      },
      createBufferAttribute: function (t, e, n) {
        let i = this.createBufferData(e.buffer());
        if (i)
          switch (e.type()) {
            case Nb.VertexAttribute.INDEX:
              let r = new Wf(n);
              r.setIndex(i), t.setVertexIndex(r);
              break;
            case Nb.VertexAttribute.POSITION:
              t.addVertexBufferAttribute(
                'position',
                new Fe(i, e.elementPerVertex()),
              );
              break;
            case Nb.VertexAttribute.COLOR:
              t.addVertexBufferAttribute(
                'color',
                new Fe(i, e.elementPerVertex()),
              );
              break;
            case Nb.VertexAttribute.NORMAL:
              t.addVertexBufferAttribute(
                'normal',
                new Fe(i, e.elementPerVertex()),
              );
              break;
            case Nb.VertexAttribute.TEXTUREPARAM:
              t.addVertexBufferAttribute('uv', new Fe(i, e.elementPerVertex()));
              break;
            case Nb.VertexAttribute.INSTANCEMATR1:
              t.addInstanceVertexBufferAttribute(
                _m.name,
                new Fe(i, e.elementPerVertex()),
              );
              break;
            case Nb.VertexAttribute.INSTANCEMATR2:
              t.addInstanceVertexBufferAttribute(
                xm.name,
                new Fe(i, e.elementPerVertex()),
              );
              break;
            case Nb.VertexAttribute.INSTANCEMATR3:
              t.addInstanceVertexBufferAttribute(
                wm.name,
                new Fe(i, e.elementPerVertex()),
              );
              break;
            case Nb.VertexAttribute.INSTANCEMATR4:
              t.addInstanceVertexBufferAttribute(
                Am.name,
                new Fe(i, e.elementPerVertex()),
              );
              break;
            case Nb.VertexAttribute.CENTERLINECYLINDERRADIUS:
              t.addVertexBufferAttribute(
                'CCYRadius',
                new Le(i, e.elementPerVertex()),
              );
          }
      },
      createBufferGeometry: function (t) {
        let e =
            this.viewer.bimViewer.renderContext.renderer.capabilities.isWebGL2,
          n = t.vertexAttributeArrayLength();
        if (0 === n) return null;
        let i,
          r = null;
        switch (t.type()) {
          case Nb.GeometryType.POINT:
            (r = new Vm()), (i = Hf.POINT);
            break;
          case Nb.GeometryType.UNKNOWN:
            break;
          case Nb.GeometryType.LINES:
            (r = new Vm()), (i = Hf.LINES);
            break;
          case Nb.GeometryType.LINE_LOOP:
          case Nb.GeometryType.LINE_STRIP:
            break;
          case Nb.GeometryType.TRIANGLES:
            (r = new Vm()), (i = Hf.TRIANGLES);
            break;
          case Nb.GeometryType.TRIANGLE_STRIP:
          case Nb.GeometryType.TRIANGLE_FAN:
            break;
          case Nb.GeometryType.INSTANCE_MESH:
            (r = new Nm()), (i = Hf.TRIANGLES);
            break;
          case Nb.GeometryType.CENTRELINE_MESH:
            (r = new Vm()), (i = e ? Hf.TRIANGLE_STRIP : Hf.TRIANGLES);
        }
        if (r) {
          r.setUUID(t.uuid());
          for (let e = 0; e < n; e++)
            this.createBufferAttribute(r, t.vertexAttributeArray(e), i);
          if (t.type() === Nb.GeometryType.CENTRELINE_MESH) {
            (r.CycleSegCount = 8), (r.WebGl2Buffer = e);
            let t = 2;
            r.CycleSegCount >= 24 && e
              ? ((r.CycleSegCount = 24), (t = 0))
              : r.CycleSegCount >= 16 && e
              ? ((r.CycleSegCount = 16), (t = 1))
              : ((r.CycleSegCount = 8), (t = 2));
            let n = r.getVertexIndex().bufferAttribute,
              i = new Uint32Array(n.array.length);
            r.addVertexBufferAttribute('oldIndex', new Le(i, 1));
            let o = r.getVertexBufferAttribute('CCYRadius'),
              s = o.array.byteOffset,
              a = new DataView(o.array.buffer),
              c = o.array.length / 2,
              l = new Uint32Array(c),
              h = new Float32Array(c);
            for (let t = 0; t < c; ++t) {
              let e = 2 * t,
                n = 8 * t + s + 4;
              (l[t] = o.array[e]), (h[t] = a.getFloat32(n, !0));
            }
            r.removeVertexBufferAttribute('CCYRadius');
            let u = r.getVertexBufferAttribute('position'),
              d = u.count,
              p = u.itemSize,
              f = n.array,
              m = u.array,
              b = new Array(),
              g = 0;
            for (let t = 0; t < f.length; ++t)
              4294967295 === f[t] &&
                (b.push({ first: g, second: t }), (g = t + 1));
            let y = new Array(d),
              v = new Array(d),
              _ = new Array(d);
            for (let t = 0; t < d; ++t) {
              let e = l.findIndex((e) => e > t);
              e < 0 ? (e = 0) : e > 0 && --e;
              let n = h[e];
              (v[t] = n), (y[t] = new J()), (_[t] = new J());
            }
            let x = new J(),
              w = new J(),
              A = new J(),
              M = -1;
            b.forEach((t) => {
              M = -1;
              for (let e = t.first; e < t.second; ++e) {
                let n = e == t.first ? t.second - 1 : e - 1,
                  i = e == t.second - 1 ? t.first : e + 1,
                  r = f[e],
                  o = f[n],
                  s = f[i],
                  a = r * p,
                  c = o * p,
                  l = s * p;
                if (
                  ((x.x = m[l] - m[a]),
                  (x.y = m[l + 1] - m[a + 1]),
                  (x.z = m[l + 2] - m[a + 2]),
                  -1 === M)
                ) {
                  if (
                    ((w.x = m[a] - m[c]),
                    (w.y = m[a + 1] - m[c + 1]),
                    (w.z = m[a + 2] - m[c + 2]),
                    w.lengthSq() < 1e-8)
                  )
                    continue;
                  w.normalize(), (M = r);
                }
                x.lengthSq() < 1e-8 ? x.copy(w) : x.normalize();
                let h = e === t.first,
                  u = e === t.second - 1;
                if (h || u) {
                  h || x.copy(w), _[r].copy(x), y[r].copy(x), w.copy(x);
                  continue;
                }
                _[r].copy(x), A.copy(w), A.add(x);
                let d = A.length();
                A.normalize();
                let b = w.dot(A);
                0.999999 < Math.abs(b) ||
                1e-6 > Math.abs(b) ||
                d < 1e-6 ||
                (0 == A.x && 0 == A.y && 0 == A.z)
                  ? y[r].copy(x)
                  : y[r].copy(A),
                  w.copy(x);
              }
              for (let e = t.first; e < M; ++e) {
                let t = f[e];
                (y[t] = y[M]), (_[t] = _[M]);
              }
            });
            let S = 4,
              I = b.length,
              E = 2 * I * r.CycleSegCount,
              D = new Float32Array((2 * d + E) * S),
              C = 0;
            if (e) C = 2 * n.count - I + 2 * I * (r.CycleSegCount + 1);
            else {
              C = 6 * (n.count - 2 * I + (r.CycleSegCount - 2) * I);
            }
            let T = new Uint32Array(C),
              L = e ? 3 : 4,
              R = (2 * d + E) * L,
              F = new Float32Array(R),
              P = new Float32Array(R);
            r.addVertexBufferAttribute('CcyMatR1', new Fe(F, L)),
              r.addVertexBufferAttribute('CcyMatR2', new Fe(P, L));
            let B = 0,
              O = 0,
              V = 0,
              N = new DataView(D.buffer);
            b.forEach((n) => {
              for (let t = n.first; t < n.second; ++t) {
                let r = B / 4;
                e ||
                  (t >= 2 + n.first &&
                    ((T[V] = T[V - 2]), ++V, (T[V] = T[V - 2]), ++V)),
                  (i[t] = r),
                  (T[V++] = r),
                  e ||
                    (t >= 1 + n.first &&
                      ((T[V] = T[V - 2]), ++V, (T[V] = T[V - 2]), ++V)),
                  (T[V++] = r + 1);
                let o = f[t],
                  s = o * p;
                if (
                  ((D[B + 4] = D[B] = u.array[s]),
                  (D[B + 5] = D[B + 1] = u.array[s + 1]),
                  (D[B + 6] = D[B + 2] = u.array[s + 2]),
                  (F[O + L] = F[O] = y[o].x),
                  (F[O + 1 + L] = F[O + 1] = y[o].y),
                  (F[O + 2 + L] = F[O + 2] = y[o].z),
                  (P[O + 0 + L] = P[O] = _[o].x),
                  (P[O + 1 + L] = P[O + 1] = _[o].y),
                  (P[O + 2 + L] = P[O + 2] = _[o].z),
                  e)
                ) {
                  let t = 1048575 & parseInt(1e3 * v[o]);
                  N.setInt32(4 * (B + 3), t, !0),
                    N.setInt32(4 * (B + 7), 1048576 + t, !0);
                } else
                  (D[B + 3] = D[B + 7] = v[o]),
                    (F[O + 3] = F[O + 3 + L] = 0),
                    (P[O + 3] = 0),
                    (P[O + 3 + L] = 1);
                (B += 2 * S), (O += 2 * L);
              }
              (i[n.second] = 4294967295), e && (T[V++] = 4294967295);
              let o = [f[n.first], f[n.second - 1]];
              for (let n = 0; n < 2; ++n) {
                let i = o[n],
                  s = i * p,
                  a = 1048575 & parseInt(1e3 * v[i]);
                for (let o = 0; o < r.CycleSegCount; ++o) {
                  let r = B / 4;
                  !e &&
                    o > 2 &&
                    ((T[V] = T[V - 2]), ++V, (T[V] = T[V - 2]), ++V),
                    (T[V++] = r),
                    (D[B] = m[s]),
                    (D[B + 1] = m[s + 1]),
                    (D[B + 2] = m[s + 2]),
                    (P[O] = _[i].x),
                    (P[O + 1] = _[i].y),
                    (P[O + 2] = _[i].z);
                  let c = n + 1,
                    l = o;
                  e
                    ? N.setInt32(
                        4 * (B + 3),
                        (c << 30) + (t << 28) + (l << 20) + a,
                        !0,
                      )
                    : ((D[B + 3] = v[i]), (F[O + 3] = c), (P[O + 3] = l)),
                    (B += S),
                    (O += L);
                }
                e && (T[V++] = 4294967295);
              }
            }),
              (u.array = D),
              (u.count = D.length / S),
              (u.itemSize = S),
              (n.array = T),
              (n.count = T.length),
              r.updateVertexBoundingSphere();
          }
          return r;
        }
      },
      createBufferGeometryDataFile: function (t) {
        let e = new lm.ByteBuffer(new Uint8Array(t));
        return Nb.BufferGeometryDataFile.getRootAsBufferGeometryDataFile(e);
      },
      createBufferGeometryArray: function (t, e, n, i, r) {
        for (let i = 0, o = t.bufferGeometryArrayLength(); i < o; i++) {
          let o,
            s = t.bufferGeometryArray(i),
            a = this.createBufferGeometry(s);
          if (a) {
            if (a.getVertexBufferAttribute('oldIndex')) {
              if (((o = n.get(s.materialID())), !o)) {
                (o = new oa({ color: 16711680 })), (o.side = 2);
                let t = e.get(s.materialID());
                t && (o.color = t.color), n.set(s.materialID(), o);
              }
            } else
              (o = e.get(s.materialID())),
                o || (o = new xe({ color: 16711680 }));
            a.setMaterial(o), r.push(a);
          }
        }
        for (let e = 0, n = t.instanceBufferGeometryArrayLength(); e < n; e++) {
          let n = t.instanceBufferGeometryArray(e),
            o = i.get(n.refID());
          if (!o) continue;
          let s = o.getRefObjectArray();
          for (let t = 0, e = s.length; t < e; t++) {
            let e = this.createBufferGeometry(n);
            if (!e) continue;
            let i = s[t];
            e.setUUID(i.getUUID().toString() + n.uuid().toString()),
              e.setVertexAttributeArray(i.getVertexAttributeArray()),
              e.setVertexIndex(i.getVertexIndex()),
              e.setMaterial(i.getMaterial()),
              e.updateInstanceBoundingSphere(),
              r.push(e);
          }
        }
      },
      createRefDefinitionMap: function (t, e, n) {
        let i = new lm.ByteBuffer(new Uint8Array(t)),
          r = Nb.RefDefinitionDataFile.getRootAsRefDefinitionDataFile(i);
        for (let t = 0, i = r.refDefinitionArrayLength(); t < i; t++) {
          let i = r.refDefinitionArray(t),
            o = new Um();
          o.setUUID(i.uuid());
          for (let t = 0, n = i.bufferGeometryArrayLength(); t < n; t++) {
            let n = i.bufferGeometryArray(t),
              r = this.createBufferGeometry(n);
            if (!r) continue;
            let s = e.get(n.materialID());
            r.setMaterial(s || new xe({ color: 16711680 })),
              r.sortVertexIndex(),
              o.addRefObject(r);
          }
          n.set(o.getUUID(), o);
        }
      },
      createMaterial: function (t, e, n) {
        let i = null;
        'dwg' === this.viewer.type
          ? (i = new Eo())
          : ((i = new ea()), (i.smoothLighting = !0), (i.shininess = 1)),
          t.enablePolygonOffset() &&
            i.setVertexOffset(t.polygonOffsetFactor() * this.sceneScale),
          (i.mapCopy = this.getImageData(t.image(), e)),
          (i.map = i.mapCopy),
          (i.colorCopy = new fe(t.color())),
          i.map || (i.color = i.colorCopy),
          (i.transparent = t.enableTransparent()),
          (i.opacity = t.transparency()),
          i.opacity > 0.999999 && !i.map && (i.transparent = !1),
          i.transparent && 1 === i.opacity && (i.blending = 1),
          i.transparent || (i.opacity = 1),
          (i.flatShading = !1),
          (i.depthFunc = void 0 === t.depthFunc() ? 2 : t.depthFunc()),
          (i.blending = 1),
          (i.polygonOffset = t.enablePolygonOffset()),
          (i.polygonOffsetUnits = t.polygonOffsetUnits() / 1e3),
          (i.polygonOffsetFactor = t.polygonOffsetFactor() / 1e3),
          (i.alphaTest = 0.05),
          this.isPhone
            ? (i.side = !0 === t.doubleSide() ? 2 : 0)
            : ((i.side = 2), (i.precision = 'highp')),
          (i.userData = t.uuid()),
          n.set(t.uuid(), i);
      },
      createMaterialMap: function (t, e, n) {
        let i = new lm.ByteBuffer(new Uint8Array(t)),
          r = Nb.MaterialDataFile.getRootAsMaterialDataFile(i);
        for (let t = 0, i = r.materialArrayLength(); t < i; t++) {
          let i = r.materialArray(t);
          this.createMaterial(i, e, n);
        }
      },
      getImageData: function (t, e) {
        if (!t) return null;
        let n = e.get(t.uuid());
        if (n) return n;
        let i = `${this.fileLoader.getCloudURL()}IMG${t.url()}`;
        if (t.isUserImage()) {
          let e = this.fileLoader.getFileIndex(t.url());
          e && (i = e.getURL());
        }
        return (
          i.includes('.tga')
            ? (n = this.TGALoader.load(
                i,
                () => {
                  console.log('tga贴图加载成功');
                },
                void 0,
                () => {
                  console.log('tga贴图加载失败');
                },
              ))
            : ((n = this.textureLoader.load(
                i,
                () => {
                  console.log('贴图加载成功');
                },
                void 0,
                () => {
                  console.log('贴图加载失败');
                },
              )),
              (n.format = v)),
          (n.wrapS = this.textureWrapS),
          (n.wrapT = this.textureWrapT),
          (n.anisotropy = this.texturemaxAnisotropy),
          e.set(t.uuid(), n),
          n
        );
      },
      createEntityMap: function (t, e) {
        let n = new lm.ByteBuffer(new Uint8Array(t)),
          i = Vb.EntInfoDataFile.getRootAsEntInfoDataFile(n),
          r = this.getModel().getModelTree();
        for (let t = 0, n = i.entInfoArrayLength(); t < n; t++) {
          let n = i.entInfoArray(t),
            o = e.get(n.id());
          o || ((o = new $f(n.id())), e.set(n.id(), o)),
            o.setEntInfo(
              n.id(),
              n.flootID(),
              n.comtype(),
              n.comID(),
              n.handle(),
            ),
            o.setSelectVisible(n.selectAbility());
          for (let t = 0, e = n.stageArrayLength(); t < e; t++)
            o.addLayerID(n.stageArray(t));
          if (!o.getModelNode())
            if (o.getModelNodeID() > 0) {
              let t = r.findNodeByID(o.getModelNodeID());
              t
                ? t.insertEntity(o)
                : console.warn(
                    'Invalid model-node at id: ' +
                      o.getModelNodeID().toString(),
                  );
            } else {
              if ('dwg' === this.viewer.type) {
                r.getRootNode()
                  .findChildByTypeValue(em, o.getComtype())[0]
                  .insertEntity(o);
              } else {
                let t = r
                  .getRootNode()
                  .findChildByTypeValue(nm, o.getFloorID());
                for (let e = 0, n = t.length; e < n; ++e) {
                  let n = t[e].findChildByTypeValue(im, o.getComtype());
                  if (n.length > 0) {
                    n.length > 1 && console.log(o), n[0].insertEntity(o);
                    break;
                  }
                }
              }
              o.getModelNode() ||
                console.warn(
                  'Invalid model-node at floorid:' +
                    o.getFloorID().toString() +
                    ' comtype:' +
                    o.getComtype().toString(),
                );
            }
        }
      },
      createEntityGeoData: (function () {
        let t = new J();
        function e(e, n, i) {
          t.set(e.bndBoxMin(0), e.bndBoxMin(1), e.bndBoxMin(2)),
            n.expandBoundingByPoint(t),
            t.set(e.bndBoxMax(0), e.bndBoxMax(1), e.bndBoxMax(2)),
            n.expandBoundingByPoint(t),
            i.addGeoData(n);
        }
        return (
          new J(),
          function (t, n, i) {
            let r = new lm.ByteBuffer(new Uint8Array(t)),
              o = Vb.EntDataDataFile.getRootAsEntDataDataFile(r);
            for (let t = 0, n = o.meshDataArrayLength(); t < n; t++) {
              let n = o.meshDataArray(t),
                r = i.get(n.entID());
              r || ((r = new $f(n.entID())), i.set(n.entID(), r));
              let s = new Yf(
                n.geoID(),
                new vm(3 * n.trianglesOffset(), 3 * n.trianglesCount(), 0, 0),
              );
              e(n, s, r);
            }
            for (
              let t = 0, n = o.centerLineCylinderDataArrayLength();
              t < n;
              t++
            ) {
              let n = o.centerLineCylinderDataArray(t),
                r = i.get(n.entID());
              r || ((r = new $f(n.entID())), i.set(n.entID(), r));
              let s = new Yf(
                n.geoID(),
                new vm(n.indeciesOffset(), n.indeciesCount(), 0, 0),
              );
              (s.isCCy = !0),
                (s.lineCountBefore = n.lineCountBefore()),
                (s.lineCountThis = n.lineCountThis()),
                e(n, s, r);
            }
            for (let t = 0, r = o.instanceMeshDataArrayLength(); t < r; t++) {
              let r = o.instanceMeshDataArray(t),
                s = n.get(r.instancedRefDefinitionID());
              if (!s) continue;
              let a = s.getRefObjectArray();
              for (let t = 0, n = a.length; t < n; t++) {
                let n = i.get(r.entID());
                n || ((n = new $f(r.entID())), i.set(r.entID(), n));
                let o = new Yf(
                  a[t].getUUID().toString() + r.geoID().toString(),
                  new vm(r.matrixIndex(), 1, 0, 0),
                );
                e(r, o, n);
              }
            }
            for (let t = 0, n = o.lineDataArrayLength(); t < n; t++) {
              let n = o.lineDataArray(t),
                r = i.get(n.entID());
              r || ((r = new $f(n.entID())), i.set(n.entID(), r));
              let s = new Yf(
                n.geoID(),
                new vm(2 * n.lineSegOffset(), 2 * n.lineSegCount(), 0, 0),
              );
              e(n, s, r);
            }
            for (let t = 0, r = o.InstanceLineDataArrayLength(); t < r; t++) {
              let r = o.InstanceLineDataArray(t),
                s = n.get(r.instancedRefDefinitionID());
              if (!s) continue;
              let a = s.getRefObjectArray();
              for (let t = 0, n = a.length; t < n; t++) {
                let n = i.get(r.entID());
                n || ((n = new $f(r.entID())), i.set(r.entID(), n));
                let o = new Yf(
                  a[t].getUUID().toString() + r.geoID().toString(),
                  new vm(r.matrixIndex(), 1, 0, 0),
                );
                e(r, o, n);
              }
            }
            for (let t = 0, n = o.pointDataArrayLength(); t < n; t++) {
              let n = o.pointDataArray(t),
                r = i.get(n.entID());
              r || ((r = new $f(n.entID())), i.set(n.entID(), r));
              let s = new Yf(
                n.geoID(),
                new vm(1 * n.pointOffset(), 1 * n.pointCount(), 0, 0),
              );
              e(n, s, r);
            }
          }
        );
      })(),
      createHeadDataFile: function (t) {
        let e = new lm.ByteBuffer(new Uint8Array(t));
        return Gb.HeadDataFile.getRootAsHeadDataFile(e);
      },
      getHeadFileVersion: function (t) {
        return t ? t.version() : -1;
      },
      getBasicFileTotal: (t) =>
        t.materialDataFileArrayLength() +
        t.refDefinitionDataFileArrayLength() +
        t.floorAxisFileArrayLength() +
        t.layoutDataFileLength() +
        1 +
        1 +
        1,
      createMaterialFileIndexArray: function (t, e) {
        if (!t) return null;
        for (let n = 0, i = t.materialDataFileArrayLength(); n < i; n++) {
          let i = this.createFileIndex(t.materialDataFileArray(n));
          i && e.push(i);
        }
      },
      createRefDefinitionFileIndexArray: function (t, e) {
        if (!t) return null;
        for (let n = 0, i = t.refDefinitionDataFileArrayLength(); n < i; n++) {
          let i = this.createFileIndex(t.refDefinitionDataFileArray(n));
          i && e.push(i);
        }
      },
      createProjectFileIndex: function (t) {
        return t ? this.createFileIndex(t.projectFileIndex()) : null;
      },
      createFloorAxisFileIndexArray: function (t, e) {
        if (!t) return null;
        for (let n = 0, i = t.floorAxisFileArrayLength(); n < i; n++) {
          let i = this.createFileIndex(t.floorAxisFileArray(n));
          i && e.push(i);
        }
      },
      createFloorAxisArray: function (t, e) {
        let n = new lm.ByteBuffer(new Uint8Array(t)),
          i = kb.FloorAxisInfoDataFile.getRootAsFloorAxisInfoDataFile(n),
          r = [];
        for (let t = 0; t < i.floorAxisInfoArrayLength(); t++) {
          let e = i.floorAxisInfoArray(t),
            n = [];
          for (let t = 0; t < e.axisLineArrayLength(); t++) {
            let i = e.axisLineArray(t),
              r = {
                textHeight: i.symbol().textHeight(),
                textRoundRadius: i.symbol().textRoundRadius(),
                name: i.symbol().name(),
                textInsert: i.symbol().positionArray(),
                start: i.startArray(),
                end: i.endArray(),
              };
            n.push(r);
          }
          let o = [];
          for (let t = 0; t < e.axisArcArrayLength(); t++) {
            let n = e.axisArcArray(t),
              i = {
                textHeight: n.symbol().textHeight(),
                textRoundRadius: n.symbol().textRoundRadius(),
                name: n.symbol().name(),
                textInsert: n.symbol().positionArray(),
                center: n.centerArray(),
                radius: n.radiu(),
                startAngle: n.startAngle(),
                endAngle: n.endAngle(),
                antiClockWise: n.antiClockWise(),
              };
            o.push(i);
          }
          let s = [];
          for (let t = 0; t < e.axisLineSegArrayLength(); t++) {
            let n = e.axisLineSegArray(t),
              i = {
                start: Array.prototype.slice.call(n.startArray()),
                end: Array.prototype.slice.call(n.endArray()),
              };
            s.push(i);
          }
          let a = {
            floorId: e.id(),
            floorHeight: e.height(),
            floorElevation: e.elevation(),
            floorName: e.name(),
            axisNetLineArray: n,
            axisNetArcArray: o,
            crossLines: s,
          };
          r.push(a);
        }
        e.setFloorAxisArray(r);
      },
      getDefaultCamera: function (t) {
        let e = t.defaultCamera();
        return {
          position: e.positionArray(),
          Target: e.targetArray(),
          up: e.upvecArray(),
          Width: e.width(),
          Height: e.height(),
        };
      },
      getSceneBoundingBox: function (t) {
        let e = t.rootNode();
        return { bndBoxMin: e.bndBoxMinArray(), bndBoxMax: e.bndBoxMaxArray() };
      },
      getSceneRootNode: function (t) {
        return t.rootNode();
      },
      getSceneScale: function (t) {
        return t.scale();
      },
      createSceneTree: function (t, e) {
        if (!t || !e) return;
        let n = new Pm(this);
        e.add(n);
        let i = t.bndBoxMinArray(),
          r = t.bndBoxMaxArray();
        if ('dwg' === this.viewer.type) {
          let t = new J(i[0], i[1], i[2]),
            e = new J(r[0], r[1], r[2]);
          n.setBndBox(new Nt(t, e));
        } else {
          let t = new J(i[0] - 1e-5, i[1] - 1e-5, i[2] - 1e-5),
            e = new J(r[0] + 1e-5, r[1] + 1e-5, r[2] + 1e-5);
          n.setBndBox(new Nt(t, e));
        }
        let o = this.createPageData(t.nodeData());
        o && (o.setUsage(-1), n.setPageData(o));
        for (let e = 0, i = t.lodDataLength(); e < i; e++) {
          let i = t.lodData(e);
          if (!i) continue;
          let r = this.createPageData(i.pageData());
          if (!r) continue;
          r.setUsage(i.level());
          let o = new zb();
          o.setLoadRange(i.minLoadDistance(), i.maxLoadDistance()),
            o.setPageData(r),
            n.addPageLOD(o);
        }
        for (let e = 0, i = t.entInfoDataFileArrayLength(); e < i; e++) {
          let i = this.createFileIndex(t.entInfoDataFileArray(e));
          i && n.addEntInfoFileList(i);
        }
        for (let e = 0, i = t.childNodeArrayLength(); e < i; e++)
          this.createSceneTree(t.childNodeArray(e), n);
      },
      createPageData: function (t) {
        if (!t) return null;
        let e = new km();
        e.setContentSize(t.dataContentSize());
        for (let n = 0, i = t.bufferGeometryDataFileArrayLength(); n < i; n++) {
          let i = this.createFileIndex(t.bufferGeometryDataFileArray(n));
          i && e.addBufferGeometryFile(i);
        }
        for (let n = 0, i = t.entDataDataFileArrayLength(); n < i; n++) {
          let i = this.createFileIndex(t.entDataDataFileArray(n));
          i && e.addEntDataFileList(i);
        }
        return e;
      },
      createFileIndex: function (t) {
        if (!t) return null;
        let e = new gm();
        return (
          e.setID(t.id()), e.setURL(t.url()), e.setFileSize(t.fileSize()), e
        );
      },
      createSceneDataFile: function (t) {
        let e = this.fileLoader.getFileIndex(
          this.createFileIndex(t.sceneDataFile()).getURL(),
        );
        return new Promise((t) => {
          this.fileLoader.loadFile(e).then((e) => {
            let n = new lm.ByteBuffer(new Uint8Array(e.data));
            t(Gb.SceneDataFile.getRootAsSceneDataFile(n));
          });
        });
      },
      createSceneData: function (t, e) {
        let n = this.getSceneRootNode(t);
        this.createSceneTree(n, e.getSceneNode()),
          (this.viewer.scale = this.getSceneScale(t)),
          (this.viewer.dwgDefaultView = this.getDefaultCamera(t));
      },
      createProjectDataFile: function (t) {
        let e = this.fileLoader.getFileIndex(
          this.createFileIndex(t.projectFileIndex()).getURL(),
        );
        return new Promise((t) => {
          this.fileLoader.loadFile(e).then((e) => {
            let n = new lm.ByteBuffer(new Uint8Array(e.data));
            t(kb.ProjectDataFile.getRootAsProjectDataFile(n));
          });
        });
      },
      createCadComponentsDataFile: function (t) {
        let e = this.fileLoader.getFileIndex(
          this.createFileIndex(t.cadComponentsDataFile()).getURL(),
        );
        return new Promise((t) => {
          this.fileLoader.loadFile(e).then((e) => {
            let n = new lm.ByteBuffer(new Uint8Array(e.data));
            t(Ub.CADComponentsDataFile.getRootAsCADComponentsDataFile(n));
          });
        });
      },
      createDwgLayer: function (t, e) {
        let n = e.getModelTree();
        for (let e = 0, i = t.layerInfoArrayLength(); e < i; e++) {
          let i = t.layerInfoArray(e),
            r = new Hb(em, i.name(), i.color(), i.id(), i.show());
          n.insertNode(r);
        }
      },
      createLayoutDataFileArray: function (t, e) {
        if (!t) return null;
        for (let n = 0; n < t.layoutDataFileLength(); n++) {
          let i = this.createFileIndex(t.layoutDataFile(n));
          i && e.push(i);
        }
      },
      createDwgLayout: function (t, e) {
        let n = new lm.ByteBuffer(new Uint8Array(t)),
          i = Gb.LayoutDataFile.getRootAsLayoutDataFile(n),
          r = this.viewer.viewDevices.getDevicesWidthHeight(),
          o = r.w,
          s = r.h;
        for (let t = 0; t < i.layoutArrayLength(); t++) {
          let n = i.layoutArray(t),
            r = n.name(),
            a = { showThis: !1, bndBox: null, sceneArr: [] };
          const c = new hb(o, s, null, r);
          this.viewer.bimViewer.addDwgLayoutSceneArray(c), a.sceneArr.push(c);
          let l = n.node(),
            h = new Pm(this);
          this.createSceneTree(l, h);
          let u = new Bm('', this);
          u.setSceneNode(h), c.addModel(u);
          let d = l.bndBoxMinArray(),
            p = l.bndBoxMaxArray(),
            f = new J(d[0], d[1], d[2]),
            m = new J(p[0], p[1], p[2]);
          a.bndBox = new Nt(f, m);
          for (let t = 0; t < n.subViewPortArrayLength(); t++) {
            let e = n.subViewPortArray(t);
            const i = new jb(
              r,
              {
                viewMatrix: e.viewMatrixArray(),
                Width: e.width(),
                Height: e.height(),
                startPt: e.startPtArray(),
                endPt: e.endPtArray(),
              },
              this.viewer,
            );
            this.viewer.bimViewer.addDwgLayoutSceneArray(i), a.sceneArr.push(i);
          }
          e.set(r, a);
        }
      },
      createModelTree: function (t, e) {
        let n = e.getModelTree();
        for (let e = 0, i = t.buildingInfoArrayLength(); e < i; e++) {
          let i = this.createBuildingNode(t.buildingInfoArray(e), n);
          n.insertNode(i);
        }
        for (let e = 0, i = t.stageInfoArrayLength(); e < i; e++) {
          let i = t.stageInfoArray(e),
            r = new sm(i.name(), i.id());
          n.addLayer(r);
        }
      },
      createBuildingNode: function (t, e) {
        let n = new om(em, t.name(), t.id(), e);
        for (let i = 0, r = t.floorInfoArrayLength(); i < r; i++) {
          let r = this.createFloorNode(t.floorInfoArray(i), e);
          n.addChild(r);
        }
        return n;
      },
      createFloorNode: function (t, e) {
        let n = new om(nm, t.name(), t.id(), e);
        for (let i = 0, r = t.baseComtypeArrayLength(); i < r; i++) {
          let r = this.createBaseComtypeNode(t.baseComtypeArray(i), e);
          n.addChild(r);
        }
        return n;
      },
      createBaseComtypeNode: function (t, e) {
        let n = new om(im, t.name(), t.id(), e);
        for (let i = 0, r = t.comtypeArrayLength(); i < r; i++) {
          let r = this.createComtypeNode(t.comtypeArray(i), e);
          n.addChild(r);
        }
        for (let i = 0, r = t.baseComtypeArrayLength(); i < r; i++) {
          let r = this.createBaseComtypeNode(t.baseComtypeArray(i), e);
          n.addChild(r);
        }
        return n;
      },
      createComtypeNode: function (t, e) {
        let n = new om(im, t.name(), t.id(), e);
        for (let i = 0, r = t.comidArrayLength(); i < r; i++) {
          let r = this.createComidNode(t.comidArray(i), e);
          n.addChild(r);
        }
        for (let i = 0, r = t.comtypeInfoArrayLength(); i < r; i++) {
          let r = this.createComtypeNode(t.comtypeInfoArray(i), e);
          n.addChild(r);
        }
        return n;
      },
      createComidNode: function (t, e) {
        let n = new om(rm, t.name(), t.id(), e);
        for (let e = 0, n = t.handleArrayLength(); e < n; e++);
        return n;
      },
      async loadModel(t, e, n) {
        let i = this.createHeadDataFile(t);
        if (!i) return;
        let r = this.getFileLoader();
        r.setBasicFileTotal(this.getBasicFileTotal(i)),
          await this.createSceneDataFile(i).then((t) => {
            r.setBasicProgress(1),
              n(r.getBasicProgress()),
              this.createSceneData(t, e);
          });
        let o = [];
        this.createMaterialFileIndexArray(i, o);
        let s = [],
          a = e.getTextureImageMap(),
          c = e.getMaterialMap();
        for (let t = 0, e = o.length; t < e; t++) {
          let e = r.getFileIndex(o[t].getURL());
          e &&
            s.push(
              r.loadFile(e).then((t) => {
                r.setBasicProgress(1),
                  n(r.getBasicProgress()),
                  this.createMaterialMap(t.data, a, c);
              }),
            );
        }
        await Promise.all(s);
        let l = [];
        this.createRefDefinitionFileIndexArray(i, l);
        let h = [],
          u = e.getRefDefinitionMap();
        for (let t = 0, e = l.length; t < e; t++) {
          let e = r.getFileIndex(l[t].getURL());
          e &&
            h.push(
              r.loadFile(e).then((t) => {
                r.setBasicProgress(1),
                  n(r.getBasicProgress()),
                  this.createRefDefinitionMap(t.data, c, u);
              }),
            );
        }
        if (
          (await Promise.all(h),
          await this.createProjectDataFile(i).then((t) => {
            r.setBasicProgress(1),
              n(r.getBasicProgress()),
              'dwg' === this.viewer.type || this.createModelTree(t, e);
          }),
          i.cadComponentsDataFile() &&
            (await this.createCadComponentsDataFile(i).then((t) => {
              r.setBasicProgress(1),
                n(r.getBasicProgress()),
                this.createDwgLayer(t, e);
            })),
          i.layoutDataFile())
        ) {
          let t = [];
          this.createLayoutDataFileArray(i, t);
          let o = [];
          for (let i = 0; i < t.length; i++) {
            let s = r.getFileIndex(t[i].getURL());
            s &&
              o.push(
                r.loadFile(s).then((t) => {
                  r.setBasicProgress(1), n(r.getBasicProgress());
                  let i = new Map();
                  this.createDwgLayout(t.data, i), e.setDwgLayoutMap(i);
                }),
              );
          }
          await Promise.all(o);
        }
        let d = [];
        this.createFloorAxisFileIndexArray(i, d);
        let p = [];
        for (let t = 0, i = d.length; t < i; t++) {
          let i = r.getFileIndex(d[t].getURL());
          i &&
            p.push(
              r.loadFile(i).then((t) => {
                r.setBasicProgress(1),
                  n(r.getBasicProgress()),
                  this.createFloorAxisArray(t.data, e);
              }),
            );
        }
        if ((await Promise.all(p), this.cancelCreateModel))
          throw new Error('取消了加载');
      },
      createModel: function (t, e) {
        return new Promise((n, i) => {
          this.model
            ? this.cancelCreateModel
              ? i('取消加载')
              : n(this.model)
            : this.fileLoader.loadFile(t.headFile).then((r) => {
                (this.model = new Bm(t.version, this)),
                  this.loadModel(r.data, this.model, e)
                    .then((t) => {
                      this.cancelCreateModel ? i('取消加载') : n(this.model);
                    })
                    .catch(() => {
                      i('.13 catch取消加载');
                    });
              });
        });
      },
      cancelCreateModelAsync: function () {
        this.cancelCreateModel = !0;
      },
      loadSceneNode: function (t, e, n) {
        if (!t || !e) return;
        const i = e.getBufferGeometryFileList(),
          r = e.getEntDataFileList(),
          o = t.getEntInfoFileList();
        let s = this.getFileLoader();
        const a = s.entInfoFileTotal + i.length + r.length + o.length;
        s.setEntInfoFileTotal(a);
        let c = this.getModel(),
          l = c.getMaterialMap(),
          h = c.getMaterialMap_CCY(),
          u = c.getRefDefinitionMap();
        for (let e = 0, r = i.length; e < r; e++) {
          let r = s.getFileIndex(i[e].getURL());
          if (!r) continue;
          let o = s.loadFile(r).then((e) => {
            let n = this.createBufferGeometryDataFile(e.data),
              i = [];
            this.createBufferGeometryArray(n, l, h, u, i);
            for (let e = 0, n = i.length; e < n; e++)
              t.renderBufferMap.set(i[e].getUUID(), i[e]),
                this.getBufferGeometryDataCallback &&
                  this.getBufferGeometryDataCallback(i[e]);
            this.samllProgress(s);
          });
          o && n.push(o);
        }
        for (let e = 0, i = r.length; e < i; e++) {
          let i = s.getFileIndex(r[e].getURL());
          if (!i) continue;
          let o = s.loadFile(i).then((e) => {
            this.createEntityGeoData(e.data, u, t.entityMap),
              this.samllProgress(s);
          });
          o && n.push(o);
        }
        for (let e = 0, i = o.length; e < i; e++) {
          let i = s.getFileIndex(o[e].getURL());
          if (!i) continue;
          let r = s.loadFile(i).then((e) => {
            this.createEntityMap(e.data, t.entityMap), this.samllProgress(s);
          });
          r && n.push(r);
        }
      },
      redefineEntData: function (t, e) {
        let n =
          this.viewer.bimViewer.renderContext.renderer.capabilities.isWebGL2;
        e.forEach((e) => {
          e.geoDataArray.forEach((e) => {
            if (e.isCCy) {
              let i = t.get(e.geoID);
              if (i) {
                let t = i.getVertexBufferAttribute('oldIndex'),
                  r = e.lineCountBefore,
                  o = e.lineCountThis;
                if (0 === o) {
                  for (let n = 0; n < e.bufferSegment.offset; ++n)
                    4294967295 === t.array[n] && ++r;
                  for (
                    let n = e.bufferSegment.offset,
                      i = n + e.bufferSegment.count;
                    n < i;
                    ++n
                  )
                    4294967295 === t.array[n] && ++o;
                }
                if (
                  ((e.bufferSegment.offset_old = e.bufferSegment.offset),
                  (e.bufferSegment.count_old = e.bufferSegment.count),
                  n)
                )
                  (e.bufferSegment.offset =
                    2 * e.bufferSegment.offset -
                    r +
                    2 * r * (i.CycleSegCount + 1)),
                    (e.bufferSegment.count =
                      2 * e.bufferSegment.count -
                      o +
                      2 * o * (i.CycleSegCount + 1));
                else {
                  let t =
                      6 *
                      (e.bufferSegment.offset -
                        2 * r +
                        (i.CycleSegCount - 2) * r),
                    n =
                      6 *
                      (e.bufferSegment.count -
                        2 * o +
                        (i.CycleSegCount - 2) * o);
                  (e.bufferSegment.offset = t), (e.bufferSegment.count = n);
                }
              } else console.log("error! Can't find geobuffer of CcyObject");
            }
          });
        });
      },
      samllProgress: function (t) {
        if (this.cancelCreateModel) return;
        t.setEntInfoProgress(1);
        const e = t.getEntInfoProgress();
        let n = document.getElementById(
            this.viewer.parentElementId + '__ccbim__small__progress__div',
          ),
          i = document.getElementById(
            this.viewer.parentElementId + '__ccbim__small__progress',
          );
        i && (i.style.display = 'block'),
          n && (n.style.width = e + '%'),
          e >= 100 &&
            (i && (i.style.display = 'none'),
            this.hasloadOnce ||
              setTimeout(() => {
                this.viewer.renderFinish(),
                  this.viewer.dispatchEvent({
                    type: 'renderFinish',
                    object: !0,
                  }),
                  (this.hasloadOnce = !0);
              }));
      },
    }));
  let Xb = 0;
  function Zb() {
    Wb.call(this),
      (this.clipBox = new Nt()),
      (this.material = new xe({ color: 16711680 })),
      (this.material.side = 2);
  }
  function Yb() {
    (this.position = new J()),
      (this.alignAxis = new J(0, 0, 1)),
      (this.scale = 1),
      (this.angle = 0);
  }
  function qb(t, e, n, i) {
    ob.call(this, t, e, n, i),
      (this.matrixAutoUpdate = !1),
      (this.state = new Yb()),
      (this.buffer = void 0),
      (this.glContext = void 0);
  }
  (Zb.prototype = Object.assign(Object.create(Wb.prototype), {
    constructor: Zb,
    createModelBuffer: (function () {
      let t = new vm(),
        e = new ot(),
        n = [new J(), new J(), new J()];
      function i(t, e, n) {
        return n.x < t.x || n.x > e.x || n.y < t.y || n.y > e.y;
      }
      function r(t, e, n, r) {
        for (let o = 0, s = r; o < s; ++o) if (!i(t, e, n[o])) return !1;
        return !0;
      }
      function o(t, e, n) {
        let i = Nb.BufferData.createDataVector(n, new Int8Array(e));
        return (
          Nb.BufferData.startBufferData(n),
          Nb.BufferData.addType(n, t),
          Nb.BufferData.addData(n, i),
          Nb.BufferData.endBufferData(n)
        );
      }
      function s(t, e, n, i, r) {
        return (
          Nb.BufferAttribute.startBufferAttribute(r),
          Nb.BufferAttribute.addType(r, t),
          Nb.BufferAttribute.addBuffer(r, e),
          Nb.BufferAttribute.addElementPerVertex(r, n),
          Nb.BufferAttribute.addInstanceAttribute(r, i),
          Nb.BufferAttribute.endBufferAttribute(r)
        );
      }
      function a(t, e, i, o, s, a, c) {
        let l = 0;
        switch (e.getDrawMode()) {
          case Hf.POINT:
            l = 1;
            break;
          case Hf.LINES:
            l = 2;
            break;
          case Hf.TRIANGLES:
            l = 3;
        }
        if (0 === l) return;
        let h = o.min,
          u = o.max,
          d = t.array,
          p = e.getBufferAttribute().array,
          f = [];
        for (let t = i.offset, e = i.offset + i.count; t < e; t += l) {
          for (let e = 0; e < l; e++) {
            let i = 3 * p[t + e];
            n[e].set(d[i], d[i + 1], d[i + 2]), c && n[e].applyMatrix4(c);
          }
          if (!r(h, u, n, l))
            for (let e = 0; e < l; e++) {
              let n = p[t + e];
              f.push(n);
            }
        }
        let m = new J(),
          b = new Map();
        for (let t = 0; t < f.length; t++) {
          let e = f[t];
          b.has(e) ||
            (m.set(d[3 * e], d[3 * e + 1], d[3 * e + 2]),
            c && m.applyMatrix4(c),
            s.push(m.x, m.y, m.z),
            b.set(e, s.length / 3 - 1)),
            a.push(b.get(e));
        }
      }
      function c(n, i, r, c) {
        let l = n.getRenderBuffer(),
          h = l.getVertexBufferAttribute('position');
        if (!h) return;
        let u = [],
          d = [],
          p = l.getVertexIndex();
        if (l.isPMInstanceRenderBuffer) {
          t.set(0, p.getBufferAttribute().array.length);
          let n = l.getInstanceVertexAttributeArray(),
            o = n.getBufferAttribute(_m.name).array,
            s = n.getBufferAttribute(xm.name).array,
            c = n.getBufferAttribute(wm.name).array,
            f = n.getBufferAttribute(Am.name).array;
          for (let n = 0, l = i.length; n < l; ++n) {
            let l = i[n];
            for (let n = 0, i = l.count; n < i; ++n)
              PMMath.getInstanceMatrixByArray(o, s, c, f, l.start() + n, e),
                a(h, p, t, r, u, d, e);
          }
        } else for (let t = 0, e = i.length; t < e; ++t) a(h, p, i[t], r, u, d);
        if (0 === u.length) return;
        let f = r.min,
          m = new ArrayBuffer(4 * u.length),
          b = new Float32Array(m);
        for (let t = 0, e = b.length; t < e; t += 3)
          (b[t] = u[t] - f.x),
            (b[t + 1] = u[t + 1] - f.y),
            (b[t + 2] = u[t + 2] - f.z);
        let g = o(Nb.BufferType.FLOAT32, m, c),
          y = s(Nb.VertexAttribute.POSITION, g, 3, !1, c);
        m = new ArrayBuffer(4 * d.length);
        let v = new Uint32Array(m);
        for (let t = 0, e = d.length; t < e; ++t) v[t] = d[t];
        let _ = o(Nb.BufferType.UINT32, m, c),
          x = s(Nb.VertexAttribute.INDEX, _, 1, !1, c),
          w = Nb.BufferGeometry.createVertexAttributeArrayVector(c, [y, x]);
        return (
          Nb.BufferGeometry.startBufferGeometry(c),
          Nb.BufferGeometry.addUuid(c, ++Xb),
          Nb.BufferGeometry.addType(
            c,
            (function (t) {
              switch (t) {
                case Hf.POINT:
                  return Nb.GeometryType.POINT;
                case Hf.LINES:
                  return Nb.GeometryType.LINES;
                case Hf.LINE_LOOP:
                  return Nb.GeometryType.LINE_LOOP;
                case Hf.LINE_STRIP:
                  return Nb.GeometryType.LINE_STRIP;
                case Hf.TRIANGLES:
                  return Nb.GeometryType.TRIANGLES;
                case Hf.TRIANGLE_STRIP:
                  return Nb.GeometryType.TRIANGLE_STRIP;
                case Hf.TRIANGLE_FAN:
                  return Nb.GeometryType.TRIANGLE_FAN;
              }
              return Nb.GeometryType.UNKNOWN;
            })(l.getVertexIndex().getDrawMode()),
          ),
          Nb.BufferGeometry.addVertexAttributeArray(c, w),
          Nb.BufferGeometry.endBufferGeometry(c)
        );
      }
      function l(t, e, n) {
        let i = t.getGeoDataArray();
        for (let t = 0, e = i.length; t < e; ++t) {
          let e = i[t].getRenderObject();
          if (e) {
            let r = n.get(e);
            void 0 === r
              ? ((r = [i[t].getBufferSegment()]), n.set(e, r))
              : r.push(i[t].getBufferSegment());
          }
        }
      }
      function h(t, e, n, i) {
        if (t.isPMSceneNode) {
          let r = t.entityArray,
            o = new Map();
          for (let t = 0, e = r.length; t < e; ++t) l(r[t], 0, o);
          for (let [t, r] of o) {
            let o = c(t, r, e, n);
            o && i.push(o);
          }
        }
        let r = t.children;
        for (let t = 0, o = r.length; t < o; ++t) h(r[t], e, n, i);
      }
      function u(t, e, n) {
        let i = [];
        return (
          h(t.getSceneNode(), e, n, i),
          Nb.ModelDataFile.createBufferGeometryArrayVector(n, i)
        );
      }
      function d(t, e) {
        return Nb.ModelDataFile.createBndBoxMinVector(e, [t.x, t.y, t.z]);
      }
      return function (t, e) {
        this.clipBox.copy(e);
        let n = new lm.Builder(),
          i = u(t, this.clipBox, n),
          r = new J(),
          o = d(r, n);
        r.copy(this.clipBox.max), r.sub(this.clipBox.min);
        let s = d(r, n);
        Nb.ModelDataFile.startModelDataFile(n),
          Nb.ModelDataFile.addBufferGeometryArray(n, i),
          Nb.ModelDataFile.addBndBoxMin(n, o),
          Nb.ModelDataFile.addBndBoxMax(n, s);
        let a = Nb.ModelDataFile.endModelDataFile(n);
        return n.finish(a), n.asUint8Array();
      };
    })(),
    loadModelBuffer: function (t) {
      let e = new lm.ByteBuffer(new Uint8Array(t)),
        n = Nb.ModelDataFile.getRootAsModelDataFile(e),
        i = new Map(),
        r = new Map();
      for (let t = 0, e = n.materialArrayLength(); t < e; t++)
        this.createMaterial(n.materialArray(t), i, r);
      let o = { objects: [], boxMin: new J(), boxMax: new J() };
      for (let t = 0, e = n.bufferGeometryArrayLength(); t < e; t++) {
        let e = this.createBufferGeometry(n.bufferGeometryArray(t));
        if (!e) continue;
        let i = e.getVertexIndex().getBufferAttribute().array.length;
        e.setMaterial(this.material);
        let r = new Em(e, this.material);
        r.addDrawSegment(new vm(0, i)),
          (r.needBounding = !1),
          o.objects.push(r);
      }
      return (
        (o.boxMin.x = n.bndBoxMin(0)),
        (o.boxMin.y = n.bndBoxMin(1)),
        (o.boxMin.z = n.bndBoxMin(2)),
        (o.boxMax.x = n.bndBoxMax(0)),
        (o.boxMax.y = n.bndBoxMax(1)),
        (o.boxMax.z = n.bndBoxMax(2)),
        o
      );
    },
    splitBufferFile: function (t, e = 3145728) {
      let n = [],
        i = [],
        r = t.length,
        o = 0;
      for (; r > 0; ) {
        let s = e * o,
          a = new ArrayBuffer(r < e ? r : e),
          c = new Uint8Array(a);
        for (let e = 0, n = c.length; e < n; ++e) c[e] = t[s + e];
        let l = new lm.Builder(),
          h = Nb.BufferDataFile.createBufferVector(l, c);
        Nb.BufferDataFile.startBufferDataFile(l),
          Nb.BufferDataFile.addUuid(l, o),
          Nb.BufferDataFile.addBuffer(l, h),
          l.finish(Nb.BufferDataFile.endBufferDataFile(l)),
          n.push(o),
          i.push(l.asUint8Array()),
          (o += 1),
          (r -= e);
      }
      return { bufferID: n, bufferFile: i };
    },
    combineBufferFile: (function () {
      function t(t, e) {
        return t.uuid() - e.uuid();
      }
      return function (e) {
        let n = [];
        for (let t = 0, i = e.length; t < i; ++t) {
          let i = new lm.ByteBuffer(new Uint8Array(e[t]));
          n.push(Nb.BufferDataFile.getRootAsBufferDataFile(i));
        }
        let i = 0;
        n.sort(t);
        let r = -1;
        for (let t = 0, e = n.length; t < e; ++t) {
          let e = n[t].uuid();
          if (e - r != 1)
            return (
              console.error('Buffer data request serial uuid-number'), null
            );
          (r = e), (i += n[t].bufferLength());
        }
        let o = new Uint8Array(i),
          s = 0;
        for (let t = 0, e = n.length; t < e; ++t) {
          let e = n[t],
            i = e.bufferArray(),
            r = e.bufferLength();
          for (let t = 0; t < r; ++t) o[s + t] = i[t];
          s += r;
        }
        return o;
      };
    })(),
  })),
    (Yb.prototype = {
      constructor: Yb,
      assign: function (t) {
        return (
          this.position.copy(t.position),
          this.alignAxis.copy(t.alignAxis),
          (this.scale = t.scale),
          (this.angle = t.angle),
          this
        );
      },
      clone: function () {
        return new Yb().assign(this);
      },
      getClippingPlane: (function () {
        let t = new J();
        return function (e) {
          let n = e;
          return (
            n || (n = new Kt()),
            n.setFromNormalAndCoplanarPoint(
              t.copy(this.alignAxis).negate(),
              this.position,
            ),
            n
          );
        };
      })(),
    }),
    (qb.prototype = Object.assign(Object.create(ob.prototype), {
      constructor: qb,
      isDWGBufferScene: !0,
      onAttached: function (t, e) {
        ob.prototype.onAttached.call(this, t, e),
          (this.glContext = e.getRenderer().getContext());
      },
      setBuffer: function (t) {
        this.clearBuffer();
        let e = new Zb().loadModelBuffer(t);
        for (let t = 0, n = e.objects.length; t < n; ++t)
          this.add(e.objects[t]);
        this.buffer = e;
      },
      clearBuffer: function () {
        let t = this.children;
        for (let e = 0; e < t.length; ++e) {
          let n = t[e];
          n.isPMRenderObject &&
            (n.release(this.glContext), t.splice(e, 1), e--);
        }
      },
      getBuffer: function () {
        return this.buffer;
      },
      updateMatrix: (function () {
        let t = new ot();
        return function () {
          this.matrixWorld.identity(),
            Xf.getCoordinateByRefAxis(Xf.origin, this.state.alignAxis, t),
            this.matrixWorld.premultiply(t),
            Xf.makeRotationMatrix4(
              Xf.origin,
              this.state.alignAxis,
              this.state.angle,
              t,
            ),
            this.matrixWorld.premultiply(t),
            t.makeScale(this.state.scale, this.state.scale, this.state.scale),
            this.matrixWorld.premultiply(t),
            t.makeTranslation(
              this.state.position.x,
              this.state.position.y,
              this.state.position.z,
            ),
            this.matrixWorld.premultiply(t);
        };
      })(),
      getMatrix: function () {
        return this.matrixWorld;
      },
      getBoundingBox: (function () {
        let t = new Nt(),
          e = new J();
        return function () {
          if (!this.buffer) return null;
          t.set(this.buffer.boxMin, this.buffer.boxMax);
          let n = new Nt();
          for (let i = 0; i < 8; i++)
            Xf.getBox3Corner(t, i, e),
              e.applyMatrix4(this.matrixWorld),
              n.expandByPoint(e);
          return n;
        };
      })(),
      setPosition: function (t) {
        this.state.position.copy(t), this.updateMatrix();
      },
      setAlignAxis: function (t) {
        this.state.alignAxis.copy(t),
          this.state.alignAxis.normalize(),
          this.updateMatrix();
      },
      setAngle: function (t) {
        (this.state.angle = t), this.updateMatrix();
      },
      setScale: function (t) {
        (this.state.scale = t), this.updateMatrix();
      },
      setState: function (t) {
        this.state.assign(t), this.updateMatrix();
      },
      getState: function () {
        return this.state;
      },
    }));
  let Qb = { totalCommand: 0, remainCommand: 0 };
  function Jb(t = {}) {
    let e = this;
    (t.antialias = void 0 === t.antialias || t.antialias),
      (t.perceision = void 0 !== t.perceision ? t.perceision : 'highp'),
      (t.logarithmicDepthBuffer =
        void 0 === t.logarithmicDepthBuffer || t.logarithmicDepthBuffer),
      (t.preserveDrawingBuffer =
        void 0 === t.preserveDrawingBuffer || t.preserveDrawingBuffer),
      (t.textureType = void 0 !== t.textureType ? t.textureType : 2),
      (t.width = void 0 !== t.width ? t.width : window.innerWidth),
      (t.height = void 0 !== t.height ? t.height : window.innerHeight),
      (t.frameUpdateCallback =
        void 0 !== t.frameUpdateCallback ? t.frameUpdateCallback : void 0),
      (this.renderer = (function (t) {
        let e = new jm({
          depth: !0,
          stencil: !1,
          antialias: t.antialias,
          precision: t.perceision,
          logarithmicDepthBuffer: !1,
          premultipliedAlpha: !0,
          powerPreference: 'default',
          alpha: !0,
          preserveDrawingBuffer: t.preserveDrawingBuffer,
          useOffScreenCanvas: t.useOffScreenCanvas,
          canvas: document.createElement('canvas'),
        });
        return (
          e.setSize(t.width, t.height),
          e.setPixelRatio(window.devicePixelRatio),
          (e.autoClear = !1),
          (e.autoClearColor = !1),
          (e.autoClearDepth = !1),
          (e.autoClearStencil = !1),
          t.dom && t.dom.appendChild(e.domElement),
          e
        );
      })(t)),
      (this.writeFragDepthEnable =
        this.renderer.capabilities.isWebGL2 ||
        null !== this.renderer.extensions.get('EXT_frag_depth')),
      (this.tgaLoader = new mm()),
      (this.textureLoader = new Ba());
    let n = new Rc(),
      i =
        window.CcbimSDKLoaderConfig.staticHost +
        '/ccbimSDK@' +
        window.CcbimSDKLoaderConfig.version;
    function r(t, n) {
      if (t && t.isPMSceneNode) {
        t.bindLoadRenderDataEvent((t) => e.requestFrameUpdate(), n),
          t.bindRemoveObjectEvent((t) => e.requestFrameUpdate(), n);
        for (let e = 0, i = t.children.length; e < i; ++e) r(t.children[e], n);
      }
    }
    n.load(i + '/ccbim/resources/gentilis_regular.typeface.json', (t) => {
      this.webglFont = t;
    }),
      (this.progressiveRenderingRT = (function (t, n, i) {
        let r = {
            minFilter: u,
            magFilter: u,
            format: _,
            depthBuffer: !0,
            stencilBuffer: !1,
          },
          o = [void 0, void 0];
        return (
          t.capabilities.isWebGL2
            ? ((r.samples = t.capabilities.maxSamples), (o[0] = new Z(n, i, r)))
            : (o[0] = new X(n, i, r)),
          e.writeFragDepthEnable && (r.depthTexture = new Vo(n, i)),
          (o[1] = new X(n, i, r)),
          o
        );
      })(
        this.renderer,
        t.width * window.devicePixelRatio,
        t.height * window.devicePixelRatio,
      )),
      (this.progressiveRenderingMode = !1),
      (this.progressiveRenderingDelay = 8),
      (this.progressiveRenderingCommand = new Wm()),
      (this.progressiveRenderingProcessCallback = void 0),
      (this.wireframeWorker = new fb()),
      (this.sceneList = (function (t, e, n, i, r) {
        let o = {
          background: new Ob(e, n, t, 'pm_background'),
          model: new hb(e, n, t, 'pm_main'),
          wireframe: new mb(e, n, t, 'pm_wireframe', i, r),
          dwgbuffer: new qb(e, n, t, 'pm_dwgbuffer'),
          highlight: new gb(e, n, t, 'pm_highlight', i, r),
          incremental: new yb(e, n, t, 'pm_incremental'),
          viewBox: new Ib(100, 100, t, 'pm_viewbox'),
          minimap: new Eb(256, 256, t, 'pm_minimap'),
          dwgLayout: [],
          progressive1: [],
          progressive2: [],
        };
        return (
          o.wireframe.bindModelEvent(o.model),
          o.highlight.bindModelEvent(o.model),
          o.viewBox.setLayout(rb | nb, 20, 20),
          o.minimap.setLayout(ib | nb, 20, 20),
          o.minimap.setSceneData(o.model),
          (o.progressive1 = [o.background, o.model, o.wireframe, o.dwgbuffer]),
          (o.progressive2 = [o.incremental, o.highlight, o.viewBox, o.minimap]),
          o
        );
      })(t.mainCamera, t.width, t.height, this.wireframeWorker, this)),
      this.sceneList.model.bindAddModelEvent(
        (t) =>
          (function (t) {
            r(t.model.getSceneNode(), !0);
          })(t),
        !0,
      ),
      this.sceneList.model.bindRemoveModelEvent(
        (t) =>
          (function (t) {
            r(t.model.getSceneNode(), !1);
          })(t),
        !0,
      );
    let o = this.writeFragDepthEnable ? Cb : Db,
      s = new wn({
        uniforms: xn.clone(o.uniforms),
        vertexShader: o.vertexShader,
        fragmentShader: o.fragmentShader,
        extensions: {
          derivatives: !1,
          fragDepth: e.writeFragDepthEnable,
          drawBuffers: !1,
          shaderTextureLOD: !1,
        },
      });
    (this.copyToScreen = {
      uniforms: s.uniforms,
      fsQuad: new Rb.FullScreenQuad(s),
    }),
      (this.requestUpdate = !1),
      (this.setRequestUpdate = function (t) {
        this.requestUpdate = t;
      });
    let a = new U();
    this.requestFrameUpdate = function () {
      if (((this.requestUpdate = !0), this.getProgressiveRendering())) {
        let t = this.renderer,
          e = this.progressiveRenderingCommand;
        e.clear(),
          t.getSize(a),
          this.progressiveRenderingRT[0].isWebGLMultisampleRenderTarget
            ? e.push_back(new Xm(this.progressiveRenderingRT[0]))
            : e.push_back(new Xm(this.progressiveRenderingRT[1])),
          e.push_back(new Zm(!0)),
          e.push_back(new Ym(0, 0, a.x, a.y));
        let n = this.sceneList.progressive1;
        for (let i = 0, r = n.length; i < r; ++i) {
          let r = n[i];
          r && r.getVisible() && r.buildRenderCommand(t, e);
        }
        Qb.totalCommand = e.length();
      }
    };
    let c = t.frameUpdateCallback;
    function l(t, e) {
      for (let n = 0, i = t.length; n < i; ++n) {
        let i = t[n];
        i && i.getVisible() && e.renderPMScene(i);
      }
    }
    !(function t() {
      if ((requestAnimationFrame(t), c && c(), !e.requestUpdate)) return;
      let n = e.renderer;
      if (e.getProgressiveRendering()) {
        let t = e.progressiveRenderingCommand,
          i = performance.now(),
          r = t.take_front();
        for (
          ;
          r &&
          (r.execute(n),
          !(performance.now() - i > e.progressiveRenderingDelay));

        )
          r = t.take_front();
        e.progressiveRenderingProcessCallback &&
          ((Qb.remainCommand = t.length()),
          e.progressiveRenderingProcessCallback(Qb));
        let o = e.progressiveRenderingRT;
        o[0].isWebGLMultisampleRenderTarget && n.blitRenderTarget(o[0], o[1]),
          e.writeFragDepthEnable
            ? (n.setRenderTarget(null),
              n.clear(!0, !0, !0),
              (e.copyToScreen.uniforms.tDiffuse.value = o[1].texture),
              (e.copyToScreen.uniforms.dDiffuse.value = o[1].depthTexture),
              e.copyToScreen.fsQuad.render(n),
              l(e.sceneList.progressive2, n))
            : (n.setRenderTarget(o[1]),
              l(e.sceneList.progressive2, n),
              n.setRenderTarget(null),
              n.clear(!0, !0, !0),
              (e.copyToScreen.uniforms.tDiffuse.value = o[1].texture),
              e.copyToScreen.fsQuad.render(n)),
          n.setRenderTarget(o[0]);
      } else l(e.sceneList.progressive1, n), l(e.sceneList.progressive2, n);
      e.requestUpdate = !1;
    })();
  }
  Jb.prototype = {
    constructor: Jb,
    getTextureLoader: function () {
      return {
        tgaLoader: this.tgaLoader,
        textureLoader: this.textureLoader,
        wrapS: o,
        wrapT: o,
        maxAnisotropy: this.renderer.capabilities.getMaxAnisotropy(),
      };
    },
    getWebGLFont: function () {
      return this.webglFont;
    },
    addDwgLayoutSceneArray: function (t) {
      this.sceneList.dwgLayout.push(t), this.sceneList.progressive1.push(t);
    },
    resize: function (t, e) {
      this.renderer.setSize(t, e);
      let n = this.renderer.getPixelRatio(),
        i = t * n,
        r = e * n;
      for (let t = 0, e = this.progressiveRenderingRT.length; t < e; ++t)
        this.progressiveRenderingRT[t] &&
          this.progressiveRenderingRT[t].setSize(i, r);
      let o = this.getSceneArray();
      for (let n = 0, i = o.length; n < i; ++n)
        o[n] && o[n].onMainWindowSizeChanged(t, e);
    },
    setProgressiveRendering: function (t, e) {
      this.progressiveRenderingMode !== t &&
        ((this.progressiveRenderingMode = !!t),
        this.progressiveRenderingCommand.clear(),
        this.getProgressiveRendering()
          ? this.renderer.setRenderTarget(this.progressiveRenderingRT[0])
          : this.renderer.setRenderTarget(null),
        (this.progressiveRenderingProcessCallback = e));
    },
    getProgressiveRendering: function () {
      return this.progressiveRenderingMode;
    },
    getRenderer: function () {
      return this.renderer;
    },
    getSceneList: function () {
      return this.sceneList;
    },
    getSceneArray: function () {
      return this.sceneList.progressive1.concat(this.sceneList.progressive2);
    },
  };
  let $b,
    Kb = { type: 'cameraChanged', viewer: void 0, camera: void 0 };
  function tg(t) {
    At.call(this);
    let e = this,
      n = void 0 !== (t = t || {}).width ? t.width : window.innerWidth,
      i = void 0 !== t.height ? t.height : window.innerHeight;
    (t.width = n),
      (t.height = i),
      (this.mainCamera = new Km()),
      this.mainCamera.setAsPerspective(50),
      this.mainCamera.setViewSize(n, i),
      this.mainCamera.makeLookAt(
        new J(0, -1, 0),
        new J(0, 0, 0),
        new J(0, 0, 1),
      ),
      (this.viewSize = new U(n, i)),
      (this.autoNearFar = !0),
      (this.nearFarRatio = 0),
      this.setNearFarRatio(0.001),
      (this.operatorQueue = [null, null]),
      (t.mainCamera = this.mainCamera.clone()),
      (t.frameUpdateCallback = function () {
        for (let t = 0, n = e.operatorQueue.length; t < n; ++t) {
          let n = e.operatorQueue[t];
          n && n.onFrame();
        }
      }),
      (this.renderContext = new Jb(t)),
      (this.renderContext.renderer.localClippingEnabled = !0),
      (this.dom = this.renderContext.renderer.domElement),
      this.dom.addEventListener(
        'mousedown',
        (t) => this.onMouseButtonDown(t),
        !1,
      ),
      this.dom.addEventListener('mouseup', (t) => this.onMouseButtonUp(t), !1),
      this.dom.addEventListener('mousemove', (t) => this.onMouseMove(t), !1),
      this.dom.addEventListener('wheel', (t) => this.onMouseWheel(t), !1),
      this.dom.addEventListener('touchstart', (t) => this.onTouchStart(t), !1),
      this.dom.addEventListener('touchend', (t) => this.onTouchEnd(t), !1),
      this.dom.addEventListener('touchmove', (t) => this.onTouchMove(t), !1),
      document.addEventListener('keydown', (t) => this.onKeyDown(t), !1),
      document.addEventListener('keyup', (t) => this.onKeyUp(t), !1);
    let r = this.renderContext.getSceneArray();
    for (let t = 0, e = r.length; t < e; ++t)
      r[t].onAttached(this, this.renderContext);
    this.getWireframeScene().setVisible(!1),
      this.setAutoComputeNearFar(!0),
      this.setNearFarRatio(0.001),
      this.setProgressiveRendering(!0);
  }
  function eg(t) {
    (this.type = 'FileLoader'),
      (this.axios = t),
      (this.cloudURL = void 0),
      (this.fileIndexArray = []),
      (this.calcelTokenArray = []),
      (this.basicFileTotal = 0),
      (this.basicFileLoaded = 0),
      (this.basicProgress = 0),
      (this.entInfoFileTotal = 0),
      (this.entInfoFileLoaded = 0),
      (this.entInfoProgress = 0);
  }
  function ng(t, e, n) {
    let i = null;
    try {
      const i = (t, e, n) => {
        for (let r = 0; r < t.length; r++) {
          let o = t[r];
          if (o.type === im)
            for (let t = 0; t < o.entityArray.length; t++) {
              let i = o.entityArray[t];
              if (i.handle === n && i.floorID === e) throw i;
            }
          o.childArray && i(o.childArray, e, n);
        }
      };
      i(t, e, n);
    } catch (t) {
      i = t;
    }
    return i;
  }
  function ig(t) {
    t.bimViewer.cameraChanged();
    const e = t.bimViewer
      .getModelScene()
      .getModelArray()[0]
      .modelTree.getRootNode();
    let n = e.boundingBox.max,
      i = e.boundingBox.min,
      r = n.x - i.x,
      o = n.y - i.y,
      s = document.createElement('canvas');
    (s.width = r), (s.height = o);
    let a = s.getContext('2d'),
      c = [];
    rg(e, c);
    let l = [];
    !(function (t, e, n, i) {
      for (let r = 0; r < t.length; r++) {
        let o = t[r],
          s = o.max,
          a = o.min,
          c = a.x - e.x,
          l = n.y - s.y,
          h = s.x - a.x,
          u = s.y - a.y;
        i.push([c, l, h, u]);
      }
    })(c, i, n, l),
      a.clearRect(0, 0, r, o),
      (a.fillStyle = '#AAAAAA'),
      l.forEach((t) => {
        a.fillRect(t[0], t[1], t[2], t[3]);
      }),
      (function (t, e, n, i) {
        if ($b) return null;
        let r = new Bn(t.x - e.x, t.y - e.y),
          o = new xe({ map: new Ba().load(n), transparent: !0 });
        ($b = new ln(r, o)),
          ($b.name = 'bottomShadow'),
          ($b.position.x = (t.x + e.x) / 2),
          ($b.position.y = (t.y + e.y) / 2),
          ($b.position.z = e.z - 5e3 * i.scale),
          i.bimViewer.getModelScene().add($b);
      })(n, i, s.toDataURL('image/png'), t),
      (s.width = s.height = 0);
  }
  function rg(t, e) {
    if (t.childArray && t.childArray.length > 0 && t.childArray[0].type !== rm)
      for (let n = 0; n < t.childArray.length; n++) {
        const i = t.childArray[n];
        if (i.type === im && i.childArray[0].type === rm)
          for (let t = 0; t < i.entityArray.length; t++)
            e.push(i.entityArray[t].boundingBox);
        rg(i, e);
      }
  }
  function og(t) {
    if ($b) {
      t.bimViewer.getModelScene().remove($b),
        ($b = null),
        t.bimViewer.cameraChanged();
    }
  }
  function sg(t) {
    t.bimViewer
      .getModelScene()
      .getModelArray()[0]
      .materialMap.forEach((t) => {
        (t.map = t.mapCopy), t.map && (t.color = null), (t.needsUpdate = !0);
      });
  }
  function ag(t) {
    t.bimViewer
      .getModelScene()
      .getModelArray()[0]
      .materialMap.forEach((t) => {
        (t.color = t.colorCopy), t.map && (t.map = null), (t.needsUpdate = !0);
      });
  }
  function cg(t, e) {
    let n = document.getElementById(e.parentElementId + '__ccbim__markPoints');
    n.style.display = t ? 'block' : 'none';
  }
  function lg(t, e, n) {
    const i = new fe(e),
      r = new J(i.r, i.g, i.b),
      o = new fe(n),
      s = new J(o.r, o.g, o.b);
    t.bimViewer.setBackgroundColor(r, s);
  }
  (tg.prototype = Object.assign(Object.create(At.prototype), {
    constructor: tg,
    dispose: function () {
      this.dom.removeEventListener(
        'mousedown',
        (t) => this.onMouseButtonDown(t),
        !1,
      ),
        this.dom.removeEventListener(
          'mouseup',
          (t) => this.onMouseButtonUp(t),
          !1,
        ),
        this.dom.removeEventListener(
          'mousemove',
          (t) => this.onMouseMove(t),
          !1,
        ),
        this.dom.removeEventListener('wheel', (t) => this.onMouseWheel(t), !1),
        this.dom.removeEventListener(
          'touchstart',
          (t) => this.onTouchStart(t),
          !1,
        ),
        this.dom.removeEventListener('touchend', (t) => this.onTouchEnd(t), !1),
        this.dom.removeEventListener(
          'touchmove',
          (t) => this.onTouchMove(t),
          !1,
        ),
        document.removeEventListener('keydown', (t) => this.onKeyDown(t), !1),
        document.removeEventListener('keyup', (t) => this.onKeyUp(t), !1);
      let t = this.renderContext.getSceneArray();
      for (let e = 0, n = t.length; e < n; ++e)
        t[e].onDetached(this, this.renderContext);
    },
    setProgressiveRendering: function (t, e) {
      this.renderContext.setProgressiveRendering(t, e);
    },
    getProgressiveRendering: function () {
      return this.renderContext.getProgressiveRendering();
    },
    setBackgroundColor: function (t, e) {
      return this.renderContext.getSceneList().background.setColor(t, e);
    },
    setLightFollowCamera: function (t) {
      this.getModelScene().setLightFollowCamera(!!t);
    },
    setWireframeVisible: function (t) {
      this.getWireframeScene().setVisible(!!t);
    },
    setAutoComputeNearFar: function (t) {
      this.autoNearFar = !!t;
    },
    setNearFarRatio: function (t) {
      t < 0 ||
        t >= 1 ||
        ((this.nearFarRatio = t),
        0 === this.nearFarRatio &&
          ((this.mainCamera.near = 1e-4),
          (this.mainCamera.far = 1e6),
          this.mainCamera.updateProjectionMatrix()));
    },
    setViewBoxVisible: function (t) {
      return this.renderContext.getSceneList().viewBox.setVisible(!!t);
    },
    setDynamicRendering: function (t, e) {
      this.getModelScene().setDynamicRendering(t, e);
    },
    setMemoryLimit: function (t) {
      this.getModelScene().setMemoryLimit(t);
    },
    getRenderContext: function () {
      return this.renderContext;
    },
    getMainCamera: function () {
      return this.mainCamera;
    },
    viewPortPosToWorldPos: function (t, e) {
      let n = this.getSize();
      e.set((2 * t.x) / n.x - 1, 1 - (2 * t) / n.y, t.z),
        e.unproject(this.getMainCamera());
    },
    worldPosToViewPortPos: function (t, e) {
      let n = this.getSize();
      e.copy(t),
        e.project(this.getMainCamera()),
        (e.x = 0.5 * (e.x + 1) * n.x),
        (e.y = 0.5 * (e.y + 1) * n.y);
    },
    getAsymmetricFrustum: (function () {
      let t = new U(),
        e = new gl(),
        n = new J(),
        i = new Kt(),
        r = new J(),
        o = new J(),
        s = new J(),
        a = new J();
      return function (c, l, h, u, d) {
        let p = this.getMainCamera();
        n.subVectors(p.position, p.target).normalize(),
          i.setFromNormalAndCoplanarPoint(n, p.target);
        let f = this.getSize();
        this.worldPosToViewPortPos(p.target, r),
          t.set((2 * r.x) / f.x - 1, 1 - (2 * l) / f.y),
          e.setFromCamera(t, this.getMainCamera()),
          e.ray.intersectPlane(i, o),
          t.set((2 * c) / f.x - 1, 1 - (2 * l) / f.y),
          e.setFromCamera(t, this.getMainCamera()),
          e.ray.intersectPlane(i, s),
          t.set((2 * h) / f.x - 1, 1 - (2 * l) / f.y),
          e.setFromCamera(t, this.getMainCamera()),
          e.ray.intersectPlane(i, a);
        let m = s.distanceTo(o),
          b = a.distanceTo(o);
        c < r.x && (m *= -1),
          h < r.x && (b *= -1),
          t.set((2 * c) / f.x - 1, 1 - (2 * r.y) / f.y),
          e.setFromCamera(t, this.getMainCamera()),
          e.ray.intersectPlane(i, o),
          t.set((2 * c) / f.x - 1, 1 - (2 * l) / f.y),
          e.setFromCamera(t, this.getMainCamera()),
          e.ray.intersectPlane(i, s),
          t.set((2 * c) / f.x - 1, 1 - (2 * u) / f.y),
          e.setFromCamera(t, this.getMainCamera()),
          e.ray.intersectPlane(i, a);
        let g = s.distanceTo(o),
          y = a.distanceTo(o);
        l < r.y && (g *= -1),
          u < r.y && (y *= -1),
          p.getAsymmetricFrustum(m, b, g, y, d);
      };
    })(),
    getModelScene: function () {
      return this.renderContext.getSceneList().model;
    },
    addDwgLayoutSceneArray: function (t) {
      this.renderContext.addDwgLayoutSceneArray(t);
    },
    getDwgLayoutSceneArray: function () {
      return this.renderContext.getSceneList().dwgLayout;
    },
    getWireframeScene: function () {
      return this.renderContext.getSceneList().wireframe;
    },
    getHighlightScene: function () {
      return this.renderContext.getSceneList().highlight;
    },
    getIncrementalScene: function () {
      return this.renderContext.getSceneList().incremental;
    },
    getDwgBufferScene: function () {
      return this.renderContext.getSceneList().dwgbuffer;
    },
    getMinimapScene: function () {
      return this.renderContext.getSceneList().minimap;
    },
    setClippingPlanes: function (t) {
      this.getModelScene().setClippingPlanes(t), this.requestFrameUpdate();
    },
    resize: function (t, e) {
      this.viewSize.set(t, e),
        this.mainCamera.setViewSize(t, e),
        this.renderContext.resize(t, e),
        this.requestFrameUpdate();
    },
    getSize: function () {
      return this.viewSize;
    },
    pickSelectEntityByScreenPos: (function () {
      let t = new U();
      return function (e, n) {
        return (
          t.set((2 * e) / this.viewSize.x - 1, 1 - (2 * n) / this.viewSize.y),
          this.getModelScene().pickSelectEntity(t)
        );
      };
    })(),
    pickSelectEntityByWindowPos: function (t) {
      return this.getModelScene().pickSelectEntity(t);
    },
    highlightEntity: function (t) {
      this.getHighlightScene().insertSelection(t) && this.cameraChanged();
    },
    unhighlightEntity: function (t) {
      this.getHighlightScene().removeSelection(t) && this.cameraChanged();
    },
    clearAllHighlightEntity: function () {
      this.getHighlightScene().clearSelection() && this.cameraChanged();
    },
    setOperator: function (t) {
      this.setOperatorAt(0, t);
    },
    getOperator: function () {
      return this.getOperatorAt(0);
    },
    setOperatorAt: function (t, e) {
      void 0 === t ||
        t < 0 ||
        t >= this.operatorQueue.length ||
        (this.operatorQueue[t] !== e &&
          (this.operatorQueue[t] && this.operatorQueue[t].willEnd(this),
          (this.operatorQueue[t] = e),
          this.operatorQueue[t] && this.operatorQueue[t].willBegin(this)));
    },
    getOperatorAt: function (t) {
      if (!(void 0 === t || t < 0 || t >= this.operatorQueue.length))
        return this.operatorQueue[t];
    },
    onMouseButtonDown: function (t) {
      switch (t.button) {
        case 0:
          for (let e = 0, n = this.operatorQueue.length; e < n; ++e)
            this.operatorQueue[e] && this.operatorQueue[e].onLButtonDown(t);
          break;
        case 1:
          for (let e = 0, n = this.operatorQueue.length; e < n; ++e)
            this.operatorQueue[e] && this.operatorQueue[e].onMButtonDown(t);
          break;
        case 2:
          for (let e = 0, n = this.operatorQueue.length; e < n; ++e)
            this.operatorQueue[e] && this.operatorQueue[e].onMButtonDown(t);
      }
    },
    onMouseButtonUp: function (t) {
      switch (t.button) {
        case 0:
          for (let e = 0, n = this.operatorQueue.length; e < n; ++e)
            this.operatorQueue[e] && this.operatorQueue[e].onLButtonUp(t);
          break;
        case 1:
          for (let e = 0, n = this.operatorQueue.length; e < n; ++e)
            this.operatorQueue[e] && this.operatorQueue[e].onMButtonUp(t);
          break;
        case 2:
          for (let e = 0, n = this.operatorQueue.length; e < n; ++e)
            this.operatorQueue[e] && this.operatorQueue[e].onMButtonUp(t);
      }
    },
    onMouseMove: function (t) {
      for (let e = 0, n = this.operatorQueue.length; e < n; ++e)
        this.operatorQueue[e] && this.operatorQueue[e].onMouseMove(t);
    },
    onMouseWheel: function (t) {
      for (let e = 0, n = this.operatorQueue.length; e < n; ++e)
        this.operatorQueue[e] && this.operatorQueue[e].onMouseWheel(t);
    },
    onTouchStart: function (t) {
      for (let e = 0, n = this.operatorQueue.length; e < n; ++e)
        this.operatorQueue[e] && this.operatorQueue[e].onTouchStart(t);
    },
    onTouchEnd: function (t) {
      for (let e = 0, n = this.operatorQueue.length; e < n; ++e)
        this.operatorQueue[e] && this.operatorQueue[e].onTouchEnd(t);
    },
    onTouchMove: function (t) {
      for (let e = 0, n = this.operatorQueue.length; e < n; ++e)
        this.operatorQueue[e] && this.operatorQueue[e].onTouchMove(t);
    },
    onKeyDown: function (t) {
      for (let e = 0, n = this.operatorQueue.length; e < n; ++e)
        this.operatorQueue[e] && this.operatorQueue[e].onKeyDown(t);
    },
    onKeyUp: function (t) {
      for (let e = 0, n = this.operatorQueue.length; e < n; ++e)
        this.operatorQueue[e] && this.operatorQueue[e].onKeyUp(t);
    },
    requestFrameUpdate: function () {
      this.renderContext.requestFrameUpdate();
    },
    cameraChanged: (function () {
      let t = new J(),
        e = new Kt(),
        n = new J();
      return function (i = !0) {
        if (
          (this.requestFrameUpdate(),
          this.mainCamera.updateMatrixWorld(),
          this.autoNearFar && this.nearFarRatio > 0)
        ) {
          t.subVectors(this.mainCamera.target, this.mainCamera.position),
            t.normalize();
          let i = this.getModelScene().getBoundingBox();
          for (let t = 0, e = this.operatorQueue.length; t < e; ++t) {
            let e = this.operatorQueue[t]
              ? this.operatorQueue[t].getBounding()
              : null;
            null == e || e.isEmpty() || i.union(e);
          }
          let r = this.getDwgBufferScene().getBoundingBox();
          r && i.union(r),
            Xf.getBox3MaxCorner(i, t, n),
            e.setFromNormalAndCoplanarPoint(t, this.mainCamera.position),
            (this.mainCamera.far = e.distanceToPoint(n) + 1),
            t.negate(),
            Xf.getBox3MaxCorner(i, t, n);
          let o = e.distanceToPoint(n),
            s = this.mainCamera.far * this.nearFarRatio;
          (this.mainCamera.near = o > 0 ? Math.max(s, o) : s),
            this.mainCamera.updateProjectionMatrix();
        }
        this.mainCamera.updatePixelVector();
        let r = this.renderContext.getSceneArray();
        for (let t = 0, e = r.length; t < e; ++t) {
          let e = r[t];
          e.getVisible() && e.onMainCameraChanged(this.mainCamera);
        }
        (Kb.viewer = this),
          (Kb.camera = this.mainCamera),
          this.dispatchEvent(Kb);
      };
    })(),
    bindCameraChangedEvent: function (t) {
      t && this.addEventListener(Kb.type, t);
    },
    unbindCameraChangedEvent: function (t) {
      t && this.removeEventListener(Kb.type, t);
    },
  })),
    (eg.prototype = {
      constructor: eg,
      setCloudURL: function (t) {
        this.cloudURL = t;
      },
      getCloudURL: function () {
        return this.cloudURL;
      },
      addFileIndex: function (t) {
        t && this.fileIndexArray.push(t);
      },
      getFileIndex: function (t) {
        for (let e = 0, n = this.fileIndexArray.length; e < n; e++) {
          let n = this.fileIndexArray[e];
          if (n.getURL().includes(t)) return n;
        }
        return null;
      },
      getFileIndexArray: function () {
        return this.fileIndexArray;
      },
      getAxios: function () {
        return this.axios;
      },
      addCancelToken: function (t) {
        this.calcelTokenArray.push(t);
      },
      clearData: function () {
        (this.fileIndexArray = []), (this.calcelTokenArray = []);
      },
      loadFile: function (t, e) {
        return t
          ? new Promise((n, i) => {
              let r = this.axios.CancelToken.source();
              this.calcelTokenArray.push(r),
                this.axios({
                  method: 'get',
                  responseType: e || 'arraybuffer',
                  cancelToken: r.token,
                  url: t.getURL(),
                })
                  .then((t) => {
                    n(t);
                  })
                  .catch((t) => {
                    this.axios.isCancel(t)
                      ? console.log('fileLoad', t.message)
                      : i('catch 处理');
                  });
            })
          : null;
      },
      cancelAxios() {
        this.calcelTokenArray.forEach((t) => {
          t.cancel('CCBIM-cancelAxios by the user');
        });
      },
      setBasicFileTotal(t) {
        this.basicFileTotal = t;
      },
      setBasicProgress(t) {
        if (t) {
          this.basicFileLoaded += t;
          let e = (this.basicFileLoaded / this.basicFileTotal) * 100;
          this.basicProgress = parseInt(e);
        }
      },
      getBasicProgress() {
        return this.basicProgress;
      },
      setEntInfoFileTotal(t) {
        this.entInfoFileTotal = t;
      },
      setEntInfoProgress(t) {
        if (t) {
          this.entInfoFileLoaded += t;
          let e = (this.entInfoFileLoaded / this.entInfoFileTotal) * 100;
          this.entInfoProgress = parseInt(e);
        }
      },
      getEntInfoProgress() {
        return this.entInfoProgress;
      },
    });
  class hg extends Sh {
    constructor(t) {
      super(t),
        (this.state = {
          isShowPointImage: !1,
          pointImageSrc: '',
          pointImageTop: 0,
          pointImageLeft: 0,
        });
    }
    showPointImage(t) {
      t.photo &&
        this.setState({
          isShowPointImage: !0,
          pointImageSrc: t.photo,
          pointImageTop: t.top - 160,
          pointImageLeft: t.left - 100,
        });
    }
    render() {
      return Xh`<${Mh}>
      ${this.props.pointList.map(
        (t) => Xh`
          <div
            style=${{
              position: 'absolute',
              left: `${t.left}px`,
              top: `${t.top}px`,
              display: '' + (t.show ? 'block' : 'none'),
            }}
            onClick=${() => {
              t.clickPointCallback({
                type: 'markClick',
                left: t.left,
                top: t.top,
                data: t.selfDefiningData,
              });
            }}
          >
            ${
              t.labelText &&
              Xh` <label
              class=${t.warning ? 'ccbim__label warning' : 'ccbim__label'}
              title=${t.labelText}
              >${t.labelText}</label
            >`
            }

            <div
              class=${t.color ? 'ccbim__point__color' : 'ccbim__point'}
              style=${{
                backgroundImage: `url(${t.iconImg})`,
                backgroundColor: `${t.color}`,
              }}
              onMouseEnter=${() => {
                this.showPointImage(t);
              }}
              onMouseLeave=${() => {
                this.setState({ isShowPointImage: !1 });
              }}
            ></div>

            ${
              t.iconText &&
              Xh` <span class="ccbim__point__text">${t.iconText}</span>`
            }
          </div>
        `,
      )}
      ${
        this.state.isShowPointImage &&
        Xh`<div
          style=${{
            top: `${this.state.pointImageTop}px`,
            left: `${this.state.pointImageLeft}px`,
          }}
          class="ccbim__pointOver__image"
        >
          <img src=${this.state.pointImageSrc} />
        </div>`
      }
    </${Mh}>`;
    }
  }
  let ug = new Map(),
    dg = new Map();
  function pg(t, e, n) {
    ug.clear(), dg.clear();
    const i = e.bimViewer
      .getModelScene()
      .getModelArray()[0]
      .modelTree.getRootNode();
    for (let r = 0; r < t.length; r++) {
      const o = t[r];
      if ('{}' === JSON.stringify(o))
        return console.log('添加模型标注对象格式不正确'), !1;
      if (ug.has(o.id)) return;
      let s = o.floorId;
      const a = e.scale;
      if (o.markPosition.indexOf(';') > -1) {
        const t = o.markPosition.split(';')[1].split(',');
        let e = t[0] + t[1] + t[2],
          i = new J(t[0] * a, t[1] * a, t[2] * a);
        i.add(n),
          ug.set(o.id, {
            uuid: e,
            id: o.id,
            point: i,
            iconText: o.iconText,
            labelText: o.labelText,
            selfDefiningData: o.selfDefiningData,
            warning: o.warning,
            iconImg: o.iconImg,
            color: o.color,
            photo: o.photo,
            contentText: o.contentText,
            floorId: s,
            clickPointCallback: o.clickPointCallback,
          });
      } else {
        let t = ng([i], s, o.markPosition);
        if (!t) return;
        const e = t.boundingBox.max,
          r = t.boundingBox.min;
        let a = new J((e.x + r.x) / 2, (e.y + r.y) / 2, (e.z + r.z) / 2);
        a.add(n);
        let c = a.x + a.y + a.z;
        ug.set(o.id, {
          uuid: c,
          id: o.id,
          point: a,
          iconText: o.iconText,
          labelText: o.labelText,
          selfDefiningData: o.selfDefiningData,
          warning: o.warning,
          iconImg: o.iconImg,
          color: o.color,
          photo: o.photo,
          contentText: o.contentText,
          floorId: s,
          clickPointCallback: o.clickPointCallback,
        });
      }
    }
  }
  function fg(t, e, n, i) {
    let r = (function (t, e, n) {
      if (0 === ug.size) return [];
      let i = new Map();
      for (let r of ug.values()) {
        let o = r.point.clone();
        o.project(t);
        let s = e / 2,
          a = n / 2;
        (o.x = o.x * s + s), (o.y = -o.y * a + a);
        let c = r.uuid;
        if (i.has(c)) {
          let t = i.get(c);
          t.push(c);
          let e = t.length - 1;
          o.x = o.x + 30 * e;
        } else i.set(c, [c]);
        let l = !0;
        dg.set(r.id, {
          id: r.id,
          left: o.x - 15,
          top: o.y - 30,
          iconText: r.iconText,
          labelText: r.labelText,
          selfDefiningData: r.selfDefiningData,
          warning: r.warning,
          iconImg: r.iconImg
            ? r.iconImg
            : 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB8AAAAmCAYAAAA820BcAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA39pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDIxIDc5LjE1NTc3MiwgMjAxNC8wMS8xMy0xOTo0NDowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDphODRkMDNjNC04MzBlLTZlNDEtOWUyYS0xOWEzYTRiNGMwNTkiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6RDgwNzJDN0NFQjhFMTFFN0E4ODlENTE1NEZCQzExQkIiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6RDgwNzJDN0JFQjhFMTFFN0E4ODlENTE1NEZCQzExQkIiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOmQ4NmY1MTliLWJhMmUtYjk0ZC1iYmRjLWZhMzlhOTM0NWNmNiIgc3RSZWY6ZG9jdW1lbnRJRD0iYWRvYmU6ZG9jaWQ6cGhvdG9zaG9wOmJmNDQzMjIyLTcwNTgtYmE0Yi04ZGVmLTRlNDgzYTI0MDA4NiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqFeqsUAAAPDSURBVHjatFhpbExRFP5mOqglqEgZWvyQ2IoIaklaIRp7Ygvxxw+x/7BNEIkKQYJmosSPqkhERIJIJGgVKSli19RWkUa0Hbso0ui0quM77715fTPtzLxZ3km+m3fuvHe+e8+9555zx+bz+dBGXDa0I/2IuUQ2MZRwEp2JBuIzUUmUEVfg9n2ECbG1Sx44kMlsdxCziCQTNv8RxcQBDuJebOQuWx+2R4kliF3OExs4iC/mydXZXtBcrYqjEzB4KpAxHxg0CUgZCCT3ALy/gLpq4P194OUloOoW0NxotCZLsrg9L7Qld9nEvRe19QTsDiBzBTBjN9DdGXmu9V+B0oPA3WNcgCZ/r+yLRRxAcWhyl20C21Kii6KnDgGW03POUdE7/NNz4PRS4Osbf88fYhoH8LAtucvWi20Fkabo6eOB1dc4jF6xr3hDHVBIR9bofB5iNAfwQ3Gq4dVDOnEqI2ntjfiIRTqnAGtKVHuqpGk8hpm7bKP5XC46kjoAm5/E5uqQS/ACODyWe+CvaOLqMZx9hX/mWxVikayNiSUWcY5U7WoTJrapM9+CHlo4JMORDOQybLqlIuEiUbCX4dnsFU2avjLzGQqxyPC51hCLiN0R8/ya8M20a2e1KsPnwFIZNtuoZQt5hq6mjbWWPH2cURsh5P11NWWAteQ9041afyHvqqtyVlspgfa7CPlfXfX+tpY80L5XyL/r6s9aa8l/eYxanZC/09Xax9aS1zwyatVC/lRXK4usJQ+0Xy7kJbr66rJ6Elkh9d9U+63ywM4DXhLKW0WVo+9WnjXkt/P8R6uIpNQ7/sRyXH/pzhG1EEikSFYryzf2nOGkG/3khfqul7QnFYjUZgkJL9o5vcSfThX/Eu7WYsLtq2e7U/9ASp+C6fGvv3xfkGMspUQKyFcTXMmcEKe3hh0LinyWUp5nsRF/4FbKzwwOX0nduaEKSDl8ha233ifV68SVQM4uc9Xr70/A9T3Aw5NAS7PxlxYlfbt9N8OVztO0G0fHgH4pNCTfS9qV7KfU7d3VI1Pqdg+Pi9dXiSvGXW2UXBLvM3NpkFvKWZPXIzMi0bSO5AFk9jDXnGVEUwKI6X+sDyYORw7tuiSlTTypTsrkVSRuae9HR4SPZXNkEUUBRYe5m+omkh4L95LdhCE57iYEJKAI0U0siERsllyJWs0D5yK8x22PySS+bMaoPQpXNmibcH+ohKkQAy/MGrRHuYF82jG8I6hfCKcQH6MxZo9xFx8gTmnPEo4LiW/RGnHEEUbbiUztj4SqWAz8F2AAwxUsG0cxVxkAAAAASUVORK5CYII=',
          color: r.color,
          photo: r.photo,
          contentText: r.contentText,
          show: l,
          floorId: r.floorId,
          clickPointCallback: r.clickPointCallback,
        });
      }
      return [...dg.values()];
    })(e, n, i);
    r && jh(Xh`<${hg} pointList=${r} />`, t);
  }
  function mg(t) {
    for (let e of ug.values())
      e.point.applyAxisAngle(new J(0, 0, 1), k.degToRad(t));
  }
  function bg(t) {
    for (let e of ug.values()) e.point.multiplyScalar(t);
  }
  function gg(t) {
    (this.viewRender = t),
      (this.animateId = null),
      (this.markPointList = []),
      (this.angleCur = 0),
      (this.scaleCur = null);
  }
  Object.assign(gg.prototype, {
    setMarkPointList: function (t) {
      (this.markPointList = []), (this.markPointList = t);
      let e = this.viewRender.camera,
        n = this.viewRender.innerWidth,
        i = this.viewRender.innerHeight,
        r = this.viewRender.positionCustomCoords;
      var o = document.createElement('div');
      o.setAttribute('id', 'ccbim__GIS__mark'),
        this.viewRender.dom.appendChild(o),
        pg(t, this.viewRender.GlobalShare, r),
        fg(o, e, n, i);
    },
    changeMarkPointFromCamera: function () {
      let t = this.viewRender.camera,
        e = this.viewRender.innerWidth,
        n = this.viewRender.innerHeight;
      var i = document.getElementById('ccbim__GIS__mark');
      i && fg(i, t, e, n);
    },
    bounceMarkPoint: function (t) {
      let e = document.getElementById('ccbim__GIS__mark');
      e &&
        (function (t, e) {
          let n = 0,
            i = setInterval(() => {
              n += 30;
              let i = ((2 * Math.PI) / 360) * n;
              (dg.get(e).top -= 3 * Math.sin(i)),
                jh(Xh`<${hg} pointList=${[...dg.values()]} />`, t);
            }, 25);
          setTimeout(() => {
            clearInterval(i);
          }, 1500);
        })(e, t);
    },
    setModelRotate: function (t) {
      this.viewRender.group.rotateZ(k.degToRad(-this.angleCur)),
        this.viewRender.selectGeoGroup.rotateZ(k.degToRad(-this.angleCur)),
        mg(-this.angleCur),
        this.viewRender.group.rotateZ(k.degToRad(t)),
        this.viewRender.selectGeoGroup.rotateZ(k.degToRad(t)),
        mg(t),
        this.viewRender.map.render(),
        (this.angleCur = t);
    },
    setModelScale: function (t) {
      this.viewRender.group.scale.set(t, t, t),
        this.viewRender.selectGeoGroup.scale.set(t, t, t),
        this.scaleCur && bg(1 / this.scaleCur),
        bg(t),
        this.viewRender.map.render(),
        (this.scaleCur = t);
    },
    setModelPosition: function (t) {
      this.viewRender.setPosition(t),
        pg(
          this.markPointList,
          this.viewRender.GlobalShare,
          this.viewRender.positionCustomCoords,
        ),
        this.viewRender.map.render();
    },
    startAnimateRotation: function () {
      this.viewRender.map.setRotation(
        (this.viewRender.map.getRotation() + 0.6) % 360,
      ),
        (this.animateId = requestAnimationFrame(
          this.startAnimateRotation.bind(this),
        ));
    },
    stopAnimateRotation: function () {
      cancelAnimationFrame(this.animateId);
    },
    disposeModel: function () {
      this.viewRender.disposeModel();
    },
  }),
    (Gf.defaults.headers['X-Requested-With'] = 'XMLHttpRequest'),
    (Gf.defaults.headers.Accept = 'application/json');
  let yg,
    vg,
    _g,
    xg,
    wg,
    Ag,
    Mg = [];
  function Sg(t) {
    this.init(t),
      (this.interfaceApi = new gg(this)),
      (this.map = null),
      (this.THREE = null),
      (this.camera = null),
      (this.renderer = null),
      (this.scene = null),
      (this.group = null),
      (this.selectGeoGroup = null),
      (this.positionCustomCoords = null);
  }
  Sg.prototype = Object.assign(Object.create(e.prototype), {
    constructor: Sg,
    init(t) {
      (this.dom = t),
        this.setInnerWidthHeight(),
        (this.ccbimAxiosAll = []),
        (this.GlobalShare = {
          urlIp: '',
          viewToken: '',
          type: 'model',
          scale: 1,
        });
    },
    setInnerWidthHeight() {
      (this.innerWidth = this.dom.clientWidth),
        (this.innerHeight = this.dom.clientHeight);
    },
    modelRun(t, e, n) {
      (this.map = t),
        (this.THREE = e),
        (this.Material = new this.THREE.MeshBasicMaterial({ color: 61107 }));
      var i = this.map.customCoords,
        r = new AMap.GLCustomLayer({
          zIndex: 10,
          init: (t) => {
            (this.camera = new this.THREE.PerspectiveCamera(
              60,
              this.innerWidth / this.innerHeight,
              100,
              1 << 30,
            )),
              (this.renderer = new this.THREE.WebGLRenderer({
                context: t,
                alpha: !0,
                antialias: !0,
                canvas: t.canvas,
              })),
              (this.renderer.autoClear = !1),
              (this.scene = new this.THREE.Scene());
            var e = new this.THREE.AmbientLight(16777215, 1),
              i = new this.THREE.DirectionalLight(16777215, 1);
            i.position.set(1e3, -100, 900),
              this.scene.add(i),
              this.scene.add(e),
              (this.group = new this.THREE.Group()),
              this.scene.add(this.group),
              (this.selectGeoGroup = new this.THREE.Group()),
              this.scene.add(this.selectGeoGroup),
              this.getModelData(n, (t) => {
                if (t.isPMInstanceRenderBuffer) {
                  const i = new this.THREE.BufferGeometry();
                  i.setIndex(t.vertexIndex.bufferAttribute);
                  for (
                    let e = 0;
                    e < t.vertexAttributeArray.vertexAttributes.length;
                    e++
                  ) {
                    let n = t.vertexAttributeArray.vertexAttributes[e];
                    i.setAttribute(n.name, n.bufferAttribute);
                  }
                  const r = t.material,
                    o = new this.THREE.Mesh(i, r);
                  let s =
                      t.instanceVertexAttributeArray.vertexAttributes[0]
                        .bufferAttribute.array,
                    a =
                      t.instanceVertexAttributeArray.vertexAttributes[1]
                        .bufferAttribute.array,
                    c =
                      t.instanceVertexAttributeArray.vertexAttributes[2]
                        .bufferAttribute.array,
                    l =
                      t.instanceVertexAttributeArray.vertexAttributes[3]
                        .bufferAttribute.array,
                    h =
                      t.instanceVertexAttributeArray.vertexAttributes[0]
                        .bufferAttribute.array.length / 4;
                  for (let i = 0; i < h; i++) {
                    let r = new this.THREE.Matrix4();
                    var e = 4 * i;
                    r.set(
                      s[e],
                      a[e],
                      c[e],
                      l[e],
                      s[e + 1],
                      a[e + 1],
                      c[e + 1],
                      l[e + 1],
                      s[e + 2],
                      a[e + 2],
                      c[e + 2],
                      l[e + 2],
                      s[e + 3],
                      a[e + 3],
                      c[e + 3],
                      l[e + 3],
                    );
                    var n = o.clone();
                    n.applyMatrix4(r),
                      (n.userData = {
                        name: 'instanceMesh',
                        geoID: t.id,
                        bufferSegment: { offset: i },
                      }),
                      this.group.add(n);
                  }
                } else {
                  const e = new this.THREE.BufferGeometry();
                  e.setIndex(t.vertexIndex.bufferAttribute);
                  for (
                    let n = 0;
                    n < t.vertexAttributeArray.vertexAttributes.length;
                    n++
                  ) {
                    let i = t.vertexAttributeArray.vertexAttributes[n];
                    e.setAttribute(i.name, i.bufferAttribute);
                  }
                  const n = t.material,
                    i = new this.THREE.Mesh(e, n);
                  (i.userData = { name: 'mesh', geoID: t.id }),
                    this.group.add(i);
                }
                this.map.render();
              }),
              this.setPosition(n.modelLocation);
          },
          render: () => {
            this.renderer.state.reset();
            var {
              near: t,
              far: e,
              fov: n,
              up: r,
              lookAt: o,
              position: s,
            } = i.getCameraParams();
            (this.camera.near = t),
              (this.camera.far = e),
              (this.camera.fov = n),
              this.camera.position.set(...s),
              this.camera.up.set(...r),
              this.camera.lookAt(...o),
              this.camera.updateProjectionMatrix(),
              this.interfaceApi.changeMarkPointFromCamera(),
              this.renderer.render(this.scene, this.camera);
          },
        });
      this.map.add(r);
    },
    setPosition(t) {
      var e = this.map.customCoords.lngLatsToCoords([t]);
      this.group.position.set(e[0][0], e[0][1], 10),
        this.selectGeoGroup.position.set(e[0][0], e[0][1], 10),
        (this.positionCustomCoords = new this.THREE.Vector3(
          e[0][0],
          e[0][1],
          0,
        ));
    },
    getModelData(t, e) {
      if (!t.urlIp || !t.viewToken || !t.type) return !1;
      (this.GlobalShare.urlIp = t.urlIp),
        (this.GlobalShare.viewToken = t.viewToken),
        (this.GlobalShare.bimViewer = new tg(t));
      let n = {};
      n.viewToken = t.viewToken;
      let i = Gf.CancelToken.source();
      this.ccbimAxiosAll.push(i),
        Gf({
          method: 'post',
          url: `${t.urlIp}/console/bimfile/modelConstructInfoCors`,
          cancelToken: i.token,
          data: Uf(n),
        })
          .then((n) => {
            let { data: i } = n;
            if (i.success) {
              if (0 === i.result.jsons.length)
                return void (this.errorMsg = '模型或者图纸未转换完成');
              let n,
                r,
                o = new eg(Gf);
              for (let t = 0, e = i.result.jsons.length; t < e; t++) {
                let e = i.result.jsons[t];
                n || (n = e.URI.split('.com/')[0] + '.com/');
                let s = new gm();
                s.setType(e.resultType),
                  s.setURL(e.URI),
                  s.setFileSize(e.FileSize),
                  o.addFileIndex(s);
                let a = s.getType();
                (9 !== a && 13 !== a) || (r = s);
              }
              if ((o.setCloudURL(n), !r))
                return void (this.errorMsg = '协议文件丢失');
              let s,
                a = this.GlobalShare.bimViewer
                  .getRenderContext()
                  .getTextureLoader();
              switch (((a.fileLoader = o), r.getType())) {
                case 9:
                  s = new Gm(a, this);
                  break;
                case 13:
                  s = new Wb(a, this, e);
              }
              if (!s) return void (this.errorMsg = '无法解析的协议版本');
              console.log('Head protocol type.' + r.getType().toString());
              let c = { version: t.viewToken, headFile: r };
              s.createModel(c, () => {}).then((t) => {
                let e = this.GlobalShare.bimViewer.getModelScene();
                e.addModel(t);
                let n = e.getBoundingBox();
                this.GlobalShare.bimViewer
                  .getMainCamera()
                  .makeLookAtBoundingBox(n),
                  this.GlobalShare.bimViewer.cameraChanged(),
                  this.GlobalShare.bimViewer.setProgressiveRendering(!1);
              });
            }
          })
          .catch((t) => {
            Gf.isCancel(t) && console.log('Request canceled', t.message);
          });
    },
    renderFinish() {
      this.bindListener();
      let t = this.GlobalShare.bimViewer.getModelScene().getModelArray();
      for (let e = 0, n = t.length; e < n; ++e) Mg.push(t[e].getSceneNode());
      for (let t = 0; t < Mg.length; ++t) {
        let e = Mg[t].children;
        for (let t = 0, n = e.length; t < n; ++t) {
          let n = e[t];
          n.isPMSceneNode && Mg.push(n);
        }
      }
    },
    bindListener() {
      const t = this;
      document.addEventListener(
        'mousedown',
        function () {
          document.addEventListener('mouseup', i, !1),
            document.addEventListener('mousemove', r, !1);
        },
        !1,
      );
      var e = new this.THREE.Raycaster(),
        n = new this.THREE.Vector2();
      function i(i) {
        document.removeEventListener('mousemove', r, !1),
          i.preventDefault(),
          (n.x = (i.clientX / t.innerWidth) * 2 - 1),
          (n.y = (-i.clientY / t.innerHeight) * 2 + 1),
          e.setFromCamera(n, t.camera);
        const o = e.intersectObjects(t.scene.children, !0);
        if ((t.removeSelectGeo(), o.length > 0))
          for (let e = 0; e < Mg.length; e++) {
            let n = Mg[e].getEntityArray();
            for (let e = 0; e < n.length; e++) {
              let i = n[e];
              for (let e = 0, n = i.geoDataArray.length; e < n; ++e) {
                let n = i.geoDataArray[e],
                  r = n.getGeoID();
                if (o[0].object.userData.geoID === r)
                  if ('instanceMesh' === o[0].object.userData.name) {
                    if (
                      o[0].object.userData.bufferSegment.offset ===
                      n.bufferSegment.offset
                    )
                      return (
                        console.log('找到InstanceMesh', i),
                        t.selectGeo(i),
                        void t.getSelectGeometryInfo(i)
                      );
                  } else if (
                    o[0].faceIndex >= n.bufferSegment.offset / 3 &&
                    o[0].faceIndex <
                      n.bufferSegment.offset / 3 + n.bufferSegment.count / 3
                  )
                    return (
                      console.log('找到', i),
                      t.selectGeo(i),
                      void t.getSelectGeometryInfo(i)
                    );
              }
            }
          }
      }
      function r(t) {
        (t.movementX > -5 && t.movementX < 5) ||
          (t.movementY > -5 && t.movementY < 5) ||
          document.removeEventListener('mouseup', i, !1);
      }
    },
    selectGeo(t, e) {
      for (let n = 0, i = t.geoDataArray.length; n < i; ++n) {
        const i = t.geoDataArray[n];
        this.setGeoFromRenderBuffer(i, e);
      }
    },
    setGeoFromRenderBuffer(t, e) {
      const n = t.renderObject.renderBuffer;
      if (n.isPMInstanceRenderBuffer)
        if (e) {
          let t = new this.THREE.BufferGeometry();
          t.setIndex(n.vertexIndex.bufferAttribute);
          for (
            let e = 0;
            e < n.vertexAttributeArray.vertexAttributes.length;
            e++
          ) {
            let i = n.vertexAttributeArray.vertexAttributes[e];
            t.setAttribute(i.name, i.bufferAttribute);
          }
          (this.Material.polygonOffset = n.material.polygonOffset),
            (this.Material.polygonOffsetUnits = n.material.polygonOffsetUnits),
            (this.Material.polygonOffsetFactor =
              n.material.polygonOffsetFactor),
            (this.Material.alphaTest = n.material.alphaTest);
          let i = new this.THREE.Mesh(t, this.Material);
          i.applyMatrix4(e), (i.renderOrder = 999), this.selectGeoGroup.add(i);
        } else {
          let e = new this.THREE.BufferGeometry();
          e.setIndex(n.vertexIndex.bufferAttribute);
          for (
            let t = 0;
            t < n.vertexAttributeArray.vertexAttributes.length;
            t++
          ) {
            let i = n.vertexAttributeArray.vertexAttributes[t];
            e.setAttribute(i.name, i.bufferAttribute);
          }
          (this.Material.polygonOffset = n.material.polygonOffset),
            (this.Material.polygonOffsetUnits = n.material.polygonOffsetUnits),
            (this.Material.polygonOffsetFactor =
              n.material.polygonOffsetFactor),
            (this.Material.alphaTest = n.material.alphaTest);
          let o = new this.THREE.Mesh(e, this.Material),
            s =
              n.instanceVertexAttributeArray.vertexAttributes[0].bufferAttribute
                .array,
            a =
              n.instanceVertexAttributeArray.vertexAttributes[1].bufferAttribute
                .array,
            c =
              n.instanceVertexAttributeArray.vertexAttributes[2].bufferAttribute
                .array,
            l =
              n.instanceVertexAttributeArray.vertexAttributes[3].bufferAttribute
                .array,
            h = new this.THREE.Matrix4();
          var i = 4 * t.bufferSegment.offset;
          h.set(
            s[i],
            a[i],
            c[i],
            l[i],
            s[i + 1],
            a[i + 1],
            c[i + 1],
            l[i + 1],
            s[i + 2],
            a[i + 2],
            c[i + 2],
            l[i + 2],
            s[i + 3],
            a[i + 3],
            c[i + 3],
            l[i + 3],
          );
          var r = o.clone();
          r.applyMatrix4(h), (r.renderOrder = 999), this.selectGeoGroup.add(r);
        }
      else {
        let e = n.vertexIndex.bufferAttribute.array,
          i = [],
          r = [];
        for (
          let t = 0;
          t < n.vertexAttributeArray.vertexAttributes.length;
          t++
        ) {
          let e = n.vertexAttributeArray.vertexAttributes[t];
          'position' === e.name && (i = e.bufferAttribute.array),
            'normal' === e.name && (r = e.bufferAttribute.array);
        }
        let o = [],
          s = [];
        for (
          let n = t.bufferSegment.offset;
          n < t.bufferSegment.offset + t.bufferSegment.count;
          ++n
        ) {
          let t = 3 * e[n];
          o.push(i[t], i[t + 1], i[t + 2]), s.push(r[t], r[t + 1], r[t + 2]);
        }
        let a = new this.THREE.BufferGeometry();
        a.setAttribute(
          'position',
          new this.THREE.BufferAttribute(new Float32Array(o), 3),
        ),
          a.setAttribute(
            'normal',
            new this.THREE.BufferAttribute(new Float32Array(s), 3),
          ),
          (this.Material.polygonOffset = n.material.polygonOffset),
          (this.Material.polygonOffsetUnits = n.material.polygonOffsetUnits),
          (this.Material.polygonOffsetFactor = n.material.polygonOffsetFactor),
          (this.Material.alphaTest = n.material.alphaTest);
        let c = new this.THREE.Mesh(a, this.Material);
        (c.renderOrder = 999), this.selectGeoGroup.add(c);
      }
      this.map.render();
    },
    removeSelectGeo() {
      if (this.selectGeoGroup.children.length > 0) {
        for (let t = this.selectGeoGroup.children.length - 1; t >= 0; t--) {
          let e = this.selectGeoGroup.children[t];
          e.geometry.dispose(),
            e.material.dispose(),
            this.selectGeoGroup.remove(e);
        }
        this.map.render();
      }
    },
    getSelectGeometryInfo(t) {
      let e = {
        comid: t.comid,
        comtype: t.comtype,
        floorID: t.floorID,
        handle: t.handle,
      };
      this.dispatchEvent({ type: 'selectedEntity', object: e });
    },
    disposeModel() {
      let t = this.GlobalShare.bimViewer.getModelScene();
      const e = t.getModelArray();
      t.removeModel(e[0]);
      let n = this.GlobalShare.bimViewer.renderContext.getSceneList();
      (n.progressive1 = []),
        (n.progressive2 = []),
        this.scene.children.forEach((t) => {
          this.scene.remove(t);
        });
      var i = document.getElementById('ccbim__GIS__mark');
      i &&
        (!(function (t) {
          jh(Xh``, t);
        })(i),
        i.remove()),
        this.map.render(),
        console.log('模型销毁成功');
    },
  });
  function Ig(t) {
    (this.rect = null), (this.viewer = t), (this.dom = null);
  }
  function Eg() {
    (this.canvas = !!window.CanvasRenderingContext2D),
      (this.workers = !!window.Worker),
      (this.fileapi =
        window.File && window.FileReader && window.FileList && window.Blob);
  }
  (Ig.prototype = {
    constructor: Ig,
    setDevicesWidthHeight(t) {
      t &&
        ((this.dom = t),
        (this.rect = t.getBoundingClientRect()),
        (this.rect.w = t.clientWidth),
        (this.rect.h = t.clientHeight),
        (this.rect.wHalf = this.rect.w / 2),
        (this.rect.hHalf = this.rect.h / 2));
    },
    getDevicesWidthHeight() {
      return this.rect;
    },
    setRenderWidth(t) {
      t &&
        ((this.rect.w = t),
        (this.rect.wHalf = t / 2),
        (this.dom.style.width = t + 'px'));
    },
    setRenderHeight(t) {
      t &&
        ((this.rect.h = t),
        (this.rect.hHalf = t / 2),
        (this.dom.style.height = t + 'px'));
    },
    resize() {
      let { w: t, h: e } = this.rect;
      this.viewer.bimViewer.resize(t, e), this.viewer.bimViewer.cameraChanged();
    },
    getIsPhone: () =>
      !!navigator.userAgent.match(
        /(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i,
      ),
    is360ByUserActivationProperty: () => !window.navigator.userActivation,
    launchFullscreen() {
      let t = this.viewer.bimViewer.dom.parentElement;
      t.requestFullscreen
        ? t.requestFullscreen()
        : t.mozRequestFullScreen
        ? t.mozRequestFullScreen()
        : t.msRequestFullscreen
        ? t.msRequestFullscreen()
        : t.webkitRequestFullscreen && t.webkitRequestFullScreen();
    },
    exitFullscreen() {
      document.exitFullscreen
        ? document.exitFullscreen()
        : document.msExitFullscreen
        ? document.msExitFullscreen()
        : document.mozCancelFullScreen
        ? document.mozCancelFullScreen()
        : document.webkitExitFullscreen && document.webkitExitFullscreen();
    },
  }),
    (Eg.prototype = {
      constructor: Eg,
      webgl: (() => {
        try {
          let t = document.createElement('canvas');
          return !(
            !window.WebGLRenderingContext ||
            (!t.getContext('webgl') && !t.getContext('experimental-webgl'))
          );
        } catch (t) {
          return !1;
        }
      })(),
      webgl2: (() => {
        try {
          let t = document.createElement('canvas');
          return !(!window.WebGL2RenderingContext || !t.getContext('webgl2'));
        } catch (t) {
          return !1;
        }
      })(),
      isIe: function () {
        return !!navigator.userAgent.includes('Trident');
      },
    });
  class Dg extends Sh {
    constructor(t) {
      super(t);
    }
    render() {
      return Xh`<div class="ccbim__basic__progress" id="ccbim__basic__progress">
      <div class="ccbim__basic__progress__com">
        <div
          class="ccbim__basic__progress__div"
          id="ccbim__basic__progress__div"
          style="width: 0%"
        >
          0%
        </div>
      </div>
    </div>`;
    }
  }
  function Cg(t) {
    jh(Xh`<${Dg} />`, t);
  }
  function Tg() {
    (this.viewer = null), (this.started = !1), (this.name = '');
  }
  function Lg() {
    Tg.call(this), (this.lastWorldPos = new J()), (this.name = 'CameraPan');
  }
  function Rg() {
    Tg.call(this),
      (this.lastWindowPos = new U()),
      (this.currentWindowPos = new U()),
      (this.rotateSpeed = 2),
      (this.rotateCenter = null),
      (this.name = 'CameraOrbit');
  }
  function Fg() {
    Tg.call(this), (this.name = 'CameraZoom'), (this.zoomCenter = null);
  }
  function Pg(t, e, n) {
    Tg.call(this),
      (this.pan = t || new Lg()),
      (this.orbit = e || new Rg()),
      (this.zoom = n || new Fg()),
      (this.name = 'MultipleCamera'),
      (this.dwgLeftButtonPan = !1),
      (this.windowPos = new U()),
      (this.zoomStartX = 0),
      (this.zoomStartY = 0),
      (this.distanceCurrent = 0);
  }
  function Bg(t, e) {
    return new Promise((n, i) => {
      Gf({ method: 'get', url: t, params: e })
        .then((t) => {
          n(t);
        })
        .catch((t) => {
          Gf.isCancel(t)
            ? console.log('Request canceled', t.message)
            : console.log('catch处理'),
            i();
        });
    });
  }
  (Tg.prototype = {
    constructor: Tg,
    willBegin: function (t) {
      this.viewer = t;
    },
    willEnd: function (t) {
      this.viewer = null;
    },
    getViewer: function () {
      return this.viewer;
    },
    setStarted: function (t) {
      this.started = t;
    },
    getStarted: function () {
      return this.started;
    },
    onLButtonDown: function (t) {},
    onLButtonUp: function (t) {},
    onRButtonDown: function (t) {},
    onRButtonUp: function (t) {},
    onMButtonDown: function (t) {},
    onMButtonUp: function (t) {},
    onMouseMove: function (t) {
      1 & t.buttons
        ? this.onLButtonDownAndMove(t)
        : 2 & t.buttons
        ? this.onRButtonDownAndMove(t)
        : 4 & t.buttons
        ? this.onMButtonDownAndMove(t)
        : this.onNoButtonDownAndMove(t);
    },
    onLButtonDownAndMove: function (t) {},
    onRButtonDownAndMove: function (t) {},
    onMButtonDownAndMove: function (t) {},
    onNoButtonDownAndMove: function (t) {},
    onMouseWheel: function (t) {},
    onTouchStart: function (t) {},
    onTouchEnd: function (t) {},
    onTouchMove: function (t) {},
    onKeyDown: function (t) {},
    onKeyUp: function (t) {},
    onFrame: function () {},
    getCamera: function () {
      return this.getViewer().getMainCamera();
    },
    getDwgLayoutMap: function () {
      return this.getViewer()
        .getModelScene()
        .getModelArray()[0]
        .getDwgLayoutMap();
    },
    getMainModelScene: function () {
      return this.getViewer().getModelScene();
    },
    getBounding: function () {
      return null;
    },
    getMouseWindowPos: function (t, e) {
      let n = this.viewer.getSize();
      e.set((2 * t.offsetX) / n.x - 1, 1 - (2 * t.offsetY) / n.y);
    },
    getMouseRaycaster: (function () {
      let t = new U();
      return function (e, n) {
        this.getMouseWindowPos(e, t);
        let i = this.getCamera();
        (n.far = 1 / 0), (n.near = i.near), n.setFromCamera(t, i);
      };
    })(),
    getMouseWorldPos: (function () {
      let t = new J(),
        e = new Kt(),
        n = new gl();
      return function (i, r) {
        let o = this.getCamera();
        t.subVectors(o.position, o.target).normalize(),
          e.setFromNormalAndCoplanarPoint(t, o.target),
          this.getMouseRaycaster(i, n),
          n.ray.intersectPlane(e, r);
      };
    })(),
  }),
    (Lg.prototype = Object.assign(Object.create(Tg.prototype), {
      constructor: Lg,
      isCameraPanOperator: !0,
      onLButtonDown: function (t) {
        (t.target.style.cursor = 'grab'),
          this.getMouseWorldPos(t, this.lastWorldPos),
          this.setStarted(!0);
      },
      onLButtonUp: function (t) {
        (t.target.style.cursor = 'default'), this.setStarted(!1);
      },
      onMouseMove: function (t) {
        this.getStarted() && this.onLButtonDownAndMove(t);
      },
      onLButtonDownAndMove: (function () {
        let t = new J(),
          e = new J();
        return function (n) {
          (n.target.style.cursor = 'grabbing'),
            this.getMouseWorldPos(n, t),
            e.subVectors(this.lastWorldPos, t),
            this.getCamera().makePan(e),
            this.getViewer().cameraChanged();
        };
      })(),
    })),
    (Rg.prototype = Object.assign(Object.create(Tg.prototype), {
      constructor: Rg,
      isCameraOrbitOperator: !0,
      setRotateCenter: function (t) {
        this.rotateCenter = t;
      },
      onLButtonDown: function (t) {
        this.getMouseWindowPos(t, this.lastWindowPos),
          this.currentWindowPos.copy(this.lastWindowPos),
          this.setStarted(!0);
      },
      onLButtonUp: function (t) {
        this.setStarted(!1);
      },
      onMouseMove: function (t) {
        this.getStarted() && this.onLButtonDownAndMove(t);
      },
      onLButtonDownAndMove: (function () {
        let t = new J(),
          e = new U(),
          n = new ot(),
          i = new J(),
          r = new J();
        return function (o) {
          this.getMouseWindowPos(o, this.currentWindowPos),
            e.subVectors(this.currentWindowPos, this.lastWindowPos);
          let s = e.length() * this.rotateSpeed,
            a = this.getCamera();
          if (
            (i.subVectors(a.position, a.target).normalize(),
            r.crossVectors(a.up, i).normalize(),
            Math.abs(e.x) > Math.abs(e.y)
              ? (t.set(0, 0, 1), e.x > 0 && (s = -s))
              : (t.copy(r), e.y < 0 && (s = -s)),
            !this.rotateCenter)
          ) {
            let t = this.getMainModelScene().getBoundingBox(),
              e = new J(),
              n = (t.max.x + t.min.x) / 2,
              i = (t.max.y + t.min.y) / 2,
              r = (t.max.z + t.min.z) / 2;
            e.set(n, i, r), this.setRotateCenter(e);
          }
          Xf.makeRotationMatrix4(this.rotateCenter || a.target, t, s, n),
            a.makeRotate(n),
            this.lastWindowPos.copy(this.currentWindowPos),
            this.getViewer().cameraChanged();
        };
      })(),
    })),
    (Fg.prototype = Object.assign(Object.create(Tg.prototype), {
      constructor: Fg,
      isCameraZoomOperator: !0,
      getSelectResult: function (t, e) {
        return (
          this.getMouseWindowPos(t, e),
          this.getViewer().pickSelectEntityByWindowPos(e)
        );
      },
      onMouseWheel: (function () {
        let t = new gl(),
          e = new U(),
          n = new J(),
          i = new J(),
          r = new J(),
          o = new J(),
          s = new J(),
          a = new Kt(),
          c = null;
        return function (l) {
          let h = this.getSelectResult(l, e);
          h && ((c = h), (this.zoomCenter = c.point));
          let u = this.getCamera();
          s.subVectors(u.position, u.target).normalize(),
            (t.far = u.far),
            (t.near = u.near),
            t.setFromCamera(e, u),
            c
              ? (a.setFromNormalAndCoplanarPoint(s, c.point),
                a.projectPoint(u.position, r),
                u.lookAt(r))
              : a.setFromNormalAndCoplanarPoint(s, u.target),
            t.ray.intersectPlane(a, n);
          let d = 0.002;
          (d *= Math.floor(Math.abs(l.deltaY))),
            d >= 1 && (d = 0.9),
            u.makeZoom(l.deltaY > 0 ? 1 + d : 1 - d),
            t.setFromCamera(e, u),
            a.setFromNormalAndCoplanarPoint(s, u.target),
            t.ray.intersectPlane(a, i),
            o.subVectors(n, i),
            u.makePan(o),
            this.getViewer().cameraChanged();
        };
      })(),
    })),
    (Pg.prototype = Object.assign(Object.create(Tg.prototype), {
      constructor: Pg,
      isMultipleCameraOperator: !0,
      willBegin: function (t) {
        Tg.prototype.willBegin.call(this, t),
          this.pan && this.pan.willBegin(t),
          this.orbit && this.orbit.willBegin(t),
          this.zoom && this.zoom.willBegin(t);
      },
      willEnd: function (t) {
        this.pan && this.pan.willEnd(t),
          this.orbit && this.orbit.willEnd(t),
          this.zoom && this.zoom.willEnd(t),
          Tg.prototype.willEnd.call(this, t);
      },
      setPan: function (t) {
        this.pan && this.pan.willEnd(this.viewer),
          (this.pan = t),
          this.pan && this.pan.willBegin(this.viewer);
      },
      setOrbit: function (t) {
        this.orbit && this.orbit.willEnd(this.viewer),
          (this.orbit = t),
          this.orbit && this.orbit.willBegin(this.viewer);
      },
      setZoom: function (t) {
        this.zoom && this.zoom.willEnd(this.viewer),
          (this.zoom = t),
          this.zoom && this.zoom.willBegin(this.viewer);
      },
      setDwgLeftButtonPan: function (t) {
        this.dwgLeftButtonPan = t;
      },
      onLButtonDown: function (t) {
        if (this.orbit) {
          this.getMouseWindowPos(t, this.windowPos);
          let e = this.getViewer().pickSelectEntityByWindowPos(this.windowPos);
          e
            ? this.orbit.setRotateCenter(e.point)
            : this.zoom.zoomCenter &&
              this.orbit.setRotateCenter(this.zoom.zoomCenter),
            this.orbit.onLButtonDown(t),
            (this.zoom.zoomCenter = null);
        }
        this.dwgLeftButtonPan && this.pan && this.pan.onLButtonDown(t);
      },
      onLButtonUp: function (t) {
        this.orbit && this.orbit.onLButtonUp(t),
          this.dwgLeftButtonPan && this.pan && this.pan.onLButtonUp(t);
      },
      onMButtonDown: function (t) {
        this.pan && this.pan.onLButtonDown(t);
      },
      onMButtonUp: function (t) {
        this.pan && this.pan.onLButtonUp(t);
      },
      onMouseMove: function (t) {
        this.pan && this.pan.onMouseMove(t),
          this.orbit && this.orbit.onMouseMove(t);
      },
      onMouseWheel: function (t) {
        this.zoom && this.zoom.onMouseWheel(t);
      },
      onTouchMove: function (t) {
        switch (
          (t.preventDefault(),
          t.stopPropagation(),
          (t.offsetX = t.touches[0].pageX),
          (t.offsetY = t.touches[0].pageY),
          t.touches.length)
        ) {
          case 1:
            this.orbit && this.orbit.onMouseMove(t),
              this.dwgLeftButtonPan && this.pan && this.pan.onMouseMove(t);
            break;
          case 2:
            (t.offsetX = 0.5 * (t.touches[0].pageX + t.touches[1].pageX)),
              (t.offsetY = 0.5 * (t.touches[0].pageY + t.touches[1].pageY)),
              this.pan && this.pan.onMouseMove(t);
            var e = t.touches[0].pageX - t.touches[1].pageX,
              n = t.touches[0].pageY - t.touches[1].pageY,
              i = Math.sqrt(e * e + n * n),
              r = Math.sqrt(
                this.zoomStartX * this.zoomStartX +
                  this.zoomStartY * this.zoomStartY,
              );
            let o = Math.abs(i - r),
              s = 0.008 * Math.abs(o - this.distanceCurrent);
            (this.distanceCurrent = o),
              (this.zoomStartX = e),
              (this.zoomStartY = n);
            let a = this.getCamera();
            i < r ? a.makeZoom(1 + s) : a.makeZoom(1 - s);
        }
        this.getViewer().cameraChanged();
      },
      onTouchStart: function (t) {
        switch (
          (t.stopPropagation(),
          (t.offsetX = t.touches[0].pageX),
          (t.offsetY = t.touches[0].pageY),
          t.touches.length)
        ) {
          case 1:
            if (this.orbit) {
              this.getMouseWindowPos(t, this.windowPos);
              let e = this.getViewer().pickSelectEntityByWindowPos(
                this.windowPos,
              );
              e
                ? this.orbit.setRotateCenter(e.point)
                : this.zoom.zoomCenter &&
                  this.orbit.setRotateCenter(this.zoom.zoomCenter),
                this.orbit.onLButtonDown(t),
                (this.zoom.zoomCenter = null);
            }
            this.dwgLeftButtonPan && this.pan && this.pan.onLButtonDown(t);
            break;
          case 2:
            (t.offsetX = 0.5 * (t.touches[0].pageX + t.touches[1].pageX)),
              (t.offsetY = 0.5 * (t.touches[0].pageY + t.touches[1].pageY)),
              this.pan && this.pan.onLButtonDown(t),
              (this.zoomStartX = t.touches[0].pageX - t.touches[1].pageX),
              (this.zoomStartY = t.touches[0].pageY - t.touches[1].pageY);
        }
      },
      onTouchEnd: function (t) {
        t.stopPropagation(),
          t.touches.length > 1 ||
            (this.orbit && this.orbit.onLButtonUp(t),
            this.pan && this.pan.onLButtonUp(t),
            (this.zoomStartX = 0),
            (this.zoomStartY = 0),
            (this.distanceCurrent = 0));
      },
    })),
    (Gf.defaults.headers['X-Requested-With'] = 'XMLHttpRequest'),
    (Gf.defaults.headers.Accept = 'application/json');
  class Og extends Sh {
    constructor(t) {
      super(t);
    }
    reConvert() {
      this.props.reConvertCallbackFuc();
    }
    renderIcon() {
      return '-310045' === this.props.errorCode
        ? Xh`<svg class="convertIcon" style="color: #00B589">
        <use xlinkHref="#iconhuojian"></use>
      </svg>`
        : '-310044' === this.props.errorCode
        ? Xh`<svg class="queueIcon" style="color: #1890FF">
        <use xlinkHref="#iconkafei"></use>
      </svg>`
        : Xh`<svg class="queueIcon" style="color: #FEC52A">
        <use xlinkHref="#iconjinggao"></use>
      </svg>`;
    }
    renderMsg() {
      return 'object' == typeof this.props.errorMsg
        ? Xh`<div>
        <p style="user-select:text;">${this.props.errorMsg.errorInfo}</p>
        <p style="user-select:text;" class="suggest">
          ${this.props.errorMsg.suggest}
        </p>
        ${
          this.props.errorMsg.canReConvert &&
          Xh`<button class="reConvert" onClick=${() =>
            this.reConvert()}>重新转换</button>`
        }
      </div>`
        : Xh`<div>
        <p style="user-select:text;">${this.props.errorMsg}</p>
        ${
          '-310036' === this.props.errorCode &&
          Xh`<button class="reConvert" onClick=${() =>
            this.reConvert()}>重新转换</button>`
        }
      </div>`;
    }
    render() {
      return Xh`<${Mh}>
        <div class="ccbim__error">
          <div>
            ${this.renderIcon()}
            ${this.renderMsg()}
          </div>
        </div>
      </${Mh}>`;
    }
  }
  function Vg(t, e, n, i) {
    jh(
      Xh`<${Og}
      errorCode=${e}
      errorMsg=${n}
      reConvertCallbackFuc=${i}
    />`,
      t,
    );
  }
  class Ng extends Sh {
    constructor(t) {
      super(t);
    }
    render() {
      return Xh`<${Mh}>
      <div class='ccbim__rotateCenterPoint'>
        <svg
          id=${this.props.parentElementId + '__ccbim__rotateCenterPoint'}
          class="icon"
          title="旋转中心"
        >
          <use xlinkHref="#iconzhou"></use>
        </svg>
      </div>
      </${Mh}>`;
    }
  }
  function kg(t) {
    document.getElementById(t + '__ccbim__rotateCenterPoint').style.display =
      'none';
  }
  function Ug() {
    Rr.call(this),
      (this.type = 'PMAutoTransform'),
      (this.autoScale = !1),
      (this.alignToScreen = !1);
  }
  function Gg(t) {
    (this.name = t || ''),
      (this.autoTransform = new Ug()),
      (this.scene = void 0),
      (this.shapeObjectArray = []),
      (this.isHandled = !1),
      (this.visible = !0),
      (this.userData = void 0);
  }
  function zg(t) {
    Gg.call(this, t), (this.handleArray = []), (this.curHandle = null);
  }
  function jg(t) {
    Gg.call(this, t);
  }
  function Hg(t, e) {
    jg.call(this, t),
      (this.moveDirection = new J()),
      e && this.moveDirection.copy(e),
      (this.firstPosition = new J()),
      (this.prePosition = new J()),
      (this.currentPosition = new J());
  }
  function Wg(t, e, n) {
    Pg.call(this, t, e, n),
      (this.name = 'ClippingBox'),
      (this.clippingPlanes = []);
    for (let t = 0; t < 6; ++t) this.clippingPlanes.push(new Kt(new J(), 0));
    this.clippingHandle = new zg('');
    let i = new He();
    i.setAttribute('position', new Re(new Float32Array(72), 3)),
      (this.boxLine = new So(i, new bo({ color: 64447 }))),
      (this.orbitCenter = new J()),
      this.orbit.setRotateCenter(this.orbitCenter),
      (this.clippingBoxChanged = null),
      (this.clippingBox = new Nt());
  }
  function Xg(t) {
    this.dom = t;
  }
  function Zg(t) {
    this.dom = t;
  }
  (Ug.prototype = Object.assign(Object.create(Rr.prototype), {
    constructor: Ug,
    isPMAutoTransform: !0,
    setPosition: function (t) {
      this.position.copy(t);
    },
    getPosition: function () {
      return this.position;
    },
    setAutoScale: function (t) {
      this.autoScale = t;
    },
    getAutoScale: function () {
      return this.autoScale;
    },
    setAlignToScreen: function (t) {
      this.alignToScreen = t;
    },
    getAlignToScreen: function (t) {
      return this.alignToScreen;
    },
    updateMatrix: (function () {
      let t = new ot(),
        e = new J(),
        n = new J();
      return function (i) {
        if (i && i.isPMCamera) {
          if (
            (this.matrix.identity(),
            this.alignToScreen &&
              (e.subVectors(i.position, i.target).normalize(),
              n.crossVectors(i.up, e).normalize(),
              Xf.makeCoordinateMatrix4(n, i.up, e, Xf.origin, t),
              this.matrix.premultiply(t)),
            this.autoScale)
          ) {
            let e = i.getPixelScale(this.position);
            t.makeScale(e, e, e), this.matrix.premultiply(t);
          }
          t.makeScale(this.scale.x, this.scale.y, this.scale.z),
            this.matrix.premultiply(t),
            t.makeTranslation(
              this.position.x,
              this.position.y,
              this.position.z,
            ),
            this.matrix.premultiply(t),
            (this.matrixWorldNeedsUpdate = !0);
        }
      };
    })(),
  })),
    (Gg.prototype = {
      constructor: Gg,
      isGeometryHandle: !0,
      install: function (t) {
        void 0 === this.scene &&
          ((this.scene = t),
          this.visible && this.scene.add(this.autoTransform));
      },
      uninstall: function () {
        void 0 !== this.scene &&
          (this.scene.remove(this.autoTransform),
          this.autoTransform.removeAll(),
          (this.scene = void 0));
      },
      setVisible: function (t) {
        (t = !!t),
          this.visible !== t &&
            ((this.visible = t),
            this.scene &&
              (this.visible
                ? this.scene.add(this.autoTransform)
                : this.scene.remove(this.autoTransform)));
      },
      getVisible: function () {
        return this.visible;
      },
      setPosition: function (t) {
        this.autoTransform.setPosition(t);
      },
      getPosition: function () {
        return this.autoTransform.getPosition();
      },
      setAutoScale: function (t) {
        this.autoTransform.setAutoScale(t);
      },
      setAlignToScreen: function (t) {
        this.autoTransform.setAlignToScreen(t);
      },
      setUserData: function (t) {
        this.userData = t;
      },
      getUserData: function () {
        return this.userData;
      },
      addShapeObject: function (t, e, n) {
        this.shapeObjectArray.push({
          object: t,
          normalMaterial: e,
          highlightMaterial: n,
        }),
          this.autoTransform.add(t);
      },
      setShapeTransform: function (t) {
        for (let e = 0, n = this.shapeObjectArray.length; e < n; ++e)
          (this.shapeObjectArray[e].object.matrixAutoUpdate = !1),
            this.shapeObjectArray[e].object.matrix.copy(t);
      },
      intersectWithRaycaster: (function () {
        function t(t, e) {
          return t.distance - e.distance;
        }
        return function (e) {
          let n = [];
          for (let t = 0, i = this.shapeObjectArray.length; t < i; ++t) {
            this.shapeObjectArray[t].object.raycast(e, n);
          }
          return 0 === n.length ? -1 : (n.sort(t), n[0].distance);
        };
      })(),
      begin: function (t) {},
      end: function (t) {
        this.isHandled = !1;
      },
      handled: function (t) {
        return this.isHandled;
      },
      highlight: function (t, e) {
        for (let e = 0, n = this.shapeObjectArray.length; e < n; ++e) {
          let n = this.shapeObjectArray[e];
          n.object.material = t ? n.highlightMaterial : n.normalMaterial;
        }
        t && e
          ? this.autoTransform.scale.set(e, e, e)
          : this.autoTransform.scale.set(1, 1, 1);
      },
    }),
    (zg.prototype = Object.assign(Object.create(Gg.prototype), {
      constructor: zg,
      addHandle: function (t) {
        this.handleArray.push(t);
      },
      getHandleArray: function () {
        return this.handleArray;
      },
      indexOfHandle: function (t) {
        return this.handleArray.indexOf(t);
      },
      getHandleAt: function (t) {
        return t < this.handleArray.length ? this.handleArray[t] : void 0;
      },
      install: function (t) {
        Gg.prototype.install.call(this, t);
        for (let e = 0, n = this.handleArray.length; e < n; ++e)
          this.handleArray[e].install(t);
      },
      uninstall: function () {
        Gg.prototype.uninstall.call(this);
        for (let t = 0, e = this.handleArray.length; t < e; ++t)
          this.handleArray[t].uninstall();
      },
      intersectWithRaycaster: function (t) {
        let e,
          n = 0;
        for (let i = 0, r = this.handleArray.length; i < r; ++i) {
          let r = this.handleArray[i],
            o = r.intersectWithRaycaster(t);
          o < 0 || ((void 0 === e || o < n) && ((e = r), (n = o)));
        }
        return e;
      },
      begin: function (t) {
        this.curHandle ||
          ((this.curHandle = this.intersectWithRaycaster(t)),
          this.curHandle && this.curHandle.begin(t));
      },
      end: function (t) {
        return (
          !!this.curHandle &&
          (this.curHandle.end(t),
          Gg.prototype.end.call(this, t),
          (this.curHandle = null),
          !0)
        );
      },
      handled: function (t, e) {
        if (this.curHandle) return this.curHandle.handled(t), this.curHandle;
        for (let t = 0, e = this.handleArray.length; t < e; ++t)
          this.handleArray[t].highlight(!1);
        let n = this.intersectWithRaycaster(t);
        n && (n.highlight(!0), e && e());
      },
    })),
    (jg.prototype = Object.assign(Object.create(Gg.prototype), {
      constructor: jg,
    })),
    (Hg.prototype = Object.assign(Object.create(jg.prototype), {
      constructor: Hg,
      setDirection: function (t) {
        this.moveDirection.copy(t);
      },
      getDirection: function () {
        return this.moveDirection;
      },
      begin: (function () {
        let t = new Ml();
        return function (e) {
          if (this.isHandled) return;
          let n = this.getPosition();
          t.set(n, n),
            t.end.addScaledVector(this.moveDirection, 1e3),
            (this.isHandled = Xf.computeIntersectionRayLine3(
              e.ray,
              t,
              !0,
              this.firstPosition,
            )),
            this.prePosition.copy(this.firstPosition);
        };
      })(),
      handled: (function () {
        let t = new Ml(),
          e = new J();
        return function (n) {
          let i = this.getPosition();
          return (
            t.set(i, i),
            t.end.addScaledVector(this.moveDirection, 1e3),
            Xf.computeIntersectionRayLine3(n.ray, t, !0, this.currentPosition),
            e.subVectors(this.currentPosition, this.prePosition),
            i.add(e),
            this.prePosition.copy(this.currentPosition),
            this.isHandled
          );
        };
      })(),
    })),
    (Wg.prototype = Object.assign(Object.create(Pg.prototype), {
      constructor: Wg,
      isClippingBoxOperator: !0,
      setClippingBoxChangedCallback: function (t) {
        this.clippingBoxChanged = t;
      },
      setBoxLineVisible: function (t) {
        this.boxLine.visible = t;
      },
      willBegin: (function () {
        let t = new ra({ color: 16711680 }),
          e = new ra({ color: 65280 }),
          n = new ra({ color: 255 }),
          i = new ra({ color: 16776960 }),
          r = new ot();
        r.set(0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1);
        let o = new ot(),
          s = new ot();
        function a(a, c, l) {
          let h = new Hg(a, l);
          h.setPosition(c), h.setAutoScale(!0);
          let u = t;
          Xf.isParallelVector3(l, Xf.yAxis)
            ? (u = e)
            : Xf.isParallelVector3(l, Xf.zAxis) && (u = n);
          Xf.getCoordinateByRefAxis(Xf.origin, l, o);
          let d = new ln(new Ws(5, 5, 10), u);
          (d.matrixAutoUpdate = !1),
            d.matrix.identity(),
            d.matrix.premultiply(r),
            s.makeTranslation(0, 0, 5),
            d.matrix.premultiply(s),
            d.matrix.premultiply(o),
            h.addShapeObject(d, u, i);
          let p = new ln(new Zs(10, 10), u);
          return (
            (p.matrixAutoUpdate = !1),
            p.matrix.identity(),
            p.matrix.premultiply(r),
            s.makeTranslation(0, 0, 15),
            p.matrix.premultiply(s),
            p.matrix.premultiply(o),
            h.addShapeObject(p, u, i),
            h
          );
        }
        return function (t) {
          Pg.prototype.willBegin.call(this, t),
            t.setClippingPlanes(this.clippingPlanes),
            this.clippingHandle.addHandle(a('', new J(), new J(-1, 0, 0))),
            this.clippingHandle.addHandle(a('', new J(), new J(0, -1, 0))),
            this.clippingHandle.addHandle(a('', new J(), new J(0, 0, -1))),
            this.clippingHandle.addHandle(a('', new J(), new J(0, 0, 1))),
            this.clippingHandle.addHandle(a('', new J(), new J(0, 1, 0))),
            this.clippingHandle.addHandle(a('', new J(), new J(1, 0, 0)));
          let e = t.getIncrementalScene();
          this.clippingHandle.install(e), e.add(this.boxLine);
          let n = t.getModelScene().getBoundingBox();
          this.updateHandlePosition(n), this.updateClipping(n);
        };
      })(),
      willEnd: function (t) {
        t.setClippingPlanes([]);
        let e = t.getIncrementalScene();
        this.clippingHandle.uninstall(e),
          e.remove(this.boxLine),
          t.requestFrameUpdate(),
          Pg.prototype.willEnd.call(this, t);
      },
      onLButtonDown: (function () {
        let t = new gl();
        return function (e) {
          Pg.prototype.onLButtonDown.call(this, e),
            this.getMouseRaycaster(e, t),
            this.clippingHandle.begin(t);
        };
      })(),
      onLButtonUp: (function () {
        let t = new gl();
        return function (e) {
          Pg.prototype.onLButtonUp.call(this, e),
            this.getMouseRaycaster(e, t),
            this.clippingHandle.end(t);
        };
      })(),
      onMouseMove: (function () {
        let t = new gl(),
          e = new Nt(),
          n = new Kt(),
          i = new J(),
          r = new J();
        return function (o) {
          this.getMouseRaycaster(o, t);
          let s = this.clippingHandle.handled(t, () => {
            this.getViewer().renderContext.setRequestUpdate(!0);
          });
          if (s) {
            let t = this.clippingHandle.indexOfHandle(s),
              o = this.clippingHandle.getHandleAt(5 - t).getPosition();
            i.subVectors(s.getPosition(), o),
              n.setFromNormalAndCoplanarPoint(i.normalize(), o),
              e.makeEmpty();
            let a = this.clippingHandle.getHandleArray();
            for (let i = 0, o = a.length; i < o; ++i)
              i === t
                ? e.expandByPoint(s.getPosition())
                : (n.projectPoint(a[i].getPosition(), r), e.expandByPoint(r));
            this.updateClipping(e),
              this.updateHandlePosition(e),
              this.getViewer().requestFrameUpdate();
          } else Pg.prototype.onMouseMove.call(this, o);
        };
      })(),
      onTouchStart: (function () {
        let t = new gl();
        return function (e) {
          (e.offsetX = e.changedTouches[0].clientX),
            (e.offsetY = e.changedTouches[0].clientY),
            Pg.prototype.onTouchStart.call(this, e),
            this.getMouseRaycaster(e, t),
            this.clippingHandle.handled(t, () => {
              this.getViewer().renderContext.setRequestUpdate(!0);
            }),
            this.clippingHandle.begin(t);
        };
      })(),
      onTouchEnd: (function () {
        let t = new gl();
        return function (e) {
          (e.offsetX = e.changedTouches[0].clientX),
            (e.offsetY = e.changedTouches[0].clientY),
            Pg.prototype.onTouchEnd.call(this, e),
            this.getMouseRaycaster(e, t),
            this.clippingHandle.end(t);
        };
      })(),
      onTouchMove: (function () {
        let t = new gl(),
          e = new Nt(),
          n = new Kt(),
          i = new J(),
          r = new J();
        return function (o) {
          (o.offsetX = o.changedTouches[0].clientX),
            (o.offsetY = o.changedTouches[0].clientY),
            this.getMouseRaycaster(o, t);
          let s = this.clippingHandle.handled(t, () => {
            this.getViewer().renderContext.setRequestUpdate(!0);
          });
          if (s) {
            let t = this.clippingHandle.indexOfHandle(s),
              o = this.clippingHandle.getHandleAt(5 - t).getPosition();
            i.subVectors(s.getPosition(), o),
              n.setFromNormalAndCoplanarPoint(i.normalize(), o),
              e.makeEmpty();
            let a = this.clippingHandle.getHandleArray();
            for (let i = 0, o = a.length; i < o; ++i)
              i === t
                ? e.expandByPoint(s.getPosition())
                : (n.projectPoint(a[i].getPosition(), r), e.expandByPoint(r));
            this.updateClipping(e),
              this.updateHandlePosition(e),
              this.getViewer().requestFrameUpdate();
          } else Pg.prototype.onTouchMove.call(this, o);
        };
      })(),
      updateHandlePosition: (function () {
        let t = [
            0, 1, 1, 3, 3, 2, 2, 0, 4, 5, 5, 7, 7, 6, 6, 4, 0, 4, 1, 5, 3, 7, 2,
            6,
          ],
          e = new J();
        return function (n) {
          let i = n.min,
            r = n.max,
            o = this.clippingHandle.getHandleArray();
          o[0].setPosition(new J(i.x, 0.5 * (i.y + r.y), 0.5 * (i.z + r.z))),
            o[1].setPosition(new J(0.5 * (i.x + r.x), i.y, 0.5 * (i.z + r.z))),
            o[2].setPosition(new J(0.5 * (i.x + r.x), 0.5 * (i.y + r.y), i.z)),
            o[3].setPosition(new J(0.5 * (i.x + r.x), 0.5 * (i.y + r.y), r.z)),
            o[4].setPosition(new J(0.5 * (i.x + r.x), r.y, 0.5 * (i.z + r.z))),
            o[5].setPosition(new J(r.x, 0.5 * (i.y + r.y), 0.5 * (i.z + r.z)));
          let s = this.boxLine.geometry.attributes.position,
            a = s.array;
          for (let i = 0, r = t.length; i < r; ++i)
            Xf.getBox3Corner(n, t[i], e),
              (a[3 * i] = e.x),
              (a[3 * i + 1] = e.y),
              (a[3 * i + 2] = e.z);
          s.needsUpdate = !0;
        };
      })(),
      updateClipping: function (t) {
        let e = t.min,
          n = t.max;
        this.clippingPlanes[0].normal.set(1, 0, 0),
          (this.clippingPlanes[0].constant = -e.x),
          this.clippingPlanes[1].normal.set(-1, 0, 0),
          (this.clippingPlanes[1].constant = n.x),
          this.clippingPlanes[2].normal.set(0, 1, 0),
          (this.clippingPlanes[2].constant = -e.y),
          this.clippingPlanes[3].normal.set(0, -1, 0),
          (this.clippingPlanes[3].constant = n.y),
          this.clippingPlanes[4].normal.set(0, 0, 1),
          (this.clippingPlanes[4].constant = -e.z),
          this.clippingPlanes[5].normal.set(0, 0, -1),
          (this.clippingPlanes[5].constant = n.z),
          t.getCenter(this.orbitCenter),
          this.clippingBoxChanged && this.clippingBoxChanged(t),
          this.clippingBox.copy(t),
          this.getViewer().cameraChanged();
      },
      getBounding: function () {
        return new Nt().copy(this.clippingBox);
      },
    })),
    (Xg.prototype = {
      constructor: Xg,
      mouseDownListener(t) {
        let e = this.dom.offsetLeft,
          n = this.dom.offsetTop;
        'touchstart' === t.type &&
          ((t.pageX = t.changedTouches[0].pageX),
          (t.pageY = t.changedTouches[0].pageY));
        let i = t.pageX,
          r = t.pageY,
          o = (t) => {
            console.log('move'),
              'touchmove' === t.type &&
                ((t.pageX = t.changedTouches[0].pageX),
                (t.pageY = t.changedTouches[0].pageY));
            let o = t.pageX - i + e,
              s = t.pageY - r + n;
            o < 0 && (o = 0), s < 0 && (s = 0);
            let a = this.dom.parentElement.clientWidth - this.dom.clientWidth,
              c = this.dom.parentElement.clientHeight - this.dom.clientHeight;
            o > a && (o = a),
              s > c && (s = c),
              (this.dom.style.left = o + 'px'),
              (this.dom.style.top = s + 'px');
          },
          s = () => {
            document.removeEventListener('mousemove', o, !1),
              document.removeEventListener('mouseup', s, !1),
              document.removeEventListener('touchmove', o, !1),
              document.removeEventListener('touchend', s, !1);
          };
        document.addEventListener('mousemove', o, !1),
          document.addEventListener('mouseup', s, !1),
          document.addEventListener('touchmove', o, !1),
          document.addEventListener('touchend', s, !1);
      },
      bind(t) {
        t.setAttribute('style', 'cursor: move;');
        let e = (t) => {
          this.mouseDownListener(t);
        };
        return (
          t.addEventListener('mousedown', e, !1),
          t.addEventListener('touchstart', e, !1),
          e
        );
      },
      unBind(t, e) {
        t.setAttribute('style', 'cursor: default;'),
          t.removeEventListener('mousedown', e, !1),
          t.removeEventListener('touchstart', e, !1);
      },
    }),
    (Zg.prototype = {
      constructor: Zg,
      mouseDownListener(t) {
        t.preventDefault();
        let e = this.dom.offsetWidth,
          n = this.dom.offsetHeight;
        'touchstart' === t.type &&
          ((t.pageX = t.changedTouches[0].pageX),
          (t.pageY = t.changedTouches[0].pageY));
        let i = t.pageX,
          r = t.pageY,
          o = (t) => {
            console.log('move'),
              'touchmove' === t.type &&
                ((t.pageX = t.changedTouches[0].pageX),
                (t.pageY = t.changedTouches[0].pageY));
            let o = t.pageX - i + e,
              s = t.pageY - r + n,
              a = this.dom.parentElement.clientWidth - this.dom.offsetLeft,
              c = this.dom.parentElement.clientHeight - this.dom.offsetTop;
            o > a && (o = a),
              s > c && (s = c),
              (this.dom.style.width = o + 'px'),
              (this.dom.style.height = s + 'px');
          },
          s = () => {
            document.removeEventListener('mousemove', o, !1),
              document.removeEventListener('mouseup', s, !1),
              document.removeEventListener('touchmove', o, !1),
              document.removeEventListener('touchend', s, !1);
          };
        document.addEventListener('mousemove', o, !1),
          document.addEventListener('mouseup', s, !1),
          document.addEventListener('touchmove', o, !1),
          document.addEventListener('touchend', s, !1);
      },
      bind(t) {
        t.setAttribute('style', 'cursor: nw-resize;');
        let e = (t) => {
          this.mouseDownListener(t);
        };
        return (
          t.addEventListener('mousedown', e, !1),
          t.addEventListener('touchstart', e, !1),
          e
        );
      },
      unBind(t, e) {
        t.setAttribute('style', 'cursor: default;'),
          t.removeEventListener('mousedown', e, !1),
          t.removeEventListener('touchstart', e, !1);
      },
    });
  class Yg extends Sh {
    constructor(t) {
      super(t),
        (this.state = {
          xForwardWidth: 0,
          xReverseWidth: 120,
          yForwardWidth: 0,
          yReverseWidth: 120,
          zForwardWidth: 0,
          zReverseWidth: 120,
          slideToolWidth: 120,
          showCutLineCheck: !0,
          xDistance: 0,
          yDistance: 0,
          zDistance: 0,
          boundingBoxAll: new Nt(),
        }),
        (this.sliderLXRef = { current: null }),
        (this.sliderRXRef = { current: null }),
        (this.sliderLYRef = { current: null }),
        (this.sliderRYRef = { current: null }),
        (this.sliderLZRef = { current: null }),
        (this.sliderRZRef = { current: null }),
        (this.sliderLXSpanRef = { current: null }),
        (this.sliderRXSpanRef = { current: null }),
        (this.sliderLYSpanRef = { current: null }),
        (this.sliderRYSpanRef = { current: null }),
        (this.sliderLZSpanRef = { current: null }),
        (this.sliderRZSpanRef = { current: null }),
        (this.name = ''),
        (this.width = 0),
        (this.clientXD = 0),
        (this.touchStart = !1),
        (this.clippingBox = new Wg()),
        (this.currentBox = new Nt()),
        (this.changedBox = new Nt());
    }
    onmousemoveFuc(t) {
      if (!this.touchStart) return;
      let e = t || event,
        n = 0;
      n = 'touchmove' === e.type ? e.changedTouches[0].clientX : e.clientX;
      let i = this.width + (n - this.clientXD);
      i <= 0 && (i = 0), i >= 120 && (i = 120);
      let r = new Nt().copy(this.state.boundingBoxAll),
        o = new Nt().copy(this.state.boundingBoxAll);
      if (
        (this.currentBox &&
          (o = new Nt(this.currentBox.min, this.currentBox.max)),
        'xForwardMove' === this.name)
      ) {
        i > this.sliderRXRef.current.offsetWidth &&
          (i = this.sliderRXRef.current.offsetWidth);
        const t = i / 120;
        (o.min.x = r.min.x + this.state.xDistance * t),
          this.setState({ xForwardWidth: i });
      } else if ('xReverseMove' === this.name) {
        i < this.sliderLXRef.current.offsetWidth &&
          (i = this.sliderLXRef.current.offsetWidth);
        const t = i / 120;
        (o.max.x = r.max.x - this.state.xDistance * (1 - t)),
          this.setState({ xReverseWidth: i });
      } else if ('yForwardMove' === this.name) {
        i > this.sliderRYRef.current.offsetWidth &&
          (i = this.sliderRYRef.current.offsetWidth);
        const t = i / 120;
        (o.min.y = r.min.y + this.state.yDistance * t),
          this.setState({ yForwardWidth: i });
      } else if ('yReverseMove' === this.name) {
        i < this.sliderLYRef.current.offsetWidth &&
          (i = this.sliderLYRef.current.offsetWidth);
        const t = i / 120;
        (o.max.y = r.max.y - this.state.yDistance * (1 - t)),
          this.setState({ yReverseWidth: i });
      } else if ('zForwardMove' === this.name) {
        i > this.sliderRZRef.current.offsetWidth &&
          (i = this.sliderRZRef.current.offsetWidth);
        const t = i / 120;
        (o.min.z = r.min.z + this.state.zDistance * t),
          this.setState({ zForwardWidth: i });
      } else if ('zReverseMove' === this.name) {
        i < this.sliderLZRef.current.offsetWidth &&
          (i = this.sliderLZRef.current.offsetWidth);
        const t = i / 120;
        (o.max.z = r.max.z - this.state.zDistance * (1 - t)),
          this.setState({ zReverseWidth: i });
      }
      (this.changedBox = o), this.clippingPlanes(this.changedBox);
    }
    axialCutStripDown(t, e) {
      this.touchStart = !0;
      let n = 0;
      'xForwardMove' === t
        ? (n = this.sliderLXRef.current.offsetWidth)
        : 'xReverseMove' === t
        ? (n = this.sliderRXRef.current.offsetWidth)
        : 'yForwardMove' === t
        ? (n = this.sliderLYRef.current.offsetWidth)
        : 'yReverseMove' === t
        ? (n = this.sliderRYRef.current.offsetWidth)
        : 'zForwardMove' === t
        ? (n = this.sliderLZRef.current.offsetWidth)
        : 'zReverseMove' === t && (n = this.sliderRZRef.current.offsetWidth),
        (this.width = n),
        (this.name = t),
        'touchstart' === e.type
          ? (this.clientXD = e.changedTouches[0].clientX)
          : ((this.clientXD = e.clientX),
            (document.onmousemove = (t) => this.onmousemoveFuc(t)),
            (document.onmouseup = function () {
              document.onmousemove = null;
            }));
    }
    widthValueChange(t, e) {
      let n = parseFloat(t.target.value);
      n > 100 && (n = 100), n < -100 && (n = -100);
      const i = (n / 100) * 60 + 60,
        r = i / 120;
      let o = new Nt().copy(this.state.boundingBoxAll),
        s = new Nt().copy(this.state.boundingBoxAll);
      this.currentBox && (s = new Nt(this.currentBox.min, this.currentBox.max)),
        'xForwardMove' === e
          ? ((s.min.x = o.min.x + this.state.xDistance * r),
            this.setState({ xForwardWidth: i }))
          : 'xReverseMove' === e
          ? ((s.max.x = o.max.x - this.state.xDistance * (1 - r)),
            this.setState({ xReverseWidth: i }))
          : 'yForwardMove' === e
          ? ((s.min.y = o.min.y + this.state.yDistance * r),
            this.setState({ yForwardWidth: i }))
          : 'yReverseMove' === e
          ? ((s.max.y = o.max.y - this.state.yDistance * (1 - r)),
            this.setState({ yReverseMove: i }))
          : 'zForwardMove' === e
          ? ((s.min.z = o.min.z + this.state.zDistance * r),
            this.setState({ zForwardMove: i }))
          : 'zReverseMove' === e &&
            ((s.max.z = o.max.z - this.state.zDistance * (1 - r)),
            this.setState({ zReverseMove: i })),
        (this.changedBox = s),
        this.clippingPlanes(this.changedBox);
    }
    setBoxLineVisible(t) {
      let e = t.target.checked;
      this.setState({ showCutLineCheck: e }),
        this.clippingBox.setBoxLineVisible(e),
        this.props.viewer.bimViewer.requestFrameUpdate();
    }
    clippingBoxChangedCallback(t) {
      let e = new Nt().copy(this.state.boundingBoxAll),
        n = (t.min.x - e.min.x) / this.state.xDistance,
        i = 1 - (e.max.x - t.max.x) / this.state.xDistance,
        r = (t.min.y - e.min.y) / this.state.yDistance,
        o = 1 - (e.max.y - t.max.y) / this.state.yDistance,
        s = (t.min.z - e.min.z) / this.state.zDistance,
        a = 1 - (e.max.z - t.max.z) / this.state.zDistance;
      n > 1 ? (n = 1) : n < 0 && (n = 0),
        i > 1 ? (i = 1) : i < 0 && (i = 0),
        r > 1 ? (r = 1) : r < 0 && (r = 0),
        o > 1 ? (o = 1) : o < 0 && (o = 0),
        s > 1 ? (s = 1) : s < 0 && (s = 0),
        a > 1 ? (a = 1) : a < 0 && (a = 0),
        this.setState({
          xForwardWidth: 120 * n,
          xReverseWidth: 120 * i,
          yForwardWidth: 120 * r,
          yReverseWidth: 120 * o,
          zForwardWidth: 120 * s,
          zReverseWidth: 120 * a,
        });
    }
    clippingPlanes(t) {
      this.clippingBox.updateHandlePosition(t),
        this.clippingBox.updateClipping(t),
        this.props.viewer.bimViewer.requestFrameUpdate();
    }
    initCut() {
      this.clippingPlanes(this.state.boundingBoxAll),
        this.clippingBox.setBoxLineVisible(!0);
      let t = this.props.viewer.bimViewer.getModelScene().getBoundingBox();
      (this.currentBox = new Nt().copy(t)),
        this.setState({
          xForwardWidth: 0,
          xReverseWidth: 120,
          yForwardWidth: 0,
          yReverseWidth: 120,
          zForwardWidth: 0,
          zReverseWidth: 120,
          showCutLineCheck: !0,
        });
    }
    componentDidMount() {
      this.props.viewer.bimViewer.setOperator(this.clippingBox),
        this.clippingBox.setClippingBoxChangedCallback((t) =>
          this.clippingBoxChangedCallback(t),
        );
      let t = this.props.viewer.bimViewer.getModelScene().getBoundingBox(),
        e = t.max.x - t.min.x,
        n = t.max.y - t.min.y,
        i = t.max.z - t.min.z;
      (this.currentBox = new Nt().copy(t)),
        this.setState({
          boundingBoxAll: t,
          xDistance: e,
          yDistance: n,
          zDistance: i,
        }),
        (yg = new Xg(document.getElementById('ccbim__axialCut'))),
        (vg = yg.bind(document.getElementById('ccbim__axialCut__top'))),
        this.sliderLXSpanRef.current.addEventListener(
          'touchstart',
          this.axialCutStripDown.bind(this, 'xForwardMove'),
          !1,
        ),
        this.sliderRXSpanRef.current.addEventListener(
          'touchstart',
          this.axialCutStripDown.bind(this, 'xReverseMove'),
          !1,
        ),
        this.sliderLYSpanRef.current.addEventListener(
          'touchstart',
          this.axialCutStripDown.bind(this, 'yForwardMove'),
          !1,
        ),
        this.sliderRYSpanRef.current.addEventListener(
          'touchstart',
          this.axialCutStripDown.bind(this, 'yReverseMove'),
          !1,
        ),
        this.sliderLZSpanRef.current.addEventListener(
          'touchstart',
          this.axialCutStripDown.bind(this, 'zForwardMove'),
          !1,
        ),
        this.sliderRZSpanRef.current.addEventListener(
          'touchstart',
          this.axialCutStripDown.bind(this, 'zReverseMove'),
          !1,
        ),
        document.addEventListener(
          'touchend',
          this.touchEndEvent.bind(this),
          !1,
        ),
        document.addEventListener(
          'touchmove',
          this.onmousemoveFuc.bind(this),
          !1,
        );
    }
    touchEndEvent() {
      this.touchStart = !1;
    }
    componentWillUnmount() {
      this.props.viewer.bimViewer.setOperator(new Pg()),
        yg && yg.unBind(document.getElementById('ccbim__axialCut__top'), vg),
        this.sliderLXSpanRef.current.removeEventListener(
          'touchstart',
          this.axialCutStripDown.bind(this, 'xForwardMove'),
          !1,
        ),
        this.sliderRXSpanRef.current.removeEventListener(
          'touchstart',
          this.axialCutStripDown.bind(this, 'xReverseMove'),
          !1,
        ),
        this.sliderLYSpanRef.current.removeEventListener(
          'touchstart',
          this.axialCutStripDown.bind(this, 'yForwardMove'),
          !1,
        ),
        this.sliderRYSpanRef.current.removeEventListener(
          'touchstart',
          this.axialCutStripDown.bind(this, 'yReverseMove'),
          !1,
        ),
        this.sliderLZSpanRef.current.removeEventListener(
          'touchstart',
          this.axialCutStripDown.bind(this, 'zForwardMove'),
          !1,
        ),
        this.sliderRZSpanRef.current.removeEventListener(
          'touchstart',
          this.axialCutStripDown.bind(this, 'zReverseMove'),
          !1,
        ),
        document.removeEventListener(
          'touchend',
          this.touchEndEvent.bind(this),
          !1,
        ),
        document.removeEventListener(
          'touchmove',
          this.onmousemoveFuc.bind(this),
          !1,
        );
    }
    render() {
      return Xh` <div
      class="ccbim__axialCut ccbim__common__dialog"
      id="ccbim__axialCut"
    >
      <div class="ccbim__common__title" id="ccbim__axialCut__top">
        <span>剖切</span>
        <svg
          title="关闭"
          class="icon"
          aria-hidden="true"
          onClick=${() => this.props.close()}
        >
          <use xlinkHref="#iconguanbi1"></use>
        </svg>
      </div>
      <div class="ccbim__axialCut__content">
        <div class="ccbim__axialCut__li">
          <input
            class="ccbim__axialCut__input"
            value=${(((this.state.xForwardWidth - 60) / 60) * 100).toFixed(1)}
            onChange=${(t) => this.widthValueChange(t, 'xForwardMove')}
            type="text"
          />
          <div class="ccbim__axialCut__slideTool">
            <span class="ccbim__axialTxt ccbim__text__color--x">X</span>
            <div class="ccbim__axialCut__slideBottom">
              <div
                class="ccbim__axialCut__slideLeft"
                ref=${this.sliderLXRef}
                style=${{ width: (this.state.xForwardWidth / 120) * 100 + '%' }}
              ></div>
              <span
                class="ccbim__axialCut__slider ccbim__btn__color--x"
                style=${{ left: (this.state.xForwardWidth / 120) * 100 + '%' }}
                ref=${this.sliderLXSpanRef}
                onMouseDown=${(t) => {
                  this.axialCutStripDown('xForwardMove', t);
                }}
              ></span>
              <div
                class="ccbim__axialCut__slideRight ccbim__strip__color--x"
                ref=${this.sliderRXRef}
                style=${{ width: (this.state.xReverseWidth / 120) * 100 + '%' }}
              ></div>
              <span
                class="ccbim__axialCut__slider ccbim__btn__color--x"
                style=${{ left: (this.state.xReverseWidth / 120) * 100 + '%' }}
                ref=${this.sliderRXSpanRef}
                onMouseDown=${(t) => {
                  this.axialCutStripDown('xReverseMove', t);
                }}
              ></span>
            </div>
          </div>
          <input
            class="ccbim__axialCut__input"
            value=${(((this.state.xReverseWidth - 60) / 60) * 100).toFixed(1)}
            onChange=${(t) => this.widthValueChange(t, 'xReverseMove')}
            type="text"
          />
        </div>
        <div class="ccbim__axialCut__li">
          <input
            class="ccbim__axialCut__input"
            value=${(((this.state.yForwardWidth - 60) / 60) * 100).toFixed(1)}
            onChange=${(t) => this.widthValueChange(t, 'yForwardMove')}
            type="text"
          />
          <div class="ccbim__axialCut__slideTool">
            <span class="ccbim__axialTxt ccbim__text__color--y">Y</span>
            <div class="ccbim__axialCut__slideBottom">
              <div
                class="ccbim__axialCut__slideLeft"
                ref=${this.sliderLYRef}
                style=${{ width: (this.state.yForwardWidth / 120) * 100 + '%' }}
              ></div>
              <span
                class="ccbim__axialCut__slider ccbim__btn__color--y"
                style=${{ left: (this.state.yForwardWidth / 120) * 100 + '%' }}
                ref=${this.sliderLYSpanRef}
                onMouseDown=${(t) => {
                  this.axialCutStripDown('yForwardMove', t);
                }}
              ></span>
              <div
                class="ccbim__axialCut__slideRight ccbim__strip__color--y"
                ref=${this.sliderRYRef}
                style=${{ width: (this.state.yReverseWidth / 120) * 100 + '%' }}
              ></div>
              <span
                class="ccbim__axialCut__slider ccbim__btn__color--y"
                style=${{ left: (this.state.yReverseWidth / 120) * 100 + '%' }}
                ref=${this.sliderRYSpanRef}
                onMouseDown=${(t) => {
                  this.axialCutStripDown('yReverseMove', t);
                }}
              ></span>
            </div>
          </div>
          <input
            class="ccbim__axialCut__input"
            value=${(((this.state.yReverseWidth - 60) / 60) * 100).toFixed(1)}
            onChange=${(t) => this.widthValueChange(t, 'yReverseMove')}
            type="text"
          />
        </div>
        <div class="ccbim__axialCut__li">
          <input
            class="ccbim__axialCut__input"
            value=${(((this.state.zForwardWidth - 60) / 60) * 100).toFixed(1)}
            onChange=${(t) => this.widthValueChange(t, 'zForwardMove')}
            type="text"
          />
          <div class="ccbim__axialCut__slideTool">
            <span class="ccbim__axialTxt ccbim__text__color--z">Z</span>
            <div class="ccbim__axialCut__slideBottom">
              <div
                class="ccbim__axialCut__slideLeft"
                ref=${this.sliderLZRef}
                style=${{ width: (this.state.zForwardWidth / 120) * 100 + '%' }}
              ></div>
              <span
                class="ccbim__axialCut__slider ccbim__btn__color--z"
                style=${{ left: (this.state.zForwardWidth / 120) * 100 + '%' }}
                ref=${this.sliderLZSpanRef}
                onMouseDown=${(t) => {
                  this.axialCutStripDown('zForwardMove', t);
                }}
              ></span>
              <div
                class="ccbim__axialCut__slideRight ccbim__strip__color--z"
                ref=${this.sliderRZRef}
                style=${{ width: (this.state.zReverseWidth / 120) * 100 + '%' }}
              ></div>
              <span
                class="ccbim__axialCut__slider ccbim__btn__color--z"
                style=${{ left: (this.state.zReverseWidth / 120) * 100 + '%' }}
                ref=${this.sliderRZSpanRef}
                onMouseDown=${(t) => {
                  this.axialCutStripDown('zReverseMove', t);
                }}
              ></span>
            </div>
          </div>
          <input
            class="ccbim__axialCut__input"
            value=${(((this.state.zReverseWidth - 60) / 60) * 100).toFixed(1)}
            onChange=${(t) => this.widthValueChange(t, 'zReverseMove')}
            type="text"
          />
        </div>
      </div>
      <div class="ccbim__axialCut_bottom">
        <div class="ccbim__axialCut__showLine">
          <span>显示剖切轮廓线</span>
          <input
            class="ccbim__axialCut__switch ccbim__axialCut__switch__anim"
            type="checkbox"
            checked=${this.state.showCutLineCheck}
            onChange=${(t) => this.setBoxLineVisible(t)}
          />
        </div>
        <div class="ccbim__common__recoverDefault">
          <span onClick=${() => this.initCut()}>恢复默认</span>
        </div>
      </div>
    </div>`;
    }
  }
  function qg(t, e, n) {
    Pg.call(this, t, e, n),
      (this.name = 'ClippingBoxPhone'),
      (this.clippingPlanes = []);
    for (let t = 0; t < 6; ++t) this.clippingPlanes.push(new Kt(new J(), 0));
    let i = new He();
    i.setAttribute('position', new Re(new Float32Array(72), 3)),
      (this.boxLine = new So(i, new bo({ color: 64447 }))),
      (this.orbitCenter = new J()),
      this.orbit.setRotateCenter(this.orbitCenter),
      (this.clippingBoxChanged = null),
      (this.clippingBox = new Nt());
  }
  qg.prototype = Object.assign(Object.create(Pg.prototype), {
    constructor: qg,
    isClippingBoxOperator: !0,
    setClippingBoxChangedCallback: function (t) {
      this.clippingBoxChanged = t;
    },
    setBoxLineVisible: function (t) {
      this.boxLine.visible = t;
    },
    willBegin:
      (new ot().set(0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1),
      function (t) {
        Pg.prototype.willBegin.call(this, t),
          t.setClippingPlanes(this.clippingPlanes),
          t.getIncrementalScene().add(this.boxLine);
        let e = t.getModelScene().getBoundingBox();
        this.updateHandlePosition(e), this.updateClipping(e);
      }),
    willEnd: function (t) {
      t.setClippingPlanes([]),
        t.getIncrementalScene().remove(this.boxLine),
        t.requestFrameUpdate(),
        Pg.prototype.willEnd.call(this, t);
    },
    onLButtonDown:
      (new gl(),
      function (t) {
        Pg.prototype.onLButtonDown.call(this, t);
      }),
    onLButtonUp:
      (new gl(),
      function (t) {
        Pg.prototype.onLButtonUp.call(this, t);
      }),
    onMouseMove:
      (new gl(),
      function (t) {
        Pg.prototype.onMouseMove.call(this, t);
      }),
    updateHandlePosition: (function () {
      let t = [
          0, 1, 1, 3, 3, 2, 2, 0, 4, 5, 5, 7, 7, 6, 6, 4, 0, 4, 1, 5, 3, 7, 2,
          6,
        ],
        e = new J();
      return function (n) {
        let i = this.boxLine.geometry.attributes.position,
          r = i.array;
        for (let i = 0, o = t.length; i < o; ++i)
          Xf.getBox3Corner(n, t[i], e),
            (r[3 * i] = e.x),
            (r[3 * i + 1] = e.y),
            (r[3 * i + 2] = e.z);
        i.needsUpdate = !0;
      };
    })(),
    updateClipping: function (t) {
      let e = t.min,
        n = t.max;
      this.clippingPlanes[0].normal.set(1, 0, 0),
        (this.clippingPlanes[0].constant = -e.x),
        this.clippingPlanes[1].normal.set(-1, 0, 0),
        (this.clippingPlanes[1].constant = n.x),
        this.clippingPlanes[2].normal.set(0, 1, 0),
        (this.clippingPlanes[2].constant = -e.y),
        this.clippingPlanes[3].normal.set(0, -1, 0),
        (this.clippingPlanes[3].constant = n.y),
        this.clippingPlanes[4].normal.set(0, 0, 1),
        (this.clippingPlanes[4].constant = -e.z),
        this.clippingPlanes[5].normal.set(0, 0, -1),
        (this.clippingPlanes[5].constant = n.z),
        t.getCenter(this.orbitCenter),
        this.clippingBoxChanged && this.clippingBoxChanged(t),
        this.clippingBox.copy(t),
        this.getViewer().cameraChanged();
    },
    getBounding: function () {
      return new Nt().copy(this.clippingBox);
    },
  });
  class Qg extends Sh {
    constructor(t) {
      super(t),
        (this.state = {
          xForwardWidth: 0,
          xReverseWidth: 0,
          yForwardWidth: 0,
          yReverseWidth: 0,
          zForwardWidth: 0,
          zReverseWidth: 0,
          showCutLineCheck: !0,
          xDistance: 0,
          yDistance: 0,
          zDistance: 0,
          axialCutState: {
            xShow: !0,
            xOrientation: 1,
            yShow: !1,
            yOrientation: 1,
            zShow: !1,
            zOrientation: 1,
          },
          axialSlideWidth: 0,
          boundingBoxAll: new Nt(),
        }),
        (this.sliderRef = { current: null }),
        (this.clippingBox = new qg()),
        (this.currentBox = new Nt()),
        (this.changedBox = new Nt());
    }
    axialCutStripDown(t) {
      let e = 0;
      e = this.sliderRef.current.offsetWidth;
      let n = t.clientX;
      (document.ontouchmove = (t) => {
        let i = t.changedTouches[0],
          r = e + (i.clientX - n);
        r <= 0 && (r = 0), r >= 120 && (r = 120);
        let o = new Nt().copy(this.state.boundingBoxAll),
          s = new Nt().copy(this.state.boundingBoxAll);
        if (
          (this.currentBox &&
            (s = new Nt(this.currentBox.min, this.currentBox.max)),
          this.state.axialCutState.xShow)
        )
          if (1 === this.state.axialCutState.xOrientation) {
            const t = r / 120;
            (s.min.x = o.min.x + this.state.xDistance * t),
              this.setState({ xForwardWidth: r });
          } else {
            const t = r / 120;
            (s.max.x = o.max.x - this.state.xDistance * t),
              this.setState({ xReverseWidth: r });
          }
        else if (this.state.axialCutState.yShow)
          if (1 === this.state.axialCutState.yOrientation) {
            const t = r / 120;
            (s.min.y = o.min.y + this.state.yDistance * t),
              this.setState({ yForwardWidth: r });
          } else {
            const t = r / 120;
            (s.max.y = o.max.y - this.state.yDistance * t),
              this.setState({ yReverseWidth: r });
          }
        else if (this.state.axialCutState.zShow)
          if (1 === this.state.axialCutState.zOrientation) {
            const t = r / 120;
            (s.min.z = o.min.z + this.state.zDistance * t),
              this.setState({ zForwardWidth: r });
          } else {
            const t = r / 120;
            (s.max.z = o.max.z - this.state.zDistance * t),
              this.setState({ zReverseWidth: r });
          }
        (this.changedBox = s),
          this.clippingPlanes(this.changedBox),
          this.setChangedAxial();
      }),
        (document.ontouchend = function () {
          document.ontouchmove = null;
        });
    }
    setBoxLineVisible(t) {
      let e = t.target.checked;
      this.setState({ showCutLineCheck: e }),
        this.clippingBox.setBoxLineVisible(e);
    }
    clippingPlanes(t) {
      this.clippingBox.updateHandlePosition(t),
        this.clippingBox.updateClipping(t),
        this.props.viewer.bimViewer.requestFrameUpdate();
    }
    changedAxial(t) {
      if ('axial' === t)
        if (this.state.axialCutState.xShow) {
          this.setState({
            axialCutState: {
              xShow: !1,
              xOrientation: 1,
              yShow: !0,
              yOrientation: 1,
              zShow: !1,
              zOrientation: 1,
            },
          });
          let t = this.state.yForwardWidth;
          this.setState({ axialSlideWidth: t });
        } else if (this.state.axialCutState.yShow) {
          this.setState({
            axialCutState: {
              xShow: !1,
              xOrientation: 1,
              yShow: !1,
              yOrientation: 1,
              zShow: !0,
              zOrientation: 1,
            },
          });
          let t = this.state.zForwardWidth;
          this.setState({ axialSlideWidth: t });
        } else if (this.state.axialCutState.zShow) {
          this.setState({
            axialCutState: {
              xShow: !0,
              xOrientation: 1,
              yShow: !1,
              yOrientation: 1,
              zShow: !1,
              zOrientation: 1,
            },
          });
          let t = this.state.xForwardWidth;
          this.setState({ axialSlideWidth: t });
        }
      if ('orientation' === t)
        if (this.state.axialCutState.xShow) {
          let t = 1 === this.state.axialCutState.xOrientation ? 0 : 1;
          if (
            (this.setState({
              axialCutState: {
                xShow: !0,
                xOrientation: t,
                yShow: !1,
                yOrientation: 1,
                zShow: !1,
                zOrientation: 1,
              },
            }),
            1 === t)
          ) {
            let t = this.state.xForwardWidth;
            this.setState({ axialSlideWidth: t });
          } else if (0 === t) {
            let t = this.state.xReverseWidth;
            this.setState({ axialSlideWidth: t });
          }
        } else if (this.state.axialCutState.yShow) {
          let t = 1 === this.state.axialCutState.yOrientation ? 0 : 1;
          if (
            (this.setState({
              axialCutState: {
                xShow: !1,
                xOrientation: 1,
                yShow: !0,
                yOrientation: t,
                zShow: !1,
                zOrientation: 1,
              },
            }),
            1 === t)
          ) {
            let t = this.state.yForwardWidth;
            this.setState({ axialSlideWidth: t });
          } else if (0 === t) {
            let t = this.state.yReverseWidth;
            this.setState({ axialSlideWidth: t });
          }
        } else if (this.state.axialCutState.zShow) {
          let t = 1 === this.state.axialCutState.zOrientation ? 0 : 1;
          if (
            (this.setState({
              axialCutState: {
                xShow: !1,
                xOrientation: 1,
                yShow: !1,
                yOrientation: 1,
                zShow: !0,
                zOrientation: t,
              },
            }),
            1 === t)
          ) {
            let t = this.state.zForwardWidth;
            this.setState({ axialSlideWidth: t });
          } else if (0 === t) {
            let t = this.state.zReverseWidth;
            this.setState({ axialSlideWidth: t });
          }
        }
    }
    setChangedAxial() {
      let t = 0;
      this.state.axialCutState.xShow
        ? (t = this.state.axialCutState.xOrientation
            ? this.state.xForwardWidth
            : this.state.xReverseWidth)
        : this.state.axialCutState.yShow
        ? (t = this.state.axialCutState.yOrientation
            ? this.state.yForwardWidth
            : this.state.yReverseWidth)
        : this.state.axialCutState.zShow &&
          (t = this.state.axialCutState.zOrientation
            ? this.state.zForwardWidth
            : this.state.zReverseWidth),
        this.setState({ axialSlideWidth: t });
    }
    componentDidMount() {
      this.props.viewer.bimViewer.setOperator(this.clippingBox);
      let t = this.props.viewer.bimViewer.getModelScene().getBoundingBox(),
        e = t.max.x - t.min.x,
        n = t.max.y - t.min.y,
        i = t.max.z - t.min.z;
      (this.currentBox = new Nt().copy(t)),
        this.setState({
          boundingBoxAll: t,
          xDistance: e,
          yDistance: n,
          zDistance: i,
        }),
        this.setChangedAxial();
    }
    componentWillUnmount() {
      this.props.viewer.bimViewer.setOperator(new Pg());
    }
    render() {
      return Xh` <div class="ccbim__axialCutPhone">
      <div class="ccbim__axialBox">
        <div
          class="ccbim__axialOrientation"
          onClick=${() => this.changedAxial('axial')}
        >
          ${(() =>
            this.state.axialCutState.xShow
              ? Xh`<svg class="icon" aria-hidden="true">
                <use xlinkHref="#iconaxis-x-letter"></use>
              </svg>`
              : this.state.axialCutState.yShow
              ? Xh`<svg class="icon" aria-hidden="true">
                <use xlinkHref="#iconaxis-y-letter"></use>
              </svg>`
              : this.state.axialCutState.zShow
              ? Xh`<svg class="icon" aria-hidden="true">
                <use xlinkHref="#iconaxis-z-letter"></use>
              </svg>`
              : void 0)()}
        </div>
        <div
          class="ccbim__axialOrientation"
          onClick=${() => this.changedAxial('orientation')}
        >
          ${(() => {
            let t = !1;
            return (
              this.state.axialCutState.xShow
                ? 0 === this.state.axialCutState.xOrientation && (t = !0)
                : this.state.axialCutState.yShow
                ? 0 === this.state.axialCutState.yOrientation && (t = !0)
                : this.state.axialCutState.zShow &&
                  0 === this.state.axialCutState.zOrientation &&
                  (t = !0),
              Xh`<svg
              class="icon ${t && 'reverseDirection'}"
              aria-hidden="true"
            >
              <use xlinkHref="#iconpouqie1"></use>
            </svg>`
            );
          })()}
        </div>
      </div>
      <div
        class="ccbim__axialCutPhone__slideBottom__box"
        onTouchStart=${(t) => {
          this.axialCutStripDown(t.changedTouches[0]);
        }}
      >
        <div class="ccbim__axialCutPhone__slideBottom">
          <div
            class="ccbim__axialCutPhone__slideLeft"
            ref=${this.sliderRef}
            style=${{ width: (this.state.axialSlideWidth / 120) * 100 + '%' }}
          ></div>
          <span
            class="ccbim__axialCutPhone__slider"
            style=${{ left: (this.state.axialSlideWidth / 120) * 100 + '%' }}
          ></span>
        </div>
      </div>
      <div class="ccbim__axialClose" onClick=${() => this.props.close()}>
        <svg class="icon" aria-hidden="true">
          <use xlinkHref="#iconguanbi1"></use>
        </svg>
      </div>
    </div>`;
    }
  }
  class Jg extends Sh {
    constructor(t) {
      super(t);
    }
    performComponentCut() {
      const t = this.props.viewer.uiState.selectedEntity;
      let e = new Wg();
      this.props.viewer.bimViewer.setOperator(e);
      let n = t.getBoundingBox();
      e.updateHandlePosition(n),
        e.updateClipping(n),
        this.props.viewer.bimViewer.getMainCamera().makeLookAtBoundingBox(n),
        this.props.viewer.bimViewer.cameraChanged(),
        this.props.viewer.bimViewer.requestFrameUpdate(),
        this.cancelComponentCut();
    }
    cancelComponentCut() {
      this.props.viewer.bimViewer.clearAllHighlightEntity(),
        (document.getElementById('ccbim__componentCutBox').style.display =
          'none');
    }
    render() {
      return Xh` <div
      class="ccbim__componentCutBox"
      id="ccbim__componentCutBox"
    >
      <p>确定剖切选中的构件吗</p>
      <div class="ccbim__button__box">
        <span onClick=${() => this.performComponentCut()}>确定</span>
        <span onClick=${() => this.cancelComponentCut()}>取消</span>
      </div>
    </div>`;
    }
  }
  class $g extends Sh {
    constructor(t) {
      super(t);
    }
    componentWillMount() {
      setTimeout(() => {
        (_g = new Xg(document.getElementById('ccbim__componentInfo__box'))),
          (xg = _g.bind(
            document.getElementById('ccbim__componentInfo__title'),
          )),
          (wg = new Zg(document.getElementById('ccbim__componentInfo__box'))),
          (Ag = wg.bind(
            document.getElementById('ccbim__componentInfo__dragChangeSize'),
          ));
      });
    }
    componentWillUnmount() {
      _g &&
        (_g.unBind(document.getElementById('ccbim__componentInfo__title'), xg),
        (_g = null)),
        wg &&
          (wg.unBind(
            document.getElementById('ccbim__componentInfo__dragChangeSize'),
            Ag,
          ),
          (wg = null));
    }
    render() {
      return Xh`<${Mh}>
        <div class="ccbim__componentInfo__box ccbim__common__dialog" id="ccbim__componentInfo__box">
          <div class="ccbim__common__title" id="ccbim__componentInfo__title">
            <span>构件信息</span>
            <svg
              title="关闭"
              class="icon"
              aria-hidden="true"
              onClick=${() => this.props.close()}
            >
              <use xlinkHref="#iconguanbi1"></use>
            </svg>
          </div>
          <div class="ccbim__componentInfo__body">
            ${this.props.componentInfoData.map(
              (t) => Xh`<div class="ccbim__componentInfo__com">
                  <p>
                    <b>${t.strName}：</b>
                    <span>${t.strValue}</span>
                  </p>
                </div>`,
            )}
          </div>
          <svg
            title="拖拽大小"
            class="icon ccbim__componentInfo__dragChangeSize"
            id="ccbim__componentInfo__dragChangeSize"
            aria-hidden="true"
          >
            <use xlinkHref="#icontuozhuaisuofang"></use>
          </svg>
        </div>
      </${Mh}>`;
    }
  }
  class Kg extends Sh {
    constructor(t) {
      super(t);
    }
    toggle(t) {
      this.props.toggle(t);
    }
    checkSwitch(t) {
      this.props.checkSwitch(t);
    }
    textClick(t) {
      this.props.textClick(t);
    }
    render() {
      return Xh` ${this.props.treeData.map(
        (t) => Xh`
        <li
          class="ccbim__treeNodeLi ${t.lookThisModel ? 'lookThisModel' : ''}"
          key=${t.uuid}
        >
          <div class="ccbim__toggleBox">
            ${
              t.childArray &&
              t.childArray.length > 0 &&
              t.childArray[0].type !== rm &&
              'dwg' !== this.props.type &&
              Xh`
              <svg
                class="icon expanded"
                aria-hidden="true"
                onClick=${this.toggle.bind(this, t)}
              >
                <use
                  xlinkHref="${t.opened ? '#iconshouqi1' : '#iconzhankai-r'}"
                ></use>
              </svg>
            `
            }
          </div>
          <div class="ccbim_treeAnchor">
            <svg
              class="icon checkIcon"
              aria-hidden="true"
              onClick=${this.checkSwitch.bind(this, t)}
            >
              ${
                'dwg' !== this.props.type
                  ? Xh`<use
                    xlinkHref="${
                      t.checkedHalf
                        ? '#iconbangouxuan'
                        : t.checked
                        ? '#icongouxuan'
                        : '#iconweigouxuan'
                    }"
                  ></use>`
                  : Xh`<use
                    xlinkHref="${
                      t.checkedHalf || t.checked
                        ? '#iconbulb-fill'
                        : '#iconbulb'
                    }"
                  ></use>`
              }
            </svg>
            ${
              t.color &&
              Xh`<span
              class="colorBox"
              style=${{ backgroundColor: t.color }}
            ></span>`
            }
            <span
              class="text ${t.searchColor ? 'searchColor' : ''}${
          t.disableThis ? 'disableThis' : ''
        }"
              onClick=${this.textClick.bind(this, t)}
              >${t.name}</span
            >
          </div>
          ${
            t.opened &&
            t.childArray[0].type !== rm &&
            Xh`<ul>
            <${Kg}
              treeData=${t.childArray}
              toggle=${this.toggle.bind(this)}
              checkSwitch=${this.checkSwitch.bind(this)}
              textClick=${this.textClick.bind(this)}
              type=${this.props.type}
            />
          </ul>`
          }
        </li>
      `,
      )}`;
    }
  }
  let ty,
    ey,
    ny,
    iy,
    ry,
    oy = new bb();
  oy.setMeshColor(0, 0, 0),
    oy.setMeshOpacity(0.1),
    oy.setMeshDoubleSide(!0),
    oy.setMeshVertexOffset(-1.1),
    oy.setLineColor(0, 0, 0);
  class sy extends Sh {
    constructor(t) {
      super(t),
        (this.state = {
          floorTree: this.props.treeData,
          inputSearchValue: '',
          showStagesAll: !1,
          stageSelectOn: null,
        }),
        (sy.checkSwitchApi = this.checkSwitchApi.bind(this));
    }
    toggle(t) {
      (t.opened = !t.opened),
        this.setState({ floorTree: this.state.floorTree });
    }
    textClick(t) {
      const e = new Set();
      e.add(t.uuid),
        this.state.floorTree[0].setEntityStyle(null, !0, !0),
        this.state.floorTree[0].setEntityStyle(oy, !0, !1, e),
        this.props.viewer.bimViewer.requestFrameUpdate(),
        this.recursionNodeChild(this.state.floorTree[0], void 0, (t) => {
          t.lookThisModel = !1;
        }),
        (this.state.floorTree[0].lookThisModel = !1),
        (t.lookThisModel = !0),
        this.setState({ floorTree: this.state.floorTree }),
        (document.getElementById(
          this.props.viewer.parentElementId + '__ccbim__showAllModelTree',
        ).style.display = 'block');
    }
    checkSwitchApi(t, e) {
      (t.checked = e),
        (t.checkedHalf = !1),
        this.recursionNodeChild(t, e, (t, e) => {
          (t.checked = e), (t.checkedHalf = !1);
        }),
        this.recursionNodeBrother(t),
        t.setNodeVisible(e, !0),
        this.setState({ floorTree: this.state.floorTree }),
        this.props.viewer.bimViewer.requestFrameUpdate();
    }
    checkSwitch(t) {
      const e = !t.checked;
      (t.checked = e),
        (t.checkedHalf = !1),
        'dwg' === this.props.viewer.type && (t.disableThis = !e),
        this.recursionNodeChild(t, e, (t, e) => {
          (t.checked = e),
            (t.checkedHalf = !1),
            'dwg' === this.props.viewer.type && (t.disableThis = !e);
        }),
        this.recursionNodeBrother(t),
        t.setNodeVisible(e, !0),
        this.setState({ floorTree: this.state.floorTree }),
        this.props.viewer.bimViewer.requestFrameUpdate();
    }
    recursionNodeChild(t, e, n) {
      if (
        t.childArray &&
        t.childArray.length > 0 &&
        t.childArray[0].type !== rm
      )
        for (let i = 0; i < t.childArray.length; i++) {
          const r = t.childArray[i];
          n && n(r, e), this.recursionNodeChild(r, e, n);
        }
    }
    recursionNodeParent(t, e) {
      t.parent && (e && e(t.parent), this.recursionNodeParent(t.parent, e));
    }
    recursionNodeBrother(t) {
      if (t.parent) {
        (t.parent.checked = !1), (t.parent.checkedHalf = !0);
        let e = 0;
        for (let n = 0; n < t.parent.childArray.length; n++) {
          t.parent.childArray[n].checked && e++;
        }
        0 === e
          ? ((t.parent.checked = !1),
            (t.parent.checkedHalf = !1),
            t.checkedHalf && (t.parent.checkedHalf = !0))
          : e === t.parent.childArray.length
          ? ((t.parent.checked = !0), (t.parent.checkedHalf = !1))
          : ((t.parent.checked = !1), (t.parent.checkedHalf = !0)),
          this.recursionNodeBrother(t.parent);
      }
    }
    onInputValue(t) {
      const { value: e } = t.target;
      this.setState({ inputSearchValue: e });
    }
    onInputEnter(t) {
      13 === t.keyCode && this.inputSearch(this.state.inputSearchValue);
    }
    inputSearch(t) {
      const e = new RegExp(t);
      this.recursionNodeChild(this.state.floorTree[0], void 0, (n) => {
        (n.opened = !1),
          (n.searchColor = !1),
          '' !== t &&
            e.test(n.name) &&
            ((n.searchColor = !0),
            this.recursionNodeParent(n, (t) => {
              t.opened = !0;
            }));
      }),
        this.setState({ floorTree: this.state.floorTree });
    }
    controlStages(t) {
      this.props.viewer.bimViewer
        .getModelScene()
        .getModelArray()[0]
        .modelTree.setCurrentLayer(t);
      for (let e = 0; e < this.props.stagesAll.length; e++) {
        let n = this.props.stagesAll[e];
        n.id === t && this.setState({ stageSelectOn: n });
      }
      this.setState({ showStagesAll: !1 }),
        this.props.viewer.bimViewer.requestFrameUpdate();
    }
    componentWillReceiveProps(t) {
      if (
        (t.treeData !== this.state.floorTree &&
          this.setState({ floorTree: t.treeData }),
        t.visible)
      ) {
        let t = this.props.viewer.bimViewer
          .getModelScene()
          .getModelArray()[0]
          .modelTree.getCurrentLayer();
        this.setState({ stageSelectOn: t }),
          setTimeout(() => {
            (ty = new Xg(document.getElementById('ccbim__modelTree'))),
              (ey = ty.bind(
                document.getElementById('ccbim__modelTree__header'),
              )),
              (ny = new Zg(document.getElementById('ccbim__modelTree'))),
              (iy = ny.bind(
                document.getElementById('ccbim__modelTree__dragChangeSize'),
              ));
          });
      } else ty && (ty.unBind(document.getElementById('ccbim__modelTree__header'), ey), (ty = null)), ny && (ny.unBind(document.getElementById('ccbim__modelTree__dragChangeSize'), iy), (ny = null)), this.setState({ showStagesAll: !1 });
    }
    render() {
      return Xh`<${Mh}>
    ${
      this.props.visible &&
      Xh`<div
        class="ccbim__modelTree ccbim__common__dialog
        ${'dwg' === this.props.viewer.type && 'ccbim__modelTree__dwg'}
        ${this.props.viewer.isPhone && 'ccbim__modelTree__phone'}"
        id="ccbim__modelTree"
      >
        <div class="ccbim__common__title" id="ccbim__modelTree__header">
          <span>${'dwg' === this.props.viewer.type ? '图层' : '楼层'}</span>
          <!--阶段选择-->
          <div class="selectStagesAllBox">
            ${
              this.props.stagesAll.length > 1 &&
              Xh` <div class="ccbim__stageSelect">
              <div
                class="ccbim__stageSelect__selectOn"
                onClick=${() =>
                  this.setState({ showStagesAll: !this.state.showStagesAll })}
              >
                <span
                  >${
                    this.state.stageSelectOn
                      ? this.state.stageSelectOn.name
                      : this.props.stagesAll[0].name
                  }</span
                >
                <svg class="selectIcon">
                  <use xlinkHref="#iconxiala"></use>
                </svg>
              </div>
              ${
                this.state.showStagesAll &&
                Xh`<ul class="ccbim__selectList">
                ${this.props.stagesAll.map(
                  (t) => Xh` <li
                    onClick=${() => this.controlStages(t.id)}
                  >
                    ${t.name}
                  </li>`,
                )}
              </ul>`
              }
            </div>`
            }
            <div class="iconBox">
              <svg
                title="关闭"
                class="icon"
                aria-hidden="true"
                onClick=${() => {
                  this.props.close();
                }}
              >
                <use xlinkHref="#iconguanbi1"></use>
              </svg>
            </div>
          </div>
        </div>
        <div class="ccbim__modelTree__searchBox">
          <svg
            title="搜索"
            class="icon ccbim__modelTree__searchBox__searchIcon"
            aria-hidden="true"
          >
            <use xlinkHref="#iconsousuo"></use>
          </svg>
          <input
            type="text"
            placeholder="请输入要搜索的关键字"
            class="ccbim__modelTree__searchBox__txtSearch"
            value=${this.state.inputSearchValue}
            onInput=${this.onInputValue.bind(this)}
            onKeyDown=${this.onInputEnter.bind(this)}
          />
          <svg
            title="确定"
            class="icon ccbim__modelTree__searchBox__searchIcon"
            aria-hidden="true"
            onClick=${this.inputSearch.bind(this, this.state.inputSearchValue)}
          >
            <use xlinkHref="#iconhuiche"></use>
          </svg>
        </div>
        <div class="ccbim_floorTree">
          <ul
            class="ccbim__treeAll ${
              'dwg' === this.props.viewer.type ? 'ccbim__treeAll__dwg' : ''
            }"
          >
            <${Kg}
              treeData=${this.state.floorTree}
              toggle=${this.toggle.bind(this)}
              checkSwitch=${this.checkSwitch.bind(this)}
              textClick=${this.textClick.bind(this)}
              type=${this.props.viewer.type}
            />
          </ul>
        </div>
        <svg
          title="拖拽大小"
          class="icon ccbim__modelTree__dragChangeSize"
          id="ccbim__modelTree__dragChangeSize"
          aria-hidden="true"
        >
          <use xlinkHref="#icontuozhuaisuofang"></use>
        </svg>
      </div>`
    }
    </${Mh}>`;
    }
  }
  function ay(t) {
    (this.bimViewer = t),
      (this.floorAxisArray = []),
      (this.selected = 0),
      (this.axisTextLength = 0),
      (this.crossData = []),
      (this.mapRoomInfoData = []),
      (this.rectangleData = {}),
      (this.ctx = null),
      (this.miniMapScale = 0);
  }
  ay.prototype = {
    constructor: ay,
    initMap(t, e, n, i) {
      (this.mapCanvasWidth = e),
        (this.mapCanvasHeight = n),
        (this.scaleBig = i),
        (this.floorAxisArray = this.bimViewer
          .getModelScene()
          .getModelArray()[0]
          .getFloorAxisArray()),
        (this.ctx = t.getContext('2d')),
        this.getMapData(e, n),
        this.drawUpload(e, n, i);
    },
    getRectangleData() {
      return this.rectangleData;
    },
    getMiniMapScale() {
      return this.miniMapScale;
    },
    getSelectFloorPlanGraph() {
      let t = [];
      for (let e = 0; e < this.floorAxisArray.length; e++) {
        let n = {};
        (n.floorElevation = this.floorAxisArray[e].floorElevation),
          (n.floorHeight = this.floorAxisArray[e].floorHeight),
          (n.floorId = this.floorAxisArray[e].floorId),
          (n.floorName = this.floorAxisArray[e].floorName),
          t.push(n);
      }
      return t;
    },
    setSelectedFloor(t) {
      this.selected = t;
    },
    getMapData(t, e) {
      if (
        ((this.crossData = []),
        (this.mapRoomInfoData = []),
        this.floorAxisArray.length <= 0)
      )
        return;
      if (
        this.floorAxisArray[this.selected].axisNetLineArray.length <= 0 &&
        this.floorAxisArray[this.selected].crossLines.length <= 0
      )
        return;
      for (
        let t = 0;
        t < this.floorAxisArray[this.selected].axisNetLineArray.length;
        t++
      ) {
        let e = this.floorAxisArray[this.selected].axisNetLineArray[t];
        e.name.length > this.axisTextLength &&
          (this.axisTextLength = e.name.length),
          (this.crossData[t] = {
            name: e.name,
            start: [e.start[0], -1 * e.start[1]],
            end: [e.end[0], -1 * e.end[1]],
            selectOn: !1,
          });
      }
      for (
        let t = 0;
        t < this.floorAxisArray[this.selected].crossLines.length;
        t++
      ) {
        let e = this.floorAxisArray[this.selected].crossLines[t];
        this.mapRoomInfoData[t] = {
          start: [e.start[0], -1 * e.start[1]],
          end: [e.end[0], -1 * e.end[1]],
        };
      }
      let n = this.rectangulareEnvelope(this.crossData, this.mapRoomInfoData);
      (this.rectangleData.height = n.maxY - n.minY + 26),
        (this.rectangleData.width = n.maxX - n.minX + 26),
        (this.rectangleData.centerPoint = [
          (n.maxX + n.minX) / 2,
          (n.maxY + n.minY) / 2,
        ]),
        (this.miniMapScale = Math.min(
          t / this.rectangleData.width,
          e / this.rectangleData.height,
        )),
        this.translateOrigin(t, e);
    },
    rectangulareEnvelope(t, e) {
      if (t.length <= 0 && e.length <= 0) return;
      let n = 1 / 0,
        i = -1 / 0,
        r = 1 / 0,
        o = -1 / 0;
      for (let e = 0; e < t.length; e++)
        t[e].start[0] < n
          ? (n = t[e].start[0])
          : t[e].start[0] > i && (i = t[e].start[0]),
          t[e].end[0] < n
            ? (n = t[e].end[0])
            : t[e].end[0] > i && (i = t[e].end[0]),
          t[e].start[1] < r
            ? (r = t[e].start[1])
            : t[e].start[1] > o && (o = t[e].start[1]),
          t[e].end[1] < r
            ? (r = t[e].end[1])
            : t[e].end[1] > o && (o = t[e].end[1]);
      for (let t = 0; t < e.length; t++)
        e[t].start[0] < n
          ? (n = e[t].start[0])
          : e[t].start[0] > i && (i = e[t].start[0]),
          e[t].end[0] < n
            ? (n = e[t].end[0])
            : e[t].end[0] > i && (i = e[t].end[0]),
          e[t].start[1] < r
            ? (r = e[t].start[1])
            : e[t].start[1] > o && (o = e[t].start[1]),
          e[t].end[1] < r
            ? (r = e[t].end[1])
            : e[t].end[1] > o && (o = e[t].end[1]);
      return { minX: n, maxX: i, minY: r, maxY: o };
    },
    translateOrigin(t, e) {
      if (!(this.crossData.length <= 0 && this.mapRoomInfoData.length <= 0)) {
        for (let n = 0; n < this.crossData.length; n++)
          (this.crossData[n].start[0] = parseInt(
            (this.crossData[n].start[0] - this.rectangleData.centerPoint[0]) *
              this.miniMapScale +
              t / 2,
          )),
            (this.crossData[n].start[1] = parseInt(
              (this.crossData[n].start[1] - this.rectangleData.centerPoint[1]) *
                this.miniMapScale +
                e / 2,
            )),
            (this.crossData[n].end[0] = parseInt(
              (this.crossData[n].end[0] - this.rectangleData.centerPoint[0]) *
                this.miniMapScale +
                t / 2,
            )),
            (this.crossData[n].end[1] = parseInt(
              (this.crossData[n].end[1] - this.rectangleData.centerPoint[1]) *
                this.miniMapScale +
                e / 2,
            ));
        for (let n = 0; n < this.mapRoomInfoData.length; n++)
          (this.mapRoomInfoData[n].start[0] =
            (this.mapRoomInfoData[n].start[0] -
              this.rectangleData.centerPoint[0]) *
              this.miniMapScale +
            t / 2),
            (this.mapRoomInfoData[n].start[1] =
              (this.mapRoomInfoData[n].start[1] -
                this.rectangleData.centerPoint[1]) *
                this.miniMapScale +
              e / 2),
            (this.mapRoomInfoData[n].end[0] =
              (this.mapRoomInfoData[n].end[0] -
                this.rectangleData.centerPoint[0]) *
                this.miniMapScale +
              t / 2),
            (this.mapRoomInfoData[n].end[1] =
              (this.mapRoomInfoData[n].end[1] -
                this.rectangleData.centerPoint[1]) *
                this.miniMapScale +
              e / 2);
      }
    },
    drawUpload(t, e, n) {
      this.ctx.clearRect(0, 0, t, e), this.drawCross(n), this.drawFloor();
    },
    drawCross(t) {
      if (this.crossData.length <= 0) return;
      let e = 0;
      1 === this.axisTextLength
        ? (e = 16)
        : 2 === this.axisTextLength
        ? (e = 12)
        : 3 === this.axisTextLength
        ? (e = 10)
        : 4 === this.axisTextLength
        ? (e = 9)
        : this.axisTextLength >= 5 && (e = 8),
        (this.ctx.font = e + 'px Arial');
      for (let e = 0; e < this.crossData.length; e++)
        this.ctx.beginPath(),
          this.ctx.moveTo(
            this.crossData[e].start[0],
            this.crossData[e].start[1],
          ),
          this.ctx.lineTo(this.crossData[e].end[0], this.crossData[e].end[1]),
          this.ctx.closePath(),
          this.crossData[e].selectOn
            ? (this.ctx.strokeStyle = '#ff0000')
            : (this.ctx.strokeStyle = '#333333'),
          this.ctx.stroke(),
          e % 3 == 0 &&
            t &&
            this.crossText(
              this.crossData[e].name,
              this.crossData[e].start[0],
              this.crossData[e].start[1],
              this.crossData[e].end[0],
              this.crossData[e].end[1],
              12,
            );
    },
    drawFloor() {
      if (!(this.mapRoomInfoData.length <= 0))
        for (let t = 0; t < this.mapRoomInfoData.length; t++)
          this.ctx.beginPath(),
            this.ctx.moveTo(
              this.mapRoomInfoData[t].start[0],
              this.mapRoomInfoData[t].start[1],
            ),
            this.ctx.lineTo(
              this.mapRoomInfoData[t].end[0],
              this.mapRoomInfoData[t].end[1],
            ),
            (this.ctx.strokeStyle = '#00ffff'),
            this.ctx.closePath(),
            this.ctx.stroke();
    },
    crossText(t, e, n, i, r, o) {
      let s = new U(e, n),
        a = new U(i, r),
        c = new U();
      c.subVectors(s, a);
      let l = c.normalize();
      (e += o * l.x),
        (i -= o * l.x),
        (n += o * l.y),
        (r -= o * l.y),
        (this.ctx.fillStyle = '#333'),
        this.ctx.fillText(t, e, n),
        (this.ctx.textAlign = 'center'),
        (this.ctx.textBaseline = 'middle'),
        this.ctx.beginPath(),
        (this.ctx.strokeStyle = '#333'),
        this.ctx.arc(e, n, o, 0, 2 * Math.PI),
        this.ctx.closePath(),
        this.ctx.stroke(),
        (this.ctx.fillStyle = '#333'),
        this.ctx.fillText(t, i, r),
        (this.ctx.textAlign = 'center'),
        (this.ctx.textBaseline = 'middle'),
        this.ctx.beginPath(),
        (this.ctx.strokeStyle = '#333'),
        this.ctx.arc(i, r, o, 0, 2 * Math.PI),
        this.ctx.closePath(),
        this.ctx.stroke();
    },
    getCrossPoint(t, e) {
      for (let n = 0; n < this.crossData.length; n++)
        (this.crossData[n].selectOn = !1),
          t - this.crossData[n].start[0] > 0 &&
            t - this.crossData[n].end[0] < 0 &&
            e === this.crossData[n].start[1] &&
            e === this.crossData[n].end[1] &&
            (this.crossData[n].selectOn = !0),
          t === this.crossData[n].start[0] &&
            t === this.crossData[n].end[0] &&
            e - this.crossData[n].start[1] < 0 &&
            e - this.crossData[n].end[1] > 0 &&
            (this.crossData[n].selectOn = !0);
      this.drawUpload(this.mapCanvasWidth, this.mapCanvasHeight, this.scaleBig);
    },
    canvasDoubleClick(t, e) {
      let n = e.getBoundingClientRect(),
        i = t.clientX - n.left * (e.width / n.width),
        r = t.clientY - n.top * (e.height / n.height),
        o =
          (i - this.mapCanvasWidth / 2) / this.miniMapScale +
          this.rectangleData.centerPoint[0],
        s =
          -1 *
          ((r - this.mapCanvasHeight / 2) / this.miniMapScale +
            this.rectangleData.centerPoint[1]),
        a =
          this.floorAxisArray[this.selected].floorElevation +
          this.floorAxisArray[this.selected].floorHeight / 2;
      this.bimViewer
        .getMainCamera()
        .makeLookAt(new J(o, s, a), new J(0, 0, a), new J(0, 0, 1)),
        this.bimViewer.cameraChanged();
    },
    zoomMap(t, e) {
      (this.mapCanvasWidth = t),
        (this.mapCanvasHeight = e),
        (this.scaleBig = !0),
        this.getMapData(t, e),
        setTimeout(() => {
          this.drawUpload(t, e, !0);
        }, 0);
    },
    shrinkMap(t, e) {
      (this.mapCanvasWidth = t),
        (this.mapCanvasHeight = e),
        (this.scaleBig = !1),
        this.getMapData(t, e),
        setTimeout(() => {
          this.drawUpload(t, e, !1);
        }, 0);
    },
  };
  let cy,
    ly,
    hy = 320,
    uy = 265;
  function dy() {
    const t = document.getElementById('ccbim__map__circle');
    if (!t) return;
    let e = this.getMainCamera(),
      n = e.target,
      i = e.position,
      r = new J(0, 1, 0);
    n && (r = n.clone()), r.sub(i), (r.z = 0);
    let o = new J(0, 1, 0),
      s = (180 * r.angleTo(o)) / Math.PI;
    if (
      (r.x < 0 && (s = 360 - s),
      0 === Object.keys(ry.getRectangleData()).length)
    )
      return void (t.style.display = 'none');
    t.style.display = 'block';
    !(function (t, e, n) {
      document.getElementById('ccbim__map__circle').style.transform =
        'translate(' + t + 'px,' + e + 'px) rotate(' + n + 'deg)';
    })(
      (i.x - ry.getRectangleData().centerPoint[0]) * ry.getMiniMapScale() +
        hy / 2,
      (-1 * i.y - ry.getRectangleData().centerPoint[1]) * ry.getMiniMapScale() +
        uy / 2,
      s,
    );
  }
  class py extends Sh {
    constructor(t) {
      super(t),
        (this.state = {
          selectFloorPlanGraph: [],
          mapCanvasWidth: 320,
          mapCanvasHeight: 265,
          scaleBig: !1,
        });
    }
    componentDidMount() {
      (ry = new ay(this.props.viewer.bimViewer)),
        ry.initMap(
          document.getElementById('ccbim__map__canvas'),
          this.state.mapCanvasWidth,
          this.state.mapCanvasHeight,
          this.state.scaleBig,
        );
      let t = ry.getSelectFloorPlanGraph();
      this.setState({ selectFloorPlanGraph: t }),
        this.props.viewer.bimViewer.bindCameraChangedEvent(dy),
        (cy = new Xg(document.getElementById('ccbim__map'))),
        (ly = cy.bind(document.getElementById('ccbim__map__topTip')));
    }
    componentWillUnmount() {
      this.props.viewer.bimViewer.unbindCameraChangedEvent(dy),
        cy &&
          (cy.unBind(document.getElementById('ccbim__map__topTip'), ly),
          (cy = null));
    }
    canvasMove(t) {
      ry.getCrossPoint(t.offsetX, t.offsetY);
    }
    zoomMap() {
      this.setState({
        scaleBig: !0,
        mapCanvasWidth: 600,
        mapCanvasHeight: 450,
      }),
        (hy = 600),
        (uy = 450),
        ry.zoomMap(600, 450);
      let t = document.getElementById('ccbim__map');
      (t.style.left = 'calc(50% - 300px)'), (t.style.top = '10%');
    }
    shrinkMap() {
      this.setState({
        scaleBig: !1,
        mapCanvasWidth: 320,
        mapCanvasHeight: 265,
      }),
        (hy = 320),
        (uy = 265),
        ry.shrinkMap(320, 265);
      let t = document.getElementById('ccbim__map');
      (t.style.left = 'auto'), (t.style.top = 'auto');
    }
    selectFloor(t) {
      const e = parseInt(t.target.value);
      ry.setSelectedFloor(e),
        ry.getMapData(this.state.mapCanvasWidth, this.state.mapCanvasHeight),
        ry.drawUpload(
          this.state.mapCanvasWidth,
          this.state.mapCanvasHeight,
          this.state.scaleBig,
        );
      let n =
          this.state.selectFloorPlanGraph[e].floorElevation +
          this.state.selectFloorPlanGraph[e].floorHeight / 2,
        i = this.props.viewer.bimViewer.getModelScene().getBoundingBox(),
        r = this.props.viewer.bimViewer.getMainCamera();
      r.makeLookAt(
        new J(r.position.x, r.position.y, n),
        new J(
          i.min.x + (i.max.x - i.min.x) / 2,
          i.min.y + (i.max.y - i.min.y) / 2,
          n,
        ),
        new J(0, 0, 1),
      ),
        this.props.viewer.bimViewer.cameraChanged();
    }
    canvasDoubleClick(t) {
      ry.canvasDoubleClick(t, document.getElementById('ccbim__map__canvas'));
    }
    closeMap() {
      this.props.closeMap();
    }
    render() {
      return Xh` <div
      class=${
        'ccbim__map ccbim__common__dialog ' +
        (this.state.scaleBig ? 'center' : '')
      }
      id="ccbim__map"
    >
      <div class="ccbim__common__title">
        <select
          class="ccbim__map__floorSelect"
          onChange=${(t) => this.selectFloor(t)}
        >
          ${this.state.selectFloorPlanGraph.map(
            (t, e) => Xh`<option value=${e} key=${e}>
                ${t.floorName}
              </option>`,
          )}
        </select>
        <span id="ccbim__map__topTip" class="opacitySpan">&nbsp;</span>
        <div class="ccbim__map__button">
          ${
            this.state.scaleBig
              ? Xh`<svg
                class="icon small"
                title="缩小"
                onClick=${() => this.shrinkMap()}
              >
                <use xlinkHref="#iconzuixiaohua"></use>
              </svg>`
              : Xh`<svg
                class="icon small"
                title="放大"
                onClick=${() => this.zoomMap()}
              >
                <use xlinkHref="#iconzuixiaohua"></use>
              </svg>`
          }
          <svg class="icon" title="关闭" onClick=${() => this.closeMap()}>
            <use xlinkHref="#iconguanbi1"></use>
          </svg>
        </div>
      </div>
      <div style="position: relative; overflow: hidden;">
        <canvas
          id="ccbim__map__canvas"
          width=${this.state.mapCanvasWidth}
          height=${this.state.mapCanvasHeight}
          onMouseMove=${(t) => this.canvasMove(t)}
          onDblClick=${(t) => this.canvasDoubleClick(t)}
        ></canvas>
        <div class="ccbim__map__circle" id="ccbim__map__circle"></div>
      </div>
    </div>`;
    }
  }
  function fy(t, e, n) {
    (this.scene = t),
      (this.gripArr = []),
      (this.precision = e),
      (this.precisionText = n);
  }
  fy.prototype = {
    constructor: fy,
    checkIntersectionDistanceWithShape: function (t, e) {
      return -1;
    },
    setMaterial: function (t) {},
    checkIntersectionWithGrip: (function () {
      function t(t, e) {
        return t.distance < e.distance;
      }
      function e(t, e, n) {
        return (
          !(!e && !n) &&
          (n
            ? n.containsPoint(t.getPosition())
            : t.intersectWithRaycaster(e) >= 0)
        );
      }
      return function (n, i) {
        let r = [],
          o = [];
        for (let t = 0, r = this.gripArr.length; t < r; ++t)
          e(this.gripArr[t], n, i) && o.push(this.gripArr[t]);
        if (0 === o.length) return null;
        if (1 === o.length) return o[0];
        let s = n.ray.origin;
        for (let t = 0, e = o.length; t < e; ++t) {
          let e = o[t];
          r.push({ distance: e.getPosition().distanceTo(s), grip: e });
        }
        return r.sort(t), r[0].grip;
      };
    })(),
    setShowGrip: function (t) {
      let e = !!t;
      for (let t = 0, n = this.gripArr.length; t < n; ++t)
        this.gripArr[t].setVisible(e);
    },
    dispose: function () {
      for (let t = 0, e = this.gripArr.length; t < e; ++t)
        this.gripArr[t].uninstall();
      this.gripArr = [];
    },
    createGripHandle: function (t, e, n, i) {
      let r = new Gg();
      return (
        r.setAutoScale(!0),
        r.setAlignToScreen(!0),
        r.setPosition(n),
        r.setUserData(i),
        r.setVisible(!1),
        r.addShapeObject(new ln(new qs(6), t), t, e),
        r.install(this.scene),
        r
      );
    },
  };
  let my = 0,
    by = 1,
    gy = 2,
    yy = 3;
  function vy() {
    Tg.call(this),
      (this.downPos = new U()),
      (this.tempMeasure = null),
      (this.currentMeasure = null),
      (this.measureResultArray = []),
      (this.hoverMeasure = null),
      (this.hoverGrip = null),
      (this.editGrip = null),
      (this.osnapMaterial = new bo({ color: 10040319 })),
      (this.osnapMaterial.depthRange = new vb(!0, 0, 0.08)),
      (this.osnapShapeGroup = new Ug()),
      this.osnapShapeGroup.setAutoScale(!0),
      this.osnapShapeGroup.setAlignToScreen(!0),
      (this.currentOsnapShape = null),
      (this.osnapShapeArray = [null, null, null, null]),
      (this.highlightMaterial = new bo({ color: 16776960 })),
      (this.precision = 1),
      (this.precisionText = 'm');
  }
  function _y(t, e, n, i, r, o, s) {
    fy.call(this, t, r, o),
      (this.mvpInverseMatrix4 = s),
      (this.ptsArr = []),
      (this.material = e),
      (this.highlightMaterial = n),
      (this.font = i),
      (this.line = null),
      (this.autoTransform = new Ug()),
      this.autoTransform.setAutoScale(!0),
      this.scene.add(this.autoTransform);
  }
  function xy() {
    vy.call(this), (this.material = new bo({ color: 10040319 }));
  }
  function wy(t, e, n, i, r, o, s, a, c) {
    fy.call(this, t, s, a),
      (this.mvpInverseMatrix4 = c),
      (this.showClearHeight = !1),
      (this.font = e),
      (this.materials = n),
      (this.lineShape = [null, null, null, null]),
      (this.textShape = [null, null, null, null]),
      (this.ptsArr = [r.clone(), o.clone()]),
      this.updateShape(this.ptsArr[0], this.ptsArr[1]),
      this.gripArr.push(this.createGripHandle(i[0], i[1], this.ptsArr[0], 0)),
      this.gripArr.push(this.createGripHandle(i[0], i[1], this.ptsArr[1], 1));
  }
  function Ay() {
    function t(t, e) {
      for (let n = 0, i = t.length; n < i; ++n) t[n].depthRange = e;
    }
    vy.call(this),
      (this.name = 'MeasureDistance'),
      (this.materials = [
        new bo({ color: 10040319 }),
        new bo({ color: 16711680 }),
        new bo({ color: 65280 }),
        new bo({ color: 255 }),
      ]);
    let e = new vb(!0, 0, 0.1);
    t(this.materials, e),
      (this.highlightMaterial = new bo({ color: 16776960 })),
      (this.highlightMaterial.depthRange = new vb(!0, 0, 0.08)),
      (this.gripMaterial = [this.materials[0], this.highlightMaterial]),
      t(this.gripMaterial, e),
      (this.editMode = 0),
      (this.precision = 1),
      (this.precisionText = 'm');
  }
  function My() {
    Ay.call(this),
      (this.name = 'MeasureDistance2D'),
      (this.precision = 1e3),
      (this.precisionText = 'mm'),
      (this.dwgLayoutViewPortData = null);
  }
  function Sy(t, e, n, i, r, o) {
    fy.call(this, t, r, o),
      (this.material = n),
      (this.autoTransform = new Ug()),
      this.autoTransform.setAutoScale(!0),
      this.autoTransform.setAlignToScreen(!0),
      this.scene.add(this.autoTransform),
      (this.font = e),
      (this.textPos = new J(80, 25, 0));
    let s = [
        0,
        0,
        0,
        this.textPos.x,
        this.textPos.y,
        this.textPos.z,
        this.textPos.x + 60,
        this.textPos.y,
        this.textPos.z,
      ],
      a = new He();
    a.setAttribute('position', new Re(new Float32Array(s), 3)),
      (this.line = new wo(a, this.material)),
      this.autoTransform.add(this.line),
      (this.sphere = new ln(new Bs(6), this.material)),
      this.autoTransform.add(this.sphere),
      (this.text = null),
      this.setPosition(i);
  }
  function Iy() {
    vy.call(this),
      (this.material = new bo({ color: 10040319 })),
      this.material.setDepthRange(new vb(!0, 0, 0.01)),
      (this.currentPoint = void 0);
  }
  function Ey() {
    Tg.call(this),
      (this.name = 'MeasureOperator'),
      (this.measureHeight = new Iy()),
      (this.measureDistance = new Ay()),
      (this.measureDistance2D = new My()),
      (this.measureArea2D = new xy()),
      (this.currentMeasure = null);
  }
  (vy.prototype = Object.assign(Object.create(Tg.prototype), {
    constructor: vy,
    isMeasureOperator: !0,
    willBegin: function (t) {
      Tg.prototype.willBegin.call(this, t),
        t.getIncrementalScene().add(this.osnapShapeGroup);
    },
    willEnd: function (t) {
      this.tempMeasure &&
        (this.tempMeasure.dispose(), (this.tempMeasure = null));
      for (let t = 0, e = this.measureResultArray.length; t < e; ++t)
        this.measureResultArray[t].dispose();
      (this.measureResultArray = []),
        this.osnapShapeGroup.removeAll(),
        t.getIncrementalScene().remove(this.osnapShapeGroup),
        Tg.prototype.willEnd.call(this, t);
    },
    onLButtonDown: function (t) {
      this.downPos.set(t.offsetX, t.offsetY);
    },
    onLButtonUp: (function () {
      let t = new gl(),
        e = new Ln();
      return function (n) {
        if (
          Math.abs(n.offsetX - this.downPos.x) > 1 ||
          Math.abs(n.offsetY - this.downPos.y) > 1
        )
          return;
        let i = this.getViewer(),
          r = n.offsetX,
          o = i.getSize().y - n.offsetY;
        i.getAsymmetricFrustum(r - 8, o - 8, r + 16, o + 16, e),
          this.getMouseRaycaster(n, t);
        let s = this.getPoint(n, e);
        if (s) {
          if (this.dwgLayoutViewPortData) {
            const t = this.getViewPortData(s);
            if (this.dwgLayoutViewPortData.camera.uuid !== t.camera.uuid)
              return;
          } else this.dwgLayoutViewPortData = this.getViewPortData(s);
          if (this.tempMeasure) this.stepMeasure();
          else {
            if (this.currentMeasure && this.hoverGrip)
              return (
                (this.tempMeasure = this.currentMeasure),
                (this.editGrip = this.hoverGrip),
                void this.setCurrentMeasure(null)
              );
            if (this.hoverMeasure) this.setCurrentMeasure(this.hoverMeasure);
            else {
              this.setCurrentMeasure(null);
              let t = null;
              if (this.dwgLayoutViewPortData.scene.isDwgLayoutScene) {
                t = this.dwgLayoutViewPortData.scene.mvpInverse;
              }
              this.tempMeasure = this.createNewMeasure(s, t);
            }
          }
        }
      };
    })(),
    onNoButtonDownAndMove: (function () {
      let t = new gl(),
        e = new Ln();
      return function (n) {
        this.getViewer().renderContext.setRequestUpdate(!0),
          this.hoverMeasure &&
            (this.hoverMeasure.setMaterial(void 0), (this.hoverMeasure = null)),
          this.hoverGrip &&
            (this.hoverGrip.highlight(!1), (this.hoverGrip = null));
        let i = this.getViewer(),
          r = n.offsetX,
          o = i.getSize().y - n.offsetY;
        i.getAsymmetricFrustum(r - 8, o - 8, r + 16, o + 16, e),
          this.getMouseRaycaster(n, t);
        let s = this.getPoint(n, e);
        if (this.tempMeasure) {
          const t = this.getViewPortData(s);
          if (this.dwgLayoutViewPortData.camera.uuid !== t.camera.uuid) return;
          s && this.updateMeasure(s);
        } else
          (this.hoverGrip = this.currentMeasure
            ? this.currentMeasure.checkIntersectionWithGrip(t, e)
            : null),
            this.hoverGrip
              ? this.hoverGrip.highlight(!0)
              : ((this.hoverMeasure = this.tryGetSelectMeasureResult(t, e)),
                this.hoverMeasure &&
                  this.hoverMeasure !== this.currentMeasure &&
                  this.hoverMeasure.setMaterial(this.highlightMaterial));
      };
    })(),
    setCurrentMeasure: function (t) {
      this.currentMeasure && this.currentMeasure.setShowGrip(!1),
        (this.currentMeasure = t),
        this.currentMeasure && this.currentMeasure.setShowGrip(!0),
        this.hoverGrip &&
          (this.hoverGrip.highlight(!1), (this.hoverGrip = null));
    },
    deleteCurrentMeasure: function () {
      if (!this.currentMeasure) return;
      for (let t = 0, e = this.measureResultArray.length; t < e; ++t)
        this.measureResultArray[t] === this.currentMeasure &&
          this.measureResultArray.splice(t, 1);
      let t = this.currentMeasure;
      this.setCurrentMeasure(null), t.dispose();
    },
    tryGetSelectMeasureResult: function (t, e) {
      let n,
        i = -1,
        r = this.measureResultArray;
      for (let o = 0, s = r.length; o < s; ++o) {
        let s = r[o],
          a = s.checkIntersectionDistanceWithShape(t, e);
        a < 0 || ((!n || a < i) && ((n = s), (i = a)));
      }
      return n;
    },
    setOsnap: function (t, e) {
      if (void 0 !== t && e) {
        if ((this.osnapShapeGroup.setPosition(e), !this.osnapShapeArray[t])) {
          let e;
          switch (t) {
            case my:
              e = [-8, -8, 0, 8, -8, 0, 8, 8, 0, -8, 8, 0, -8, -8, 0];
              break;
            case by:
              let t = Math.tan(Math.PI / 6),
                n = 12;
              e = [-n, -n * t, 0, n, -n * t, 0, 0, n, 0, -n, -n * t, 0];
              break;
            case gy:
              e = [-8, -8, 0, 8, 8, 0, -8, 8, 0, 8, -8, 0, -8, -8, 0];
              break;
            case yy:
              e = [
                -8, -8, 0, 8, -8, 0, 8, 8, 0, -8, 8, 0, -8, -8, 0, 8, 8, 0, -8,
                8, 0, 8, -8, 0,
              ];
          }
          let n = new He();
          n.setAttribute('position', new Re(new Float32Array(e), 3)),
            (this.osnapShapeArray[t] = new wo(n, this.osnapMaterial));
        }
        if (this.currentOsnapShape === this.osnapShapeArray[t]) return;
        this.currentOsnapShape &&
          this.osnapShapeGroup.remove(this.currentOsnapShape),
          (this.currentOsnapShape = this.osnapShapeArray[t]),
          this.osnapShapeGroup.add(this.currentOsnapShape);
      } else
        this.currentOsnapShape &&
          (this.osnapShapeGroup.remove(this.currentOsnapShape),
          (this.currentOsnapShape = null));
    },
    stepMeasure: function () {
      for (let t = 0, e = this.measureResultArray.length; t < e; ++t)
        if (this.measureResultArray[t] === this.tempMeasure) {
          this.measureResultArray.splice(t, 1);
          break;
        }
      this.measureResultArray.push(this.tempMeasure),
        this.setCurrentMeasure(this.tempMeasure),
        (this.tempMeasure = null),
        this.setOsnap(void 0),
        (this.editGrip = null);
    },
    getPoint: function (t, e) {},
    updateMeasure: function (t) {},
    createNewMeasure: function (t) {},
    getViewPortData: function (t) {
      const e = this.getDwgLayoutMap();
      for (let n of e.values())
        if (n.showThis)
          for (let e = 0; e < n.sceneArr.length; e++) {
            let i = n.sceneArr[e];
            if (i.isDwgLayoutScene) {
              i.setDwgLayoutSceneRenderBgVisible(!1);
              const e = i.userData.bndBox.max,
                n = i.userData.bndBox.min;
              if (t.x > n.x && t.x < e.x && t.y > n.y && t.y < e.y) {
                let t = i.getCamera();
                return (
                  this.dwgLayoutViewPortData &&
                    this.dwgLayoutViewPortData.camera.uuid !== t.uuid &&
                    i.setDwgLayoutSceneRenderBgVisible(!0),
                  { scene: i, camera: t }
                );
              }
            }
          }
      let n = this.getCamera();
      return (
        this.dwgLayoutViewPortData &&
          this.dwgLayoutViewPortData.camera.uuid !== n.uuid &&
          this.dwgLayoutViewPortData.scene.setDwgLayoutSceneRenderBgVisible(!0),
        { scene: this.getMainModelScene(), camera: n }
      );
    },
  })),
    (_y.prototype = Object.assign(Object.create(fy.prototype), {
      constructor: _y,
      addPoint: function (t) {
        t
          ? this.ptsArr.push(new J(t.x, t.y, 0))
          : this.ptsArr.length > 0 &&
            this.ptsArr.push(this.ptsArr[this.ptsArr.length - 1].clone()),
          this.updateShape();
      },
      setLast: function (t) {
        this.setPointAt(this.ptsArr.length - 1, t);
      },
      setPointAt: function (t, e) {
        t < 0 ||
          t >= this.ptsArr.length ||
          (this.ptsArr[t].set(e.x, e.y, 0), this.updateShape());
      },
      removeLast: function () {
        let t = this.ptsArr.length;
        0 !== t && (this.ptsArr.splice(t - 1, 1), this.updateShape());
      },
      setMaterial: function (t) {
        this.line && (this.line.material = t || this.material),
          this.autoTransform &&
            this.autoTransform.children.length > 0 &&
            (this.autoTransform.children[0].material = t || this.material);
      },
      updateShape: function () {
        if ((this.dispose(), this.ptsArr.length < 2)) return;
        let t = new Float32Array(3 * this.ptsArr.length);
        for (let e = 0, n = this.ptsArr.length; e < n; ++e) {
          let n = this.ptsArr[e];
          (t[3 * e] = n.x), (t[3 * e + 1] = n.y), (t[3 * e + 2] = n.z);
        }
        let e = new He();
        e.setAttribute('position', new Re(t, 3)),
          (this.line = new Io(e, this.material)),
          this.scene.add(this.line);
        let n = Math.abs(Xf.computeAreaOfPolygon(this.ptsArr)) * this.precision;
        if (this.mvpInverseMatrix4) {
          let t = [];
          for (let e = 0, n = this.ptsArr.length; e < n; ++e) {
            let n = this.ptsArr[e].clone();
            n.applyMatrix4(this.mvpInverseMatrix4), t.push(n);
          }
          n = Math.abs(Xf.computeAreaOfPolygon(t)) * this.precision;
        }
        let i = new Rs(`${n.toFixed(3)} ` + this.precisionText, {
          font: this.font,
          size: 20,
          height: 0.001,
          curveSegments: 1,
        });
        this.text = new ln(i, this.material);
        let r = 0,
          o = 0;
        for (let t = 0, e = this.ptsArr.length; t < e; ++t)
          (r += this.ptsArr[t].x), (o += this.ptsArr[t].y);
        this.autoTransform.setPosition(
          new J(r / this.ptsArr.length, o / this.ptsArr.length, 0),
        ),
          this.autoTransform.add(this.text);
        for (let t = 0, e = this.ptsArr.length; t < e; ++t) {
          let e = this.createGripHandle(
            this.material,
            this.highlightMaterial,
            this.ptsArr[t],
            t,
          );
          this.gripArr.push(e);
        }
      },
      valid: function () {
        return this.ptsArr.length > 2;
      },
      dispose: function () {
        this.line &&
          (this.line.dispose(),
          this.scene.remove(this.line),
          (this.line = null)),
          this.autoTransform.removeAll(),
          fy.prototype.dispose.call(this);
      },
      checkIntersectionDistanceWithShape: (function () {
        let t = new Ml(),
          e = new J();
        return function (n, i) {
          let r = -1,
            o = this.ptsArr;
          for (let s = 0, a = o.length; s <= a; ++s) {
            if (
              (t.set(o[s % a], o[(s + 1) % a]),
              !Xf.computeIntersectionRayLine3(n.ray, t, !1, e))
            )
              continue;
            if (!i.containsPoint(e)) continue;
            let c = e.distanceTo(n.ray.origin);
            (c < r || r < 0) && (r = c);
          }
          return r;
        };
      })(),
    })),
    (xy.prototype = Object.assign(Object.create(vy.prototype), {
      constructor: xy,
      isMeasure2DOperator: !0,
      onRButtonUp: (function () {
        let t = new Ln();
        return function (e) {
          if (!this.tempMeasure || this.editGrip) return;
          let n = this.getPoint(e, t);
          if (n) {
            if (this.dwgLayoutViewPortData) {
              const t = this.getViewPortData(n);
              if (this.dwgLayoutViewPortData.camera.uuid !== t.camera.uuid)
                return;
            }
            (this.dwgLayoutViewPortData = null),
              this.tempMeasure.removeLast(),
              this.tempMeasure.valid()
                ? vy.prototype.stepMeasure.call(this)
                : (this.tempMeasure.dispose(),
                  (this.tempMeasure = null),
                  this.setOsnap(void 0));
          }
        };
      })(),
      getPoint: (function () {
        let t = new gl(),
          e = new Kt(new J(0, 0, 1), 0),
          n = new J();
        return function (i, r) {
          if ((this.getMouseRaycaster(i, t), t.ray.intersectPlane(e, n)))
            return n.clone();
        };
      })(),
      stepMeasure: function () {
        this.editGrip
          ? vy.prototype.stepMeasure.call(this)
          : this.tempMeasure.addPoint();
      },
      updateMeasure: function (t) {
        this.tempMeasure &&
          (this.editGrip
            ? this.tempMeasure.setPointAt(this.editGrip.getUserData(), t)
            : this.tempMeasure.setLast(t));
      },
      createNewMeasure: function (t, e) {
        let n = this.getViewer(),
          i = new _y(
            n.getIncrementalScene(),
            this.material,
            this.highlightMaterial,
            n.getRenderContext().getWebGLFont(),
            this.precision,
            this.precisionText,
            e,
          );
        return i.addPoint(t), i.addPoint(t), i;
      },
    })),
    (wy.prototype = Object.assign(Object.create(fy.prototype), {
      constructor: wy,
      isMeasureDistanceOperator: !0,
      setPoint: function (t, e) {
        t &&
          (this.ptsArr[e].copy(t),
          this.gripArr[e].setPosition(t),
          this.updateShape(this.ptsArr[0], this.ptsArr[1]));
      },
      getStart: function (t) {
        t.copy(this.ptsArr[0]);
      },
      getEnd: function (t) {
        t.copy(this.ptsArr[1]);
      },
      setShowClearHeight: function (t) {
        this.showClearHeight !== t &&
          ((this.showClearHeight = !!t),
          this.updateShape(this.ptsArr[0], this.ptsArr[1]));
      },
      setMaterial: function (t) {
        this.lineShape[0] &&
          (this.lineShape[0].material = t || this.materials[0]),
          this.textShape[0] &&
            this.textShape[0].children.length > 0 &&
            (this.textShape[0].children[0].material = t || this.materials[0]);
      },
      setPrecision: function (t, e) {
        (this.precision = t), (this.precisionText = e);
      },
      updateShape: (function (t, e) {
        let n = new J(),
          i = new J(),
          r = new J(),
          o = 1,
          s = 'm';
        function a(t, e, a, c, l, h, u, d, p) {
          if (!a[e]) {
            let n = new He();
            n.setAttribute('position', new Re(new Float32Array(6), 3)),
              (a[e] = new So(n, u[e])),
              t.add(a[e]);
          }
          let f = a[e].geometry.attributes.position;
          f.array.set([c.x, c.y, c.z, l.x, l.y, l.z], 0),
            (f.needsUpdate = !0),
            a[e].geometry.updateBounding(),
            h[e]
              ? h[e].removeAll()
              : ((h[e] = new Ug()),
                h[e].setAutoScale(!0),
                h[e].setAlignToScreen(!0));
          let m = c.distanceTo(l) * o;
          if (p) {
            let t = c.clone(),
              e = l.clone(),
              n = t.applyMatrix4(p),
              i = e.applyMatrix4(p);
            m = n.distanceTo(i) * o;
          }
          if (0 !== Math.trunc(m * Math.pow(10, 3))) {
            let o = new Rs(`${m.toFixed(3)} ` + s, {
              font: d,
              size: 20,
              height: 0.001,
              curveSegments: 1,
            });
            r.set(0.5 * (n.x + i.x), 0.5 * (n.y + i.y), 0.5 * (n.z + i.z)),
              h[e].position.copy(r),
              h[e].add(new ln(o, u[e])),
              t.add(h[e]);
          }
        }
        return function (t, e) {
          n.copy(t),
            i.copy(e),
            (o = this.precision),
            (s = this.precisionText),
            a(
              this.scene,
              0,
              this.lineShape,
              n,
              i,
              this.textShape,
              this.materials,
              this.font,
              this.mvpInverseMatrix4,
            ),
            this.showClearHeight
              ? (n.set(t.x, t.y, t.z),
                i.set(e.x, t.y, t.z),
                a(
                  this.scene,
                  1,
                  this.lineShape,
                  n,
                  i,
                  this.textShape,
                  this.materials,
                  this.font,
                  this.mvpInverseMatrix4,
                ),
                n.set(e.x, t.y, t.z),
                i.set(e.x, e.y, t.z),
                a(
                  this.scene,
                  2,
                  this.lineShape,
                  n,
                  i,
                  this.textShape,
                  this.materials,
                  this.font,
                  this.mvpInverseMatrix4,
                ),
                n.set(e.x, e.y, t.z),
                i.set(e.x, e.y, e.z),
                a(
                  this.scene,
                  3,
                  this.lineShape,
                  n,
                  i,
                  this.textShape,
                  this.materials,
                  this.font,
                  this.mvpInverseMatrix4,
                ))
              : this.removeShape([1, 2, 3]);
        };
      })(),
      removeShape: function (t) {
        for (let e = 0, n = t.length; e < n; ++e)
          this.lineShape[t[e]] &&
            (this.lineShape[t[e]].dispose(),
            this.scene.remove(this.lineShape[t[e]]),
            (this.lineShape[t[e]] = null)),
            this.textShape[t[e]] &&
              (this.textShape[t[e]].removeAll(),
              this.scene.remove(this.textShape[t[e]]),
              (this.textShape[t[e]] = null));
      },
      dispose: function () {
        this.removeShape([0, 1, 2, 3]), fy.prototype.dispose.call(this);
      },
      checkIntersectionDistanceWithShape: (function () {
        let t = new Ml(),
          e = new J(),
          n = new J(),
          i = new J();
        return function (r, o) {
          return (
            this.getStart(n),
            this.getEnd(i),
            t.set(n, i),
            Xf.computeIntersectionRayLine3(r.ray, t, !1, e) &&
            o.containsPoint(e)
              ? e.distanceTo(r.ray.origin)
              : -1
          );
        };
      })(),
    })),
    (Ay.prototype = Object.assign(Object.create(vy.prototype), {
      constructor: Ay,
      setCurrentMeasure: function (t) {
        this.currentMeasure !== t &&
          (this.currentMeasure &&
            (this.currentMeasure.setShowClearHeight(!1),
            this.currentMeasure.setShowGrip(!1)),
          (this.currentMeasure = t),
          this.currentMeasure &&
            (this.currentMeasure.setShowClearHeight(!0),
            this.currentMeasure.setShowGrip(!0)),
          this.hoverGrip &&
            (this.hoverGrip.highlight(!1), (this.hoverGrip = null)));
      },
      getPoint: (function () {
        let t = new U(),
          e = new J(),
          n = new Ln(),
          i = new gl(),
          r = new Ml();
        function o(t, e) {
          return t.type === e.type ? t.distance < e.distance : t.type < e.type;
        }
        function s(t, e, n, i, r) {
          e.containsPoint(t) &&
            i.push({ type: r || my, point: t, distance: t.distanceTo(n) });
        }
        function a(t, n, i, o, a, c) {
          r.set(t, n),
            Xf.computeIntersectionRayLine3(i, r, !1, e) &&
              s(e.clone(), o, a, c, gy);
        }
        return function (e, r) {
          this.getMouseWindowPos(e, t);
          let c = this.getViewer().pickSelectEntityByWindowPos(t);
          if (!c) return;
          let l = this.getViewer(),
            h = l.getMainCamera().position;
          if (r) n.copy(r);
          else {
            let t = e.offsetX,
              i = l.getSize().y - e.offsetY;
            l.getAsymmetricFrustum(t - 8, i - 8, t + 16, i + 16, n);
          }
          let u = [];
          return (
            s(c.vA, n, h, u),
            s(c.vB, n, h, u),
            c.face && s(c.vC, n, h, u),
            this.getMouseRaycaster(e, i),
            a(c.vA, c.vB, i.ray, n, h, u),
            c.face &&
              (a(c.vB, c.vC, i.ray, n, h, u), a(c.vC, c.vA, i.ray, n, h, u)),
            u.push({
              type: yy,
              point: c.point,
              distance: c.point.distanceTo(h),
            }),
            u.sort(o),
            this.setOsnap(u[0].type, u[0].point),
            u[0].point.clone()
          );
        };
      })(),
      updateMeasure: function (t) {
        this.tempMeasure.setPoint(
          t,
          this.editGrip ? this.editGrip.getUserData() : 1,
        );
      },
      createNewMeasure: function (t, e) {
        let n = this.getViewer();
        return new wy(
          n.getIncrementalScene(),
          n.getRenderContext().getWebGLFont(),
          this.materials,
          this.gripMaterial,
          t,
          t,
          this.precision,
          this.precisionText,
          e,
        );
      },
    })),
    (My.prototype = Object.assign(Object.create(Ay.prototype), {
      constructor: My,
      getPoint: (function () {
        let t = new gl(),
          e = new Kt(new J(0, 0, 1), 0),
          n = new J();
        return function (i, r) {
          let o = Ay.prototype.getPoint.call(this, i, r);
          return (
            o ||
            (this.getMouseRaycaster(i, t),
            t.ray.intersectPlane(e, n)
              ? (this.setOsnap(my, n), n.clone())
              : null)
          );
        };
      })(),
      stepMeasure: function () {
        Ay.prototype.stepMeasure.call(this),
          (this.dwgLayoutViewPortData = null);
      },
    })),
    (Sy.prototype = Object.assign(Object.create(fy.prototype), {
      constructor: Sy,
      setPosition: function (t) {
        this.autoTransform.setPosition(t),
          this.text &&
            (this.text.dispose(), this.autoTransform.remove(this.text));
        let e = new Rs(
          `${(t.z * this.precision).toFixed(3)} ` + this.precisionText,
          { font: this.font, size: 20, height: 0.001, curveSegments: 1 },
        );
        (this.text = new ln(e, this.material)),
          this.text.position.copy(this.textPos),
          this.autoTransform.add(this.text);
      },
      getPosition: function () {
        return this.autoTransform.getPosition();
      },
      setMaterial: function (t) {
        for (let e = 0, n = this.autoTransform.children.length; e < n; ++e)
          this.autoTransform.children[e].material = t || this.material;
      },
      checkIntersectionDistanceWithShape: function (t, e) {
        return e.containsPoint(this.autoTransform.getPosition())
          ? this.autoTransform.getPosition().distanceTo(t.ray.origin)
          : -1;
      },
      dispose: function () {
        this.autoTransform.removeAll(), this.scene.remove(this.autoTransform);
      },
    })),
    (Iy.prototype = Object.assign(Object.create(vy.prototype), {
      constructor: Iy,
      isMeasureHeightOperator: !0,
      onLButtonUp: function (t) {
        if (
          !(
            Math.abs(t.offsetX - this.downPos.x) > 1 ||
            Math.abs(t.offsetY - this.downPos.y) > 1
          )
        )
          if (
            (this.currentMeasure &&
              this.currentMeasure.setMaterial(this.material),
            this.hoverMeasure)
          )
            this.setCurrentMeasure(this.hoverMeasure),
              this.currentMeasure.setMaterial(this.highlightMaterial);
          else if ((this.setCurrentMeasure(null), this.currentPoint)) {
            let t = this.getViewer();
            this.measureResultArray.push(
              new Sy(
                t.getIncrementalScene(),
                t.getRenderContext().getWebGLFont(),
                this.material,
                this.currentPoint,
                this.precision,
                this.precisionText,
              ),
            );
          }
      },
      getPoint: (function () {
        let t = new U();
        return function (e, n) {
          this.getMouseWindowPos(e, t);
          let i = this.getViewer().pickSelectEntityByWindowPos(t);
          if (i) return i.point;
        };
      })(),
      onNoButtonDownAndMove: (function () {
        let t = new gl(),
          e = new Ln();
        return function (n) {
          this.getViewer().renderContext.setRequestUpdate(!0),
            (this.currentPoint = this.getPoint(n, e));
          let i = this.getViewer(),
            r = n.offsetX,
            o = i.getSize().y - n.offsetY;
          i.getAsymmetricFrustum(r - 8, o - 8, r + 16, o + 16, e),
            this.hoverMeasure &&
              this.hoverMeasure != this.currentMeasure &&
              this.hoverMeasure.setMaterial(this.material),
            (this.hoverMeasure = this.tryGetSelectMeasureResult(t, e)),
            this.hoverMeasure &&
              this.hoverMeasure.setMaterial(this.highlightMaterial),
            this.currentPoint
              ? this.setOsnap(my, this.currentPoint)
              : this.setOsnap(void 0);
        };
      })(),
    })),
    (Ey.prototype = Object.assign(Object.create(Tg.prototype), {
      constructor: Ey,
      willBegin: function (t) {
        Tg.prototype.willBegin.call(this, t),
          this.measureHeight && this.measureHeight.willBegin(t),
          this.measureDistance && this.measureDistance.willBegin(t),
          this.measureDistance2D && this.measureDistance2D.willBegin(t),
          this.measureArea2D && this.measureArea2D.willBegin(t);
      },
      willEnd: function (t) {
        this.measureHeight && this.measureHeight.willEnd(t),
          this.measureDistance && this.measureDistance.willEnd(t),
          this.measureDistance2D && this.measureDistance2D.willEnd(t),
          this.measureArea2D && this.measureArea2D.willEnd(t),
          Tg.prototype.willEnd.call(this, t);
      },
      onLButtonDown: function (t) {
        this.currentMeasure && this.currentMeasure.onLButtonDown(t);
      },
      onLButtonUp: function (t) {
        this.currentMeasure && this.currentMeasure.onLButtonUp(t);
      },
      onRButtonUp: function (t) {
        this.currentMeasure && this.currentMeasure.onRButtonUp(t);
      },
      onMButtonUp: function (t) {
        this.currentMeasure && this.currentMeasure.onRButtonUp(t);
      },
      onNoButtonDownAndMove: function (t) {
        this.currentMeasure && this.currentMeasure.onNoButtonDownAndMove(t);
      },
      setMeasureMode: function (t) {
        switch (
          (this.currentMeasure &&
            (this.onRButtonUp(),
            this.currentMeasure.setCurrentMeasure(null),
            this.currentMeasure.setOsnap(void 0, void 0)),
          t)
        ) {
          case 1:
            this.currentMeasure = this.measureHeight;
            break;
          case 2:
            this.currentMeasure = this.measureDistance;
            break;
          case 3:
            (this.currentMeasure = this.measureArea2D),
              (this.currentMeasure.precision = 1),
              (this.currentMeasure.precisionText = 'mm²');
            break;
          case 4:
            (this.currentMeasure = this.measureDistance2D),
              (this.currentMeasure.precision = 1),
              (this.currentMeasure.precisionText = 'mm');
        }
      },
      getMeasureMode: function () {
        return this.currentMeasure;
      },
      closeMeasureMode: function () {
        this.currentMeasure = null;
      },
      deleteCurrentMeasure: function () {
        this.currentMeasure.deleteCurrentMeasure();
      },
    }));
  let Dy = 1,
    Cy = 2,
    Ty = 4,
    Ly = 8,
    Ry = 16,
    Fy = 32,
    Py = Dy,
    By = Cy,
    Oy = Ty,
    Vy = Ly,
    Ny = Ry,
    ky = Fy,
    Uy = Cy | Dy,
    Gy = Ly | Dy,
    zy = Cy | Ty,
    jy = Ly | Ty;
  function Hy() {
    Tg.call(this),
      (this.speed = 1),
      (this.directionStack = []),
      (this.currentDirection = 0),
      (this.lastWindowPos = new U());
  }
  Hy.prototype = Object.assign(Object.create(Tg.prototype), {
    constructor: Tg,
    isCameraWalkaroundOperator: !0,
    getKeyDirection: function (t) {
      let e = 0;
      switch (t.keyCode) {
        case 38:
        case 87:
          e = Dy;
          break;
        case 37:
        case 65:
          e = Cy;
          break;
        case 40:
        case 83:
          e = Ty;
          break;
        case 39:
        case 68:
          e = Ly;
          break;
        case 81:
          e = Ry;
          break;
        case 69:
          e = Fy;
      }
      return e;
    },
    getWalkDirection: function (t) {
      let e = t.length;
      if (0 === e) return 0;
      if (1 === e) return t[0];
      let n = t[e - 1],
        i = n | t[e - 2];
      return i === Uy || i === Gy || i === zy || i === jy ? i : n;
    },
    changeSpeed: function (t) {
      (this.speed += t), this.speed <= 0 && (this.speed = 0.2);
    },
    onLButtonDown: function (t) {
      this.getMouseWindowPos(t, this.lastWindowPos), this.setStarted(!0);
    },
    onLButtonUp: function (t) {
      this.setStarted(!1);
    },
    onMouseMove: function (t) {
      this.getStarted() && this.onLButtonDownAndMove(t);
    },
    onLButtonDownAndMove: (function () {
      let t = new U(),
        e = new J(),
        n = new J(),
        i = new J();
      return function (r) {
        this.getMouseWindowPos(r, t),
          e.set(
            this.lastWindowPos.x,
            this.lastWindowPos.y,
            1 -
              Math.sqrt(
                this.lastWindowPos.x * this.lastWindowPos.x +
                  this.lastWindowPos.y * this.lastWindowPos.y,
              ),
          ),
          n.set(t.x, t.y, 1 - Math.sqrt(t.x * t.x + t.y * t.y)),
          this.lastWindowPos.copy(t);
        let o = e.angleTo(n);
        if (Xf.isZeroNumber(o)) return;
        let s = this.getViewer().getMainCamera(),
          a = s.position,
          c = s.target;
        i.subVectors(c, a);
        let l = (i.angleTo(Xf.zAxis) / Math.PI) * 180,
          h = 0,
          u = 0,
          d = 0,
          p = Math.abs(n.x - e.x),
          f = Math.abs(n.y - e.y);
        if (Xf.isParallelVector3(i, Xf.zAxis))
          (d = (120 * o * p) / (p + f)),
            n.x < n.x && (d *= -1),
            Xf.isZeroNumber(i.angleTo(Xf.zAxis)) && (d *= -1);
        else {
          (h = (120 * o * (1 - Math.abs(l - 90) / 90) * p) / (p + f)),
            n.x > e.x && (h *= -1);
        }
        (u = (120 * o * f) / (p + f)), n.y > e.y && (u *= -1);
        u > 0 ? l + u > 179 && (u = 179 - l) : l + u < 1 && (u = 1 - l),
          s.makeYaw(h),
          s.makePitch(u),
          s.makeRoll(d),
          s.makeCameraUp(Xf.zAxis),
          this.getViewer().cameraChanged();
      };
    })(),
    onMouseWheel: function (t) {
      this.changeSpeed(t.deltaY < 0 ? 0.5 : -0.5);
    },
    onKeyDown: function (t) {
      let e = this.getKeyDirection(t);
      if (0 !== e) {
        for (let t = 0, n = this.directionStack.length; t < n; ++t)
          if (this.directionStack[t] === e) {
            this.directionStack.splice(t, 1);
            break;
          }
        this.directionStack.push(e),
          (this.currentDirection = this.getWalkDirection(this.directionStack));
      }
    },
    onKeyUp: function (t) {
      let e = this.getKeyDirection(t);
      if (0 !== e) {
        for (let t = 0, n = this.directionStack.length; t < n; ++t)
          if (this.directionStack[t] === e) {
            this.directionStack.splice(t, 1);
            break;
          }
        this.currentDirection = this.getWalkDirection(this.directionStack);
      }
    },
    onFrame: (function () {
      let t = new J(),
        e = new J(),
        n = new J(),
        i = new J(),
        r = new Y();
      return function () {
        if (0 === this.currentDirection) return;
        let o = this.getViewer().getMainCamera();
        switch (
          (e.subVectors(o.target, o.position).normalize(),
          i.copy(o.up),
          n.crossVectors(i, e).normalize(),
          t.set(0, 0, 0),
          this.currentDirection)
        ) {
          case Py:
            t.copy(e), (t.z = 0), Xf.isZeroVector3(t) && t.copy(i);
            break;
          case By:
            t.copy(n);
            break;
          case Oy:
            t.set(-e.x, -e.y, -e.z),
              (t.z = 0),
              Xf.isZeroVector3(t) && t.set(-i.x, -i.y, -i.z);
            break;
          case Vy:
            t.set(-n.x, -n.y, -n.z);
            break;
          case Ny:
            t.set(0, 0, 1);
            break;
          case ky:
            t.set(0, 0, -1);
            break;
          case Uy:
            t.copy(e),
              (t.z = 0),
              Xf.isZeroVector3(t) && t.copy(i),
              r.setFromAxisAngle(Xf.zAxis, Math.PI / 4),
              t.applyQuaternion(r);
            break;
          case Gy:
            t.copy(e),
              (t.z = 0),
              Xf.isZeroVector3(t) && t.copy(i),
              r.setFromAxisAngle(Xf.zAxis, -Math.PI / 4),
              t.applyQuaternion(r);
            break;
          case zy:
            t.copy(n),
              r.setFromAxisAngle(Xf.zAxis, Math.PI / 4),
              t.applyQuaternion(r);
            break;
          case jy:
            t.set(-n.x, -n.y, -n.z),
              r.setFromAxisAngle(Xf.zAxis, -Math.PI / 4),
              t.applyQuaternion(r);
        }
        t.normalize().multiplyScalar(this.speed),
          o.makePan(t),
          this.getViewer().cameraChanged();
      };
    })(),
  });
  let Wy,
    Xy = 1,
    Zy = 2,
    Yy = 4,
    qy = 8,
    Qy = Xy,
    Jy = Zy,
    $y = Yy,
    Ky = qy,
    tv = 16,
    ev = 32,
    nv = Zy | Xy,
    iv = qy | Xy,
    rv = Zy | Yy,
    ov = qy | Yy;
  function sv(t) {
    Hy.call(this), (this.bimViewer = t), (this.gravity = !1), (this.speed = 1);
  }
  sv.prototype = Object.assign(Object.create(Hy.prototype), {
    constructor: sv,
    setGravity: function (t) {
      this.gravity = t;
    },
    getSpeed: function () {
      return this.speed;
    },
    changeSpeed: function (t) {
      (this.speed = t),
        this.speed <= 0 && (this.speed = 0.1),
        this.speed >= 999 && (this.speed = 999),
        this.dispatchEvent({ type: 'changeSpeedListener' });
    },
    addEventListener: function (t, e) {
      void 0 === this._listeners && (this._listeners = {});
      var n = this._listeners;
      void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e);
    },
    dispatchEvent: function (t) {
      if (void 0 !== this._listeners) {
        var e = this._listeners[t.type];
        if (void 0 !== e) {
          t.target = this;
          for (var n = e.slice(0), i = 0, r = n.length; i < r; i++)
            n[i].call(this, t);
        }
      }
    },
    onMouseWheel: function () {},
    onKeyDown: function (t) {
      Hy.prototype.onKeyDown.call(this, t);
    },
    onKeyUp: function (t) {
      switch ((Hy.prototype.onKeyUp.call(this, t), t.keyCode)) {
        case 107:
          this.changeSpeed((++this.speed).toFixed(1));
          break;
        case 109:
          this.changeSpeed((--this.speed).toFixed(1));
      }
    },
    onFrame: (function () {
      let t = new J(),
        e = new J(),
        n = new J(),
        i = new J(),
        r = new Y();
      function o(t, e) {
        return t.distance - e.distance;
      }
      return function () {
        if (0 === this.currentDirection) return;
        let s = this.getViewer(),
          a = s.getMainCamera();
        switch (
          (e.subVectors(a.target, a.position).normalize(),
          i.copy(a.up),
          n.crossVectors(i, e).normalize(),
          t.set(0, 0, 0),
          this.currentDirection)
        ) {
          case Qy:
            t.copy(e), (t.z = 0), Xf.isZeroVector3(t) && t.copy(i);
            break;
          case Jy:
            t.copy(n);
            break;
          case $y:
            t.set(-e.x, -e.y, -e.z),
              (t.z = 0),
              Xf.isZeroVector3(t) && t.set(-i.x, -i.y, -i.z);
            break;
          case Ky:
            t.set(-n.x, -n.y, -n.z);
            break;
          case tv:
            t.set(0, 0, 1);
            break;
          case ev:
            t.set(0, 0, -1);
            break;
          case nv:
            t.copy(e),
              (t.z = 0),
              Xf.isZeroVector3(t) && t.copy(i),
              r.setFromAxisAngle(Xf.zAxis, Math.PI / 4),
              t.applyQuaternion(r);
            break;
          case iv:
            t.copy(e),
              (t.z = 0),
              Xf.isZeroVector3(t) && t.copy(i),
              r.setFromAxisAngle(Xf.zAxis, -Math.PI / 4),
              t.applyQuaternion(r);
            break;
          case rv:
            t.copy(n),
              r.setFromAxisAngle(Xf.zAxis, Math.PI / 4),
              t.applyQuaternion(r);
            break;
          case ov:
            t.set(-n.x, -n.y, -n.z),
              r.setFromAxisAngle(Xf.zAxis, -Math.PI / 4),
              t.applyQuaternion(r);
        }
        if (
          (t.normalize().multiplyScalar(this.speed), a.makePan(t), this.gravity)
        ) {
          const t = (function (t, e) {
            const n = new gl(t, new J(0, 0, -1), 0, 1e3);
            let i = [];
            const r = e.getModelScene().getModelArray();
            let s = [];
            for (let t = 0, e = r.length; t < e; ++t)
              s.push(r[t].getSceneNode());
            for (let t = 0; t < s.length; ++t) {
              let e = s[t].children;
              for (let t = 0, n = e.length; t < n; ++t) {
                let n = e[t];
                n.isPMSceneNode && s.push(n);
              }
              let r = s[t].getEntityArray();
              for (let t = 0, e = r.length; t < e; ++t) {
                let e = r[t].raycast(n);
                e && ((e.entity = r[t]), i.push(e));
              }
            }
            return i.sort(o), i.length > 0 ? i[0] : null;
          })(a.position, s);
          t && a.position.setZ(a.position.z - t.distance + 1);
        }
        this.getViewer().cameraChanged();
      };
    })(),
  });
  let av,
    cv,
    lv,
    hv,
    uv,
    dv,
    pv,
    fv,
    mv = 200,
    bv = 160;
  function gv() {
    const t = document.getElementById('ccbim__roamMap__circle');
    if (!t) return;
    let e = this.getMainCamera(),
      n = e.target,
      i = e.position,
      r = new J(0, 1, 0);
    n && (r = n.clone()), r.sub(i), (r.z = 0);
    let o = new J(0, 1, 0),
      s = (180 * r.angleTo(o)) / Math.PI;
    if (
      (r.x < 0 && (s = 360 - s),
      0 === Object.keys(Wy.getRectangleData()).length)
    )
      return void (t.style.display = 'none');
    t.style.display = 'block';
    !(function (t, e, n) {
      document.getElementById('ccbim__roamMap__circle').style.transform =
        'translate(' + t + 'px,' + e + 'px) rotate(' + n + 'deg)';
    })(
      (i.x - Wy.getRectangleData().centerPoint[0]) * Wy.getMiniMapScale() +
        mv / 2,
      (-1 * i.y - Wy.getRectangleData().centerPoint[1]) * Wy.getMiniMapScale() +
        bv / 2,
      s,
    );
  }
  class yv extends Sh {
    constructor(t) {
      super(t),
        (this.state = {
          selectFloorPlanGraph: [],
          mapCanvasWidth: 200,
          mapCanvasHeight: 160,
          scaleBig: !1,
          speedValue: 1,
          roamImgVisible: !0,
          gravityVisible: !1,
          speedChangeVisible: !1,
          tipSpeed: !1,
          tipGravity: !1,
        });
    }
    setRoamImg() {
      this.state.roamImgVisible ? this.closeRoamImg() : this.openRoamImg();
    }
    openRoamImg() {
      this.setState({ roamImgVisible: !0 }), this.addRoamImgDragControl();
    }
    closeRoamImg() {
      this.removeRoamImgDragControl(), this.setState({ roamImgVisible: !1 });
    }
    setSpeedChange() {
      this.state.speedChangeVisible
        ? this.closeSpeedChange()
        : this.openSpeedChange();
    }
    openSpeedChange() {
      this.setState({ speedChangeVisible: !0 }),
        this.addSpeedChangeDragControl();
    }
    closeSpeedChange() {
      this.removeSpeedChangeDragControl(),
        this.setState({ speedChangeVisible: !1 });
    }
    setGravity() {
      this.state.gravityVisible
        ? (this.setState({ gravityVisible: !1 }), av.setGravity(!1))
        : (this.setState({ gravityVisible: !0 }), av.setGravity(!0)),
        this.setState({ tipGravity: !0 }),
        setTimeout(() => {
          this.setState({ tipGravity: !1 });
        }, 2e3);
    }
    speedInputChange(t) {
      let e = parseFloat(t);
      isNaN(e) || e <= 0 ? (e = 0.1) : e >= 999 && (e = 999);
      let n = e.toFixed(1);
      this.setState({ speedValue: n }), av.changeSpeed(n);
    }
    speedChange(t) {
      let e = this.state.speedValue;
      'sub' === t
        ? (e--, e <= 0 && (e = 0.1))
        : 'add' === t && (e++, e >= 999 && (e = 999));
      let n = e.toFixed(1);
      this.setState({ speedValue: n }), av.changeSpeed(n);
    }
    roamSpeedDefault() {
      this.setState({ speedValue: 1 }), av.changeSpeed(1);
    }
    canvasMove(t) {
      Wy.getCrossPoint(t.offsetX, t.offsetY);
    }
    canvasDoubleClick(t) {
      Wy.canvasDoubleClick(
        t,
        document.getElementById('ccbim__roamMap__canvas'),
      );
    }
    selectFloor(t) {
      const e = parseInt(t.target.value);
      Wy.setSelectedFloor(e),
        Wy.getMapData(this.state.mapCanvasWidth, this.state.mapCanvasHeight),
        Wy.drawUpload(
          this.state.mapCanvasWidth,
          this.state.mapCanvasHeight,
          this.state.scaleBig,
        );
      let n =
          this.state.selectFloorPlanGraph[e].floorElevation +
          this.state.selectFloorPlanGraph[e].floorHeight / 2,
        i = this.props.viewer.bimViewer.getModelScene().getBoundingBox(),
        r = this.props.viewer.bimViewer.getMainCamera();
      r.makeLookAt(
        new J(r.position.x, r.position.y, n),
        new J(
          i.min.x + (i.max.x - i.min.x) / 2,
          i.min.y + (i.max.y - i.min.y) / 2,
          n,
        ),
        new J(0, 0, 1),
      ),
        this.props.viewer.bimViewer.cameraChanged();
    }
    changeMap() {
      this.state.scaleBig ? this.shrinkMap() : this.zoomMap();
    }
    zoomMap() {
      this.setState({
        scaleBig: !0,
        mapCanvasWidth: 600,
        mapCanvasHeight: 450,
      }),
        (mv = 600),
        (bv = 450),
        Wy.zoomMap(600, 450);
    }
    shrinkMap() {
      this.setState({
        scaleBig: !1,
        mapCanvasWidth: 200,
        mapCanvasHeight: 160,
      }),
        (mv = 200),
        (bv = 160),
        Wy.shrinkMap(200, 160);
    }
    addRoamImgDragControl() {
      setTimeout(() => {
        (lv = new Xg(document.getElementById('ccbim__roam__img'))),
          (hv = lv.bind(document.getElementById('roam__img__title')));
      });
    }
    removeRoamImgDragControl() {
      lv &&
        (lv.unBind(document.getElementById('roam__img__title'), hv),
        (lv = null));
    }
    addSpeedChangeDragControl() {
      setTimeout(() => {
        (uv = new Xg(document.getElementById('ccbim__speedChange'))),
          (dv = uv.bind(document.getElementById('ccbim__modeChange__title')));
      });
    }
    removeSpeedChangeDragControl() {
      uv &&
        (uv.unBind(document.getElementById('ccbim__modeChange__title'), dv),
        (uv = null));
    }
    componentDidMount() {
      (Wy = new ay(this.props.viewer.bimViewer)),
        Wy.initMap(
          document.getElementById('ccbim__roamMap__canvas'),
          this.state.mapCanvasWidth,
          this.state.mapCanvasHeight,
          this.state.scaleBig,
        );
      let t = Wy.getSelectFloorPlanGraph();
      this.setState({ selectFloorPlanGraph: t }),
        this.props.viewer.bimViewer.bindCameraChangedEvent(gv),
        (av = new sv(this.props.viewer.bimViewer)),
        this.props.viewer.bimViewer.setOperator(av),
        av.addEventListener('changeSpeedListener', () => {
          console.log('速度改变'),
            this.setState({ tipSpeed: !0 }),
            clearTimeout(cv),
            (cv = setTimeout(() => {
              this.setState({ tipSpeed: !1 });
            }, 2e3));
          let t = av.getSpeed();
          this.setState({ speedValue: t });
        });
      let e = av.getSpeed();
      this.setState({ speedValue: e }), this.addRoamImgDragControl();
    }
    componentWillUnmount() {
      this.props.viewer.bimViewer.unbindCameraChangedEvent(gv),
        this.props.viewer.bimViewer.setOperator(new Pg()),
        (this.cameraWalkOperator = null),
        (this.roamMapObject = null),
        this.removeRoamImgDragControl();
    }
    render() {
      return Xh`<${Mh}>
      <!--右上角小地图-->
      <div class="ccbim__roam__topRightMap">
        <div class="ccbim__roam__topRightMap__left">
          <div class="roam__leftIcon" onClick=${() => this.setSpeedChange()}>
            <span class="${
              this.state.speedChangeVisible && 'icon-on'
            }">${this.state.speedValue}</span>
          </div>
          <div class="roam__leftIcon">
            <svg class="icon ${
              this.state.gravityVisible && 'icon-on'
            }" onClick=${() => this.setGravity()}>
              <use xlinkHref="#iconzhonglimoshi"></use>
            </svg>
          </div>
          <div class="roam__leftIcon">
            <svg class="icon ${
              this.state.roamImgVisible && 'icon-on'
            }" onClick=${() => this.setRoamImg()}>
              <use xlinkHref="#iconbangzhu2"></use>
            </svg>
          </div>
          <div class="roam__leftIcon" onClick=${() => this.changeMap()}>
            <svg class="icon ${this.state.scaleBig && 'icon-on'}">
              <use xlinkHref="#iconzuixiaohua"></use>
            </svg>
          </div>
        </div>
        <div class="ccbim__roam__topRightMap__top">
          <select
            class="ccbim__roam__topRightMap__select"
            onChange=${(t) => this.selectFloor(t)}
          >
            ${this.state.selectFloorPlanGraph.map(
              (t, e) => Xh`<option value=${e} key=${e}>
                  ${t.floorName}
                </option>`,
            )}
          </select>
        </div>
        <div class="ccbim__roamMapCanvasBox">
          <canvas
            id="ccbim__roamMap__canvas"
            width=${this.state.mapCanvasWidth}
            height=${this.state.mapCanvasHeight}
            onMouseMove=${(t) => this.canvasMove(t)}
            onDblClick=${(t) => this.canvasDoubleClick(t)}
          ></canvas>
          <div class="ccbim__roamMap__circle" id="ccbim__roamMap__circle"></div>
        </div>
      </div>
      <!--提示图-->
      ${
        this.state.roamImgVisible &&
        Xh`
          <div class="ccbim__roam__img" id="ccbim__roam__img">
            <div class="roam__img__title" id="roam__img__title">
              漫游操作指引
            </div>
            <img
              src=${
                window.CcbimSDKLoaderConfig.staticHost +
                '/ccbimSDK@' +
                window.CcbimSDKLoaderConfig.version +
                '/ccbim/assets/images/roamTip.svg'
              }
              style="margin-top: 15px"
            />
            <div class="roam__img__close" title="关闭">
              <span onClick=${() => this.closeRoamImg()}>我知道了</span>
            </div>
          </div>
        `
      }
      <!--漫游中心点十字架-->
      <div class="ccbim__roamCross">
        <div class="ccbim__roamCrossW"></div>
        <div class="ccbim__roamCrossH"></div>
      </div>
      <!--web端的速度控制-->
      ${
        this.state.speedChangeVisible &&
        Xh`<div
          class="ccbim__speedChange ccbim__common__dialog"
          id="ccbim__speedChange"
        >
          <div class="ccbim__common__title" id="ccbim__modeChange__title">
            <span>漫游速度</span>
            <svg
              class="icon"
              title="关闭"
              aria-hidden="true"
              onClick=${() => this.closeSpeedChange()}
            >
              <use xlinkHref="#iconguanbi1"></use>
            </svg>
          </div>
          <div class="ccbim__speedChange__input">
            <div
              class="ccbim__roam__speed sub"
              onClick=${() => this.speedChange('sub')}
            >
              <svg class="icon">
                <use xlinkHref="#iconminus"></use>
              </svg>
            </div>
            <input
              type="number"
              class="ccbim__speed__value"
              onChange=${(t) => this.speedInputChange(t.currentTarget.value)}
              value=${this.state.speedValue}
            />
            <div
              class="ccbim__roam__speed add"
              onClick=${() => this.speedChange('add')}
            >
              <svg class="icon">
                <use xlinkHref="#iconadd"></use>
              </svg>
            </div>
          </div>
          <div
            class="ccbim__common__recoverDefault"
            onClick=${() => this.roamSpeedDefault()}
          >
            <span>恢复默认</span>
          </div>
        </div> `
      }
      <!--提示-->
      ${
        this.state.tipGravity &&
        Xh`<div class="ccbim__roam__tip">
          ${this.state.gravityVisible ? '已打开重力效果' : '已关闭重力效果'}
        </div>`
      }
      ${
        this.state.tipSpeed &&
        Xh`<div class="ccbim__roam__tip">
          漫游速度<span>${this.state.speedValue}X</span>
        </div>`
      }
    </${Mh}>`;
    }
  }
  class vv extends Sh {
    constructor(t) {
      super(t),
        (this.state = {
          checkedBorder: !1,
          checkedTexture: !0,
          checkedColor: !1,
          pureColor: !0,
          gradientColor: !1,
          pureColorVal: '#f5f5f5',
          gradientColorTopVal: '#94C2EA',
          gradientColorBottomVal: '#CFE6EE',
          checkedShadow: !1,
          checkedShowPoint: !0,
        });
    }
    switchBorder(t) {
      this.debounce(() => {
        t
          ? this.props.viewer.bimViewer.setWireframeVisible(!0)
          : this.props.viewer.bimViewer.setWireframeVisible(!1),
          this.props.viewer.bimViewer.requestFrameUpdate(),
          this.setState({ checkedBorder: t }),
          localStorage.setItem(
            'ccbim_switchBorder',
            JSON.stringify({ checkedBorder: t }),
          );
      }, 500)();
    }
    switchShadow(t) {
      this.debounce(() => {
        t ? ig(this.props.viewer) : og(this.props.viewer),
          this.setState({ checkedShadow: t }),
          localStorage.setItem(
            'ccbim_switchShadow',
            JSON.stringify({ checkedShadow: t }),
          );
      }, 500)();
    }
    switchShowPoint(t) {
      this.debounce(() => {
        cg(t, this.props.viewer),
          this.setState({ checkedShowPoint: t }),
          localStorage.setItem(
            'ccbim_switchShowPoint',
            JSON.stringify({ checkedShowPoint: t }),
          );
      }, 500)();
    }
    debounce(t, e) {
      let n;
      return function () {
        clearTimeout(n),
          (n = setTimeout(function () {
            t();
          }, e));
      };
    }
    radioEffect(t) {
      let e = parseInt(t);
      1 === e
        ? (ag(this.props.viewer),
          this.setState({ checkedColor: !0, checkedTexture: !1 }),
          localStorage.setItem(
            'ccbim_switchTexture',
            JSON.stringify({ checkedColor: !0, checkedTexture: !1 }),
          ))
        : 2 === e &&
          (sg(this.props.viewer),
          this.setState({ checkedColor: !1, checkedTexture: !0 }),
          localStorage.setItem(
            'ccbim_switchTexture',
            JSON.stringify({ checkedColor: !1, checkedTexture: !0 }),
          )),
        this.props.viewer.bimViewer.requestFrameUpdate();
    }
    radioBgColor(t) {
      let e = parseInt(t);
      1 === e
        ? (this.setState({ pureColor: !0, gradientColor: !1 }),
          this.pureColorChange(this.state.pureColorVal))
        : 2 === e &&
          (this.setState({ pureColor: !1, gradientColor: !0 }),
          this.gradientColorChange(this.state.gradientColorTopVal, 'top'),
          this.gradientColorChange(
            this.state.gradientColorBottomVal,
            'bottom',
          )),
        this.props.viewer.bimViewer.requestFrameUpdate();
    }
    pureColorChange(t) {
      this.setState({ pureColorVal: t }),
        lg(this.props.viewer, t, t),
        localStorage.setItem(
          'ccbim_switchBgColor',
          JSON.stringify({ pureColor: !0, pureColorVal: t }),
        );
    }
    gradientColorChange(t, e) {
      'top' === e
        ? (this.setState({ gradientColorTopVal: t }),
          lg(this.props.viewer, t, this.state.gradientColorBottomVal),
          localStorage.setItem(
            'ccbim_switchBgColor',
            JSON.stringify({
              gradientColor: !0,
              gradientColorTopVal: t,
              gradientColorBottomVal: this.state.gradientColorBottomVal,
            }),
          ))
        : 'bottom' === e &&
          (this.setState({ gradientColorBottomVal: t }),
          lg(this.props.viewer, this.state.gradientColorTopVal, t),
          localStorage.setItem(
            'ccbim_switchBgColor',
            JSON.stringify({
              gradientColor: !0,
              gradientColorTopVal: this.state.gradientColorTopVal,
              gradientColorBottomVal: t,
            }),
          ));
    }
    recoverDefault() {
      'dwg' !== this.props.viewer.type &&
        (this.props.viewer.bimViewer.setWireframeVisible(!1),
        this.props.viewer.bimViewer.requestFrameUpdate(),
        this.setState({ checkedBorder: !1 }),
        og(this.props.viewer),
        this.setState({ checkedShadow: !1 }),
        sg(this.props.viewer),
        this.setState({ checkedColor: !1, checkedTexture: !0 }),
        lg(this.props.viewer, '#f5f5f5', '#f5f5f5'),
        this.setState({
          pureColor: !0,
          pureColorVal: '#f5f5f5',
          gradientColor: !1,
        }),
        localStorage.removeItem('ccbim_switchBorder'),
        localStorage.removeItem('ccbim_switchShadow'),
        localStorage.removeItem('ccbim_switchTexture'),
        localStorage.removeItem('ccbim_switchBgColor')),
        cg(!0, this.props.viewer),
        this.setState({ checkedShowPoint: !0 }),
        localStorage.removeItem('ccbim_switchShowPoint');
    }
    defaultLocalVal() {
      if ('dwg' !== this.props.viewer.type) {
        let t = JSON.parse(localStorage.getItem('ccbim_switchBorder'));
        t && this.setState({ checkedBorder: t.checkedBorder });
        let e = JSON.parse(localStorage.getItem('ccbim_switchShadow'));
        e && this.setState({ checkedShadow: e.checkedShadow });
        let n = JSON.parse(localStorage.getItem('ccbim_switchTexture'));
        n &&
          this.setState({
            checkedColor: n.checkedColor,
            checkedTexture: n.checkedTexture,
          });
        let i = JSON.parse(localStorage.getItem('ccbim_switchBgColor'));
        i &&
          (i.pureColor &&
            this.setState({
              pureColor: !0,
              pureColorVal: i.pureColorVal,
              gradientColor: !1,
            }),
          i.gradientColor &&
            this.setState({
              pureColor: !1,
              gradientColor: !0,
              gradientColorTopVal: i.gradientColorTopVal,
              gradientColorBottomVal: i.gradientColorBottomVal,
            }));
      }
      let t = JSON.parse(localStorage.getItem('ccbim_switchShowPoint'));
      t && this.setState({ checkedShowPoint: t.checkedShowPoint });
    }
    componentWillMount() {
      this.defaultLocalVal(),
        setTimeout(() => {
          (pv = new Xg(document.getElementById('ccbim__setting__box'))),
            (fv = pv.bind(document.getElementById('ccbim__setting__tile')));
        });
    }
    componentWillUnmount() {
      pv &&
        (pv.unBind(document.getElementById('ccbim__setting__tile'), fv),
        (pv = null));
    }
    render() {
      return Xh`<div
      class="ccbim__setting__box ccbim__common__dialog ${
        'dwg' === this.props.viewer.type && 'ccbim__setting__box__dwg'
      }"
      id="ccbim__setting__box"
    >
      <div class="ccbim__common__title" id="ccbim__setting__tile">
        <span>渲染设置</span>
        <svg
          class="icon"
          title="关闭"
          aria-hidden="true"
          onClick=${() => this.props.close()}
        >
          <use xlinkHref="#iconguanbi1"></use>
        </svg>
      </div>
      <ul class="ccbim__setting__content">
        ${!1}
        ${
          'dwg' !== this.props.viewer.type &&
          Xh`<li>
          <div class="ccbim__setting__way">显示边框</div>
          <span class="ccbim__setting__tip"
            >显示模型构件的边线，开启后浏览器内存将大幅增加，<br />对于大模型可能会导致浏览器崩溃</span
          >
          <label class="ccbim__setting__switch__label">
            <input
              class="ccbim__setting__switch ccbim__setting__switch__anim"
              type="checkbox"
              checked=${this.state.checkedBorder}
              onChange=${(t) => this.switchBorder(t.target.checked)}
            />
          </label>
        </li>`
        }
        ${
          'dwg' !== this.props.viewer.type &&
          Xh`<li>
          <div class="ccbim__setting__way">显示阴影</div>
          <span class="ccbim__setting__tip">显示地面阴影</span>
          <label class="ccbim__setting__switch__label">
            <input
              class="ccbim__setting__switch ccbim__setting__switch__anim"
              type="checkbox"
              checked=${this.state.checkedShadow}
              onChange=${(t) => this.switchShadow(t.target.checked)}
            />
          </label>
        </li>`
        }

        <li>
          <div class="ccbim__setting__way">显示标记点</div>
          <span class="ccbim__setting__tip">显示模型中的任务和信息标记点</span>
          <label class="ccbim__setting__switch__label">
            <input
              class="ccbim__setting__switch ccbim__setting__switch__anim"
              type="checkbox"
              checked=${this.state.checkedShowPoint}
              onChange=${(t) => this.switchShowPoint(t.target.checked)}
            />
          </label>
        </li>
        ${
          'dwg' !== this.props.viewer.type &&
          Xh`<li>
          <div class="ccbim__setting__way">显示方式</div>
          <span class="ccbim__setting__tip" style="width: 55%"
            >切换模型的显示方式</span
          >
          <label
            class="ccbim__setting__radios__label ccbim__setting__radios__anim"
          >
            <input
              type="radio"
              name="effect"
              checked=${this.state.checkedColor}
              onChange=${(t) => this.radioEffect(t.target.value)}
              value="1"
            /><i class="ccbim__setting__radios"></i>着色
          </label>
          <label
            class="ccbim__setting__radios__label ccbim__setting__radios__anim"
          >
            <input
              type="radio"
              name="effect"
              checked=${this.state.checkedTexture}
              onChange=${(t) => this.radioEffect(t.target.value)}
              value="2"
            /><i class="ccbim__setting__radios"></i>贴图
          </label>
        </li> `
        }
        ${
          'dwg' !== this.props.viewer.type &&
          Xh`<li>
          <div class="ccbim__setting__way">视窗背景</div>
          <span class="ccbim__setting__tip" style="width: 55%"
            >设置视窗的背景</span
          >
          <label
            class="ccbim__setting__radios__label ccbim__setting__radios__anim"
          >
            <input
              type="radio"
              name="bgColor"
              checked=${this.state.pureColor}
              onChange=${(t) => this.radioBgColor(t.target.value)}
              value="1"
            /><i class="ccbim__setting__radios"></i>纯色
          </label>
          <label
            class="ccbim__setting__radios__label ccbim__setting__radios__anim"
          >
            <input
              type="radio"
              name="bgColor"
              checked=${this.state.gradientColor}
              onChange=${(t) => this.radioBgColor(t.target.value)}
              value="2"
            /><i class="ccbim__setting__radios"></i>渐变
          </label>
          ${
            this.state.pureColor &&
            Xh` <div class="colorContent">
            <span
              class="colorShow"
              style="background: linear-gradient(${this.state.pureColorVal}, ${
              this.state.pureColorVal
            })"
            ></span>
            <div class="colorBox">
              <input
                type="color"
                style="width: 110px"
                value=${this.state.pureColorVal}
                onChange=${(t) => this.pureColorChange(t.target.value)}
              />
            </div>
          </div>`
          }
          ${
            this.state.gradientColor &&
            Xh` <div class="colorContent">
            <span
              class="colorShow"
              style="background: linear-gradient(${
                this.state.gradientColorTopVal
              }, ${this.state.gradientColorBottomVal})"
            ></span>
            <div class="colorBox">
              <input
                type="color"
                value=${this.state.gradientColorTopVal}
                onChange=${(t) =>
                  this.gradientColorChange(t.target.value, 'top')}
              />
              <input
                type="color"
                value=${this.state.gradientColorBottomVal}
                onChange=${(t) =>
                  this.gradientColorChange(t.target.value, 'bottom')}
              />
            </div>
          </div>`
          }
        </li>`
        }
      </ul>
      <div
        class="ccbim__common__recoverDefault"
        onClick=${() => this.recoverDefault()}
      >
        <span>恢复默认</span>
      </div>
    </div>`;
    }
  }
  class _v extends Sh {
    constructor(t) {
      super(t);
    }
    render() {
      return Xh`<div class="ccbim__small__progress" id=${
        this.props.parentElementId + '__ccbim__small__progress'
      }>
      <div class="ccbim__small__progress__com">
        <div
          class="ccbim__small__progress__div"
          id=${this.props.parentElementId + '__ccbim__small__progress__div'}
          style="width: 0%"
        ></div>
      </div>
    </div>`;
    }
  }
  const xv = (t, e) => {
      const n = e.x - t.x,
        i = e.y - t.y;
      return Math.sqrt(n * n + i * i);
    },
    wv = (t) => t * (Math.PI / 180),
    Av = (t) => t * (180 / Math.PI),
    Mv = (t, e, n) => {
      const i = e.split(/[ ,]+/g);
      let r;
      for (let e = 0; e < i.length; e += 1)
        (r = i[e]),
          t.addEventListener
            ? t.addEventListener(r, n, !1)
            : t.attachEvent && t.attachEvent(r, n);
    },
    Sv = (t, e, n) => {
      const i = e.split(/[ ,]+/g);
      let r;
      for (let e = 0; e < i.length; e += 1)
        (r = i[e]),
          t.removeEventListener
            ? t.removeEventListener(r, n)
            : t.detachEvent && t.detachEvent(r, n);
    },
    Iv = (t) => (
      t.preventDefault(), t.type.match(/^touch/) ? t.changedTouches : t
    ),
    Ev = () => ({
      x:
        void 0 !== window.pageXOffset
          ? window.pageXOffset
          : (
              document.documentElement ||
              document.body.parentNode ||
              document.body
            ).scrollLeft,
      y:
        void 0 !== window.pageYOffset
          ? window.pageYOffset
          : (
              document.documentElement ||
              document.body.parentNode ||
              document.body
            ).scrollTop,
    }),
    Dv = (t, e) => {
      e.top || e.right || e.bottom || e.left
        ? ((t.style.top = e.top),
          (t.style.right = e.right),
          (t.style.bottom = e.bottom),
          (t.style.left = e.left))
        : ((t.style.left = e.x + 'px'), (t.style.top = e.y + 'px'));
    },
    Cv = (t, e, n) => {
      const i = Tv(t);
      for (let t in i)
        if (i.hasOwnProperty(t))
          if ('string' == typeof e) i[t] = e + ' ' + n;
          else {
            let r = '';
            for (let t = 0, i = e.length; t < i; t += 1)
              r += e[t] + ' ' + n + ', ';
            i[t] = r.slice(0, -2);
          }
      return i;
    },
    Tv = (t) => {
      const e = {};
      e[t] = '';
      return (
        ['webkit', 'Moz', 'o'].forEach(function (n) {
          e[n + t.charAt(0).toUpperCase() + t.slice(1)] = '';
        }),
        e
      );
    },
    Lv = (t, e) => {
      for (let n in e) e.hasOwnProperty(n) && (t[n] = e[n]);
      return t;
    },
    Rv = (t, e) => {
      if (t.length) for (let n = 0, i = t.length; n < i; n += 1) e(t[n]);
      else e(t);
    };
  var Fv,
    Pv = !!('ontouchstart' in window),
    Bv = !!window.PointerEvent,
    Ov = !!window.MSPointerEvent,
    Vv = { start: 'mousedown', move: 'mousemove', end: 'mouseup' },
    Nv = {};
  function kv() {}
  function Uv(t, e) {
    return (
      (this.identifier = e.identifier),
      (this.position = e.position),
      (this.frontPosition = e.frontPosition),
      (this.collection = t),
      (this.defaults = {
        size: 100,
        threshold: 0.1,
        color: 'white',
        fadeTime: 250,
        dataOnly: !1,
        restJoystick: !0,
        restOpacity: 0.5,
        mode: 'dynamic',
        zone: document.body,
        lockX: !1,
        lockY: !1,
        shape: 'circle',
      }),
      this.config(e),
      'dynamic' === this.options.mode && (this.options.restOpacity = 0),
      (this.id = Uv.id),
      (Uv.id += 1),
      this.buildEl().stylize(),
      (this.instance = {
        el: this.ui.el,
        on: this.on.bind(this),
        off: this.off.bind(this),
        show: this.show.bind(this),
        hide: this.hide.bind(this),
        add: this.addToDom.bind(this),
        remove: this.removeFromDom.bind(this),
        destroy: this.destroy.bind(this),
        setPosition: this.setPosition.bind(this),
        resetDirection: this.resetDirection.bind(this),
        computeDirection: this.computeDirection.bind(this),
        trigger: this.trigger.bind(this),
        position: this.position,
        frontPosition: this.frontPosition,
        ui: this.ui,
        identifier: this.identifier,
        id: this.id,
        options: this.options,
      }),
      this.instance
    );
  }
  function Gv(t, e) {
    var n = this;
    return (
      (n.nipples = []),
      (n.idles = []),
      (n.actives = []),
      (n.ids = []),
      (n.pressureIntervals = {}),
      (n.manager = t),
      (n.id = Gv.id),
      (Gv.id += 1),
      (n.defaults = {
        zone: document.body,
        multitouch: !1,
        maxNumberOfNipples: 10,
        mode: 'dynamic',
        position: { top: 0, left: 0 },
        catchDistance: 200,
        size: 100,
        threshold: 0.1,
        color: 'white',
        fadeTime: 250,
        dataOnly: !1,
        restJoystick: !0,
        restOpacity: 0.5,
        lockX: !1,
        lockY: !1,
        shape: 'circle',
        dynamicPage: !1,
      }),
      n.config(e),
      ('static' !== n.options.mode && 'semi' !== n.options.mode) ||
        (n.options.multitouch = !1),
      n.options.multitouch || (n.options.maxNumberOfNipples = 1),
      n.updateBox(),
      n.prepareNipples(),
      n.bindings(),
      n.begin(),
      n.nipples
    );
  }
  function zv(t) {
    var e,
      n = this;
    return (
      (n.ids = {}),
      (n.index = 0),
      (n.collections = []),
      n.config(t),
      n.prepareCollections(),
      Mv(window, 'resize', function (t) {
        clearTimeout(e),
          (e = setTimeout(function () {
            var t,
              e = Ev();
            n.collections.forEach(function (n) {
              n.forEach(function (n) {
                (t = n.el.getBoundingClientRect()),
                  (n.position = { x: e.x + t.left, y: e.y + t.top });
              });
            });
          }, 100));
      }),
      n.collections
    );
  }
  Bv
    ? (Fv = {
        start: 'pointerdown',
        move: 'pointermove',
        end: 'pointerup, pointercancel',
      })
    : Ov
    ? (Fv = {
        start: 'MSPointerDown',
        move: 'MSPointerMove',
        end: 'MSPointerUp',
      })
    : Pv
    ? ((Fv = {
        start: 'touchstart',
        move: 'touchmove',
        end: 'touchend, touchcancel',
      }),
      (Nv = Vv))
    : (Fv = Vv),
    (kv.prototype.on = function (t, e) {
      var n,
        i = this,
        r = t.split(/[ ,]+/g);
      i._handlers_ = i._handlers_ || {};
      for (var o = 0; o < r.length; o += 1)
        (n = r[o]),
          (i._handlers_[n] = i._handlers_[n] || []),
          i._handlers_[n].push(e);
      return i;
    }),
    (kv.prototype.off = function (t, e) {
      var n = this;
      return (
        (n._handlers_ = n._handlers_ || {}),
        void 0 === t
          ? (n._handlers_ = {})
          : void 0 === e
          ? (n._handlers_[t] = null)
          : n._handlers_[t] &&
            n._handlers_[t].indexOf(e) >= 0 &&
            n._handlers_[t].splice(n._handlers_[t].indexOf(e), 1),
        n
      );
    }),
    (kv.prototype.trigger = function (t, e) {
      var n,
        i = this,
        r = t.split(/[ ,]+/g);
      i._handlers_ = i._handlers_ || {};
      for (var o = 0; o < r.length; o += 1)
        (n = r[o]),
          i._handlers_[n] &&
            i._handlers_[n].length &&
            i._handlers_[n].forEach(function (t) {
              t.call(i, { type: n, target: i }, e);
            });
    }),
    (kv.prototype.config = function (t) {
      var e = this;
      (e.options = e.defaults || {}),
        t &&
          (e.options = ((t, e) => {
            const n = {};
            for (let i in t)
              t.hasOwnProperty(i) && e.hasOwnProperty(i)
                ? (n[i] = e[i])
                : t.hasOwnProperty(i) && (n[i] = t[i]);
            return n;
          })(e.options, t));
    }),
    (kv.prototype.bindEvt = function (t, e) {
      var n = this;
      return (
        (n._domHandlers_ = n._domHandlers_ || {}),
        (n._domHandlers_[e] = function () {
          'function' == typeof n['on' + e]
            ? n['on' + e].apply(n, arguments)
            : console.warn('[WARNING] : Missing "on' + e + '" handler.');
        }),
        Mv(t, Fv[e], n._domHandlers_[e]),
        Nv[e] && Mv(t, Nv[e], n._domHandlers_[e]),
        n
      );
    }),
    (kv.prototype.unbindEvt = function (t, e) {
      var n = this;
      return (
        (n._domHandlers_ = n._domHandlers_ || {}),
        Sv(t, Fv[e], n._domHandlers_[e]),
        Nv[e] && Sv(t, Nv[e], n._domHandlers_[e]),
        delete n._domHandlers_[e],
        this
      );
    }),
    (Uv.prototype = new kv()),
    (Uv.constructor = Uv),
    (Uv.id = 0),
    (Uv.prototype.buildEl = function (t) {
      return (
        (this.ui = {}),
        this.options.dataOnly ||
          ((this.ui.el = document.createElement('div')),
          (this.ui.back = document.createElement('div')),
          (this.ui.front = document.createElement('div')),
          (this.ui.el.className = 'nipple collection_' + this.collection.id),
          (this.ui.back.className = 'back'),
          (this.ui.front.className = 'front'),
          this.ui.el.setAttribute(
            'id',
            'nipple_' + this.collection.id + '_' + this.id,
          ),
          this.ui.el.appendChild(this.ui.back),
          this.ui.el.appendChild(this.ui.front)),
        this
      );
    }),
    (Uv.prototype.stylize = function () {
      if (this.options.dataOnly) return this;
      var t = this.options.fadeTime + 'ms',
        e = ((t, e) => {
          const n = Tv(t);
          for (let t in n) n.hasOwnProperty(t) && (n[t] = e);
          return n;
        })('borderRadius', '50%'),
        n = Cv('transition', 'opacity', t),
        i = {};
      return (
        (i.el = {
          position: 'absolute',
          opacity: this.options.restOpacity,
          display: 'block',
          zIndex: 999,
        }),
        (i.back = {
          position: 'absolute',
          display: 'block',
          width: this.options.size + 'px',
          height: this.options.size + 'px',
          marginLeft: -this.options.size / 2 + 'px',
          marginTop: -this.options.size / 2 + 'px',
          background: this.options.color,
          opacity: '.5',
        }),
        (i.front = {
          width: this.options.size / 2 + 'px',
          height: this.options.size / 2 + 'px',
          position: 'absolute',
          display: 'block',
          marginLeft: -this.options.size / 4 + 'px',
          marginTop: -this.options.size / 4 + 'px',
          background: this.options.color,
          opacity: '.5',
        }),
        Lv(i.el, n),
        'circle' === this.options.shape && Lv(i.back, e),
        Lv(i.front, e),
        this.applyStyles(i),
        this
      );
    }),
    (Uv.prototype.applyStyles = function (t) {
      for (var e in this.ui)
        if (this.ui.hasOwnProperty(e))
          for (var n in t[e]) this.ui[e].style[n] = t[e][n];
      return this;
    }),
    (Uv.prototype.addToDom = function () {
      return (
        this.options.dataOnly ||
          document.body.contains(this.ui.el) ||
          this.options.zone.appendChild(this.ui.el),
        this
      );
    }),
    (Uv.prototype.removeFromDom = function () {
      return (
        this.options.dataOnly ||
          !document.body.contains(this.ui.el) ||
          this.options.zone.removeChild(this.ui.el),
        this
      );
    }),
    (Uv.prototype.destroy = function () {
      clearTimeout(this.removeTimeout),
        clearTimeout(this.showTimeout),
        clearTimeout(this.restTimeout),
        this.trigger('destroyed', this.instance),
        this.removeFromDom(),
        this.off();
    }),
    (Uv.prototype.show = function (t) {
      var e = this;
      return (
        e.options.dataOnly ||
          (clearTimeout(e.removeTimeout),
          clearTimeout(e.showTimeout),
          clearTimeout(e.restTimeout),
          e.addToDom(),
          e.restCallback(),
          setTimeout(function () {
            e.ui.el.style.opacity = 1;
          }, 0),
          (e.showTimeout = setTimeout(function () {
            e.trigger('shown', e.instance),
              'function' == typeof t && t.call(this);
          }, e.options.fadeTime))),
        e
      );
    }),
    (Uv.prototype.hide = function (t) {
      var e = this;
      return (
        e.options.dataOnly ||
          ((e.ui.el.style.opacity = e.options.restOpacity),
          clearTimeout(e.removeTimeout),
          clearTimeout(e.showTimeout),
          clearTimeout(e.restTimeout),
          (e.removeTimeout = setTimeout(function () {
            var n = 'dynamic' === e.options.mode ? 'none' : 'block';
            (e.ui.el.style.display = n),
              'function' == typeof t && t.call(e),
              e.trigger('hidden', e.instance);
          }, e.options.fadeTime)),
          e.options.restJoystick && e.setPosition(t, { x: 0, y: 0 })),
        e
      );
    }),
    (Uv.prototype.setPosition = function (t, e) {
      var n = this;
      n.frontPosition = { x: e.x, y: e.y };
      var i = n.options.fadeTime + 'ms',
        r = {};
      r.front = Cv('transition', ['top', 'left'], i);
      var o = { front: {} };
      (o.front = {
        left: n.frontPosition.x + 'px',
        top: n.frontPosition.y + 'px',
      }),
        n.applyStyles(r),
        n.applyStyles(o),
        (n.restTimeout = setTimeout(function () {
          'function' == typeof t && t.call(n), n.restCallback();
        }, n.options.fadeTime));
    }),
    (Uv.prototype.restCallback = function () {
      var t = this,
        e = {};
      (e.front = Cv('transition', 'none', '')),
        t.applyStyles(e),
        t.trigger('rested', t.instance);
    }),
    (Uv.prototype.resetDirection = function () {
      this.direction = { x: !1, y: !1, angle: !1 };
    }),
    (Uv.prototype.computeDirection = function (t) {
      var e,
        n,
        i,
        r = t.angle.radian,
        o = Math.PI / 4,
        s = Math.PI / 2;
      if (
        (r > o && r < 3 * o && !t.lockX
          ? (e = 'up')
          : r > -o && r <= o && !t.lockY
          ? (e = 'left')
          : r > 3 * -o && r <= -o && !t.lockX
          ? (e = 'down')
          : t.lockY || (e = 'right'),
        t.lockY || (n = r > -s && r < s ? 'left' : 'right'),
        t.lockX || (i = r > 0 ? 'up' : 'down'),
        t.force > this.options.threshold)
      ) {
        var a,
          c = {};
        for (a in this.direction)
          this.direction.hasOwnProperty(a) && (c[a] = this.direction[a]);
        var l = {};
        for (a in ((this.direction = { x: n, y: i, angle: e }),
        (t.direction = this.direction),
        c))
          c[a] === this.direction[a] && (l[a] = !0);
        if (l.x && l.y && l.angle) return t;
        (l.x && l.y) || this.trigger('plain', t),
          l.x || this.trigger('plain:' + n, t),
          l.y || this.trigger('plain:' + i, t),
          l.angle || this.trigger('dir dir:' + e, t);
      } else this.resetDirection();
      return t;
    }),
    (Gv.prototype = new kv()),
    (Gv.constructor = Gv),
    (Gv.id = 0),
    (Gv.prototype.prepareNipples = function () {
      var t = this,
        e = t.nipples;
      (e.on = t.on.bind(t)),
        (e.off = t.off.bind(t)),
        (e.options = t.options),
        (e.destroy = t.destroy.bind(t)),
        (e.ids = t.ids),
        (e.id = t.id),
        (e.processOnMove = t.processOnMove.bind(t)),
        (e.processOnEnd = t.processOnEnd.bind(t)),
        (e.get = function (t) {
          if (void 0 === t) return e[0];
          for (var n = 0, i = e.length; n < i; n += 1)
            if (e[n].identifier === t) return e[n];
          return !1;
        });
    }),
    (Gv.prototype.bindings = function () {
      var t = this;
      t.bindEvt(t.options.zone, 'start'),
        (t.options.zone.style.touchAction = 'none'),
        (t.options.zone.style.msTouchAction = 'none');
    }),
    (Gv.prototype.begin = function () {
      var t = this,
        e = t.options;
      if ('static' === e.mode) {
        var n = t.createNipple(e.position, t.manager.getIdentifier());
        n.add(), t.idles.push(n);
      }
    }),
    (Gv.prototype.createNipple = function (t, e) {
      var n = this,
        i = Ev(),
        r = {},
        o = n.options;
      if (t.x && t.y)
        r = { x: t.x - (i.x + n.box.left), y: t.y - (i.y + n.box.top) };
      else if (t.top || t.right || t.bottom || t.left) {
        var s = document.createElement('DIV');
        (s.style.display = 'hidden'),
          (s.style.top = t.top),
          (s.style.right = t.right),
          (s.style.bottom = t.bottom),
          (s.style.left = t.left),
          (s.style.position = 'absolute'),
          o.zone.appendChild(s);
        var a = s.getBoundingClientRect();
        o.zone.removeChild(s),
          (r = t),
          (t = { x: a.left + i.x, y: a.top + i.y });
      }
      var c = new Uv(n, {
        color: o.color,
        size: o.size,
        threshold: o.threshold,
        fadeTime: o.fadeTime,
        dataOnly: o.dataOnly,
        restJoystick: o.restJoystick,
        restOpacity: o.restOpacity,
        mode: o.mode,
        identifier: e,
        position: t,
        zone: o.zone,
        frontPosition: { x: 0, y: 0 },
        shape: o.shape,
      });
      return (
        o.dataOnly || (Dv(c.ui.el, r), Dv(c.ui.front, c.frontPosition)),
        n.nipples.push(c),
        n.trigger('added ' + c.identifier + ':added', c),
        n.manager.trigger('added ' + c.identifier + ':added', c),
        n.bindNipple(c),
        c
      );
    }),
    (Gv.prototype.updateBox = function () {
      this.box = this.options.zone.getBoundingClientRect();
    }),
    (Gv.prototype.bindNipple = function (t) {
      var e,
        n = this,
        i = function (t, i) {
          (e = t.type + ' ' + i.id + ':' + t.type), n.trigger(e, i);
        };
      t.on('destroyed', n.onDestroyed.bind(n)),
        t.on('shown hidden rested dir plain', i),
        t.on('dir:up dir:right dir:down dir:left', i),
        t.on('plain:up plain:right plain:down plain:left', i);
    }),
    (Gv.prototype.pressureFn = function (t, e, n) {
      var i = this,
        r = 0;
      clearInterval(i.pressureIntervals[n]),
        (i.pressureIntervals[n] = setInterval(
          function () {
            var n = t.force || t.pressure || t.webkitForce || 0;
            n !== r &&
              (e.trigger('pressure', n),
              i.trigger('pressure ' + e.identifier + ':pressure', n),
              (r = n));
          }.bind(i),
          100,
        ));
    }),
    (Gv.prototype.onstart = function (t) {
      var e = this,
        n = e.options,
        i = t;
      (t = Iv(t)), e.updateBox();
      return (
        Rv(t, function (r) {
          e.actives.length < n.maxNumberOfNipples
            ? e.processOnStart(r)
            : i.type.match(/^touch/) &&
              (Object.keys(e.manager.ids).forEach(function (n) {
                if (
                  Object.values(i.touches).findIndex(function (t) {
                    return t.identifier === n;
                  }) < 0
                ) {
                  var r = [t[0]];
                  (r.identifier = n), e.processOnEnd(r);
                }
              }),
              e.actives.length < n.maxNumberOfNipples && e.processOnStart(r));
        }),
        e.manager.bindDocument(),
        !1
      );
    }),
    (Gv.prototype.processOnStart = function (t) {
      var e,
        n = this,
        i = n.options,
        r = n.manager.getIdentifier(t),
        o = t.force || t.pressure || t.webkitForce || 0,
        s = { x: t.pageX, y: t.pageY },
        a = n.getOrCreate(r, s);
      a.identifier !== r && n.manager.removeIdentifier(a.identifier),
        (a.identifier = r);
      var c = function (e) {
        e.trigger('start', e),
          n.trigger('start ' + e.id + ':start', e),
          e.show(),
          o > 0 && n.pressureFn(t, e, e.identifier),
          n.processOnMove(t);
      };
      if (
        ((e = n.idles.indexOf(a)) >= 0 && n.idles.splice(e, 1),
        n.actives.push(a),
        n.ids.push(a.identifier),
        'semi' !== i.mode)
      )
        c(a);
      else {
        if (!(xv(s, a.position) <= i.catchDistance))
          return a.destroy(), void n.processOnStart(t);
        c(a);
      }
      return a;
    }),
    (Gv.prototype.getOrCreate = function (t, e) {
      var n,
        i = this,
        r = i.options;
      return /(semi|static)/.test(r.mode)
        ? (n = i.idles[0])
          ? (i.idles.splice(0, 1), n)
          : 'semi' === r.mode
          ? i.createNipple(e, t)
          : (console.warn("Coudln't find the needed nipple."), !1)
        : (n = i.createNipple(e, t));
    }),
    (Gv.prototype.processOnMove = function (t) {
      var e = this,
        n = e.options,
        i = e.manager.getIdentifier(t),
        r = e.nipples.get(i);
      if (((t) => (isNaN(t.buttons) ? 0 !== t.pressure : 0 !== t.buttons))(t)) {
        if (!r)
          return (
            console.error('Found zombie joystick with ID ' + i),
            void e.manager.removeIdentifier(i)
          );
        if (n.dynamicPage) {
          var o = Ev();
          (a = r.el.getBoundingClientRect()),
            (r.position = { x: o.x + a.left, y: o.y + a.top });
        }
        r.identifier = i;
        var s = r.options.size / 2,
          a = { x: t.pageX, y: t.pageY };
        n.lockX && (a.y = r.position.y), n.lockY && (a.x = r.position.x);
        var c = xv(a, r.position),
          l = ((t, e) => {
            const n = e.x - t.x,
              i = e.y - t.y;
            return Av(Math.atan2(i, n));
          })(a, r.position),
          h = wv(l),
          u = c / s,
          d = { distance: c, position: a };
        'circle' === r.options.shape
          ? ((c = Math.min(c, s)),
            (a = ((t, e, n) => {
              const i = { x: 0, y: 0 };
              return (
                (n = wv(n)),
                (i.x = t.x - e * Math.cos(n)),
                (i.y = t.y - e * Math.sin(n)),
                i
              );
            })(r.position, c, l)))
          : ((a = ((t, e, n) => ({
              x: Math.min(Math.max(t.x, e.x - n), e.x + n),
              y: Math.min(Math.max(t.y, e.y - n), e.y + n),
            }))(a, r.position, s)),
            (c = xv(a, r.position)));
        var p = a.x - r.position.x,
          f = a.y - r.position.y;
        (r.frontPosition = { x: p, y: f }),
          n.dataOnly || Dv(r.ui.front, r.frontPosition);
        var m = {
          identifier: r.identifier,
          position: a,
          force: u,
          pressure: t.force || t.pressure || t.webkitForce || 0,
          distance: c,
          angle: { radian: h, degree: l },
          vector: { x: p / s, y: -f / s },
          raw: d,
          instance: r,
          lockX: n.lockX,
          lockY: n.lockY,
        };
        ((m = r.computeDirection(m)).angle = {
          radian: wv(180 - l),
          degree: 180 - l,
        }),
          r.trigger('move', m),
          e.trigger('move ' + r.id + ':move', m);
      } else this.processOnEnd(t);
    }),
    (Gv.prototype.processOnEnd = function (t) {
      var e = this,
        n = e.options,
        i = e.manager.getIdentifier(t),
        r = e.nipples.get(i),
        o = e.manager.removeIdentifier(r.identifier);
      r &&
        (n.dataOnly ||
          r.hide(function () {
            'dynamic' === n.mode &&
              (r.trigger('removed', r),
              e.trigger('removed ' + r.id + ':removed', r),
              e.manager.trigger('removed ' + r.id + ':removed', r),
              r.destroy());
          }),
        clearInterval(e.pressureIntervals[r.identifier]),
        r.resetDirection(),
        r.trigger('end', r),
        e.trigger('end ' + r.id + ':end', r),
        e.ids.indexOf(r.identifier) >= 0 &&
          e.ids.splice(e.ids.indexOf(r.identifier), 1),
        e.actives.indexOf(r) >= 0 && e.actives.splice(e.actives.indexOf(r), 1),
        /(semi|static)/.test(n.mode)
          ? e.idles.push(r)
          : e.nipples.indexOf(r) >= 0 &&
            e.nipples.splice(e.nipples.indexOf(r), 1),
        e.manager.unbindDocument(),
        /(semi|static)/.test(n.mode) && (e.manager.ids[o.id] = o.identifier));
    }),
    (Gv.prototype.onDestroyed = function (t, e) {
      var n = this;
      n.nipples.indexOf(e) >= 0 && n.nipples.splice(n.nipples.indexOf(e), 1),
        n.actives.indexOf(e) >= 0 && n.actives.splice(n.actives.indexOf(e), 1),
        n.idles.indexOf(e) >= 0 && n.idles.splice(n.idles.indexOf(e), 1),
        n.ids.indexOf(e.identifier) >= 0 &&
          n.ids.splice(n.ids.indexOf(e.identifier), 1),
        n.manager.removeIdentifier(e.identifier),
        n.manager.unbindDocument();
    }),
    (Gv.prototype.destroy = function () {
      var t = this;
      for (var e in (t.unbindEvt(t.options.zone, 'start'),
      t.nipples.forEach(function (t) {
        t.destroy();
      }),
      t.pressureIntervals))
        t.pressureIntervals.hasOwnProperty(e) &&
          clearInterval(t.pressureIntervals[e]);
      t.trigger('destroyed', t.nipples), t.manager.unbindDocument(), t.off();
    }),
    (zv.prototype = new kv()),
    (zv.constructor = zv),
    (zv.prototype.prepareCollections = function () {
      var t = this;
      (t.collections.create = t.create.bind(t)),
        (t.collections.on = t.on.bind(t)),
        (t.collections.off = t.off.bind(t)),
        (t.collections.destroy = t.destroy.bind(t)),
        (t.collections.get = function (e) {
          var n;
          return (
            t.collections.every(function (t) {
              return !(n = t.get(e));
            }),
            n
          );
        });
    }),
    (zv.prototype.create = function (t) {
      return this.createCollection(t);
    }),
    (zv.prototype.createCollection = function (t) {
      var e = this,
        n = new Gv(e, t);
      return e.bindCollection(n), e.collections.push(n), n;
    }),
    (zv.prototype.bindCollection = function (t) {
      var e,
        n = this,
        i = function (t, i) {
          (e = t.type + ' ' + i.id + ':' + t.type), n.trigger(e, i);
        };
      t.on('destroyed', n.onDestroyed.bind(n)),
        t.on('shown hidden rested dir plain', i),
        t.on('dir:up dir:right dir:down dir:left', i),
        t.on('plain:up plain:right plain:down plain:left', i);
    }),
    (zv.prototype.bindDocument = function () {
      var t = this;
      t.binded ||
        (t.bindEvt(document, 'move').bindEvt(document, 'end'), (t.binded = !0));
    }),
    (zv.prototype.unbindDocument = function (t) {
      var e = this;
      (Object.keys(e.ids).length && !0 !== t) ||
        (e.unbindEvt(document, 'move').unbindEvt(document, 'end'),
        (e.binded = !1));
    }),
    (zv.prototype.getIdentifier = function (t) {
      var e;
      return (
        t
          ? void 0 ===
              (e = void 0 === t.identifier ? t.pointerId : t.identifier) &&
            (e = this.latest || 0)
          : (e = this.index),
        void 0 === this.ids[e] &&
          ((this.ids[e] = this.index), (this.index += 1)),
        (this.latest = e),
        this.ids[e]
      );
    }),
    (zv.prototype.removeIdentifier = function (t) {
      var e = {};
      for (var n in this.ids)
        if (this.ids[n] === t) {
          (e.id = n), (e.identifier = this.ids[n]), delete this.ids[n];
          break;
        }
      return e;
    }),
    (zv.prototype.onmove = function (t) {
      return this.onAny('move', t), !1;
    }),
    (zv.prototype.onend = function (t) {
      return this.onAny('end', t), !1;
    }),
    (zv.prototype.oncancel = function (t) {
      return this.onAny('end', t), !1;
    }),
    (zv.prototype.onAny = function (t, e) {
      var n,
        i = this,
        r = 'processOn' + t.charAt(0).toUpperCase() + t.slice(1);
      e = Iv(e);
      var o = function (t, e, n) {
        n.ids.indexOf(e) >= 0 && (n[r](t), (t._found_ = !0));
      };
      return (
        Rv(e, function (t) {
          (n = i.getIdentifier(t)),
            Rv(i.collections, o.bind(null, t, n)),
            t._found_ || i.removeIdentifier(n);
        }),
        !1
      );
    }),
    (zv.prototype.destroy = function () {
      var t = this;
      t.unbindDocument(!0),
        (t.ids = {}),
        (t.index = 0),
        t.collections.forEach(function (t) {
          t.destroy();
        }),
        t.off();
    }),
    (zv.prototype.onDestroyed = function (t, e) {
      var n = this;
      if (n.collections.indexOf(e) < 0) return !1;
      n.collections.splice(n.collections.indexOf(e), 1);
    });
  const jv = new zv();
  var Hv = function (t) {
    return jv.create(t);
  };
  function Wv(t, e) {
    (this.type = 'joystick'),
      (this.options = t),
      (this.manager = null),
      (this.operator = e);
  }
  Wv.prototype = {
    constructor: Wv,
    init: function () {
      (this.manager = Hv(this.options)), this._on();
    },
    _on: function () {
      this.manager
        .on('move', (t, e) => {
          e.direction &&
            this._onMove(
              e.direction.angle,
              e.distance,
              e.instance.options.size / 2,
            );
        })
        .on('end', () => {
          this._onEnd();
        });
    },
    _onMove: function (t, e, n) {
      let i = e.toFixed(1) / 100;
      if (e === n) {
        i = this.operator.getSpeed() + 0.1;
      }
      switch ((console.log(i), t)) {
        case 'up':
          this.operator.changeSpeed(i), this.operator.startWalk('front');
          break;
        case 'right':
          this.operator.changeSpeed(i), this.operator.startWalk('right');
          break;
        case 'left':
          this.operator.changeSpeed(i), this.operator.startWalk('left');
          break;
        case 'down':
          this.operator.changeSpeed(i), this.operator.startWalk('back');
      }
    },
    _onEnd: function () {
      this.operator.stopWalk('front'),
        this.operator.stopWalk('right'),
        this.operator.stopWalk('left'),
        this.operator.stopWalk('back');
    },
    destroy: function () {
      this.manager.destroy();
    },
  };
  let Xv = 1,
    Zv = 2,
    Yv = 4,
    qv = 8,
    Qv = 16,
    Jv = 32,
    $v = Xv,
    Kv = Zv,
    t_ = Yv,
    e_ = qv,
    n_ = Qv,
    i_ = Jv,
    r_ = Zv | Xv,
    o_ = qv | Xv,
    s_ = Zv | Yv,
    a_ = qv | Yv;
  function c_(t) {
    Hy.call(this), (this.bimViewer = t), (this.gravity = !1), (this.speed = 1);
  }
  c_.prototype = Object.assign(Object.create(Hy.prototype), {
    constructor: c_,
    setGravity: function (t) {
      this.gravity = t;
    },
    changeSpeed: function (t) {
      (this.speed = t),
        this.speed <= 0 && (this.speed = 0.1),
        this.speed >= 999 && (this.speed = 999);
      let e = this.bimViewer.getMainCamera(),
        n = new J(0, 0, 0);
      e.position.distanceTo(n);
      this.speed;
    },
    getSpeed: function () {
      return this.speed;
    },
    onMouseWheel: function () {},
    onKeyDown: function () {},
    onKeyUp: function () {},
    onTouchStart: function (t) {
      t.stopPropagation(),
        (t.offsetX = t.touches[0].pageX),
        (t.offsetY = t.touches[0].pageY),
        this.getMouseWindowPos(t, this.lastWindowPos),
        this.setStarted(!0);
    },
    onTouchEnd: function (t) {
      t.stopPropagation(), this.setStarted(!1);
    },
    onTouchMove: function (t) {
      t.preventDefault(),
        t.stopPropagation(),
        this.getStarted() &&
          ((t.offsetX = t.touches[0].pageX),
          (t.offsetY = t.touches[0].pageY),
          this.onLButtonDownAndMove(t));
    },
    getKeyDirection: function (t) {
      let e = 0;
      switch (t) {
        case 'front':
          e = Xv;
          break;
        case 'left':
          e = Zv;
          break;
        case 'back':
          e = Yv;
          break;
        case 'right':
          e = qv;
          break;
        case 'up':
          e = Qv;
          break;
        case 'down':
          e = Jv;
      }
      return e;
    },
    startWalk: function (t) {
      let e = this.getKeyDirection(t);
      if (0 !== e) {
        for (let t = 0, n = this.directionStack.length; t < n; ++t)
          if (this.directionStack[t] === e) {
            this.directionStack.splice(t, 1);
            break;
          }
        this.directionStack.push(e),
          (this.currentDirection = this.getWalkDirection(this.directionStack));
      }
    },
    stopWalk: function (t) {
      let e = this.getKeyDirection(t);
      if (0 !== e) {
        for (let t = 0, n = this.directionStack.length; t < n; ++t)
          if (this.directionStack[t] === e) {
            this.directionStack.splice(t, 1);
            break;
          }
        this.currentDirection = this.getWalkDirection(this.directionStack);
      }
    },
    onFrame: (function () {
      let t = new J(),
        e = new J(),
        n = new J(),
        i = new J(),
        r = new Y();
      function o(t, e) {
        return t.distance - e.distance;
      }
      return function () {
        if (0 === this.currentDirection) return;
        let s = this.getViewer(),
          a = s.getMainCamera();
        switch (
          (e.subVectors(a.target, a.position).normalize(),
          i.copy(a.up),
          n.crossVectors(i, e).normalize(),
          t.set(0, 0, 0),
          this.currentDirection)
        ) {
          case $v:
            t.copy(e), (t.z = 0), Xf.isZeroVector3(t) && t.copy(i);
            break;
          case Kv:
            t.copy(n);
            break;
          case t_:
            t.set(-e.x, -e.y, -e.z),
              (t.z = 0),
              Xf.isZeroVector3(t) && t.set(-i.x, -i.y, -i.z);
            break;
          case e_:
            t.set(-n.x, -n.y, -n.z);
            break;
          case n_:
            t.set(0, 0, 1);
            break;
          case i_:
            t.set(0, 0, -1);
            break;
          case r_:
            t.copy(e),
              (t.z = 0),
              Xf.isZeroVector3(t) && t.copy(i),
              r.setFromAxisAngle(Xf.zAxis, Math.PI / 4),
              t.applyQuaternion(r);
            break;
          case o_:
            t.copy(e),
              (t.z = 0),
              Xf.isZeroVector3(t) && t.copy(i),
              r.setFromAxisAngle(Xf.zAxis, -Math.PI / 4),
              t.applyQuaternion(r);
            break;
          case s_:
            t.copy(n),
              r.setFromAxisAngle(Xf.zAxis, Math.PI / 4),
              t.applyQuaternion(r);
            break;
          case a_:
            t.set(-n.x, -n.y, -n.z),
              r.setFromAxisAngle(Xf.zAxis, -Math.PI / 4),
              t.applyQuaternion(r);
        }
        if (
          (t.normalize().multiplyScalar(this.speed), a.makePan(t), this.gravity)
        ) {
          const t = (function (t, e) {
            const n = new gl(t, new J(0, 0, -1), 0, 1e3);
            let i = [];
            const r = e.getModelScene().getModelArray();
            let s = [];
            for (let t = 0, e = r.length; t < e; ++t)
              s.push(r[t].getSceneNode());
            for (let t = 0; t < s.length; ++t) {
              let e = s[t].children;
              for (let t = 0, n = e.length; t < n; ++t) {
                let n = e[t];
                n.isPMSceneNode && s.push(n);
              }
              let r = s[t].getEntityArray();
              for (let t = 0, e = r.length; t < e; ++t) {
                let e = r[t].raycast(n);
                e && ((e.entity = r[t]), i.push(e));
              }
            }
            return i.sort(o), i.length > 0 ? i[0] : null;
          })(a.position, s);
          t && a.position.setZ(a.position.z - t.distance + 1);
        }
        this.getViewer().cameraChanged();
      };
    })(),
  });
  class l_ extends Sh {
    constructor(t) {
      super(t),
        (this.state = { gravityVisivle: !1 }),
        (this.cameraWalkOperator = null);
    }
    setGravity() {
      this.state.gravityVisivle
        ? (this.setState({ gravityVisivle: !1 }),
          this.cameraWalkOperator.setGravity(!1))
        : (this.setState({ gravityVisivle: !0 }),
          this.cameraWalkOperator.setGravity(!0));
    }
    componentDidMount() {
      (this.cameraWalkOperator = new c_(this.props.viewer.bimViewer)),
        this.props.viewer.bimViewer.setOperator(this.cameraWalkOperator),
        new Wv(
          {
            zone: document.getElementById('ccbim__joystick'),
            mode: 'static',
            position: { left: '50%', top: '50%' },
            size: 88,
            color: '#9e9e9e',
          },
          this.cameraWalkOperator,
        ).init();
    }
    componentWillUnmount() {
      this.props.viewer.bimViewer.setOperator(new Pg());
    }
    render() {
      return Xh`<${Mh}>
      <div class="ccbim__roamPhone">
        <div class="ccbim__roamPhone__upDown">
          <svg class="icon" 
            onTouchStart=${(t) => {
              t.preventDefault(), this.cameraWalkOperator.startWalk('up');
            }} 
            onTouchEnd=${() => {
              this.cameraWalkOperator.stopWalk('up');
            }}
            onTouchCancel=${() => {
              this.cameraWalkOperator.stopWalk('up');
            }}>
            <use xlinkHref="#iconshang"></use>
          </svg>
          <svg class="icon"
            onTouchStart=${(t) => {
              t.preventDefault(), this.cameraWalkOperator.startWalk('down');
            }} 
            onTouchEnd=${() => {
              this.cameraWalkOperator.stopWalk('down');
            }}
            onTouchCancel=${() => {
              this.cameraWalkOperator.stopWalk('down');
            }}>
            <use xlinkHref="#iconxia"></use>
          </svg>
        </div>
        <div class=${
          this.state.gravityVisivle
            ? ' ccbim__roamPhone__gravity on'
            : 'ccbim__roamPhone__gravity'
        } onClick=${() => this.setGravity()}>
          <svg class="icon">
            <use xlinkHref="#iconzhongli"></use>
          </svg>
        </div>
        <div class="ccbim__joystick" id="ccbim__joystick"></div>
      </div>
    </${Mh}>`;
    }
  }
  class h_ extends Sh {
    constructor(t) {
      super(t),
        (this.state = { show: !1, dwgLayoutArr: [], selectOn: '' }),
        (h_.changeDwgLayout = this.changeDwgLayout.bind(this));
    }
    switchShow() {
      this.setState({ show: !this.state.show });
    }
    getCameraPosition() {
      let t = this.props.viewer.scale,
        e = this.state.dwgLayoutArr;
      for (let n = 0; n < e.length; n++) {
        let i = e[n];
        if (i.name === this.state.selectOn) {
          const e = this.props.viewer.bimViewer.getMainCamera();
          let n = {
            position: {
              x: e.position.x / t,
              y: e.position.y / t,
              z: e.position.z / t,
            },
            target: { x: e.target.x / t, y: e.target.y / t, z: e.target.z / t },
            up: e.up,
          };
          i.cameraView = n;
        }
      }
      this.setState({ dwgLayoutArr: e });
    }
    setCameraView(t, e, n) {
      let i = this.props.viewer.bimViewer.getMainCamera(),
        r = this.props.viewer.scale;
      (e.x = e.x * r),
        (e.y = e.y * r),
        (e.z = e.z * r),
        (n.x = n.x * r),
        (n.y = n.y * r),
        (n.z = n.z * r),
        i.makeLookAt(n, e, t),
        this.props.viewer.bimViewer.cameraChanged();
    }
    findLayoutCameraView(t) {
      for (let e = 0; e < this.state.dwgLayoutArr.length; e++) {
        let n = this.state.dwgLayoutArr[e];
        if (n.name === t) return n.cameraView;
      }
    }
    changeDwgLayout(t) {
      this.getCameraPosition(), this.setState({ selectOn: t, show: !1 });
      const e = this.props.viewer.bimViewer.getDwgLayoutSceneArray();
      for (let t = 0; t < e.length; t++) e[t].setVisible(!1);
      this.props.dwgLayoutMap.forEach((t) => {
        t.showThis = !1;
      });
      let n = this.findLayoutCameraView(t);
      if ('Model' === t)
        if ((this.props.viewer.bimViewer.getModelScene().setVisible(!0), n))
          this.setCameraView(n.up, n.target, n.position);
        else {
          let t = this.props.viewer.dwgDefaultView,
            e = new Nt();
          (e.min.x = -t.Width / 2),
            (e.min.y = -t.Height / 2),
            (e.min.z = 0),
            (e.max.x = t.Width / 2),
            (e.max.y = t.Height / 2),
            (e.max.z = 0),
            this.props.viewer.bimViewer
              .getMainCamera()
              .makeLookAtBoundingBoxDwg(e),
            this.props.viewer.bimViewer.cameraChanged();
        }
      else {
        this.props.viewer.bimViewer.getModelScene().setVisible(!1);
        const e = this.props.dwgLayoutMap.get(t);
        if (!e) return void console.error('该布局不存在，请输入正确的布局');
        e.showThis = !0;
        for (let t = 0; t < e.sceneArr.length; t++)
          e.sceneArr[t].setVisible(!0);
        if (n) this.setCameraView(n.up, n.target, n.position);
        else {
          if (0 !== e.bndBox.max.distanceTo(e.bndBox.min)) {
            this.props.viewer.bimViewer
              .getMainCamera()
              .makeLookAtBoundingBoxDwg(e.bndBox);
          }
          this.props.viewer.bimViewer.cameraChanged();
        }
      }
      this.props.dwgLayoutChange(t);
    }
    componentWillUpdate(t, e) {
      if (0 === e.dwgLayoutArr.length) {
        let e = [{ name: 'Model', cameraView: null }];
        for (let n of t.dwgLayoutMap.keys())
          e.push({ name: n, cameraView: null });
        this.setState({ dwgLayoutArr: e, selectOn: e[0].name });
        const n = this.props.viewer.bimViewer.getDwgLayoutSceneArray();
        for (let t = 0; t < n.length; t++) n[t].setVisible(!1);
      }
    }
    render() {
      return Xh`<${Mh}>
    ${
      this.props.visible &&
      Xh`<div class="ccbim__dwgLayout
      ${this.props.viewer.isPhone && 'ccbim__dwgLayout__phone'}">
        <div
          class="ccbim__dwgLayout__select"
          onClick=${() => this.switchShow()}
        >
          <span title=${this.state.selectOn}>${this.state.selectOn}</span>
          <svg
            class=${this.state.show ? 'icon icon__vertical' : 'icon'}
            aria-hidden="true"
          >
            <use xlinkHref="#iconxiala"></use>
          </svg>
        </div>
        <ul
          class=${
            this.state.show
              ? 'ccbim__dwgLayout__result dwgLayout__show'
              : 'ccbim__dwgLayout__result'
          }
        >
          ${this.state.dwgLayoutArr.map(
            (t) => Xh`<li
              title=${t.name}
              onClick=${() => this.changeDwgLayout(t.name)}
            >
              ${t.name}
            </li>`,
          )}
        </ul>
      </div>`
    }
    </${Mh}>`;
    }
  }
  let u_ = new Map();
  class d_ extends Sh {
    constructor(t) {
      super(t),
        (this.state = {
          toggleOpen: !0,
          measureVisible: !1,
          cut: !1,
          cutPhoneVisible: !1,
          cutComponent: !1,
          roamVisible: !1,
          roamDisable: !1,
          roamPhoneVisible: !1,
          roamPhoneTransition: !1,
          MeasureHeight: !1,
          MeasureArea2D: !1,
          MeasureDistance: !1,
          floorTree: [],
          floorTreeVisible: !1,
          stagesAll: [],
          mapVisible: !1,
          mapDisable: !1,
          dwgMapVisible: !1,
          dwgMapDisable: !1,
          dwgLayoutMap: new Map(),
          dwgLayoutVisible: !1,
          settingVisible: !1,
          fullScreenVisible: !1,
          smallProgressVisible: !0,
          viewInfoImage: '',
          componentInfoVisible: !1,
          componentInfoData: {},
        }),
        (this.measureOperator = null);
      let e = {
        getHandleInfo: this.getHandleInfo.bind(this),
        setDwgLayoutChange: this.setDwgLayoutChange.bind(this),
        dwgLayoutClose: this.dwgLayoutClose.bind(this),
        closeAllOperation: this.closeAllOperation.bind(this),
      };
      u_.set(this.props.viewer.parentElementId, e);
    }
    showAllModelTree() {
      if (0 === this.state.floorTree.length) {
        this.props.viewer.bimViewer
          .getModelScene()
          .getModelArray()[0]
          .modelTree.getRootNode()
          .setEntityStyle(null, !0),
          this.props.viewer.bimViewer.requestFrameUpdate();
      } else
        this.state.floorTree[0].setEntityStyle(null, !0),
          this.props.viewer.bimViewer.requestFrameUpdate(),
          this.recursionNodeChild(this.state.floorTree[0], (t) => {
            t.lookThisModel = !1;
          }),
          (this.state.floorTree[0].lookThisModel = !1),
          this.setState({ floorTree: this.state.floorTree });
      document.getElementById(
        this.props.viewer.parentElementId + '__ccbim__showAllModelTree',
      ).style.display = 'none';
    }
    recursionNodeChild(t, e) {
      if (
        t.childArray &&
        t.childArray.length > 0 &&
        t.childArray[0].type !== rm
      )
        for (let n = 0; n < t.childArray.length; n++) {
          const i = t.childArray[n];
          e && e(i), this.recursionNodeChild(i, e);
        }
    }
    closeComponentInfo() {
      this.setState({ componentInfoVisible: !1 }),
        (this.props.viewer.uiState.componentInfoVisible = !1);
    }
    setComponentInfoVisible() {
      this.closeComponentInfo(),
        this.state.componentInfoVisible || this.getHandleInfo();
    }
    getHandleInfo() {
      const t = this.props.viewer.uiState.selectedEntity;
      if (t)
        if (this.props.viewer.optionConfig.versionId) {
          let e = `${this.props.viewer.optionConfig.urlIp}/front/bimfile/handleInfo.htm`,
            n = {
              version: this.props.viewer.optionConfig.versionId,
              floorid: t.floorID,
              handle: t.handle,
            };
          Gf({ method: 'post', url: e, data: Uf(n) }).then(
            (t) => {
              t.data.errorMsg
                ? console.log(t.data.errorMsg)
                : (this.setState({ componentInfoVisible: !0 }),
                  (this.props.viewer.uiState.componentInfoVisible = !0),
                  this.setState({ componentInfoData: t.data }));
            },
            (t) => {
              console.log(t);
            },
          );
        } else {
          let e = `${this.props.viewer.optionConfig.urlIp}/console/bimfile/handleInfo`,
            n = {
              viewToken: this.props.viewer.optionConfig.viewToken,
              floorid: t.floorID,
              handle: t.handle,
            };
          Gf({ method: 'get', url: e, params: n }).then(
            (t) => {
              t.data.errorMsg
                ? console.log(t.data.errorMsg)
                : (this.setState({ componentInfoVisible: !0 }),
                  (this.props.viewer.uiState.componentInfoVisible = !0),
                  this.setState({ componentInfoData: t.data.result }));
            },
            (t) => {
              console.log(t);
            },
          );
        }
    }
    popupMenuFilterComponent(t) {
      const e = this.props.viewer.uiState.selectedEntity;
      this.props.viewer.bimViewer.clearAllHighlightEntity();
      const n = this.props.viewer.bimViewer
        .getModelScene()
        .getModelArray()[0]
        .modelTree.getRootNode();
      if (t) {
        const t = e.modelNode.modelTree.findNodeByTypeValue(
          e.modelNode.type,
          e.modelNode.value,
        );
        let i = new Set();
        for (let e = 0; e < t.length; e++) {
          const n = t[e];
          i.add(n.uuid);
        }
        n.setEntityStyle(null, !0, !0),
          n.setEntityStyle(oy, !0, !1, i),
          this.props.viewer.bimViewer.requestFrameUpdate();
      } else n.setEntityStyle(null, !0, !0), e.modelNode.modelTree.setEntityStyleByTypeValue(e.modelNode.type, e.modelNode.value, oy, !0, !1), this.props.viewer.bimViewer.requestFrameUpdate();
      (document.getElementById(
        this.props.viewer.parentElementId + '__ccbim__rightPopupMenu',
      ).style.display = 'none'),
        (document.getElementById(
          this.props.viewer.parentElementId + '__ccbim__showAllModelTree',
        ).style.display = 'block');
    }
    cutBox() {
      this.state.cut ? this.cutBoxClose() : this.cutBoxOpen();
    }
    cutBoxOpen() {
      this.setState({ cut: !0 }),
        (this.props.viewer.uiState.cut = !0),
        this.cutComponentBoxClose(),
        this.roamClose(),
        this.props.viewer.bimViewer.clearAllHighlightEntity();
    }
    cutBoxClose() {
      this.state.cut &&
        (this.setState({ cut: !1 }), (this.props.viewer.uiState.cut = !1));
    }
    setCutPhoneVisible() {
      this.state.cutPhoneVisible
        ? this.cutBoxPhoneClose()
        : this.cutBoxPhoneOpen();
    }
    cutBoxPhoneOpen() {
      this.setState({ cutPhoneVisible: !0 }),
        (this.props.viewer.uiState.cutPhoneVisible = !0),
        this.roamPhoneClose(),
        this.props.viewer.bimViewer.clearAllHighlightEntity();
    }
    cutBoxPhoneClose() {
      this.state.cutPhoneVisible &&
        (this.setState({ cutPhoneVisible: !1 }),
        (this.props.viewer.uiState.cutPhoneVisible = !1));
    }
    cutComponentBox() {
      this.state.cutComponent
        ? this.cutComponentBoxClose()
        : this.cutComponentBoxOpen();
    }
    cutComponentBoxOpen() {
      this.state.cutComponent ||
        (this.setState({ cutComponent: !0 }),
        (this.props.viewer.uiState.cutComponent = !0),
        this.cutBoxClose(),
        this.roamClose());
    }
    cutComponentBoxClose() {
      this.state.cutComponent &&
        (this.setState({ cutComponent: !1 }),
        (this.props.viewer.uiState.cutComponent = !1),
        this.props.viewer.bimViewer.setOperator(new Pg()));
    }
    roam() {
      this.state.roamVisible ? this.roamClose() : this.roamOpen();
    }
    roamOpen() {
      this.state.roamVisible ||
        (this.cutBoxClose(),
        this.cutComponentBoxClose(),
        this.setState({ roamVisible: !0 }),
        (this.props.viewer.uiState.roamVisible = !0),
        this.setState({ mapDisable: !0 }),
        this.props.viewer.bimViewer.renderContext.renderer.domElement.classList.add(
          'ccbim__roamPerson',
        ));
    }
    roamClose() {
      this.state.roamVisible &&
        (this.setState({ roamVisible: !1 }),
        (this.props.viewer.uiState.roamVisible = !1),
        this.setState({ mapDisable: !1 }),
        this.props.viewer.bimViewer.renderContext.renderer.domElement.classList.remove(
          'ccbim__roamPerson',
        ));
    }
    setRoamPhoneVisible() {
      this.state.roamPhoneVisible
        ? this.roamPhoneClose()
        : this.setState({ roamPhoneVisible: !0 });
    }
    roamPhoneClose() {
      this.setState({ roamPhoneVisible: !1 });
    }
    setMeasureState() {
      this.setState({
        MeasureHeight: !1,
        MeasureArea2D: !1,
        MeasureDistance: !1,
      }),
        (this.props.viewer.uiState.MeasureHeight = !1),
        (this.props.viewer.uiState.MeasureArea2D = !1),
        (this.props.viewer.uiState.MeasureDistance = !1);
    }
    MeasureHeight() {
      this.setMeasureState(),
        this.setState({ MeasureHeight: !this.state.MeasureHeight }),
        (this.props.viewer.uiState.MeasureHeight = !this.state.MeasureHeight),
        this.state.MeasureHeight
          ? this.measureOperator.closeMeasureMode()
          : this.measureOperator.setMeasureMode(1);
    }
    MeasureArea2D() {
      this.setMeasureState(),
        this.setState({ MeasureArea2D: !this.state.MeasureArea2D }),
        (this.props.viewer.uiState.MeasureArea2D = !this.state.MeasureArea2D),
        this.state.MeasureArea2D
          ? this.measureOperator.closeMeasureMode()
          : this.measureOperator.setMeasureMode(3);
    }
    MeasureDistance() {
      this.setMeasureState(),
        this.setState({ MeasureDistance: !this.state.MeasureDistance }),
        (this.props.viewer.uiState.MeasureDistance =
          !this.state.MeasureDistance),
        this.state.MeasureDistance
          ? this.measureOperator.closeMeasureMode()
          : this.measureOperator.setMeasureMode(2);
    }
    MeasureDistance2D() {
      this.setMeasureState(),
        this.setState({ MeasureDistance: !this.state.MeasureDistance }),
        (this.props.viewer.uiState.MeasureDistance =
          !this.state.MeasureDistance),
        this.state.MeasureDistance
          ? this.measureOperator.closeMeasureMode()
          : this.measureOperator.setMeasureMode(4);
    }
    deleteMeasureInfo() {
      this.measureOperator.deleteCurrentMeasure();
    }
    setFloorTreeVisible() {
      this.state.floorTreeVisible
        ? this.floorTreeClose()
        : this.floorTreeOpen();
    }
    floorTreeOpen() {
      if (
        (this.setState({ floorTreeVisible: !0 }),
        (this.props.viewer.uiState.floorTreeVisible = !0),
        0 === this.state.floorTree.length)
      ) {
        const t = this.props.viewer.bimViewer.getModelScene().getModelArray(),
          e = t[0].modelTree.getRootNode();
        this.setState({ floorTree: [e] });
        const n = t[0].modelTree.getLayerArray();
        this.setState({ stagesAll: n });
      }
    }
    floorTreeClose() {
      this.setState({ floorTreeVisible: !1 }),
        (this.props.viewer.uiState.floorTreeVisible = !1);
    }
    setDwgLayoutVisible() {
      this.state.dwgLayoutVisible
        ? this.dwgLayoutClose()
        : this.dwgLayoutOpen();
    }
    dwgLayoutOpen() {
      if (0 === this.state.dwgLayoutMap.size) {
        const t = this.props.viewer.bimViewer
          .getModelScene()
          .getModelArray()[0]
          .getDwgLayoutMap();
        this.setState({ dwgLayoutMap: t });
      }
      this.setState({ dwgLayoutVisible: !0 });
    }
    dwgLayoutClose() {
      this.setState({ dwgLayoutVisible: !1 });
    }
    setDwgLayoutChange(t) {
      Xh`<${h_} />`.type.changeDwgLayout(t);
    }
    dwgLayoutChange(t) {
      'Model' === t
        ? this.setState({ dwgMapDisable: !1 })
        : (this.setState({ dwgMapDisable: !0 }), this.dwgMapClose()),
        this.closeMeasure();
    }
    setMapVisible() {
      this.state.mapVisible ? this.mapClose() : this.mapOpen();
    }
    mapOpen() {
      this.setState({ mapVisible: !0 }),
        (this.props.viewer.uiState.mapVisible = !0),
        this.setState({ roamDisable: !0 });
    }
    mapClose() {
      this.setState({ mapVisible: !1 }),
        (this.props.viewer.uiState.mapVisible = !1),
        this.setState({ roamDisable: !1 });
    }
    setDwgMapVisible() {
      this.state.dwgMapVisible ? this.dwgMapClose() : this.dwgMapOpen();
    }
    dwgMapOpen() {
      this.setState({ dwgMapVisible: !0 }),
        this.props.viewer.bimViewer.getMinimapScene().setVisible(!0),
        this.props.viewer.bimViewer.cameraChanged();
    }
    dwgMapClose() {
      this.setState({ dwgMapVisible: !1 }),
        this.props.viewer.bimViewer.getMinimapScene().setVisible(!1),
        this.props.viewer.bimViewer.cameraChanged();
    }
    dwgViewHome() {
      let t = !1;
      if (
        (this.state.dwgLayoutMap.forEach((e) => {
          if (e.showThis) {
            this.props.viewer.bimViewer
              .getMainCamera()
              .makeLookAtBoundingBoxDwg(e.bndBox),
              this.props.viewer.bimViewer.cameraChanged(),
              (t = !0);
          }
        }),
        !t)
      ) {
        let t = this.props.viewer.dwgDefaultView,
          e = new Nt();
        (e.min.x = -t.Width / 2),
          (e.min.y = -t.Height / 2),
          (e.min.z = 0),
          (e.max.x = t.Width / 2),
          (e.max.y = t.Height / 2),
          (e.max.z = 0),
          this.props.viewer.bimViewer
            .getMainCamera()
            .makeLookAtBoundingBoxDwg(e),
          this.props.viewer.bimViewer.cameraChanged();
      }
    }
    fullScreenChange() {
      this.state.fullScreenVisible
        ? (this.setState({ fullScreenVisible: !1 }),
          this.props.viewer.viewDevices.exitFullscreen())
        : (this.setState({ fullScreenVisible: !0 }),
          this.props.viewer.viewDevices.launchFullscreen());
    }
    setSettingChange() {
      this.state.settingVisible ? this.settingClose() : this.settingOpen();
    }
    settingOpen() {
      this.setState({ settingVisible: !0 });
    }
    settingClose() {
      this.setState({ settingVisible: !1 });
    }
    componentDidMount() {
      this.props.viewer.addEventListener(n.renderFinish, (t) => {
        this.dwgLayoutOpen();
      }),
        document.addEventListener('fullscreenchange', () => {
          null !== document.fullscreenElement
            ? console.info('Went full screen')
            : (console.info('Exited full screen'),
              setTimeout(() => {
                this.setState({ fullScreenVisible: !1 });
              }));
        });
    }
    closeMeasure() {
      if (
        (this.setMeasureState(),
        this.setState({ measureVisible: !1 }),
        (this.props.viewer.uiState.measureVisible = !1),
        this.state.roamPhoneTransition &&
          (this.setState({ roamPhoneTransition: !1 }),
          this.setState({ roamPhoneVisible: !0 })),
        this.props.viewer.bimViewer.setOperatorAt(1, null),
        'dwg' === this.props.viewer.type)
      ) {
        this.props.viewer.bimViewer.getOperator().setDwgLeftButtonPan(!0);
      }
      this.props.viewer.bimViewer.cameraChanged();
    }
    showMeasure() {
      if (
        (this.setState({ measureVisible: !0 }),
        (this.props.viewer.uiState.measureVisible = !0),
        (this.measureOperator = new Ey()),
        this.props.viewer.bimViewer.setOperatorAt(1, this.measureOperator),
        this.state.roamPhoneVisible &&
          (this.setState({ roamPhoneTransition: !0 }), this.roamPhoneClose()),
        'model' === this.props.viewer.type)
      )
        this.MeasureDistance();
      else if ('dwg' === this.props.viewer.type) {
        this.MeasureDistance2D();
        this.props.viewer.bimViewer.getOperator().setDwgLeftButtonPan(!1);
      }
    }
    outDwgModelRelation() {
      const t = this.props.viewer.bimViewer;
      t.getDwgBufferScene().clearBuffer(),
        t.setClippingPlanes([]),
        this.props.viewer.bimViewer.setOperator(new Pg()),
        (document.getElementById(
          this.props.viewer.parentElementId + '__ccbim__dwgModelRelation',
        ).style.display = 'none'),
        t.getMainCamera().setAsPerspective(50);
      document.getElementById(
        this.props.viewer.parentElementId + '__ccbim__markPoints',
      ).style.display = 'block';
      (document.getElementById(
        this.props.viewer.parentElementId + '__ccbim__markPoints__dwgModelRe',
      ).style.display = 'block'),
        m_(this.props.viewer.parentElementId, !0);
    }
    cameraToViewHome() {
      let t = this.props.viewer.bimViewer.getModelScene().getBoundingBox(),
        e = this.props.viewer.bimViewer.getMainCamera();
      e.makeLookAt(new J(1, -1, 1), new J(0, 0, 0), new J(0, 0, 1)),
        e.makeLookAtBoundingBox(t),
        this.props.viewer.bimViewer.cameraChanged();
    }
    closeAllOperation() {
      this.closeMeasure(),
        this.closeComponentInfo(),
        this.cutComponentBoxClose(),
        this.cutBoxClose(),
        this.roamClose(),
        this.floorTreeClose(),
        this.dwgMapClose(),
        this.mapClose(),
        this.settingClose();
    }
    renderBar() {
      if (this.props.viewer.optionConfig.operationBar.showBar) {
        if ('model' === this.props.viewer.type)
          return this.state.measureVisible
            ? Xh`
            <div class="ccbim__operationBarBox__grey">
              <div class="ccbim__operation__icon">
                <span class="ccbim__operation__txt">长度</span>
                <svg
                  title="长度"
                  class=${this.state.MeasureDistance ? 'on icon' : 'icon'}
                  aria-hidden="true"
                  onClick=${() => this.MeasureDistance()}
                >
                  <use xlinkHref="#iconxianxingtubiao-gaoduceliang"></use>
                </svg>
              </div>
              <div class="ccbim__operation__icon">
                <span class="ccbim__operation__txt">标高</span>
                <svg
                  title="标高"
                  class=${this.state.MeasureHeight ? 'on icon' : 'icon'}
                  aria-hidden="true"
                  onClick=${() => this.MeasureHeight()}
                >
                  <use xlinkHref="#iconxianxingtubiao-gaoduceliang1"></use>
                </svg>
              </div>
              <div class="ccbim__operation__icon">
                <span class="ccbim__operation__txt">删除</span>
                <svg
                  title="删除"
                  class="icon"
                  aria-hidden="true"
                  onClick=${() => this.deleteMeasureInfo()}
                >
                  <use xlinkHref="#icondelete"></use>
                </svg>
              </div>
              <div class="ccbim__operation__line"></div>
              <div class="ccbim__operation__icon">
                <span class="ccbim__operation__txt">关闭测量</span>
                <svg
                  title="关闭测量"
                  class="icon iconDel"
                  aria-hidden="true"
                  onClick=${() => this.closeMeasure()}
                >
                  <use xlinkHref="#iconguanbi1"></use>
                </svg>
              </div>
            </div>
          `
            : Xh` <div class="ccbim__operationBarBox__grey">
            <div class="ccbim__operation__icon">
              <span class="ccbim__operation__txt">测量</span>
              <svg
                title="测量"
                class="icon"
                aria-hidden="true"
                onClick=${() => this.showMeasure()}
              >
                <use xlinkHref="#iconceliang1"></use>
              </svg>
            </div>
            <div class="ccbim__operation__icon">
              <span class="ccbim__operation__txt">属性</span>
              <svg
                title="属性"
                class=${this.state.componentInfoVisible ? 'on icon' : 'icon'}
                aria-hidden="true"
                onClick=${() => this.setComponentInfoVisible()}
              >
                <use xlinkHref="#iconshuxing2"></use>
              </svg>
            </div>
            <div class="ccbim__operation__icon">
              <div class="ccbim__operation__cut">
                <div class="ccbim__operation__cutLi">
                  <span class="ccbim__operation__txt__clone positionTopLeft"
                    >构件剖切</span
                  >
                  <svg
                    title="构件剖切"
                    class=${this.state.cutComponent ? 'on icon' : 'icon'}
                    aria-hidden="true"
                    onClick=${() => this.cutComponentBox()}
                  >
                    <use xlinkHref="#iconcubelifangti"></use>
                  </svg>
                </div>
                <div class="ccbim__operation__cutLi">
                  <span class="ccbim__operation__txt__clone positionTopLeft"
                    >轴向剖切</span
                  >
                  <svg
                    title="轴向剖切"
                    class=${this.state.cut ? 'on icon' : 'icon'}
                    aria-hidden="true"
                    onClick=${() => this.cutBox()}
                  >
                    <use xlinkHref="#iconpouqiemian"></use>
                  </svg>
                </div>
              </div>
              <svg
                title="剖切"
                class=${
                  this.state.cutComponent || this.state.cut ? 'on icon' : 'icon'
                }
                aria-hidden="true"
              >
                <use xlinkHref="#iconpouqie"></use>
              </svg>
            </div>
            <div class="ccbim__operation__icon">
              <div
                class=${
                  this.state.roamDisable
                    ? 'ccbim__operation__contentBox ccbim__opreration__disabled'
                    : 'ccbim__operation__contentBox'
                }
              >
                <span class="ccbim__operation__txt">漫游</span>
                <svg
                  title="漫游"
                  class=${this.state.roamVisible ? 'on icon' : 'icon'}
                  aria-hidden="true"
                  onClick=${() => this.roam()}
                >
                  <use xlinkHref="#iconrunning"></use>
                </svg>
              </div>
            </div>
            <div class="ccbim__operation__icon">
              <span class="ccbim__operation__txt">结构树</span>
              <svg
                title="结构树"
                class=${this.state.floorTreeVisible ? 'on icon' : 'icon'}
                aria-hidden="true"
                onClick=${() => this.setFloorTreeVisible()}
              >
                <use xlinkHref="#iconjiegou"></use>
              </svg>
            </div>
            <div class="ccbim__operation__icon">
              <div
                class=${
                  this.state.mapDisable
                    ? 'ccbim__operation__contentBox ccbim__opreration__disabled'
                    : 'ccbim__operation__contentBox'
                }
              >
                <span class="ccbim__operation__txt">模型地图</span>
                <svg
                  title="模型地图"
                  class=${this.state.mapVisible ? 'on icon' : 'icon'}
                  aria-hidden="true"
                  onClick=${() => this.setMapVisible()}
                >
                  <use xlinkHref="#iconmap2"></use>
                </svg>
              </div>
            </div>
            <div class="ccbim__operation__icon">
              <span class="ccbim__operation__txt">设置</span>
              <svg
                title="设置"
                class=${this.state.settingVisible ? 'on icon' : 'icon'}
                aria-hidden="true"
                onClick=${() => this.setSettingChange()}
              >
                <use xlinkHref="#iconshezhi3"></use>
              </svg>
            </div>
            <div class="ccbim__operation__icon">
              <span class="ccbim__operation__txt"
                >${this.state.fullScreenVisible ? '退出全屏' : '全屏'}</span
              >
              <svg
                title="全屏"
                class="icon"
                aria-hidden="true"
                onClick=${() => this.fullScreenChange()}
              >
                <use
                  xlinkHref=${
                    this.state.fullScreenVisible
                      ? '#icontuichuquanping'
                      : '#iconquanping1'
                  }
                ></use>
              </svg>
            </div>
          </div>`;
        if ('dwg' === this.props.viewer.type)
          return this.state.measureVisible
            ? Xh`
            <div class="ccbim__operationBarBox__grey blockBackground">
              <div class="ccbim__operation__icon">
                <span class="ccbim__operation__txt">长度</span>
                <svg
                  title="长度"
                  class=${this.state.MeasureDistance ? 'on icon' : 'icon'}
                  aria-hidden="true"
                  onClick=${() => this.MeasureDistance2D()}
                >
                  <use xlinkHref="#iconxianxingtubiao-gaoduceliang"></use>
                </svg>
              </div>
              <div class="ccbim__operation__icon">
                <span class="ccbim__operation__txt">面积</span>
                <svg
                  title="面积"
                  class=${this.state.MeasureArea2D ? 'on icon' : 'icon'}
                  aria-hidden="true"
                  onClick=${() => this.MeasureArea2D()}
                >
                  <use xlinkHref="#iconarea"></use>
                </svg>
              </div>
              <div class="ccbim__operation__icon">
                <span class="ccbim__operation__txt">删除</span>
                <svg
                  title="删除"
                  class="icon"
                  aria-hidden="true"
                  onClick=${() => this.deleteMeasureInfo()}
                >
                  <use xlinkHref="#icondelete"></use>
                </svg>
              </div>
              <div class="ccbim__operation__line"></div>
              <div class="ccbim__operation__icon">
                <span class="ccbim__operation__txt">关闭测量</span>
                <svg
                  title="关闭测量"
                  class="icon iconDel"
                  aria-hidden="true"
                  onClick=${() => this.closeMeasure()}
                >
                  <use xlinkHref="#iconguanbi1"></use>
                </svg>
              </div>
            </div>
          `
            : Xh` <div
            class="ccbim__operationBarBox__grey blockBackground"
          >
            <div class="ccbim__operation__icon">
              <span class="ccbim__operation__txt">初始位置</span>
              <svg
                title="初始位置"
                class="icon"
                aria-hidden="true"
                onClick=${() => this.dwgViewHome()}
              >
                <use xlinkHref="#iconziyuan"></use>
              </svg>
            </div>
            <div class="ccbim__operation__icon">
              <span class="ccbim__operation__txt">测量</span>
              <svg
                title="测量"
                class="icon"
                aria-hidden="true"
                onClick=${() => this.showMeasure()}
              >
                <use xlinkHref="#iconceliang1"></use>
              </svg>
            </div>
            <div class="ccbim__operation__icon">
              <span class="ccbim__operation__txt">布局</span>
              <svg
                title="布局"
                class=${this.state.dwgLayoutVisible ? 'on icon' : 'icon'}
                aria-hidden="true"
                onClick=${() => this.setDwgLayoutVisible()}
              >
                <use xlinkHref="#iconfrontent-buju"></use>
              </svg>
            </div>
            <div class="ccbim__operation__icon">
              <span class="ccbim__operation__txt">图层</span>
              <svg
                title="图层"
                class=${this.state.floorTreeVisible ? 'on icon' : 'icon'}
                aria-hidden="true"
                onClick=${() => this.setFloorTreeVisible()}
              >
                <use xlinkHref="#iconicon-"></use>
              </svg>
            </div>
            <div class="ccbim__operation__icon">
              <div
                class=${
                  this.state.dwgMapDisable
                    ? 'ccbim__operation__contentBox ccbim__opreration__disabled'
                    : 'ccbim__operation__contentBox'
                }
              >
                <span class="ccbim__operation__txt">小地图</span>
                <svg
                  title="小地图"
                  class=${this.state.dwgMapVisible ? 'on icon' : 'icon'}
                  aria-hidden="true"
                  onClick=${() => this.setDwgMapVisible()}
                >
                  <use xlinkHref="#iconmap2"></use>
                </svg>
              </div>
            </div>
            <div class="ccbim__operation__icon">
              <span class="ccbim__operation__txt">设置</span>
              <svg
                title="设置"
                class=${this.state.settingVisible ? 'on icon' : 'icon'}
                aria-hidden="true"
                onClick=${() => this.setSettingChange()}
              >
                <use xlinkHref="#iconshezhi3"></use>
              </svg>
            </div>
            <div class="ccbim__operation__icon">
              <span class="ccbim__operation__txt"
                >${this.state.fullScreenVisible ? '退出全屏' : '全屏'}</span
              >
              <svg
                title="全屏"
                class="icon"
                aria-hidden="true"
                onClick=${() => this.fullScreenChange()}
              >
                <use
                  xlinkHref=${
                    this.state.fullScreenVisible
                      ? '#icontuichuquanping'
                      : '#iconquanping1'
                  }
                ></use>
              </svg>
            </div>
          </div>`;
      }
    }
    renderBarPhone() {
      if (this.props.viewer.optionConfig.operationBar.showBar)
        if ('model' === this.props.viewer.type) {
          if (!this.state.measureVisible && !this.state.cutPhoneVisible)
            return Xh`<div class="ccbim__operation__phoneBar">
            <div class="ccbim__operation__phoneBar__left">
              <div
                class="ccbim__operation__phoneBar__icon"
                onClick=${() => this.setFloorTreeVisible()}
              >
                <svg class="icon" aria-hidden="true">
                  <use
                    title="楼层"
                    xlinkHref="#iconjiegou"
                    class=${this.state.floorTreeVisible ? 'on icon' : 'icon'}
                    aria-hidden="true"
                  ></use>
                </svg>
              </div>
            </div>
            <div class="ccbim__operation__phoneBar__right">
              <div
                class="ccbim__operation__phoneBar__icon"
                onClick=${() =>
                  this.setState({ toggleOpen: !this.state.toggleOpen })}
              >
                <svg title="收起展开" class="icon" aria-hidden="true">
                  <use xlinkHref="#icongengduo"></use>
                </svg>
              </div>
              ${
                this.state.toggleOpen &&
                Xh`<div
                  class="ccbim__operation__phoneBar__icon"
                  onClick=${() => this.showMeasure()}
                >
                  <svg title="测量" class="icon" aria-hidden="true">
                    <use xlinkHref="#iconceliang1"></use>
                  </svg>
                </div>
                <div
                  class="ccbim__operation__phoneBar__icon"
                  onClick=${() => this.setCutPhoneVisible()}
                >
                  <svg
                    title="剖切"
                    class=${this.state.cutPhoneVisible ? 'on icon' : 'icon'}
                    aria-hidden="true"
                  >
                    <use xlinkHref="#iconpouqie"></use>
                  </svg>
                </div>
                <div
                  class="ccbim__operation__phoneBar__icon"
                  onClick=${() => this.setComponentInfoVisible()}
                >
                  <svg
                    title="属性"
                    class=${
                      this.state.componentInfoVisible ? 'on icon' : 'icon'
                    }
                    aria-hidden="true"
                  >
                    <use xlinkHref="#iconshuxing2"></use>
                  </svg>
                </div>
                <div
                  class="ccbim__operation__phoneBar__icon"
                  onClick=${() => this.setRoamPhoneVisible()}
                >
                  <svg
                    title="漫游"
                    class=${this.state.roamPhoneVisible ? 'on icon' : 'icon'}
                    aria-hidden="true"
                  >
                    <use xlinkHref="#iconrunning"></use>
                  </svg>
                </div>`
              }
            </div>
          </div>`;
          if (this.state.measureVisible)
            return Xh`<div class="ccbim__operation__phoneBar__bottom">
            <div class="ccbim__operation__phoneBar__bottom__icon">
              <span class="ccbim__operation__txt">长度</span>
              <svg
                title="长度"
                class=${this.state.MeasureDistance ? 'on icon' : 'icon'}
                aria-hidden="true"
                onClick=${() => this.MeasureDistance()}
              >
                <use xlinkHref="#iconxianxingtubiao-gaoduceliang"></use>
              </svg>
            </div>
            <div class="ccbim__operation__phoneBar__bottom__icon">
              <span class="ccbim__operation__txt">标高</span>
              <svg
                title="标高"
                class=${this.state.MeasureHeight ? 'on icon' : 'icon'}
                aria-hidden="true"
                onClick=${() => this.MeasureHeight()}
              >
                <use xlinkHref="#iconxianxingtubiao-gaoduceliang1"></use>
              </svg>
            </div>
            <div class="ccbim__operation__phoneBar__bottom__icon">
              <span class="ccbim__operation__txt">删除</span>
              <svg
                title="删除"
                class="icon"
                aria-hidden="true"
                onClick=${() => this.deleteMeasureInfo()}
              >
                <use xlinkHref="#icondelete"></use>
              </svg>
            </div>
            <div class="ccbim__operation__phoneBar__bottom__line"></div>
            <div class="ccbim__operation__phoneBar__bottom__icon">
              <span class="ccbim__operation__txt">关闭测量</span>
              <svg
                title="关闭测量"
                class="icon iconDel"
                aria-hidden="true"
                onClick=${() => this.closeMeasure()}
              >
                <use xlinkHref="#iconguanbi1"></use>
              </svg>
            </div>
          </div> `;
        } else if ('dwg' === this.props.viewer.type)
          return this.state.measureVisible
            ? Xh`<div
            class="ccbim__operation__phoneBar__bottom blockBackground"
          >
            <div class="ccbim__operation__phoneBar__bottom__icon">
              <span class="ccbim__operation__txt">长度</span>
              <svg
                title="长度"
                class=${this.state.MeasureDistance ? 'on icon' : 'icon'}
                aria-hidden="true"
                onClick=${() => this.MeasureDistance2D()}
              >
                <use xlinkHref="#iconxianxingtubiao-gaoduceliang"></use>
              </svg>
            </div>
            <div class="ccbim__operation__phoneBar__bottom__icon">
              <span class="ccbim__operation__txt">面积</span>
              <svg
                title="面积"
                class=${this.state.MeasureArea2D ? 'on icon' : 'icon'}
                aria-hidden="true"
                onClick=${() => this.MeasureArea2D()}
              >
                <use xlinkHref="#iconarea"></use>
              </svg>
            </div>
            <div class="ccbim__operation__phoneBar__bottom__icon">
              <span class="ccbim__operation__txt">删除</span>
              <svg
                title="删除"
                class="icon"
                aria-hidden="true"
                onClick=${() => this.deleteMeasureInfo()}
              >
                <use xlinkHref="#icondelete"></use>
              </svg>
            </div>
            <div class="ccbim__operation__phoneBar__bottom__line"></div>
            <div class="ccbim__operation__phoneBar__bottom__icon">
              <span class="ccbim__operation__txt">关闭测量</span>
              <svg
                title="关闭测量"
                class="icon iconDel"
                aria-hidden="true"
                onClick=${() => this.closeMeasure()}
              >
                <use xlinkHref="#iconguanbi1"></use>
              </svg>
            </div>
          </div> `
            : Xh`<div class="ccbim__operation__phoneBar">
            <div class="ccbim__operation__phoneBar__left blockBackground">
              <div
                class="ccbim__operation__phoneBar__icon"
                onClick=${() => this.setFloorTreeVisible()}
              >
                <svg class="icon" aria-hidden="true">
                  <use
                    title="图层"
                    xlinkHref="#iconicon-"
                    class=${this.state.floorTreeVisible ? 'on icon' : 'icon'}
                    aria-hidden="true"
                  ></use>
                </svg>
              </div>
            </div>
            <div class="ccbim__operation__phoneBar__right blockBackground">
              <div
                class="ccbim__operation__phoneBar__icon"
                onClick=${() =>
                  this.setState({ toggleOpen: !this.state.toggleOpen })}
              >
                <svg title="收起展开" class="icon" aria-hidden="true">
                  <use xlinkHref="#icongengduo"></use>
                </svg>
              </div>
              ${
                this.state.toggleOpen &&
                Xh`<div
                  class="ccbim__operation__phoneBar__icon"
                  onClick=${() => this.showMeasure()}
                >
                  <svg title="测量" class="icon" aria-hidden="true">
                    <use xlinkHref="#iconceliang1"></use>
                  </svg>
                </div>
                <div
                  class="ccbim__operation__phoneBar__icon"
                  onClick=${() => this.setDwgLayoutVisible()}
                >
                  <svg
                    title="布局"
                    class=${this.state.dwgLayoutVisible ? 'on icon' : 'icon'}
                    aria-hidden="true"
                  >
                    <use xlinkHref="#iconfrontent-buju"></use>
                  </svg>
                </div>`
              }
            </div>
          </div>`;
    }
    render() {
      return Xh`<${Mh}>
      <!-- 楼层构件树 -->
      ${Xh`<${sy}
        treeData=${this.state.floorTree}
        stagesAll=${this.state.stagesAll}
        close=${() => {
          this.setState({ floorTreeVisible: !1 });
        }}
        viewer=${this.props.viewer}
        visible=${this.state.floorTreeVisible}
      />`}
      <!--小房子默认视口-->
      ${
        'model' === this.props.viewer.type &&
        !this.props.viewer.isPhone &&
        this.props.viewer.optionConfig.viewBoxVisible &&
        Xh`<div
          class="ccbim__viewHome"
          onClick=${() => this.cameraToViewHome()}
        >
          <svg title="默认视口" class="icon" aria-hidden="true">
            <use xlinkHref="#iconhome-"></use>
          </svg>
        </div>`
      }
      <!-- 小进度条 -->
      ${
        this.state.smallProgressVisible &&
        Xh`<${_v}
          parentElementId=${this.props.viewer.parentElementId}
        />`
      }
      <!-- 半透明后显示全部 -->
      <div class="ccbim__showAllModelTree" id=${
        this.props.viewer.parentElementId + '__ccbim__showAllModelTree'
      } onClick=${() => this.showAllModelTree()}>显示全部</div>
      <!-- 选中构件弹窗 -->
      <div class="ccbim__rightPopupMenu" id=${
        this.props.viewer.parentElementId + '__ccbim__rightPopupMenu'
      }>
        <ul>
          ${
            this.props.viewer.optionConfig.selectEntityAction.visible &&
            Xh`<slot name="contextMenu"
              >${this.props.viewer.optionConfig.selectEntityAction.list.map(
                (t) => Xh`<li
                    class="contextMenu"
                    onClick=${() => {
                      t.action();
                    }}
                  >
                    ${t.name}
                  </li>`,
              )}
            </slot>`
          }
          ${
            'model' === this.props.viewer.type &&
            Xh`<${Mh}>
          <li class="contextMenu" onClick=${() =>
            this.popupMenuFilterComponent(!0)}>显示该类构件</li>
          <li class="contextMenu" onClick=${() =>
            this.popupMenuFilterComponent(!1)}>隐藏该类构件</li>
          </${Mh}>`
          }
        </ul>
      </div>
      <!-- 构件属性 -->
      ${
        this.state.componentInfoVisible &&
        Xh`<${$g}
          componentInfoData=${this.state.componentInfoData}
          close=${() => this.setComponentInfoVisible()}
        />`
      }
      <!-- 漫游提示界面 -->
      ${this.state.roamVisible && Xh`<${yv} viewer=${this.props.viewer} />`}
      <!--剖切相关-->
      ${this.state.cutComponent && Xh`<${Jg} viewer=${this.props.viewer} />`}
      <!--模型小地图-->
      ${
        this.state.mapVisible &&
        Xh`<${py}
          closeMap=${() => this.setMapVisible()}
          viewer=${this.props.viewer}
        />`
      }
      <!-- 模型设置界面 -->
      ${
        this.state.settingVisible &&
        Xh`<${vv}
          viewer=${this.props.viewer}
          close=${() => {
            this.setState({ settingVisible: !1 });
          }}
        />`
      }
      <!-- 模型旋转中心指示点 -->
      ${Xh`<${Ng}
        parentElementId=${this.props.viewer.parentElementId}
      />`}
      <!-- 点击位置标记点 -->
      <div id=${this.props.viewer.parentElementId + '__ccbim__markInit'}></div>
      <!-- 普通标记点 -->
      <div id=${
        this.props.viewer.parentElementId + '__ccbim__markPoints'
      }></div>
      <!-- 图模联动标记点 -->
      <div id=${
        this.props.viewer.parentElementId + '__ccbim__markPoints__dwgModelRe'
      }></div>
      <!--loading-->
      <div id=${this.props.viewer.parentElementId + '__ccbim__loading'}></div>
      <!-- 退出图模联动 -->
      <div id=${
        this.props.viewer.parentElementId + '__ccbim__dwgModelRelation'
      } class="ccbim__dwgModelRelation" onClick=${() => this.outDwgModelRelation()}>退出图模联动</div>
      <!--图模叠加方向选择-->
      <div id=${
        this.props.viewer.parentElementId + '__ccbim__dwgModelAlignAxis'
      }></div>
      <!-- 轴向剖切界面 -->
      ${
        this.state.cut &&
        Xh`<${Yg}
          viewer=${this.props.viewer}
          close=${() => this.cutBoxClose()}
        />`
      }
      <!-- 手机端轴向剖切界面 -->
      ${
        this.state.cutPhoneVisible &&
        Xh`<${Qg}
          viewer=${this.props.viewer}
          close=${() => this.cutBoxPhoneClose()}
        />`
      }
      <!-- 手机端漫游 -->
      ${
        this.state.roamPhoneVisible &&
        Xh`<${l_} viewer=${this.props.viewer}></${l_}>`
      }
      <!--视口图片显示-->
      <div id=${
        this.props.viewer.parentElementId + '__ccbim__viewInfoImg'
      }></div>

      <!-- 图纸布局 -->
      ${
        'dwg' === this.props.viewer.type &&
        Xh`<${h_}
          visible=${this.state.dwgLayoutVisible}
          viewer=${this.props.viewer}
          dwgLayoutMap=${this.state.dwgLayoutMap}
          dwgLayoutChange=${(t) => this.dwgLayoutChange(t)}
        />`
      }

      <!-- 底部操作栏 -->
      <div id=${this.props.viewer.parentElementId + '__ccbim__operationBar'}>
        ${this.props.viewer.isPhone ? this.renderBarPhone() : this.renderBar()}
      </div>
    </${Mh}>`;
    }
  }
  function p_(t) {
    jh(Xh`<${d_} viewer=${t} />`, t.optionConfig.dom);
  }
  function f_(t) {
    jh(Xh``, t);
  }
  function m_(t, e) {
    const n = document.getElementById(t + '__ccbim__operationBar');
    n.style.display = e ? 'block' : 'none';
  }
  var b_ = b_ || {};
  function g_() {
    this.type = 'flatBuffer';
  }
  (b_.Showtype = { AllHide: 0, AllShow: 1, Custom: 2 }),
    (b_.Vec3 = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (b_.Vec3.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (b_.Vec3.prototype.x = function () {
      return this.bb.readFloat32(this.bb_pos);
    }),
    (b_.Vec3.prototype.y = function () {
      return this.bb.readFloat32(this.bb_pos + 4);
    }),
    (b_.Vec3.prototype.z = function () {
      return this.bb.readFloat32(this.bb_pos + 8);
    }),
    (b_.Vec3.createVec3 = function (t, e, n, i) {
      return (
        t.prep(4, 12),
        t.writeFloat32(i),
        t.writeFloat32(n),
        t.writeFloat32(e),
        t.offset()
      );
    }),
    (b_.ViewInfo = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (b_.ViewInfo.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (b_.ViewInfo.getRootAsViewInfo = function (t, e) {
      return (e || new b_.ViewInfo()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (b_.ViewInfo.prototype.cameraInfo = function (t) {
      var e = this.bb.__offset(this.bb_pos, 4);
      return e
        ? (t || new b_.CameraInfo()).__init(
            this.bb.__indirect(this.bb_pos + e),
            this.bb,
          )
        : null;
    }),
    (b_.ViewInfo.prototype.floorInfoArr = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 6);
      return n
        ? (e || new b_.FloorInfo()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (b_.ViewInfo.prototype.floorInfoArrLength = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (b_.ViewInfo.prototype.cullPlaneArr = function (t, e) {
      var n = this.bb.__offset(this.bb_pos, 8);
      return n
        ? (e || new b_.CullPlane()).__init(
            this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * t),
            this.bb,
          )
        : null;
    }),
    (b_.ViewInfo.prototype.cullPlaneArrLength = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (b_.ViewInfo.prototype.stageId = function () {
      var t = this.bb.__offset(this.bb_pos, 10);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (b_.ViewInfo.startViewInfo = function (t) {
      t.startObject(4);
    }),
    (b_.ViewInfo.addCameraInfo = function (t, e) {
      t.addFieldOffset(0, e, 0);
    }),
    (b_.ViewInfo.addFloorInfoArr = function (t, e) {
      t.addFieldOffset(1, e, 0);
    }),
    (b_.ViewInfo.createFloorInfoArrVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (b_.ViewInfo.startFloorInfoArrVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (b_.ViewInfo.addCullPlaneArr = function (t, e) {
      t.addFieldOffset(2, e, 0);
    }),
    (b_.ViewInfo.createCullPlaneArrVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addOffset(e[n]);
      return t.endVector();
    }),
    (b_.ViewInfo.startCullPlaneArrVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (b_.ViewInfo.addStageId = function (t, e) {
      t.addFieldInt32(3, e, 0);
    }),
    (b_.ViewInfo.endViewInfo = function (t) {
      return t.endObject();
    }),
    (b_.ViewInfo.finishViewInfoBuffer = function (t, e) {
      t.finish(e);
    }),
    (b_.CameraInfo = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (b_.CameraInfo.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (b_.CameraInfo.getRootAsCameraInfo = function (t, e) {
      return (e || new b_.CameraInfo()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (b_.CameraInfo.prototype.eyePos = function (t) {
      var e = this.bb.__offset(this.bb_pos, 4);
      return e ? (t || new b_.Vec3()).__init(this.bb_pos + e, this.bb) : null;
    }),
    (b_.CameraInfo.prototype.tarPos = function (t) {
      var e = this.bb.__offset(this.bb_pos, 6);
      return e ? (t || new b_.Vec3()).__init(this.bb_pos + e, this.bb) : null;
    }),
    (b_.CameraInfo.prototype.up = function (t) {
      var e = this.bb.__offset(this.bb_pos, 8);
      return e ? (t || new b_.Vec3()).__init(this.bb_pos + e, this.bb) : null;
    }),
    (b_.CameraInfo.prototype.viewWidth = function () {
      var t = this.bb.__offset(this.bb_pos, 10);
      return t ? this.bb.readFloat32(this.bb_pos + t) : 0;
    }),
    (b_.CameraInfo.prototype.viewHeight = function () {
      var t = this.bb.__offset(this.bb_pos, 12);
      return t ? this.bb.readFloat32(this.bb_pos + t) : 0;
    }),
    (b_.CameraInfo.startCameraInfo = function (t) {
      t.startObject(5);
    }),
    (b_.CameraInfo.addEyePos = function (t, e) {
      t.addFieldStruct(0, e, 0);
    }),
    (b_.CameraInfo.addTarPos = function (t, e) {
      t.addFieldStruct(1, e, 0);
    }),
    (b_.CameraInfo.addUp = function (t, e) {
      t.addFieldStruct(2, e, 0);
    }),
    (b_.CameraInfo.addViewWidth = function (t, e) {
      t.addFieldFloat32(3, e, 0);
    }),
    (b_.CameraInfo.addViewHeight = function (t, e) {
      t.addFieldFloat32(4, e, 0);
    }),
    (b_.CameraInfo.endCameraInfo = function (t) {
      return t.endObject();
    }),
    (b_.FloorInfo = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (b_.FloorInfo.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (b_.FloorInfo.getRootAsFloorInfo = function (t, e) {
      return (e || new b_.FloorInfo()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (b_.FloorInfo.prototype.floorid = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readInt32(this.bb_pos + t) : 0;
    }),
    (b_.FloorInfo.prototype.state = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t ? this.bb.readInt8(this.bb_pos + t) : b_.Showtype.AllHide;
    }),
    (b_.FloorInfo.prototype.comtypeArr = function (t) {
      var e = this.bb.__offset(this.bb_pos, 8);
      return e
        ? this.bb.readInt32(this.bb.__vector(this.bb_pos + e) + 4 * t)
        : 0;
    }),
    (b_.FloorInfo.prototype.comtypeArrLength = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
    }),
    (b_.FloorInfo.prototype.comtypeArrArray = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t
        ? new Int32Array(
            this.bb.bytes().buffer,
            this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t),
            this.bb.__vector_len(this.bb_pos + t),
          )
        : null;
    }),
    (b_.FloorInfo.startFloorInfo = function (t) {
      t.startObject(3);
    }),
    (b_.FloorInfo.addFloorid = function (t, e) {
      t.addFieldInt32(0, e, 0);
    }),
    (b_.FloorInfo.addState = function (t, e) {
      t.addFieldInt8(1, e, b_.Showtype.AllHide);
    }),
    (b_.FloorInfo.addComtypeArr = function (t, e) {
      t.addFieldOffset(2, e, 0);
    }),
    (b_.FloorInfo.createComtypeArrVector = function (t, e) {
      t.startVector(4, e.length, 4);
      for (var n = e.length - 1; n >= 0; n--) t.addInt32(e[n]);
      return t.endVector();
    }),
    (b_.FloorInfo.startComtypeArrVector = function (t, e) {
      t.startVector(4, e, 4);
    }),
    (b_.FloorInfo.endFloorInfo = function (t) {
      return t.endObject();
    }),
    (b_.CullPlane = function () {
      (this.bb = null), (this.bb_pos = 0);
    }),
    (b_.CullPlane.prototype.__init = function (t, e) {
      return (this.bb_pos = t), (this.bb = e), this;
    }),
    (b_.CullPlane.getRootAsCullPlane = function (t, e) {
      return (e || new b_.CullPlane()).__init(
        t.readInt32(t.position()) + t.position(),
        t,
      );
    }),
    (b_.CullPlane.prototype.A = function () {
      var t = this.bb.__offset(this.bb_pos, 4);
      return t ? this.bb.readFloat32(this.bb_pos + t) : 0;
    }),
    (b_.CullPlane.prototype.B = function () {
      var t = this.bb.__offset(this.bb_pos, 6);
      return t ? this.bb.readFloat32(this.bb_pos + t) : 0;
    }),
    (b_.CullPlane.prototype.C = function () {
      var t = this.bb.__offset(this.bb_pos, 8);
      return t ? this.bb.readFloat32(this.bb_pos + t) : 0;
    }),
    (b_.CullPlane.prototype.D = function () {
      var t = this.bb.__offset(this.bb_pos, 10);
      return t ? this.bb.readFloat32(this.bb_pos + t) : 0;
    }),
    (b_.CullPlane.startCullPlane = function (t) {
      t.startObject(4);
    }),
    (b_.CullPlane.addA = function (t, e) {
      t.addFieldFloat32(0, e, 0);
    }),
    (b_.CullPlane.addB = function (t, e) {
      t.addFieldFloat32(1, e, 0);
    }),
    (b_.CullPlane.addC = function (t, e) {
      t.addFieldFloat32(2, e, 0);
    }),
    (b_.CullPlane.addD = function (t, e) {
      t.addFieldFloat32(3, e, 0);
    }),
    (b_.CullPlane.endCullPlane = function (t) {
      return t.endObject();
    }),
    (g_.prototype = {
      constructor: g_,
      DecodeBase64: function (t) {
        let e = 0,
          n = 0,
          i = 0,
          r = 0;
        (r = 0), (e = t.length);
        let o = [];
        o.length = e;
        let s = 0;
        for (n = 0; n < e; n++) o[n] = t[n];
        for (; e > 0 && '=' == o[e - 1]; ) (o[e - 1] = 0), r++, e--;
        for (n = 0; n < e; n++) {
          let t =
            'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='.indexOf(
              o[n],
              0,
            );
          if (-1 === t) break;
          o[n] = t;
        }
        let a = parseInt((3 * e) / 4 + 4),
          c = [];
        for (c.length = a, n = 0, i = 0; n < e; n += 4, i += 3)
          (c[i] = (o[n] << 2) + ((48 & o[n + 1]) >> 4)),
            (c[i + 1] = ((15 & o[n + 1]) << 4) + ((60 & o[n + 2]) >> 2)),
            (c[i + 2] = ((3 & o[n + 2]) << 6) + o[n + 3]),
            (s += 3);
        return (s -= r), (c.length = s), c;
      },
      EncodeBase64: function (t) {
        let e = 0,
          n = 0,
          i = 0,
          r = 0;
        n = e = t.length;
        let o = parseInt((n / 3) * 4 + 4),
          s = [];
        for (s.length = o, i = 0, r = 0; i <= n - 3; i += 3, r += 4)
          (s[r] = (252 & t[i]) >> 2),
            (s[r + 1] = ((3 & t[i]) << 4) + ((240 & t[i + 1]) >> 4)),
            (s[r + 2] = ((15 & t[i + 1]) << 2) + ((192 & t[i + 2]) >> 6)),
            (s[r + 3] = 63 & t[i + 2]);
        e % 3 == 1
          ? ((s[r] = (252 & t[i]) >> 2),
            (s[r + 1] = (3 & t[i]) << 4),
            (s[r + 2] = 64),
            (s[r + 3] = 64),
            (r += 4))
          : e % 3 == 2 &&
            ((s[r] = (252 & t[i]) >> 2),
            (s[r + 1] = ((3 & t[i]) << 4) + ((240 & t[i + 1]) >> 4)),
            (s[r + 2] = (15 & t[i + 1]) << 2),
            (s[r + 3] = 64),
            (r += 4));
        let a = '';
        for (i = 0; i < r; i++)
          a +=
            'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='[
              s[i]
            ];
        return a;
      },
      setFlatBuffer: function (t, e, n, i, r, o, s, a) {
        let c = new lm.Builder(1024);
        b_.CameraInfo.startCameraInfo(c);
        let l = b_.Vec3.createVec3(c, t.x, t.y, t.z);
        b_.CameraInfo.addEyePos(c, l);
        let h = b_.Vec3.createVec3(c, e.x, e.y, e.z);
        b_.CameraInfo.addTarPos(c, h);
        let u = b_.Vec3.createVec3(c, n.x, n.y, n.z);
        b_.CameraInfo.addUp(c, u),
          b_.CameraInfo.addViewWidth(c, i),
          b_.CameraInfo.addViewHeight(c, r);
        let d = b_.CameraInfo.endCameraInfo(c),
          p = [];
        for (let t = 0; t < o.length; t++) {
          let e = null,
            n = null;
          if (0 === o[t].state) e = b_.Showtype.AllHide;
          else if (1 === o[t].state) e = b_.Showtype.AllShow;
          else if (2 === o[t].state) {
            e = b_.Showtype.Custom;
            let i = o[t].comtypeArr;
            n = b_.FloorInfo.createComtypeArrVector(c, i);
          }
          b_.FloorInfo.startFloorInfo(c),
            b_.FloorInfo.addFloorid(c, o[t].floorid),
            b_.FloorInfo.addState(c, e),
            2 === o[t].state && b_.FloorInfo.addComtypeArr(c, n);
          let i = b_.FloorInfo.endFloorInfo(c);
          p.push(i);
        }
        let f = [];
        for (let t = 0; t < s.length; t++) {
          b_.CullPlane.startCullPlane(c),
            b_.CullPlane.addA(c, s[t].x),
            b_.CullPlane.addB(c, s[t].y),
            b_.CullPlane.addC(c, s[t].z),
            b_.CullPlane.addD(c, s[t].constant);
          let e = b_.CullPlane.endCullPlane(c);
          f.push(e);
        }
        let m = b_.ViewInfo.createFloorInfoArrVector(c, p),
          b = b_.ViewInfo.createCullPlaneArrVector(c, f);
        b_.ViewInfo.startViewInfo(c),
          b_.ViewInfo.addCameraInfo(c, d),
          b_.ViewInfo.addFloorInfoArr(c, m),
          b_.ViewInfo.addCullPlaneArr(c, b),
          b_.ViewInfo.addStageId(c, a);
        let g = b_.ViewInfo.endViewInfo(c);
        return c.finish(g), this.EncodeBase64(c.asUint8Array());
      },
      getFlatBuffer: function (t) {
        let e = new Uint8Array(t),
          n = new lm.ByteBuffer(e),
          i = b_.ViewInfo.getRootAsViewInfo(n),
          r = {
            x: i.cameraInfo().eyePos().x(),
            y: i.cameraInfo().eyePos().y(),
            z: i.cameraInfo().eyePos().z(),
          },
          o = {
            x: i.cameraInfo().tarPos().x(),
            y: i.cameraInfo().tarPos().y(),
            z: i.cameraInfo().tarPos().z(),
          },
          s = {
            x: i.cameraInfo().up().x(),
            y: i.cameraInfo().up().y(),
            z: i.cameraInfo().up().z(),
          },
          a = i.cameraInfo().viewWidth(),
          c = i.cameraInfo().viewHeight(),
          l = [];
        for (let t = 0; t < i.floorInfoArrLength(); t++) {
          let e = {};
          (e.floorid = i.floorInfoArr(t).floorid()),
            (e.state = i.floorInfoArr(t).state()),
            (e.comtypeArr = i.floorInfoArr(t).comtypeArrArray()),
            l.push(e);
        }
        let h = [];
        for (let t = 0; t < i.cullPlaneArrLength(); t++)
          h.push(i.cullPlaneArr(t).D());
        return {
          cameraPosition: r,
          cameraTarget: o,
          cameraUp: s,
          viewWidth: a,
          viewHeight: c,
          floorInfo: l,
          cullPlane: h,
          stageId: i.stageId(),
        };
      },
    });
  class y_ extends Sh {
    constructor(t) {
      super(t), (this.state = {});
    }
    render() {
      return Xh`<${Mh}>
      ${this.props.pointList.map(
        (t) => Xh`
          <div
            style=${{
              position: 'absolute',
              left: `${t.left}px`,
              top: `${t.top}px`,
            }}
          >
            <div
              class=${t.color ? 'ccbim__point__color' : 'ccbim__point'}
              style=${{
                backgroundImage: `url(${t.iconImg})`,
                backgroundColor: `${t.color}`,
              }}
            ></div>
          </div>
        `,
      )}
    </${Mh}>`;
    }
  }
  let v_ = new Map(),
    __ = new Map();
  function x_(t, e) {
    let n = (function (t) {
      if (0 === v_.size) return [];
      let { wHalf: e, hHalf: n } = t.viewDevices.getDevicesWidthHeight();
      for (let i of v_.values()) {
        let r = t.bimViewer.getMainCamera(),
          o = i.point.clone();
        o.project(r),
          (o.x = o.x * e + e),
          (o.y = -o.y * n + n),
          __.set(i.id, {
            id: i.id,
            left: o.x - 15,
            top: o.y - 40,
            iconImg: i.iconImg
              ? i.iconImg
              : 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB8AAAAmCAYAAAA820BcAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA39pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDIxIDc5LjE1NTc3MiwgMjAxNC8wMS8xMy0xOTo0NDowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDphODRkMDNjNC04MzBlLTZlNDEtOWUyYS0xOWEzYTRiNGMwNTkiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6RDgwNzJDN0NFQjhFMTFFN0E4ODlENTE1NEZCQzExQkIiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6RDgwNzJDN0JFQjhFMTFFN0E4ODlENTE1NEZCQzExQkIiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOmQ4NmY1MTliLWJhMmUtYjk0ZC1iYmRjLWZhMzlhOTM0NWNmNiIgc3RSZWY6ZG9jdW1lbnRJRD0iYWRvYmU6ZG9jaWQ6cGhvdG9zaG9wOmJmNDQzMjIyLTcwNTgtYmE0Yi04ZGVmLTRlNDgzYTI0MDA4NiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqFeqsUAAAPDSURBVHjatFhpbExRFP5mOqglqEgZWvyQ2IoIaklaIRp7Ygvxxw+x/7BNEIkKQYJmosSPqkhERIJIJGgVKSli19RWkUa0Hbso0ui0quM77715fTPtzLxZ3km+m3fuvHe+e8+9555zx+bz+dBGXDa0I/2IuUQ2MZRwEp2JBuIzUUmUEVfg9n2ECbG1Sx44kMlsdxCziCQTNv8RxcQBDuJebOQuWx+2R4kliF3OExs4iC/mydXZXtBcrYqjEzB4KpAxHxg0CUgZCCT3ALy/gLpq4P194OUloOoW0NxotCZLsrg9L7Qld9nEvRe19QTsDiBzBTBjN9DdGXmu9V+B0oPA3WNcgCZ/r+yLRRxAcWhyl20C21Kii6KnDgGW03POUdE7/NNz4PRS4Osbf88fYhoH8LAtucvWi20Fkabo6eOB1dc4jF6xr3hDHVBIR9bofB5iNAfwQ3Gq4dVDOnEqI2ntjfiIRTqnAGtKVHuqpGk8hpm7bKP5XC46kjoAm5/E5uqQS/ACODyWe+CvaOLqMZx9hX/mWxVikayNiSUWcY5U7WoTJrapM9+CHlo4JMORDOQybLqlIuEiUbCX4dnsFU2avjLzGQqxyPC51hCLiN0R8/ya8M20a2e1KsPnwFIZNtuoZQt5hq6mjbWWPH2cURsh5P11NWWAteQ9041afyHvqqtyVlspgfa7CPlfXfX+tpY80L5XyL/r6s9aa8l/eYxanZC/09Xax9aS1zwyatVC/lRXK4usJQ+0Xy7kJbr66rJ6Elkh9d9U+63ywM4DXhLKW0WVo+9WnjXkt/P8R6uIpNQ7/sRyXH/pzhG1EEikSFYryzf2nOGkG/3khfqul7QnFYjUZgkJL9o5vcSfThX/Eu7WYsLtq2e7U/9ASp+C6fGvv3xfkGMspUQKyFcTXMmcEKe3hh0LinyWUp5nsRF/4FbKzwwOX0nduaEKSDl8ha233ifV68SVQM4uc9Xr70/A9T3Aw5NAS7PxlxYlfbt9N8OVztO0G0fHgH4pNCTfS9qV7KfU7d3VI1Pqdg+Pi9dXiSvGXW2UXBLvM3NpkFvKWZPXIzMi0bSO5AFk9jDXnGVEUwKI6X+sDyYORw7tuiSlTTypTsrkVSRuae9HR4SPZXNkEUUBRYe5m+omkh4L95LdhCE57iYEJKAI0U0siERsllyJWs0D5yK8x22PySS+bMaoPQpXNmibcH+ohKkQAy/MGrRHuYF82jG8I6hfCKcQH6MxZo9xFx8gTmnPEo4LiW/RGnHEEUbbiUztj4SqWAz8F2AAwxUsG0cxVxkAAAAASUVORK5CYII=',
          });
      }
      return [...__.values()];
    })(e);
    n && jh(Xh`<${y_} pointList=${n} />`, t);
  }
  function w_(t, e) {
    (this.dom = t),
      (this.isMouseDown = !1),
      (this.isMouseMove = !1),
      (this.mouseDownX = 0),
      (this.mouseDownY = 0),
      (this.viewer = e),
      (this.useFlatBuffer = new g_()),
      (this.hasBindEventMarkInit = !1);
  }
  function A_(t, e) {
    (this.dom = t),
      (this.actionManager = new w_(this.dom, e)),
      (this.viewer = e);
  }
  function M_(t, e, n, i, r, o) {
    om.call(this, t, e, i, r, o), (this.color = n);
  }
  function S_(t, e) {
    bm.call(this, t),
      (this.viewer = e),
      (this.cancelCreateModel = !1),
      (this.hasloadOnce = !1),
      (this.materialMap = new Map()),
      (this.entityTreeNodeMap = new Map());
  }
  (w_.prototype = {
    constructor: w_,
    onModelMouseDown(t) {
      this.viewer.uiState.measureVisible ||
        ((this.isMouseDown = !0),
        (this.isMouseMove = !1),
        'touchstart' === t.type
          ? ((this.mouseDownX = t.changedTouches[0].clientX),
            (this.mouseDownY = t.changedTouches[0].clientY))
          : ((this.mouseDownX = t.clientX), (this.mouseDownY = t.clientY)));
    },
    onModelMouseUp(t, e = {}) {
      if (
        ((this.isMouseDown = !1),
        kg(this.viewer.parentElementId),
        !this.viewer.uiState.measureVisible && e.isChoose && !this.isMouseMove)
      )
        if ('model' === this.viewer.type) {
          if (!this.viewer.isSingleClick) return;
          this.selectGeometry(t);
        } else 'dwg' === this.viewer.type && this.addDwgMark(t);
    },
    onModelMouseMove(t) {
      if (!this.viewer.uiState.measureVisible && this.isMouseDown) {
        let e, n;
        if (
          ('touchmove' === t.type
            ? ((e = t.changedTouches[0].clientX),
              (n = t.changedTouches[0].clientY))
            : ((e = t.clientX), (n = t.clientY)),
          (Math.abs(e - this.mouseDownX) > 20 ||
            Math.abs(n - this.mouseDownY) > 20) &&
            (this.isMouseMove = !0),
          this.isMouseMove)
        ) {
          const e = this.viewer.bimViewer.getOperator();
          if (e.orbit) {
            if (
              e.orbit.rotateCenter &&
              ('touchmove' !== t.type || 1 === t.touches.length)
            ) {
              const t = document.getElementById(
                this.viewer.parentElementId + '__ccbim__rotateCenterPoint',
              );
              if ('none' === t.style.display || '' === t.style.display) {
                let t = e.orbit.rotateCenter.clone();
                const n = this.viewer.bimViewer.getMainCamera();
                let { wHalf: i, hHalf: r } =
                  this.viewer.viewDevices.getDevicesWidthHeight();
                t.project(n);
                let o = t.x * i + i,
                  s = -t.y * r + r;
                !(function (t, e = 0, n = 0) {
                  const i = document.getElementById(
                    t + '__ccbim__rotateCenterPoint',
                  );
                  (i.style.left = e + 'px'),
                    (i.style.top = n + 'px'),
                    (i.style.display = 'block');
                })(this.viewer.parentElementId, o, s);
              }
            }
            'touchmove' === t.type &&
              2 === t.touches.length &&
              kg(this.viewer.parentElementId);
          }
        }
      }
    },
    getSelectGeometryPositionInfo(t, e) {
      let n = {},
        i = this.viewer.scale,
        r = { x: e.x / i, y: e.y / i, z: e.z / i };
      const o = this.viewer.bimViewer
          .getModelScene()
          .getModelArray()[0]
          .modelTree.getRootNode(),
        s = this.recursionTreeFromIdToName([o], t.floorID);
      Object.assign(n, { clickPointPosition: r }),
        Object.assign(n, { comid: t.comid }),
        Object.assign(n, { comtype: t.comtype }),
        Object.assign(n, { floorID: t.floorID }),
        Object.assign(n, { floorId: t.floorID }),
        Object.assign(n, { floorName: s }),
        Object.assign(n, { handle: t.handle });
      let a = this.getViewInfo();
      Object.assign(n, a),
        this.viewer.dispatchEvent({ type: 'selectedEntity', object: n });
    },
    getViewInfo() {
      let t = this.viewer.scale,
        e = {};
      const n = this.getCameraPosition();
      Object.assign(e, { cameraPosition: n.cameraPosition }),
        Object.assign(e, { cameraUp: n.cameraUp }),
        Object.assign(e, { cameraTarget: n.cameraTarget });
      let i = [],
        r = this.viewer.bimViewer.getModelScene().getClippingPlanes();
      if (6 === r.length)
        for (let e = 0; e < r.length; e++)
          i.push({
            x: r[e].normal.x,
            y: r[e].normal.y,
            z: r[e].normal.z,
            constant: r[e].constant / t,
          });
      const o = this.computedTransverseView() / t;
      let s = this.viewer.bimViewer
          .getModelScene()
          .getModelArray()[0]
          .modelTree.getCurrentLayer(),
        a = s && s.id;
      const c = this.getFlatBufferFloorInfo();
      let l = this.useFlatBuffer.setFlatBuffer(
        n.cameraPosition,
        n.cameraTarget,
        n.cameraUp,
        o,
        o,
        c,
        i,
        a,
      );
      return Object.assign(e, { flatBuffer: l }), e;
    },
    getModelViewInfo() {
      let t = {},
        e = this.viewer.uiState.selectedEntity;
      e &&
        (Object.assign(t, { comid: e.comid }),
        Object.assign(t, { comtype: e.comtype }),
        Object.assign(t, { floorID: e.floorID }),
        Object.assign(t, { handle: e.handle }));
      let n = this.getViewInfo();
      return Object.assign(t, n), t;
    },
    getDwgViewInfo() {
      let t = {},
        e = this.viewer.scale;
      const n = this.getCameraPosition();
      let { wHalf: i, hHalf: r } =
          this.viewer.viewDevices.getDevicesWidthHeight(),
        o = this.getWorldCoordinateDwg(i, r);
      const s = { x: o.x / e, y: o.y / e };
      let a = this.getDwgOutWidth();
      Object.assign(t, { cameraPosition: n.cameraPosition }),
        Object.assign(t, { cameraUp: n.cameraUp }),
        Object.assign(t, { cameraTarget: n.cameraTarget }),
        Object.assign(t, { outWidth: a }),
        Object.assign(t, { scale: e }),
        Object.assign(t, { DWGMark: s }),
        Object.assign(t, { isDWG: !0 }),
        Object.assign(t, { offset: this.viewer.dwgDefaultView.Target });
      const c = this.viewer.bimViewer
        .getModelScene()
        .getModelArray()[0]
        .getDwgLayoutMap();
      let l = 'Model';
      return (
        c.forEach((t, e) => {
          t.showThis && (l = e);
        }),
        Object.assign(t, { dwgLayoutName: l }),
        t
      );
    },
    getFileLinkPositionOffset(t) {
      let e = new J();
      const n = new J(
        this.viewer.dwgDefaultView.Target[0],
        this.viewer.dwgDefaultView.Target[1],
        this.viewer.dwgDefaultView.Target[2],
      );
      return e.addVectors(t, n), e;
    },
    getDwgPositionInfo(t) {
      let e = {},
        n = this.viewer.scale;
      const i = this.getCameraPosition();
      let r = t;
      this.viewer.isDwgAddMarkNewWayComputePoint &&
        (r = this.getFileLinkPositionOffset(t));
      const o = { x: r.x / n, y: r.y / n };
      let s = this.getDwgOutWidth();
      Object.assign(e, { cameraPosition: i.cameraPosition }),
        Object.assign(e, { cameraUp: i.cameraUp }),
        Object.assign(e, { cameraTarget: i.cameraTarget }),
        Object.assign(e, { outWidth: s }),
        Object.assign(e, { scale: n }),
        Object.assign(e, { DWGMark: o }),
        Object.assign(e, { isDWG: !0 }),
        Object.assign(e, { offset: this.viewer.dwgDefaultView.Target });
      const a = this.viewer.bimViewer
        .getModelScene()
        .getModelArray()[0]
        .getDwgLayoutMap();
      let c = 'Model';
      a.forEach((t, e) => {
        t.showThis && (c = e);
      }),
        Object.assign(e, { dwgLayoutName: c }),
        this.viewer.dispatchEvent({ type: 'addDwgMark', object: e });
    },
    getDwgOutWidth() {
      const t = this.viewer.bimViewer.getMainCamera();
      let e = t.position.distanceTo(t.target);
      return { width: (t.viewWidth / t.viewHeight) * e, height: e };
    },
    recursionTreeFromIdToName(t, e) {
      let n = null;
      try {
        const n = (t, e) => {
          for (let i = 0; i < t.length; i++) {
            let r = t[i];
            if (r.type === nm && r.value === e) throw r.name;
            r.childArray && r.type <= nm && n(r.childArray, e);
          }
        };
        n(t, e);
      } catch (t) {
        n = t;
      }
      return n;
    },
    getCameraPosition() {
      let t = this.viewer.scale;
      const e = this.viewer.bimViewer.getMainCamera();
      return {
        cameraPosition: {
          x: e.position.x / t,
          y: e.position.y / t,
          z: e.position.z / t,
        },
        cameraTarget: {
          x: e.target.x / t,
          y: e.target.y / t,
          z: e.target.z / t,
        },
        cameraUp: e.up,
      };
    },
    computedTransverseView() {
      const t = Math.PI / 180,
        e = this.computedCameraVector(),
        n = this.viewer.bimViewer.getMainCamera();
      return (e * Math.tan(0.5 * t * n.fov)) / n.zoom;
    },
    computedCameraVector() {
      const t = this.viewer.bimViewer.getMainCamera(),
        e = t.position.x,
        n = t.position.y,
        i = t.position.z;
      let r = e + 1.5 * (t.target.x - e),
        o = n + 1.5 * (t.target.y - n),
        s = i + 1.5 * (t.target.z - i);
      return Math.sqrt(
        Math.pow(e - r, 2) + Math.pow(n - o, 2) + Math.pow(i - s, 2),
      );
    },
    getFlatBufferFloorInfo() {
      const t = this.viewer.bimViewer
        .getModelScene()
        .getModelArray()[0]
        .modelTree.getRootNode();
      let e = [];
      return this.recursionTreeGetFloorInfo([t], e), e;
    },
    recursionTreeGetFloorInfo(t, e) {
      for (let n = 0; n < t.length; n++) {
        let i = t[n];
        if (i.type === nm)
          if (i.checked) e.push({ floorid: i.value, state: 1 });
          else {
            let t = [];
            this.recursionTreeGetComtypeInfo(i.childArray, t),
              t.length > 0
                ? e.push({ floorid: i.value, state: 2, comtypeArr: t })
                : e.push({ floorid: i.value, state: 0 });
          }
        i.childArray &&
          i.type <= nm &&
          this.recursionTreeGetFloorInfo(i.childArray, e);
      }
    },
    recursionTreeGetComtypeInfo(t, e) {
      for (let n = 0; n < t.length; n++) {
        let i = t[n];
        i.type === im && i.checked && e.push(i.value),
          i.childArray &&
            i.type <= im &&
            this.recursionTreeGetComtypeInfo(i.childArray, e);
      }
    },
    selectGeometry(t) {
      let e;
      e =
        'touchend' === t.type
          ? this.getWorldCoordinate(
              t.changedTouches[0].clientX,
              t.changedTouches[0].clientY,
            )
          : this.getWorldCoordinate(t.clientX, t.clientY);
      let n = this.viewer.bimViewer.pickSelectEntityByWindowPos(e);
      if (
        ((document.getElementById(
          this.viewer.parentElementId + '__ccbim__rightPopupMenu',
        ).style.display = 'none'),
        this.viewer.bimViewer.clearAllHighlightEntity(),
        this.viewer.uiState.roamVisible &&
          0 === t.button &&
          this.viewer.uiState.selectedEntity &&
          this.viewer.uiState.selectedEntity.uuid === n &&
          n.entity.uuid)
      )
        return (
          (this.viewer.uiState.selectedEntity = null),
          void this.viewer.dispatchEvent({ type: 'selectedEntity', object: {} })
        );
      if (((this.viewer.uiState.selectedEntity = null), n)) {
        if (
          (this.viewer.bimViewer
            .getHighlightScene()
            .getHighlightStyle()
            .setMeshOpacity(1),
          this.viewer.bimViewer.highlightEntity(n ? n.entity : null),
          (this.viewer.uiState.selectedEntity = n.entity),
          this.viewer.uiState.componentInfoVisible)
        ) {
          let t = this.viewer.parentElementId;
          u_.get(t).getHandleInfo();
        }
        this.viewer.uiState.cutComponent
          ? (document.getElementById('ccbim__componentCutBox').style.display =
              'block')
          : (2 === t.button && this.showRightPopupMenu(t),
            this.getSelectGeometryPositionInfo(n.entity, n.point));
      } else this.viewer.dispatchEvent({ type: 'selectedEntity', object: {} });
    },
    addDwgMark(t) {
      document.getElementById(
        this.viewer.parentElementId + '__ccbim__rightPopupMenu',
      ).style.display = 'none';
      let e;
      return (
        (document.getElementById(
          this.viewer.parentElementId + '__ccbim__markInit',
        ).style.display = 'none'),
        (e =
          'touchend' === t.type
            ? this.getWorldCoordinateDwg(
                t.changedTouches[0].clientX,
                t.changedTouches[0].clientY,
              )
            : this.getWorldCoordinateDwg(t.clientX, t.clientY)),
        (0 === t.button && this.viewer.isPhoneDwgAddMark) ||
        (0 === t.button && this.viewer.isMouseLeftDwgAddMark)
          ? (this.addClickDwgMark(e), void this.getDwgPositionInfo(e))
          : 2 !== t.button || this.viewer.isMouseLeftDwgAddMark
          ? void this.viewer.dispatchEvent({ type: 'addDwgMark', object: {} })
          : (this.addClickDwgMark(e),
            this.getDwgPositionInfo(e),
            void this.showRightPopupMenu(t))
      );
    },
    setDwgViewInfoFromXY(t, e) {
      let n = this.getWorldCoordinateDwg(t, e);
      this.getDwgPositionInfo(n);
    },
    addClickDwgMark(t) {
      let e = document.getElementById(
        this.viewer.parentElementId + '__ccbim__markInit',
      );
      (e.style.display = 'block'),
        (function (t) {
          v_.clear(), __.clear();
          const e = new J(t.x, t.y, 1);
          v_.set(-1, { id: -1, point: e });
        })(t),
        x_(e, this.viewer),
        this.hasBindEventMarkInit ||
          (this.viewer.bimViewer.bindCameraChangedEvent(() => {
            x_(e, this.viewer);
          }),
          (this.hasBindEventMarkInit = !0));
    },
    getWorldCoordinate(t, e) {
      const n = this.dom.getBoundingClientRect();
      let i = new U();
      return (
        i.set(
          ((t - n.left) / n.width) * 2 - 1,
          (-(e - n.top) / n.height) * 2 + 1,
        ),
        i
      );
    },
    getWorldCoordinateDwg(t, e) {
      const n = this.dom.getBoundingClientRect(),
        i = this.viewer.bimViewer.getMainCamera();
      let r = new J();
      return (
        (r.x = ((t - n.left) / n.width) * 2 - 1),
        (r.y = (-(e - n.top) / n.height) * 2 + 1),
        r.unproject(i),
        (r.z = 1),
        r
      );
    },
    showRightPopupMenu(t) {
      let e = this.getOffsetY(t),
        n = this.getOffsetX(t);
      const i = document.getElementById(
        this.viewer.parentElementId + '__ccbim__rightPopupMenu',
      );
      i.style.display = 'block';
      const r = this.viewer.viewDevices.getDevicesWidthHeight();
      r.w - this.getOffsetX(t) < i.clientWidth &&
        (n = this.getOffsetX(t) - i.clientWidth),
        r.h - this.getOffsetY(t) < i.clientHeight &&
          (e = this.getOffsetY(t) - i.clientHeight),
        (i.style.top = e + 1 + 'px'),
        (i.style.left = n + 1 + 'px');
    },
    getOffsetX(t) {
      let e = t || window.event,
        n = e.target || e.srcElement;
      if (e.offsetX) return e.offsetX;
      {
        let t,
          i = n.getBoundingClientRect();
        return (
          (t =
            'touchend' === e.type || 'touchstart' === e.type
              ? e.changedTouches[0].clientX
              : e.clientX),
          t - i.left
        );
      }
    },
    getOffsetY(t) {
      let e = t || window.event,
        n = e.target || e.srcElement;
      if (e.offsetY) return e.offsetY;
      {
        let t,
          i = n.getBoundingClientRect();
        return (
          (t =
            'touchend' === e.type || 'touchstart' === e.type
              ? e.changedTouches[0].clientY
              : e.clientY),
          t - i.top
        );
      }
    },
  }),
    (A_.prototype = {
      constructor: A_,
      init() {
        this.dom.addEventListener('mousedown', (t) => this.onMouseDown(t), !1),
          this.dom.addEventListener('mouseup', (t) => this.onMouseUp(t), !1),
          this.dom.addEventListener(
            'mousemove',
            (t) => this.onMouseMove(t),
            !1,
          ),
          this.dom.addEventListener(
            'touchstart',
            (t) => this.onTouchStart(t),
            !1,
          ),
          this.dom.addEventListener('touchend', (t) => this.onTouchEnd(t), !1),
          this.dom.addEventListener(
            'touchmove',
            (t) => this.onTouchMove(t),
            !1,
          ),
          this.dom.addEventListener(
            'contextmenu',
            (t) => this.onContext(t),
            !1,
          ),
          this.dom.addEventListener('dblclick', (t) => this.onDblclick(t), !1);
      },
      onMouseDown(t) {
        t.preventDefault(),
          t.stopPropagation(),
          this.actionManager.onModelMouseDown(t);
      },
      onMouseUp(t) {
        2 !== t.detail &&
          (t.preventDefault(),
          t.stopPropagation(),
          this.actionManager.onModelMouseUp(t, { isChoose: !0 }));
      },
      onMouseMove(t) {
        t.preventDefault(), this.actionManager.onModelMouseMove(t);
      },
      onTouchStart(t) {
        t.stopPropagation(), this.actionManager.onModelMouseDown(t);
      },
      onTouchEnd(t) {
        t.stopPropagation(),
          this.actionManager.onModelMouseUp(t, { isChoose: !0 });
      },
      onTouchMove(t) {
        t.preventDefault(), this.actionManager.onModelMouseMove(t);
      },
      onContext(t) {
        t.preventDefault();
      },
      onDblclick(t) {
        if (
          (t.preventDefault(),
          t.stopPropagation(),
          !this.viewer.uiState.roamVisible)
        )
          if ('model' === this.viewer.type) {
            console.log('模型双击'),
              this.actionManager.onModelMouseUp(t, { isChoose: !0 });
            const e = this.viewer.uiState.selectedEntity;
            if (e) {
              let t = this.viewer.bimViewer.getMainCamera(),
                n = e.getBoundingBox();
              t.makeLookAtBoundingBox(n), this.viewer.bimViewer.cameraChanged();
            }
          } else if ('dwg' === this.viewer.type) {
            console.log('图纸双击');
            let e = this.viewer.bimViewer.getOperator();
            e.zoom && ((t.deltaY = -300), e.zoom.onMouseWheel(t));
          }
      },
    }),
    (M_.prototype = Object.assign(Object.create(om.prototype))),
    (S_.prototype = Object.assign(Object.create(bm.prototype), {
      constructor: S_,
      createModel: function (t, e) {
        return new Promise((n, i) => {
          this.model
            ? this.cancelCreateModel
              ? i('取消加载')
              : n(this.model)
            : this.fileLoader.loadFile(t.headFile, 'json').then((r) => {
                (this.viewer.dwgDefaultView = r.data.View),
                  (this.model = new Bm(t.version, this)),
                  this.loadModel(r.data, this.model, e)
                    .then(() => {
                      this.cancelCreateModel ? i('取消加载') : n(this.model);
                    })
                    .catch(() => {
                      i('.json catch取消加载');
                    });
              });
        });
      },
      cancelCreateModelAsync: function () {
        this.cancelCreateModel = !0;
      },
      async loadModel(t, e, n) {
        if (!t) return;
        let i = this.getFileLoader();
        if ((i.setBasicFileTotal(1), t.materials))
          for (let e = 0, n = t.materials.length; e < n; e++)
            this.materialMap.set(
              Number.parseInt(t.materials[e].uuid),
              t.materials[e].color,
            );
        if (
          (this.createModelTree(t.LayerOut, e),
          this.createSceneTree(t.fileList, e.getSceneNode(), t.LayerOut),
          i.setBasicProgress(1),
          n(i.getBasicProgress()),
          this.cancelCreateModel)
        )
          throw new Error('取消了加载');
      },
      createModelTree: function (t, e) {
        let n = e.getModelTree();
        for (let e = 0; e < t.length; e++)
          for (let i = 0; i < t[e].layer.length; i++) {
            const r = t[e].layer[i],
              o = this.materialMap.get(r.matId);
            let s = new M_(em, r.name, o, r.GeoInfo, n);
            if ((n.insertNode(s), r.GeoInfo))
              for (let t = 0; t < r.GeoInfo.length; t++)
                this.entityTreeNodeMap.set(r.GeoInfo[t], s);
          }
      },
      createSceneTree: function (t, e, n) {
        if (!t || !e) return;
        let i = new Pm(this);
        e.add(i);
        let r = new J(-1e3, -1e3, -1e3),
          o = new J(1e3, 1e3, 1e3);
        i.setBndBox(new Nt(r, o));
        let s = new km();
        s.setContentSize(419430400), s && (s.setUsage(-1), i.setPageData(s));
        for (let e = 0, n = t.length; e < n; e++) {
          let n = this.createFileIndex(t[e]);
          n && i.addEntInfoFileList(n);
        }
      },
      createFileIndex: function (t) {
        if (!t) return null;
        let e = new gm();
        return e.setID(t.uuid), e.setURL(t.Path), e.setFileSize(t.filesize), e;
      },
      loadSceneNode: function (t, e, n) {
        if (!t) return;
        const i = t.getEntInfoFileList();
        let r = this.getFileLoader();
        r.setEntInfoFileTotal(i.length);
        for (let e = 0, o = i.length; e < o; e++) {
          let o = r.getFileIndex(i[e].getURL());
          if (!o) continue;
          let s = r.loadFile(o, 'json').then((e) => {
            let n = [];
            this.cerateGeometryArray(e.data, n);
            for (let e = 0, i = n.length; e < i; e++) {
              let i = n[e];
              t.renderBufferMap.set(i.getUUID(), i);
              let r = new Yf(
                  i.getUUID(),
                  new vm(0, i.vertexIndex.bufferAttribute.count),
                ),
                o = new J(
                  i.vertexBoundingSphere.center.x -
                    i.vertexBoundingSphere.radius,
                  i.vertexBoundingSphere.center.y -
                    i.vertexBoundingSphere.radius,
                  0,
                );
              r.expandBoundingByPoint(o);
              let s = new J(
                i.vertexBoundingSphere.center.x + i.vertexBoundingSphere.radius,
                i.vertexBoundingSphere.center.y + i.vertexBoundingSphere.radius,
                0,
              );
              r.expandBoundingByPoint(s);
              let a = new $f(i.getUUID());
              a.addGeoData(r);
              let c = i.getVertexBufferAttribute('position');
              if (c) {
                let e = a.getBoundingBox();
                e.setFromBufferAttribute(c), t.expandBndBox(e);
              }
              t.entityMap.set(a.getID(), a);
              this.entityTreeNodeMap.get(i.getUUID()).insertEntity(a);
            }
            this.samllProgress(r);
          });
          s && n.push(s);
        }
      },
      cerateGeometryArray: function (t, e) {
        for (let n = 0; n < t.Geomery.length; n++) {
          let i = t.Geomery[n],
            r = this.addGeometry(i);
          r && e.push(r);
        }
      },
      addGeometry: function (t) {
        let e, n;
        switch (t.type) {
          case void 0:
          case null:
          case 'Line':
            {
              (n = Hf.LINES), (e = new Vm());
              const i = this.materialMap.get(t.material);
              e.setMaterial(new bo({ color: i, linewidth: 1, side: 2 })),
                e.addVertexBufferAttribute(
                  'position',
                  new Fe(new Float32Array(t.vertices), 3),
                );
            }
            break;
          case 'Pt':
            {
              (n = Hf.POINT), (e = new Vm());
              const i = this.materialMap.get(t.material);
              e.setMaterial(
                new Eo({ color: i, size: 1.5, side: 2, sizeAttenuation: !1 }),
              );
            }
            break;
          case 'Tri': {
            (n = Hf.TRIANGLES), (e = new Vm());
            const i = this.materialMap.get(t.material);
            e.setMaterial(new xe({ color: i, side: 2 })),
              e.addVertexBufferAttribute(
                'position',
                new Fe(new Float32Array(t.vertices), 3),
              );
          }
        }
        if (e) {
          let i = new Uint32Array(t.vertices.length / 3);
          for (let t = 0, e = i.length; t < e; t++) i[t] = t;
          let r = new Wf(n);
          r.setIndex(i), e.setVertexIndex(r), e.setUUID(t.uuid);
        }
        return e;
      },
      samllProgress: function (t) {
        if (this.cancelCreateModel) return;
        t.setEntInfoProgress(1);
        const e = t.getEntInfoProgress();
        let n = document.getElementById(
            this.viewer.parentElementId + '__ccbim__small__progress__div',
          ),
          i = document.getElementById(
            this.viewer.parentElementId + '__ccbim__small__progress',
          );
        i && (i.style.display = 'block'),
          n && (n.style.width = e + '%'),
          e >= 100 &&
            (i && (i.style.display = 'none'),
            this.hasloadOnce ||
              setTimeout(() => {
                this.viewer.renderFinish(),
                  this.viewer.dispatchEvent({
                    type: 'renderFinish',
                    object: !0,
                  }),
                  (this.hasloadOnce = !0);
              }));
      },
    }));
  class I_ extends Sh {
    constructor(t) {
      super(t), (this.state = { visible: !1 });
    }
    render() {
      return Xh`<${Mh}>
      <div
      class="ccbim__loading"
    >
      <img src="${
        window.CcbimSDKLoaderConfig.staticHost +
        '/ccbimSDK@' +
        window.CcbimSDKLoaderConfig.version +
        '/ccbim/assets/images/loading.gif'
      }" />
    </div>
      </${Mh}>`;
    }
  }
  class E_ extends Sh {
    constructor(t) {
      super(t),
        (this.state = {
          isShowPointImage: !1,
          pointImageSrc: '',
          pointImageTop: 0,
          pointImageLeft: 0,
          pointData: null,
        });
    }
    showPointImage(t) {
      t.photo &&
        this.setState({
          isShowPointImage: !0,
          pointImageSrc: t.photo,
          pointImageTop: t.top - 160,
          pointImageLeft: t.left - 100,
          pointData: t,
        });
    }
    render() {
      return Xh`<${Mh}>
      ${this.props.pointList.map(
        (t) => Xh`
          <div
            style=${{
              position: 'absolute',
              left: `${t.left}px`,
              top: `${t.top}px`,
              display: '' + (t.show ? 'block' : 'none'),
            }}
          >
            <div
              class=${t.color ? 'ccbim__point__color' : 'ccbim__point'}
              style=${{
                opacity: 1,
                backgroundImage: `url(${t.iconImg})`,
                backgroundColor: `${t.color}`,
              }}
              onMouseEnter=${() => {
                this.showPointImage(t);
              }}
              onMouseLeave=${() => {
                this.setState({ isShowPointImage: !1 });
              }}
            ></div>
          </div>
        `,
      )}
      ${
        this.state.isShowPointImage &&
        Xh`<div
          style=${{
            top: `${this.state.pointImageTop}px`,
            left: `${this.state.pointImageLeft}px`,
          }}
          onMouseEnter=${() => {
            this.setState({ isShowPointImage: !0 });
          }}
          onMouseLeave=${() => {
            this.setState({ isShowPointImage: !1 });
          }}
          class="ccbim__dwgModelRe__pointOver__image"
        >
          <div class="ccbim__dwgModelRe__pointOver__image__content">
            <img src=${this.state.pointImageSrc} />
          </div>
          <p class="ccbim__dwgModelRe__pointOver__image__title">
            ${this.state.pointData.title}
          </p>
          <div class="ccbim__dwgModelRe__pointOver__image__operator">
            ${
              'dwgModelLook' === this.state.pointData.relationType &&
              Xh`<div class="iconBox">
              <svg
                title="图模联动"
                class="icon"
                aria-hidden="true"
                onClick=${() => {
                  let t = {
                    id: this.state.pointData.id,
                    left: this.state.pointData.left,
                    top: this.state.pointData.top,
                    selfDefiningData: this.state.pointData.selfDefiningData,
                  };
                  this.state.pointData.clickPointContentCallback({
                    type: 'dwgModelLook',
                    data: t,
                  });
                }}
              >
                <use xlinkHref="#iconersanweiliandong1"></use>
              </svg>
              <p>图模联动</p>
            </div>`
            }
            ${
              'fileLook' === this.state.pointData.relationType &&
              Xh`<div class="iconBox">
              <svg
                title="查看文件"
                class="icon"
                aria-hidden="true"
                onClick=${() => {
                  let t = {
                    id: this.state.pointData.id,
                    left: this.state.pointData.left,
                    top: this.state.pointData.top,
                    selfDefiningData: this.state.pointData.selfDefiningData,
                  };
                  this.state.pointData.clickPointContentCallback({
                    type: 'fileLook',
                    data: t,
                  });
                }}
              >
                <use xlinkHref="#iconersanweiliandong1"></use>
              </svg>
              <p>查看文件</p>
            </div>`
            }
            <div class="iconBox">
              <svg
                title="关联详情"
                class="icon"
                aria-hidden="true"
                onClick=${() => {
                  let t = {
                    id: this.state.pointData.id,
                    left: this.state.pointData.left,
                    top: this.state.pointData.top,
                    selfDefiningData: this.state.pointData.selfDefiningData,
                  };
                  this.state.pointData.clickPointContentCallback({
                    type: 'relationDetail',
                    data: t,
                  });
                }}
              >
                <use xlinkHref="#iconcon"></use>
              </svg>
              <p>关联详情</p>
            </div>
          </div>
        </div>`
      }
    </${Mh}>`;
    }
  }
  let D_ = new Map(),
    C_ = new Map(),
    T_ = new Map();
  function L_(t, e) {
    let n = (function (t) {
      if (0 === D_.size) return [];
      let { wHalf: e, hHalf: n } = t.viewDevices.getDevicesWidthHeight();
      for (let i of D_.values()) {
        let r = t.bimViewer.getMainCamera(),
          o = i.point.clone();
        o.project(r), (o.x = o.x * e + e), (o.y = -o.y * n + n);
        let s = !1;
        if ('model' === t.type) s = !0;
        else {
          let t = 'Model';
          T_.forEach((e, n) => {
            e.showThis && (t = n);
          }),
            t === i.dwgLayoutName && (s = !0);
        }
        s && (s = !r.cullPoint(i.point)),
          C_.set(i.id, {
            id: i.id,
            left: o.x - 15,
            top: o.y - 40,
            selfDefiningData: i.selfDefiningData,
            iconImg: i.iconImg
              ? i.iconImg
              : 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB8AAAAmCAYAAAA820BcAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA39pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDIxIDc5LjE1NTc3MiwgMjAxNC8wMS8xMy0xOTo0NDowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDphODRkMDNjNC04MzBlLTZlNDEtOWUyYS0xOWEzYTRiNGMwNTkiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6RDgwNzJDN0NFQjhFMTFFN0E4ODlENTE1NEZCQzExQkIiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6RDgwNzJDN0JFQjhFMTFFN0E4ODlENTE1NEZCQzExQkIiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOmQ4NmY1MTliLWJhMmUtYjk0ZC1iYmRjLWZhMzlhOTM0NWNmNiIgc3RSZWY6ZG9jdW1lbnRJRD0iYWRvYmU6ZG9jaWQ6cGhvdG9zaG9wOmJmNDQzMjIyLTcwNTgtYmE0Yi04ZGVmLTRlNDgzYTI0MDA4NiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqFeqsUAAAPDSURBVHjatFhpbExRFP5mOqglqEgZWvyQ2IoIaklaIRp7Ygvxxw+x/7BNEIkKQYJmosSPqkhERIJIJGgVKSli19RWkUa0Hbso0ui0quM77715fTPtzLxZ3km+m3fuvHe+e8+9555zx+bz+dBGXDa0I/2IuUQ2MZRwEp2JBuIzUUmUEVfg9n2ECbG1Sx44kMlsdxCziCQTNv8RxcQBDuJebOQuWx+2R4kliF3OExs4iC/mydXZXtBcrYqjEzB4KpAxHxg0CUgZCCT3ALy/gLpq4P194OUloOoW0NxotCZLsrg9L7Qld9nEvRe19QTsDiBzBTBjN9DdGXmu9V+B0oPA3WNcgCZ/r+yLRRxAcWhyl20C21Kii6KnDgGW03POUdE7/NNz4PRS4Osbf88fYhoH8LAtucvWi20Fkabo6eOB1dc4jF6xr3hDHVBIR9bofB5iNAfwQ3Gq4dVDOnEqI2ntjfiIRTqnAGtKVHuqpGk8hpm7bKP5XC46kjoAm5/E5uqQS/ACODyWe+CvaOLqMZx9hX/mWxVikayNiSUWcY5U7WoTJrapM9+CHlo4JMORDOQybLqlIuEiUbCX4dnsFU2avjLzGQqxyPC51hCLiN0R8/ya8M20a2e1KsPnwFIZNtuoZQt5hq6mjbWWPH2cURsh5P11NWWAteQ9041afyHvqqtyVlspgfa7CPlfXfX+tpY80L5XyL/r6s9aa8l/eYxanZC/09Xax9aS1zwyatVC/lRXK4usJQ+0Xy7kJbr66rJ6Elkh9d9U+63ywM4DXhLKW0WVo+9WnjXkt/P8R6uIpNQ7/sRyXH/pzhG1EEikSFYryzf2nOGkG/3khfqul7QnFYjUZgkJL9o5vcSfThX/Eu7WYsLtq2e7U/9ASp+C6fGvv3xfkGMspUQKyFcTXMmcEKe3hh0LinyWUp5nsRF/4FbKzwwOX0nduaEKSDl8ha233ifV68SVQM4uc9Xr70/A9T3Aw5NAS7PxlxYlfbt9N8OVztO0G0fHgH4pNCTfS9qV7KfU7d3VI1Pqdg+Pi9dXiSvGXW2UXBLvM3NpkFvKWZPXIzMi0bSO5AFk9jDXnGVEUwKI6X+sDyYORw7tuiSlTTypTsrkVSRuae9HR4SPZXNkEUUBRYe5m+omkh4L95LdhCE57iYEJKAI0U0siERsllyJWs0D5yK8x22PySS+bMaoPQpXNmibcH+ohKkQAy/MGrRHuYF82jG8I6hfCKcQH6MxZo9xFx8gTmnPEo4LiW/RGnHEEUbbiUztj4SqWAz8F2AAwxUsG0cxVxkAAAAASUVORK5CYII=',
            color: i.color,
            photo: i.photo,
            show: s,
            title: i.title,
            relationType: i.relationType,
            clickPointContentCallback: i.clickPointContentCallback,
          });
      }
      return [...C_.values()];
    })(e);
    n && jh(Xh`<${E_} pointList=${n} />`, t);
  }
  class R_ extends Sh {
    constructor(t) {
      super(t), (this.state = { visible: !0 });
    }
    remove() {
      this.setState({ visible: !1 });
    }
    render() {
      return Xh`<${Mh}>
        ${
          this.state.visible &&
          Xh`<div
            id="ccbim__point__image__box"
            class="ccbim__point__image__box"
          >
            <svg
              class="ccbim__point__image__close"
              title="关闭"
              onClick=${() =>
                (function (t) {
                  const e = document.getElementById(t + '__ccbim__viewInfoImg');
                  jh(Xh``, e);
                })(this.props.domId)}
            >
              <use xlinkHref="#iconguanbi1"></use>
            </svg>
            <img class="ccbim__point__image" src=${this.props.viewInfoImage} />
          </div>`
        }
      </${Mh}>`;
    }
  }
  class F_ {
    constructor(t) {
      (this.app = t),
        (this.hasBindEvent = !1),
        (this.hasBindEventDwgModel = !1);
    }
    setViewRenderWith(t) {
      this.app.viewDevices.setRenderWidth(t), this.app.viewDevices.resize();
    }
    setViewRenderHeight(t) {
      this.app.viewDevices.setRenderHeight(t), this.app.viewDevices.resize();
    }
    canvasToImage() {
      let t = this.app.viewDevices.getDevicesWidthHeight();
      return {
        img: this.app.bimViewer.renderContext.renderer.domElement.toDataURL(
          'image/png',
        ),
        width: t.w,
        height: t.h,
      };
    }
    canvasToImageBlod() {
      let t = this.app.bimViewer.renderContext.renderer.domElement.toDataURL();
      (t = t.split(',')[1]), (t = window.atob(t));
      const e = new Uint8Array(t.length);
      for (let n = 0; n < t.length; n++) e[n] = t.charCodeAt(n);
      return new Blob([e], { type: 'image/png' });
    }
    closeBarAllOperation() {
      let t = this.app.parentElementId;
      u_.get(t).closeAllOperation();
    }
    loadingShow() {
      !(function (t) {
        const e = document.getElementById(t + '__ccbim__loading');
        jh(Xh`<${I_} />`, e);
      })(this.app.parentElementId);
    }
    loadingHidden() {
      !(function (t) {
        const e = document.getElementById(t + '__ccbim__loading');
        jh(Xh``, e);
      })(this.app.parentElementId);
    }
    setVisibleBar(t) {
      (this.app.optionConfig.operationBar.showBar = t),
        p_(this.app),
        m_(this.app.parentElementId, t);
    }
    setMarkPointListDwgModelLink(t) {
      let e = document.getElementById(
        this.app.parentElementId + '__ccbim__markPoints__dwgModelRe',
      );
      !(function (t, e) {
        D_.clear(), C_.clear();
        const n = e.bimViewer.getModelScene().getModelArray();
        T_ = n[0].getDwgLayoutMap();
        for (let n = 0; n < t.length; n++) {
          const i = t[n];
          if ('{}' === JSON.stringify(i))
            return console.log('添加模型标注对象格式不正确'), !1;
          if (D_.has(i.id)) return;
          const r = e.scale;
          if (i.pointPosition) {
            const t = i.pointPosition;
            let n = new J(t.x * r, t.y * r, t.z ? t.z * r : 1);
            if ('dwg' === e.type) {
              const t = new J(
                e.dwgDefaultView.Target[0],
                e.dwgDefaultView.Target[1],
                e.dwgDefaultView.Target[2],
              );
              let i = new J();
              i.subVectors(n, t), n.copy(i);
            }
            let o = i.dwgLayoutName ? i.dwgLayoutName : 'Model';
            D_.set(i.id, {
              id: i.id,
              point: n,
              dwgLayoutName: o,
              selfDefiningData: i.selfDefiningData,
              iconImg: i.iconImg,
              color: i.color,
              photo: i.photo,
              title: i.title,
              relationType: i.relationType,
              clickPointContentCallback: i.clickPointContentCallback,
            });
          }
        }
      })(t, this.app),
        L_(e, this.app),
        this.hasBindEventDwgModel ||
          (this.app.bimViewer.bindCameraChangedEvent(() => {
            L_(e, this.app);
          }),
          (this.hasBindEventDwgModel = !0));
    }
    bouncedwgModelReMark(t) {
      !(function (t, e) {
        let n = 0,
          i = setInterval(() => {
            n += 30;
            let i = ((2 * Math.PI) / 360) * n;
            (C_.get(e).top -= 3 * Math.sin(i)),
              jh(Xh`<${E_} pointList=${[...C_.values()]} />`, t);
          }, 25);
        setTimeout(() => {
          clearInterval(i);
        }, 1500);
      })(
        document.getElementById(
          this.app.parentElementId + '__ccbim__markPoints__dwgModelRe',
        ),
        t,
      );
    }
    setMarkVisible(t, e) {
      !(function (t, e) {
        document.getElementById(t + '__ccbim__markPoints').style.display = e
          ? 'block'
          : 'none';
        document.getElementById(
          t + '__ccbim__markPoints__dwgModelRe',
        ).style.display = e ? 'block' : 'none';
      })(t, e);
    }
    setViewInfoImg(t) {
      !(function (t, e) {
        const n = document.getElementById(t + '__ccbim__viewInfoImg');
        jh(Xh`<${R_} domId=${t} viewInfoImage=${e}/>`, n);
      })(this.app.parentElementId, t);
    }
  }
  class P_ extends F_ {
    constructor(t) {
      super(t);
    }
    setIsPhoneDwgAddMark(t) {
      this.app.isPhoneDwgAddMark = !!t;
    }
    setMouseLeftDwgAddMark(t) {
      t
        ? ((this.app.isMouseLeftDwgAddMark = !0), this.setAddDwgMarkHidden())
        : (this.app.isMouseLeftDwgAddMark = !1);
    }
    setIsDwgAddMarkNewWayComputePoint(t) {
      t
        ? ((this.app.isDwgAddMarkNewWayComputePoint = !0),
          this.setAddDwgMarkHidden())
        : (this.app.isDwgAddMarkNewWayComputePoint = !1);
    }
    setAddDwgMarkHidden() {
      const t = document.getElementById(
        this.app.parentElementId + '__ccbim__rightPopupMenu',
      );
      t && (t.style.display = 'none');
      const e = document.getElementById(
        this.app.parentElementId + '__ccbim__markInit',
      );
      e && (e.style.display = 'none'),
        this.app.dispatchEvent({ type: 'addDwgMark', object: {} });
    }
    dwgToViewHome() {
      let t = !1;
      if (
        (this.app.bimViewer
          .getModelScene()
          .getModelArray()[0]
          .getDwgLayoutMap()
          .forEach((e) => {
            if (e.showThis) {
              this.app.bimViewer
                .getMainCamera()
                .makeLookAtBoundingBoxDwg(e.bndBox),
                this.app.bimViewer.cameraChanged(),
                (t = !0);
            }
          }),
        !t)
      ) {
        let t = this.app.dwgDefaultView,
          e = new Nt();
        (e.min.x = -t.Width / 2),
          (e.min.y = -t.Height / 2),
          (e.min.z = 0),
          (e.max.x = t.Width / 2),
          (e.max.y = t.Height / 2),
          (e.max.z = 0),
          this.app.bimViewer.getMainCamera().makeLookAtBoundingBoxDwg(e),
          this.app.bimViewer.cameraChanged();
      }
    }
    getDwgViewInfo() {
      return this.app.eventManager.actionManager.getDwgViewInfo();
    }
    setDwgViewInfo(t) {
      super.closeBarAllOperation();
      let e = this.app.bimViewer.getMainCamera();
      t.cameraPosition;
      const n = t.outWidth,
        i = t.DWGMark,
        r = t.offset,
        o = new J(i.x, i.y, 1),
        s = new J(r[0], r[1], r[2]);
      let a = new J();
      a.addVectors(o, s);
      const c = new J(
        this.app.dwgDefaultView.Target[0],
        this.app.dwgDefaultView.Target[1],
        this.app.dwgDefaultView.Target[2],
      );
      let l = new J();
      l.subVectors(a, c);
      const h = [l.x, l.y];
      let u = this.app.scale,
        d = new Nt();
      (d.min.x = h[0] * u - n.width / 2),
        (d.min.y = h[1] * u - n.height / 2),
        (d.min.z = 0),
        (d.max.x = h[0] * u + n.width / 2),
        (d.max.y = h[1] * u + n.height / 2),
        (d.max.z = 0),
        e.makeLookAtBoundingBoxDwg(d),
        e.update(),
        this.app.bimViewer.cameraChanged();
    }
    setCameraCADView(t, e) {
      setTimeout(() => {
        super.closeBarAllOperation();
        let n = this.app.bimViewer.getMainCamera();
        const i = t.split(',');
        let r = [];
        try {
          let t = JSON.parse(e);
          if ('object' == typeof t && t) {
            let e = t.position.split(',');
            const n = new J(parseInt(e[0]), parseInt(e[1]), 1),
              i = new J(t.offset[0], t.offset[1], t.offset[2]);
            let o = new J();
            o.addVectors(n, i);
            const s = new J(
              this.app.dwgDefaultView.Target[0],
              this.app.dwgDefaultView.Target[1],
              this.app.dwgDefaultView.Target[2],
            );
            let a = new J();
            a.subVectors(o, s), (r = [a.x, a.y]);
          }
        } catch (t) {
          r = e.split(',');
        }
        let o = this.app.scale,
          s = new Nt();
        (s.min.x = parseFloat(r[0]) * o - parseFloat(i[2]) / 2),
          (s.min.y = parseFloat(r[1]) * o - parseFloat(i[3]) / 2),
          (s.min.z = 0),
          (s.max.x = parseFloat(r[0]) * o + parseFloat(i[2]) / 2),
          (s.max.y = parseFloat(r[1]) * o + parseFloat(i[3]) / 2),
          (s.max.z = 0),
          n.makeLookAtBoundingBoxDwg(s),
          n.update(),
          this.app.bimViewer.cameraChanged();
      });
    }
    setLinkCameraCADView(t, e) {
      setTimeout(() => {
        this.closeBarAllOperation();
        let n = this.app.bimViewer.getMainCamera();
        const i = t.split(',');
        let r = [],
          o = e.split(',');
        const s = new J(parseInt(o[0]), parseInt(o[1]), 0),
          a = new J(
            this.app.dwgDefaultView.Target[0],
            this.app.dwgDefaultView.Target[1],
            this.app.dwgDefaultView.Target[2],
          );
        let c = new J();
        c.subVectors(s, a), (r = [c.x, c.y]);
        let l = this.app.scale,
          h = new Nt();
        (h.min.x = parseFloat(r[0]) * l - parseFloat(i[2]) / 2),
          (h.min.y = parseFloat(r[1]) * l - parseFloat(i[3]) / 2),
          (h.min.z = 0),
          (h.max.x = parseFloat(r[0]) * l + parseFloat(i[2]) / 2),
          (h.max.y = parseFloat(r[1]) * l + parseFloat(i[3]) / 2),
          (h.max.z = 0),
          n.makeLookAtBoundingBoxDwg(h),
          n.update(),
          this.app.bimViewer.cameraChanged();
      });
    }
    setDwgViewInfoFromXY(t, e) {
      this.app.eventManager.actionManager.setDwgViewInfoFromXY(t, e);
    }
    setDwgLayoutChange(t) {
      setTimeout(() => {
        let e = t || 'Model',
          n = this.app.parentElementId;
        u_.get(n).setDwgLayoutChange(e);
      });
    }
  }
  class B_ extends F_ {
    constructor(t) {
      super(t), (this.modelRotateAnimation = null);
    }
    setBackgroundColor(t, e) {
      let n = new J(1, 1, 1),
        i = new J(1, 1, 1);
      if (t) {
        const e = new fe(t);
        n = new J(e.r, e.g, e.b);
      }
      if (e) {
        const t = new fe(e);
        i = new J(t.r, t.g, t.b);
      }
      this.app.bimViewer.setBackgroundColor(n, i),
        this.app.bimViewer.requestFrameUpdate();
    }
    openModelRotate(t = 0.4) {
      const e = (t) => {
        let n = this.app.bimViewer.getMainCamera(),
          i = new J(0, 0, 1),
          r = new ot();
        Xf.makeRotationMatrix4(n.target, i, Math.PI * t, r),
          n.makeRotate(r),
          this.app.bimViewer.cameraChanged(!1),
          (this.modelRotateAnimation = window.requestAnimationFrame(
            e.bind(this, t),
          ));
      };
      t > 10 ? (t = 10) : t < -10 && (t = -10),
        this.closeModelRotate(),
        e(t / 100);
    }
    closeModelRotate() {
      window.cancelAnimationFrame(this.modelRotateAnimation);
    }
    setSingleClick(t = !0) {
      t
        ? (this.app.isSingleClick = !0)
        : ((this.app.isSingleClick = !1), this.clearAllHighlightEntity());
    }
    clearAllHighlightEntity() {
      this.app.bimViewer.clearAllHighlightEntity();
    }
    modelToViewHome() {
      let t = this.app.bimViewer.getModelScene().getBoundingBox(),
        e = this.app.bimViewer.getMainCamera();
      e.makeLookAt(new J(1, -1, 1), new J(0, 0, 0), new J(0, 0, 1)),
        e.makeLookAtBoundingBox(t),
        this.app.bimViewer.cameraChanged();
    }
    setAllEntityColorStyle(t, e = 1) {
      let n = new bb();
      const i = this.app.bimViewer
          .getModelScene()
          .getModelArray()[0]
          .modelTree.getRootNode(),
        r = new fe(t);
      n.setMeshColor(r.r, r.g, r.b),
        n.setMeshOpacity(e),
        n.setMeshDoubleSide(!0),
        n.setMeshVertexOffset(-1.1),
        n.setLineColor(r.r, r.g, r.b),
        i.setEntityStyle(n, !0),
        this.app.bimViewer.cameraChanged();
    }
    recoverAllEntityColorStyle() {
      this.app.bimViewer
        .getModelScene()
        .getModelArray()[0]
        .modelTree.getRootNode()
        .setEntityStyle(null, !0),
        this.app.bimViewer.cameraChanged();
    }
    setEntityColorStyleFromFloorIdHandle(t, e, n, i = 1) {
      const r = this.app.bimViewer
        .getModelScene()
        .getModelArray()[0]
        .modelTree.getRootNode();
      let o = new bb();
      const s = new fe(n);
      o.setMeshColor(s.r, s.g, s.b),
        o.setMeshOpacity(i),
        o.setMeshDoubleSide(!0),
        o.setMeshVertexOffset(-1.1),
        o.setLineColor(s.r, s.g, s.b);
      let a = ng([r], t, e);
      a && a.setStyle(o), this.app.bimViewer.cameraChanged();
    }
    recoverEntityColorStyleFromFloorIdHandle(t, e) {
      ng(
        [
          this.app.bimViewer
            .getModelScene()
            .getModelArray()[0]
            .modelTree.getRootNode(),
        ],
        t,
        e,
      ).setStyle(null),
        this.app.bimViewer.cameraChanged();
    }
    getViewInfo() {
      return this.app.eventManager.actionManager.getModelViewInfo();
    }
    setModelViewInfo(t, e, n) {
      super.closeBarAllOperation();
      const i = this.app.bimViewer,
        r = new g_();
      let o = r.getFlatBuffer(r.DecodeBase64(n));
      const s = i.getModelScene().getModelArray(),
        a = s[0].modelTree.getRootNode();
      console.time('treeShow--time'),
        O_(o, [a]),
        i.requestFrameUpdate(),
        console.timeEnd('treeShow--time');
      let c = [o.cameraUp.x, o.cameraUp.y, o.cameraUp.z],
        l = [o.cameraTarget.x, o.cameraTarget.y, o.cameraTarget.z],
        h = [o.cameraPosition.x, o.cameraPosition.y, o.cameraPosition.z];
      if (
        (this.setCameraModelView(c, l, h),
        this.setSelectGeometry(t, e),
        s[0].modelTree.setCurrentLayer(o.stageId),
        (function (t) {
          let e = [];
          for (let t = 0; t < 6; ++t) e.push(new Kt(new J(), 0));
          let n = t.bimViewer.getModelScene().getBoundingBox(),
            i = n.min,
            r = n.max;
          e[0].normal.set(1, 0, 0),
            (e[0].constant = -i.x),
            e[1].normal.set(-1, 0, 0),
            (e[1].constant = r.x),
            e[2].normal.set(0, 1, 0),
            (e[2].constant = -i.y),
            e[3].normal.set(0, -1, 0),
            (e[3].constant = r.y),
            e[4].normal.set(0, 0, 1),
            (e[4].constant = -i.z),
            e[5].normal.set(0, 0, -1),
            (e[5].constant = r.z),
            t.bimViewer.setClippingPlanes(e);
        })(this.app),
        o.cullPlane && o.cullPlane.length > 0)
      ) {
        let t = o.cullPlane;
        !(function (t, e, n, i, r, o, s) {
          let a = s.scale,
            c = [];
          for (let t = 0; t < 6; ++t) c.push(new Kt(new J(), 0));
          c[0].normal.set(1, 0, 0),
            (c[0].constant = t * a),
            c[1].normal.set(-1, 0, 0),
            (c[1].constant = e * a),
            c[2].normal.set(0, 1, 0),
            (c[2].constant = n * a),
            c[3].normal.set(0, -1, 0),
            (c[3].constant = i * a),
            c[4].normal.set(0, 0, 1),
            (c[4].constant = r * a),
            c[5].normal.set(0, 0, -1),
            (c[5].constant = o * a),
            s.bimViewer.setClippingPlanes(c);
        })(t[0], t[1], t[2], t[3], t[4], t[5], this.app);
      }
    }
    setCameraModelView(t, e, n) {
      let i = this.app.bimViewer.getMainCamera(),
        r = this.app.scale;
      (e = e.map((t) => t * r)),
        (n = n.map((t) => t * r)),
        (i.up.x = t[0]),
        (i.up.y = t[1]),
        (i.up.z = t[2]),
        (i.position.x = n[0]),
        (i.position.y = n[1]),
        (i.position.z = n[2]),
        (i.target.x = e[0]),
        (i.target.y = e[1]),
        (i.target.z = e[2]),
        i.update(),
        this.app.bimViewer.cameraChanged();
    }
    setSelectGeometry(t, e) {
      const n = this.app.bimViewer;
      let i = ng(
        [n.getModelScene().getModelArray()[0].modelTree.getRootNode()],
        t,
        e,
      );
      n.clearAllHighlightEntity(),
        setTimeout(() => {
          n.getHighlightScene().getHighlightStyle().setMeshOpacity(1),
            n.highlightEntity(i);
        });
    }
    setEntVisibleFromFloorComtypeAPI(t) {
      O_(t, [
        this.app.bimViewer
          .getModelScene()
          .getModelArray()[0]
          .modelTree.getRootNode(),
      ]);
    }
    getFloorIdAndName() {
      let t = { floorIds: [], floorNames: [] };
      return (
        N_(
          [
            this.app.bimViewer
              .getModelScene()
              .getModelArray()[0]
              .modelTree.getRootNode(),
          ],
          t,
        ),
        t
      );
    }
  }
  function O_(t, e) {
    for (let n = 0; n < e.length; n++) {
      let i = e[n];
      if (i.type === nm)
        for (let e = 0; e < t.floorInfo.length; e++) {
          const n = t.floorInfo[e];
          1 === n.state
            ? i.value === n.floorid && sy.checkSwitchApi(i, !0)
            : 0 === n.state
            ? i.value === n.floorid && sy.checkSwitchApi(i, !1)
            : 2 === n.state &&
              i.value === n.floorid &&
              V_(i.childArray, n.floorid, n.comtypeArr);
        }
      i.childArray && i.type <= nm && O_(t, i.childArray);
    }
  }
  function V_(t, e, n) {
    for (let i = 0; i < t.length; i++) {
      let r = t[i];
      if (r.type === im)
        for (let t = 0; t < n.length; t++) {
          const e = parseInt(n[t]);
          if (r.value === e) {
            sy.checkSwitchApi(r, !0);
            break;
          }
          sy.checkSwitchApi(r, !1);
        }
      r.childArray && r.type <= im && V_(r.childArray, e, n);
    }
  }
  function N_(t, e) {
    for (let n = 0; n < t.length; n++) {
      let i = t[n];
      i.type === nm && (e.floorIds.push(i.value), e.floorNames.push(i.name)),
        i.childArray && N_(i.childArray, e);
    }
  }
  function k_(t, e) {
    jg.call(this, t),
      (this.planeNormal = new J(0, 0, 1)),
      e && this.planeNormal.copy(e),
      (this.prePosition = new J()),
      (this.currentPosition = new J());
  }
  function U_() {
    Pg.call(this),
      this.setPan(new Lg()),
      this.setZoom(new Fg()),
      this.setOrbit(null),
      (this.name = 'ClipDwgBuffer'),
      (this.clippingHandle = new zg('')),
      (this.centerHandle = void 0),
      (this.centereData = void 0);
  }
  function G_() {
    Pg.call(this),
      (this.name = 'PlacementDwgBuffer'),
      (this.handle = new zg('')),
      (this.translate1 = void 0),
      (this.translate2 = void 0),
      (this.scaleAndRotateHandle = void 0),
      (this.clippingPlanes = [new Kt(new J(0, 0, 1), 0)]),
      (this.undoState = []),
      (this.redoState = []);
  }
  (k_.prototype = Object.assign(Object.create(jg.prototype), {
    constructor: k_,
    setPlaneNormal: function (t) {
      this.planeNormal.copy(t);
    },
    getPlaneNormal: function () {
      return this.planeNormal;
    },
    begin: (function () {
      let t = new Kt();
      return function (e) {
        this.isHandled ||
          (t.setFromNormalAndCoplanarPoint(
            this.planeNormal,
            this.getPosition(),
          ),
          e.ray.intersectPlane(t, this.prePosition)
            ? (this.isHandled = !0)
            : (this.isHandled = !1));
      };
    })(),
    handled: (function () {
      let t = new Kt(),
        e = new J();
      return function (n) {
        return (
          t.setFromNormalAndCoplanarPoint(this.planeNormal, this.getPosition()),
          n.ray.intersectPlane(t, this.currentPosition) &&
            (e.subVectors(this.currentPosition, this.prePosition),
            this.getPosition().add(e),
            this.prePosition.copy(this.currentPosition)),
          this.isHandled
        );
      };
    })(),
  })),
    (U_.prototype = Object.assign(Object.create(Pg.prototype), {
      constructor: U_,
      willBegin: (function () {
        let t = new vb(!0, 0, 0.01),
          e = new xe({ color: 65535, opacity: 0.3, transparent: !0 });
        e.setDepthRange(t);
        let n = new xe({ color: 16776960, opacity: 0.3, transparent: !0 });
        n.setDepthRange(t);
        let i = new xe({ color: 65535 });
        i.setDepthRange(t);
        let r = new xe({ color: 16776960 });
        function o(t, e, n) {
          let i = 0.5 * t,
            r = 0.5 * e,
            o = new Re(
              new Float32Array([-i, -r, 0, i, -r, 0, i, r, 0, -i, r, 0]),
              3,
            ),
            s = new He();
          return (
            s.setAttribute('position', o),
            s.setIndex([0, 1, 3, 1, 2, 3]),
            new ln(s, n)
          );
        }
        function s(t, e, n, s, a) {
          let c = new Hg(t, a);
          return (
            c.setPosition(e),
            c.setAutoScale(!0),
            c.addShapeObject(o(n, s, i), i, r),
            c
          );
        }
        function a(t, e, n, s) {
          let a = new k_(t, new J(0, 0, 1));
          return (
            a.setPosition(e),
            a.setAutoScale(!0),
            a.addShapeObject(o(n, s, i), i, r),
            a
          );
        }
        return (
          r.setDepthRange(t),
          function (t) {
            Pg.prototype.willBegin.call(this, t);
            let i = 16;
            this.clippingHandle.addHandle(a('', new J(), i, i)),
              this.clippingHandle.addHandle(
                s('', new J(), i, i, new J(0, -1, 0)),
              ),
              this.clippingHandle.addHandle(a('', new J(), i, i)),
              this.clippingHandle.addHandle(
                s('', new J(), i, i, new J(1, 0, 0)),
              ),
              this.clippingHandle.addHandle(a('', new J(), i, i)),
              this.clippingHandle.addHandle(
                s('', new J(), i, i, new J(0, 1, 0)),
              ),
              this.clippingHandle.addHandle(a('', new J(), i, i)),
              this.clippingHandle.addHandle(
                s('', new J(), i, i, new J(-1, 0, 0)),
              );
            let r = t.getModelScene().getBoundingBox(),
              c = r.min,
              l = r.max;
            (this.centereData = o(l.x - c.x, l.y - c.y, e)),
              (this.centerHandle = new k_('', new J(0, 0, 1))),
              this.centerHandle.addShapeObject(this.centereData, e, n),
              this.clippingHandle.addHandle(this.centerHandle),
              this.updateHandlePosition(r);
            let h = t.getIncrementalScene();
            this.clippingHandle.install(h),
              this.pan.willBegin(t),
              this.zoom.willBegin(t);
          }
        );
      })(),
      willEnd: function (t) {
        this.pan.willEnd(t),
          this.zoom.willEnd(t),
          this.clippingHandle.uninstall(t.getIncrementalScene()),
          t.requestFrameUpdate(),
          Pg.prototype.willEnd.call(this, t);
      },
      onLButtonDown: (function () {
        let t = new gl();
        return function (e) {
          Pg.prototype.onLButtonDown.call(this, e),
            this.getMouseRaycaster(e, t),
            this.clippingHandle.begin(t);
        };
      })(),
      onLButtonUp: (function () {
        let t = new gl();
        return function (e) {
          this.getMouseRaycaster(e, t),
            this.clippingHandle.end(t),
            Pg.prototype.onLButtonUp.call(this, e);
        };
      })(),
      onMouseMove: (function () {
        let t = new gl(),
          e = new Nt(),
          n = new J(),
          i = new J();
        function r(t, e, n) {
          for (let i = 0, r = e.length; i < r; i++)
            n.expandByPoint(t[e[i] % 8].getPosition());
        }
        return function (o) {
          this.getMouseRaycaster(o, t);
          let s = this.clippingHandle.handled(t);
          if (s) {
            let t = this.clippingHandle.getHandleArray();
            if (s === this.centerHandle) {
              e.reset();
              for (let n = 0, i = t.length - 1; n < i; ++n)
                e.expandByPoint(t[n].getPosition());
              e.getCenter(n), i.subVectors(this.centerHandle.getPosition(), n);
              for (let e = 0, n = t.length - 1; e < n; ++e)
                t[e].getPosition().add(i);
            } else {
              let n = t.indexOf(s);
              e.reset(),
                r(t, n % 2 == 0 ? [n, n + 4] : [n, n + 3, n + 4, n + 5], e),
                this.updateHandlePosition(e);
            }
            this.getViewer().requestFrameUpdate();
          } else Pg.prototype.onMouseMove.call(this, o);
        };
      })(),
      updateHandlePosition: function (t) {
        let e = this.clippingHandle.getHandleArray(),
          n = t.min,
          i = t.max;
        e[0].setPosition(new J(n.x, n.y, 0)),
          e[1].setPosition(new J(0.5 * (n.x + i.x), n.y, 0)),
          e[2].setPosition(new J(i.x, n.y, 0)),
          e[3].setPosition(new J(i.x, 0.5 * (n.y + i.y), 0)),
          e[4].setPosition(new J(i.x, i.y, 0)),
          e[5].setPosition(new J(0.5 * (n.x + i.x), i.y, 0)),
          e[6].setPosition(new J(n.x, i.y, 0)),
          e[7].setPosition(new J(n.x, 0.5 * (n.y + i.y), 0)),
          e[8].setPosition(new J(0.5 * (n.x + i.x), 0.5 * (n.y + i.y), 0));
        let r = 0.5 * (t.max.x - t.min.x),
          o = 0.5 * (t.max.y - t.min.y),
          s = this.centereData.geometry.attributes.position,
          a = s.array;
        (a[0] = -r),
          (a[1] = -o),
          (a[3] = r),
          (a[4] = -o),
          (a[6] = r),
          (a[7] = o),
          (a[9] = -r),
          (a[10] = o),
          (s.needsUpdate = !0);
      },
      getClippingBox: function () {
        let t = this.clippingHandle.getHandleArray(),
          e = new Nt();
        for (let n = 0, i = t.length - 1; n < i; ++n)
          e.expandByPoint(t[n].getPosition());
        return e;
      },
    })),
    (G_.prototype = Object.assign(Object.create(Pg.prototype), {
      constructor: G_,
      undo: function () {
        let t = this.getViewer();
        t &&
          (this.undoState.length < 2 ||
            (this.redoState.push(this.undoState[this.undoState.length - 1]),
            this.undoState.splice(this.undoState.length - 1, 1),
            t
              .getDwgBufferScene()
              .setState(this.undoState[this.undoState.length - 1]),
            this.updateHandle()));
      },
      undoEnable: function () {
        return this.undoState.length > 1;
      },
      redo: function () {
        let t = this.getViewer();
        t &&
          (this.redoState.length < 1 ||
            (this.undoState.push(this.redoState[this.redoState.length - 1]),
            this.redoState.splice(this.redoState.length - 1, 1),
            t
              .getDwgBufferScene()
              .setState(this.undoState[this.undoState.length - 1]),
            this.updateHandle()));
      },
      redoEnable: function () {
        return this.redoState.length > 0;
      },
      willBegin: (function () {
        let t = new vb(!0, 0, 0.01),
          e = new xe({
            color: 4473924,
            opacity: 0.3,
            transparent: !0,
            side: 2,
          });
        e.setDepthRange(t);
        let n = new xe({
          color: 5592405,
          opacity: 0.3,
          transparent: !0,
          side: 2,
        });
        n.setDepthRange(t);
        let i = new xe({ color: 65535, side: 2 });
        i.setDepthRange(t);
        let r = new xe({ color: 16776960, side: 2 });
        r.setDepthRange(t);
        let o = new xe({ color: 16711680, side: 2 });
        o.setDepthRange(t);
        let s = new ot();
        s.set(0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1);
        let a = new ot(),
          c = new ot(),
          l = new J();
        function h(t, e) {
          let n = t.geometry.getAttribute('position').array;
          for (let t = 0, i = n.length; t < i; t += 3)
            l.set(n[t], n[t + 1], n[t + 2]),
              l.applyMatrix4(e),
              (n[t] = l.x),
              (n[t + 1] = l.y),
              (n[t + 2] = l.z);
        }
        return function (t) {
          Pg.prototype.willBegin.call(this, t);
          let l = t.getDwgBufferScene(),
            u = l.getBuffer(),
            d = u.boxMin,
            p = u.boxMax,
            f = l.getState();
          (this.translate1 = new k_('', f.alignAxis)),
            this.translate1.addShapeObject(
              (function (t, e, n, i) {
                let r = new Re(
                    new Float32Array([
                      t.x,
                      t.y,
                      0,
                      t.x + e,
                      t.y,
                      0,
                      t.x + e,
                      t.y + n,
                      0,
                      t.x,
                      t.y + n,
                      0,
                    ]),
                    3,
                  ),
                  o = new He();
                return (
                  o.setAttribute('position', r),
                  o.setIndex([0, 1, 3, 1, 2, 3]),
                  new ln(o, i)
                );
              })(Xf.origin, p.x - d.x, p.y - d.y, e),
              e,
              n,
            ),
            this.handle.addHandle(this.translate1);
          (this.translate2 = (function (t, e, n, i, r) {
            let o = new Hg(t, e);
            o.setAutoScale(!0);
            let l = 0.5 * n,
              u = 0.4 * n,
              d = new ln(new Ws(0, l, u), i);
            (d.matrixAutoUpdate = !1),
              a.identity(),
              a.premultiply(s),
              c.makeTranslation(0, 0, 0.5 * n),
              a.premultiply(c),
              h(d, a),
              o.addShapeObject(d, i, r);
            let p = new ln(new Ws(l, 0, u), i);
            (p.matrixAutoUpdate = !1),
              a.identity(),
              a.premultiply(s),
              c.makeTranslation(0, 0, 0.5 * -n),
              a.premultiply(c),
              h(p, a),
              o.addShapeObject(p, i, r);
            let f = new ln(new Ws(0.25 * n, 0.25 * n, n), i);
            return (
              (f.matrixAutoUpdate = !1), h(f, s), o.addShapeObject(f, i, r), o
            );
          })('', f.alignAxis, 16, o, r)),
            this.handle.addHandle(this.translate2),
            (this.scaleAndRotateHandle = new k_('', f.alignAxis)),
            this.scaleAndRotateHandle.addShapeObject(
              new ln(new Bs(8), i),
              i,
              r,
            ),
            this.scaleAndRotateHandle.setAutoScale(!0),
            this.handle.addHandle(this.scaleAndRotateHandle);
          let m = t.getIncrementalScene();
          this.handle.install(m),
            this.updateHandle(),
            this.undoState.push(t.getDwgBufferScene().getState().clone()),
            this.getViewer().setClippingPlanes(this.clippingPlanes);
        };
      })(),
      willEnd: function (t) {
        this.handle.uninstall(t.getIncrementalScene()),
          t.requestFrameUpdate(),
          t.setClippingPlanes([]),
          Pg.prototype.willEnd.call(this, t);
      },
      onLButtonDown: (function () {
        let t = new gl();
        return function (e) {
          Pg.prototype.onLButtonDown.call(this, e),
            this.getMouseRaycaster(e, t),
            this.handle.begin(t);
        };
      })(),
      onLButtonUp: (function () {
        let t = new gl();
        return function (e) {
          this.getMouseRaycaster(e, t),
            this.handle.end(t) &&
              (this.undoState.push(
                this.getViewer().getDwgBufferScene().getState().clone(),
              ),
              (this.redoState = [])),
            this.updateHandle(),
            Pg.prototype.onLButtonUp.call(this, e);
        };
      })(),
      onMouseMove: (function () {
        let t = new gl(),
          e = new J(),
          n = new J(),
          i = new ot();
        return function (r) {
          this.getMouseRaycaster(r, t);
          let o = this.handle.handled(t);
          if (o) {
            let t = this.getViewer().getDwgBufferScene();
            if (o === this.translate1) t.setPosition(o.getPosition());
            else if (o === this.translate2) t.setPosition(o.getPosition());
            else if (o === this.scaleAndRotateHandle) {
              let r = t.getBuffer(),
                s = r.boxMin,
                a = r.boxMax,
                c = s.distanceTo(a);
              t.setScale(
                o.getPosition().distanceTo(this.translate1.getPosition()) / c,
              ),
                Xf.getCoordinateByRefAxis(Xf.origin, t.getState().alignAxis, i),
                e.set(a.x - s.x, a.y - s.y, 0),
                e.normalize().transformDirection(i),
                n.subVectors(o.getPosition(), this.translate1.getPosition());
              let l = Xf.computeAxisAngle(e, n, t.getState().alignAxis);
              t.setAngle(l);
            }
            this.updateHandle(o), this.getViewer().requestFrameUpdate();
          } else Pg.prototype.onMouseMove.call(this, r);
        };
      })(),
      updateHandle: (function () {
        let t = new ot(),
          e = new ot();
        return function (n) {
          let i = this.getViewer().getDwgBufferScene(),
            r = i.getState();
          if (
            (this.translate1
              .getPosition()
              .set(0, 0, 0)
              .applyMatrix4(i.getMatrix()),
            this.translate1.setPlaneNormal(r.alignAxis),
            this.translate2
              .getPosition()
              .set(0, 0, 0)
              .applyMatrix4(i.getMatrix()),
            this.translate2.setDirection(r.alignAxis),
            n !== this.scaleAndRotateHandle)
          ) {
            let t = i.getBuffer().boxMin,
              e = i.getBuffer().boxMax;
            this.scaleAndRotateHandle
              .getPosition()
              .set(e.x - t.x, e.y - t.y, 0)
              .applyMatrix4(i.getMatrix());
          }
          this.scaleAndRotateHandle.setPlaneNormal(r.alignAxis),
            Xf.getCoordinateByRefAxis(Xf.origin, r.alignAxis, t),
            this.translate2.setShapeTransform(t),
            e.copy(t),
            Xf.makeRotationMatrix4(Xf.origin, r.alignAxis, r.angle, t),
            e.premultiply(t),
            e.premultiply(t.makeScale(r.scale, r.scale, r.scale)),
            this.translate1.setShapeTransform(e),
            r.getClippingPlane(this.clippingPlanes[0]),
            this.getViewer().cameraChanged();
        };
      })(),
      getBounding: (function () {
        let t = new Nt(),
          e = new J();
        return function () {
          let n = this.getViewer().getDwgBufferScene(),
            i = n.getBuffer();
          if (!i) return null;
          t.set(i.boxMin, i.boxMax),
            t.translate(e.copy(i.boxMin).multiplyScalar(-1));
          let r = new Nt();
          for (let i = 0; i < 8; i++)
            Xf.getBox3Corner(t, i, e),
              e.applyMatrix4(n.getMatrix()),
              r.expandByPoint(e);
          return r;
        };
      })(),
    }));
  class z_ extends Sh {
    constructor(t) {
      super(t), (this.state = { selectOn: 'up' });
    }
    componentDidMount() {
      this.setAxis('up');
    }
    setAxis(t) {
      const e = this.props.GlobalShare.bimViewer,
        n = e.getDwgBufferScene(),
        i = e.getModelScene().getModelArray()[0].getBoundingBox(),
        r = e.getMainCamera();
      let o = '',
        s = '';
      if (
        ('up' === t
          ? ((o = new J(0, 0, 1)),
            (s = new J(i.min.x, i.min.y, i.max.z - 0.01)))
          : 'bottom' === t
          ? ((o = new J(0, 0, -1)),
            (s = new J(i.max.x, i.max.y, i.min.z + 0.01)))
          : 'back' === t
          ? ((o = new J(0, 1, 0)),
            (s = new J(i.max.x, i.max.y - 0.01, i.min.z)))
          : 'front' === t
          ? ((o = new J(0, -1, 0)),
            (s = new J(i.min.x, i.min.y + 0.01, i.min.z)))
          : 'right' === t
          ? ((o = new J(1, 0, 0)),
            (s = new J(i.max.x - 0.01, i.min.y, i.min.z)))
          : 'left' === t &&
            ((o = new J(-1, 0, 0)),
            (s = new J(i.min.x + 0.01, i.max.y, i.min.z))),
        o && s)
      ) {
        if (
          (n.setAlignAxis(o),
          n.setPosition(s),
          e.getOperator().updateHandle(),
          Xf.isParallelVector3(o, Xf.zAxis))
        )
          r.up.set(0, o.dot(Xf.zAxis), 0);
        else {
          let t = new J();
          t.crossVectors(Xf.zAxis, o), r.up.crossVectors(o, t);
        }
        r.position.copy(r.target), r.position.addScaledVector(o, 1), r.update();
        let i = e.getModelScene().getBoundingBox();
        r.makeLookAtBoundingBox(i),
          e.cameraChanged(),
          this.setState({ selectOn: t });
      }
    }
    render() {
      return Xh`<${Mh}>
          <div class="ccbim__dwgModelAlignAxis">
          <div class="ccbim__AxisLine">
            <svg
              class=${'up' === this.state.selectOn ? 'icon selectOn' : 'icon'}
              aria-hidden="true"
              onClick=${() => this.setAxis('up')}
            >
              <use xlinkHref="#iconshitufushitu"></use>
            </svg>
            <svg
              class=${
                'bottom' === this.state.selectOn ? 'icon selectOn' : 'icon'
              }
              aria-hidden="true"
              onClick=${() => this.setAxis('bottom')}
            >
              <use xlinkHref="#iconshituyangshitu"></use>
            </svg>
          </div>
          <div class="ccbim__AxisLine">
            <svg
              class=${'back' === this.state.selectOn ? 'icon selectOn' : 'icon'}
              aria-hidden="true"
              onClick=${() => this.setAxis('back')}
            >
              <use xlinkHref="#iconshituhoushitu"></use>
            </svg>
            <svg
              class=${
                'front' === this.state.selectOn ? 'icon selectOn' : 'icon'
              }
              aria-hidden="true"
              onClick=${() => this.setAxis('front')}
            >
              <use xlinkHref="#iconshituzhushitu"></use>
            </svg>
          </div>
          <div class="ccbim__AxisLine">
            <svg
              class=${
                'right' === this.state.selectOn ? 'icon selectOn' : 'icon'
              }
              aria-hidden="true"
              onClick=${() => this.setAxis('right')}
            >
              <use xlinkHref="#iconshituyoushitu"></use>
            </svg>
            <svg
              class=${'left' === this.state.selectOn ? 'icon selectOn' : 'icon'}
              aria-hidden="true"
              onClick=${() => this.setAxis('left')}
            >
              <use xlinkHref="#iconshituzuoshitu"></use>
            </svg>
          </div>
        </div>
      </${Mh}>`;
    }
  }
  class j_ extends Sh {
    constructor(t) {
      super(t),
        (this.state = {
          isShowPointImage: !1,
          pointImageSrc: '',
          pointImageTop: 0,
          pointImageLeft: 0,
        });
    }
    showPointImage(t) {
      t.photo &&
        this.setState({
          isShowPointImage: !0,
          pointImageSrc: t.photo,
          pointImageTop: t.top - 160,
          pointImageLeft: t.left - 100,
        });
    }
    render() {
      return Xh`<${Mh}>
      ${this.props.pointList.map(
        (t) => Xh`
          <div
            style=${{
              position: 'absolute',
              left: `${t.left}px`,
              top: `${t.top}px`,
              display: '' + (t.show ? 'block' : 'none'),
            }}
            onClick=${() => {
              t.clickPointCallback({
                type: 'markClick',
                left: t.left,
                top: t.top,
                data: t.selfDefiningData,
              });
            }}
          >
            ${
              t.labelText &&
              Xh` <label
              class=${t.warning ? 'ccbim__label warning' : 'ccbim__label'}
              title=${t.labelText}
              >${t.labelText}</label
            >`
            }

            <div
              class=${t.color ? 'ccbim__point__color' : 'ccbim__point'}
              style=${{
                backgroundImage: `url(${t.iconImg})`,
                backgroundColor: `${t.color}`,
                opacity: `${t.opacity ? t.opacity : 0.7}`,
              }}
              onMouseEnter=${() => {
                this.showPointImage(t);
              }}
              onMouseLeave=${() => {
                this.setState({ isShowPointImage: !1 });
              }}
            ></div>

            ${
              t.iconText &&
              Xh` <span class="ccbim__point__text">${t.iconText}</span>`
            }
          </div>
        `,
      )}
      ${
        this.state.isShowPointImage &&
        Xh`<div
          style=${{
            top: `${this.state.pointImageTop}px`,
            left: `${this.state.pointImageLeft}px`,
          }}
          class="ccbim__pointOver__image"
        >
          <img src=${this.state.pointImageSrc} />
        </div>`
      }
    </${Mh}>`;
    }
  }
  let H_ = new Map(),
    W_ = new Map(),
    X_ = new Map();
  function Z_(t, e) {
    let n = (function (t) {
      if (0 === H_.size) return [];
      let e = new Map(),
        { wHalf: n, hHalf: i } = t.viewDevices.getDevicesWidthHeight();
      for (let r of H_.values()) {
        let o = t.bimViewer.getMainCamera(),
          s = r.point.clone();
        if (
          (s.project(o),
          (s.x = s.x * n + n),
          (s.y = -s.y * i + i),
          'model' === t.type)
        ) {
          let t = r.uuid;
          if (e.has(t)) {
            let n = e.get(t);
            n.push(t);
            let i = n.length - 1;
            s.x = s.x + 30 * i;
          } else e.set(t, [t]);
        }
        let a = !1;
        if ('model' === t.type) a = !0;
        else {
          let t = 'Model';
          X_.forEach((e, n) => {
            e.showThis && (t = n);
          }),
            t === r.dwgLayoutName && (a = !0);
        }
        a && (a = !o.cullPoint(r.point)),
          W_.set(r.id, {
            id: r.id,
            left: s.x - 15,
            top: s.y - 40,
            iconText: r.iconText,
            labelText: r.labelText,
            selfDefiningData: r.selfDefiningData,
            warning: r.warning,
            iconImg: r.iconImg
              ? r.iconImg
              : 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB8AAAAmCAYAAAA820BcAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA39pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDIxIDc5LjE1NTc3MiwgMjAxNC8wMS8xMy0xOTo0NDowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDphODRkMDNjNC04MzBlLTZlNDEtOWUyYS0xOWEzYTRiNGMwNTkiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6RDgwNzJDN0NFQjhFMTFFN0E4ODlENTE1NEZCQzExQkIiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6RDgwNzJDN0JFQjhFMTFFN0E4ODlENTE1NEZCQzExQkIiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOmQ4NmY1MTliLWJhMmUtYjk0ZC1iYmRjLWZhMzlhOTM0NWNmNiIgc3RSZWY6ZG9jdW1lbnRJRD0iYWRvYmU6ZG9jaWQ6cGhvdG9zaG9wOmJmNDQzMjIyLTcwNTgtYmE0Yi04ZGVmLTRlNDgzYTI0MDA4NiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqFeqsUAAAPDSURBVHjatFhpbExRFP5mOqglqEgZWvyQ2IoIaklaIRp7Ygvxxw+x/7BNEIkKQYJmosSPqkhERIJIJGgVKSli19RWkUa0Hbso0ui0quM77715fTPtzLxZ3km+m3fuvHe+e8+9555zx+bz+dBGXDa0I/2IuUQ2MZRwEp2JBuIzUUmUEVfg9n2ECbG1Sx44kMlsdxCziCQTNv8RxcQBDuJebOQuWx+2R4kliF3OExs4iC/mydXZXtBcrYqjEzB4KpAxHxg0CUgZCCT3ALy/gLpq4P194OUloOoW0NxotCZLsrg9L7Qld9nEvRe19QTsDiBzBTBjN9DdGXmu9V+B0oPA3WNcgCZ/r+yLRRxAcWhyl20C21Kii6KnDgGW03POUdE7/NNz4PRS4Osbf88fYhoH8LAtucvWi20Fkabo6eOB1dc4jF6xr3hDHVBIR9bofB5iNAfwQ3Gq4dVDOnEqI2ntjfiIRTqnAGtKVHuqpGk8hpm7bKP5XC46kjoAm5/E5uqQS/ACODyWe+CvaOLqMZx9hX/mWxVikayNiSUWcY5U7WoTJrapM9+CHlo4JMORDOQybLqlIuEiUbCX4dnsFU2avjLzGQqxyPC51hCLiN0R8/ya8M20a2e1KsPnwFIZNtuoZQt5hq6mjbWWPH2cURsh5P11NWWAteQ9041afyHvqqtyVlspgfa7CPlfXfX+tpY80L5XyL/r6s9aa8l/eYxanZC/09Xax9aS1zwyatVC/lRXK4usJQ+0Xy7kJbr66rJ6Elkh9d9U+63ywM4DXhLKW0WVo+9WnjXkt/P8R6uIpNQ7/sRyXH/pzhG1EEikSFYryzf2nOGkG/3khfqul7QnFYjUZgkJL9o5vcSfThX/Eu7WYsLtq2e7U/9ASp+C6fGvv3xfkGMspUQKyFcTXMmcEKe3hh0LinyWUp5nsRF/4FbKzwwOX0nduaEKSDl8ha233ifV68SVQM4uc9Xr70/A9T3Aw5NAS7PxlxYlfbt9N8OVztO0G0fHgH4pNCTfS9qV7KfU7d3VI1Pqdg+Pi9dXiSvGXW2UXBLvM3NpkFvKWZPXIzMi0bSO5AFk9jDXnGVEUwKI6X+sDyYORw7tuiSlTTypTsrkVSRuae9HR4SPZXNkEUUBRYe5m+omkh4L95LdhCE57iYEJKAI0U0siERsllyJWs0D5yK8x22PySS+bMaoPQpXNmibcH+ohKkQAy/MGrRHuYF82jG8I6hfCKcQH6MxZo9xFx8gTmnPEo4LiW/RGnHEEUbbiUztj4SqWAz8F2AAwxUsG0cxVxkAAAAASUVORK5CYII=',
            opacity: r.opacity,
            color: r.color,
            photo: r.photo,
            contentText: r.contentText,
            show: a,
            floorId: r.floorId,
            clickPointCallback: r.clickPointCallback,
          });
      }
      return [...W_.values()];
    })(e);
    n && jh(Xh`<${j_} pointList=${n} />`, t);
  }
  let Y_ = {
    DwgModelRelation: {
      DwgModelRelation: class {
        constructor(t) {
          this.app = t.app;
        }
        setClipDwg() {
          this.app.viewer.setVisibleBar(!1);
          this.app.bimViewer.setOperator(new U_()),
            setTimeout(() => {
              let t = this.app.parentElementId;
              u_.get(t).dwgLayoutClose(), this.app.bimViewer.cameraChanged();
            });
        }
        getClipDwgInfo() {
          const t = this.app.bimViewer,
            e = t.getOperator();
          if ('ClipDwgBuffer' === e.name) {
            let n = e.getClippingBox(),
              i = new Zb(),
              r = i.createModelBuffer(t.getModelScene().getModelArray()[0], n),
              o = this.app.scale,
              s = n.min,
              a = new J();
            const c = new J(
              this.app.dwgDefaultView.Target[0],
              this.app.dwgDefaultView.Target[1],
              this.app.dwgDefaultView.Target[2],
            );
            return (
              a.addVectors(s, c),
              (a.x = a.x / o),
              (a.y = a.y / o),
              (a.z = a.z / o),
              { buffer: i.splitBufferFile(r), point: a }
            );
          }
        }
        mergeShardDwg(t) {
          return new Zb().combineBufferFile(t);
        }
        setDwgPositonInModel(t, e) {
          let n = this.app.parentElementId;
          u_.get(n).closeAllOperation(), this.app.viewer.setVisibleBar(!1);
          const i = this.app.bimViewer;
          if ((i.getDwgBufferScene().setBuffer(t), e)) {
            const t = this.app.scale;
            let n = new J(e.position.x * t, e.position.y * t, e.position.z * t);
            i.getDwgBufferScene().setPosition(n),
              i.getDwgBufferScene().setScale(e.scale),
              i.getDwgBufferScene().setAngle(e.angle),
              i.getDwgBufferScene().setAlignAxis(e.alignAxis);
            let r = this.app.parentElementId + '__ccbim__dwgModelRelation',
              o = document.getElementById(r);
            o && (o.style.display = 'block');
            let s = i.getDwgBufferScene().getState().getClippingPlane();
            this.app.bimViewer.setClippingPlanes([s]);
          } else {
            let t = i.getDwgBufferScene().getBuffer().boxMin,
              e = i.getDwgBufferScene().getBuffer().boxMax,
              n = i.getModelScene().getModelArray()[0].getBoundingBox();
            n.min.distanceTo(n.max),
              t.distanceTo(e),
              i
                .getDwgBufferScene()
                .setPosition(new J(n.min.x, n.min.y, n.max.z)),
              i.getDwgBufferScene().setScale(0.001),
              i.getDwgBufferScene().setAngle(0),
              i.getDwgBufferScene().setAlignAxis(new J(0, 0, 1));
            let r = new G_();
            i.setOperator(r),
              (function (t, e) {
                const n = document.getElementById(
                  t + '__ccbim__dwgModelAlignAxis',
                );
                jh(Xh`<${z_} GlobalShare=${e} />`, n);
              })(this.app.parentElementId, this.app);
          }
          this.app.bimViewer.getMainCamera().setAsOrthographic(),
            i.cameraChanged();
        }
        getClipDwgState() {
          const t = this.app.bimViewer,
            e = this.app.scale,
            n = t.getDwgBufferScene().getState();
          return (
            (n.position.x = n.position.x / e),
            (n.position.y = n.position.y / e),
            (n.position.z = n.position.z / e),
            JSON.parse(JSON.stringify(n))
          );
        }
        outDwgModelRelation() {
          !(function (t) {
            const e = document.getElementById(t + '__ccbim__dwgModelAlignAxis');
            jh(Xh``, e);
          })(this.app.parentElementId);
          const t = this.app.bimViewer;
          t.getDwgBufferScene().clearBuffer(),
            t.setClippingPlanes([]),
            t.setOperator(new Pg()),
            t.getMainCamera().setAsPerspective(50),
            this.app.viewer.setVisibleBar(!0),
            t.cameraChanged();
        }
      },
      DwgModelRelationConfig: class {
        constructor(t) {
          this.app = t;
        }
      },
    },
    Marker2D: {
      Marker2D: class {
        constructor(t) {
          (this.app = t), (this.markList = new Map()), (this.hasBindEvent = !1);
        }
        addMarkPoint(t) {
          this.markList.set(t.id, t);
          let e = [];
          this.markList.forEach(function (t) {
            e.push(t);
          }),
            this.setMarkPointList(e);
        }
        removeMarkPoint(t) {
          this.markList.has(t) && this.markList.delete(t);
        }
        setMarkPointList(t) {
          let e = document.getElementById(
            this.app.parentElementId + '__ccbim__markPoints',
          );
          !(function (t, e) {
            H_.clear(), W_.clear();
            const n = e.bimViewer.getModelScene().getModelArray(),
              i = n[0].modelTree.getRootNode();
            X_ = n[0].getDwgLayoutMap();
            for (let n = 0; n < t.length; n++) {
              const r = t[n];
              if ('{}' === JSON.stringify(r))
                return console.error('添加模型标注对象格式不正确'), !1;
              if (H_.has(r.id)) {
                console.error('id不能重复');
                continue;
              }
              let o = r.floorId;
              o =
                r.floorId && r.floorId >= 0
                  ? r.floorId
                  : e.floorIdFromNameMap.get(r.floorName);
              const s = e.scale;
              if ('model' === e.type)
                if (r.markPosition) {
                  const t = r.markPosition;
                  let e = t.x + t.y + t.z,
                    n = new J(t.x * s, t.y * s, t.z * s);
                  H_.set(r.id, {
                    uuid: e,
                    id: r.id,
                    point: n,
                    iconText: r.iconText,
                    labelText: r.labelText,
                    selfDefiningData: r.selfDefiningData,
                    warning: r.warning,
                    iconImg: r.iconImg,
                    opacity: r.opacity,
                    color: r.color,
                    photo: r.photo,
                    contentText: r.contentText,
                    floorId: o,
                    clickPointCallback: r.clickPointCallback,
                  });
                } else {
                  let t = ng([i], o, r.handle);
                  if (!t) return;
                  const e = t.boundingBox.max,
                    n = t.boundingBox.min;
                  let s = new J(
                      (e.x + n.x) / 2,
                      (e.y + n.y) / 2,
                      (e.z + n.z) / 2,
                    ),
                    a = s.x + s.y + s.z;
                  H_.set(r.id, {
                    uuid: a,
                    id: r.id,
                    point: s,
                    iconText: r.iconText,
                    labelText: r.labelText,
                    selfDefiningData: r.selfDefiningData,
                    warning: r.warning,
                    iconImg: r.iconImg,
                    opacity: r.opacity,
                    color: r.color,
                    photo: r.photo,
                    contentText: r.contentText,
                    floorId: o,
                    clickPointCallback: r.clickPointCallback,
                  });
                }
              else if ('dwg' === e.type && r.markPosition) {
                let t = new J(),
                  n = 'Model';
                const i = r.markPosition;
                if (r.offset) {
                  let n = new J(i.x * s, i.y * s, 1);
                  const o = new J(r.offset[0], r.offset[1], r.offset[2]);
                  let a = new J();
                  a.addVectors(n, o);
                  const c = new J(
                    e.dwgDefaultView.Target[0],
                    e.dwgDefaultView.Target[1],
                    e.dwgDefaultView.Target[2],
                  );
                  t.subVectors(a, c), (t.z = 1);
                } else t = new J(i.x * s, i.y * s, 1);
                (n = r.dwgLayoutName ? r.dwgLayoutName : 'Model'),
                  H_.set(r.id, {
                    id: r.id,
                    point: t,
                    iconText: r.iconText,
                    labelText: r.labelText,
                    selfDefiningData: r.selfDefiningData,
                    warning: r.warning,
                    iconImg: r.iconImg,
                    opacity: r.opacity,
                    color: r.color,
                    photo: r.photo,
                    contentText: r.contentText,
                    dwgLayoutName: n,
                    clickPointCallback: r.clickPointCallback,
                  });
              }
            }
          })(t, this.app),
            Z_(e, this.app),
            this.hasBindEvent ||
              (this.app.bimViewer.bindCameraChangedEvent(() => {
                Z_(e, this.app);
              }),
              (this.hasBindEvent = !0));
        }
        bounceMarkPoint(t) {
          !(function (t, e) {
            let n = W_.get(e);
            if (!n) return;
            let i = 0,
              r = setInterval(() => {
                i += 30;
                let e = ((2 * Math.PI) / 360) * i;
                (n.top -= 3 * Math.sin(e)),
                  jh(Xh`<${j_} pointList=${[...W_.values()]} />`, t);
              }, 25);
            setTimeout(() => {
              clearInterval(r);
            }, 1500);
          })(
            document.getElementById(
              this.app.parentElementId + '__ccbim__markPoints',
            ),
            t,
          );
        }
      },
      Marker2dModelObj: class {
        constructor() {
          (this.id = void 0),
            (this.floorId = void 0),
            (this.floorName = void 0),
            (this.handle = void 0),
            (this.markPosition = void 0),
            (this.iconText = void 0),
            (this.iconImg = void 0),
            (this.color = void 0),
            (this.opacity = void 0),
            (this.photo = void 0),
            (this.labelText = void 0),
            (this.selfDefiningData = void 0),
            (this.clickPointCallback = void 0);
        }
      },
      Marker2dDwgObj: class {
        constructor() {
          (this.id = void 0),
            (this.markPosition = void 0),
            (this.offset = void 0),
            (this.dwgLayoutName = void 0),
            (this.iconText = void 0),
            (this.iconImg = void 0),
            (this.color = void 0),
            (this.opacity = void 0),
            (this.photo = void 0),
            (this.labelText = void 0),
            (this.selfDefiningData = void 0),
            (this.clickPointCallback = void 0);
        }
      },
    },
  };
  (t.DwgEvent = { addDwgMark: 'addDwgMark' }),
    (t.MapBondModel = Sg),
    (t.ModelEvent = { selectedEntity: 'selectedEntity' }),
    (t.Plugins = Y_),
    (t.ViewerEvent = n),
    (t.WebAppDwg = class extends e {
      constructor(t) {
        super(),
          this.init(t),
          window.addEventListener('resize', () => {
            this.onResize();
          });
      }
      init(t) {
        (this.optionConfig = t),
          (this.hasWebGL = !1),
          (this.type = 'dwg'),
          (this.parentElementId = this.optionConfig.dom.id),
          (this.scale = 1),
          (this.uiState = {}),
          (this.isMouseLeftDwgAddMark = !1),
          (this.isDwgAddMarkNewWayComputePoint = !1),
          (this.viewDevices = new Ig(this)),
          (this.isPhone = this.viewDevices.getIsPhone()),
          Cg(this.optionConfig.dom);
      }
      onResize() {
        console.log('窗口改变'),
          this.viewDevices.setDevicesWidthHeight(this.optionConfig.dom),
          this.viewDevices.resize();
      }
      addView() {
        (this.errorMsg = ''), (this.errorCode = '');
        const t = new Eg();
        if (!t.isIe())
          if (t.webgl) {
            (this.hasWebGL = !0),
              this.viewDevices.setDevicesWidthHeight(this.optionConfig.dom);
            let t = this.viewDevices.getDevicesWidthHeight();
            this.optionConfig.viewWidth
              ? (this.optionConfig.dom.style.width =
                  this.optionConfig.viewWidth + 'px')
              : (this.optionConfig.viewWidth = t.w),
              this.optionConfig.viewHeight
                ? (this.optionConfig.dom.style.height =
                    this.optionConfig.viewHeight + 'px')
                : (this.optionConfig.viewHeight = t.h),
              this.viewDevices.setDevicesWidthHeight(this.optionConfig.dom);
            let e = {
              dom: this.optionConfig.dom,
              width: this.optionConfig.viewWidth,
              height: this.optionConfig.viewHeight,
            };
            (this.bimViewer = new tg(e)),
              this.bimViewer.getMinimapScene().setVisible(!1);
            const n = new Pg();
            n.setOrbit(null),
              n.setDwgLeftButtonPan(!0),
              this.bimViewer.setViewBoxVisible(!1);
            const i = new fe('#212121'),
              r = new J(i.r, i.g, i.b),
              o = new fe('#212121'),
              s = new J(o.r, o.g, o.b);
            let a, c;
            this.bimViewer.setBackgroundColor(r, s),
              this.bimViewer.setOperator(n),
              this.bimViewer.requestFrameUpdate(),
              this.optionConfig.versionId
                ? ((a = `${this.optionConfig.urlIp}/front/bimfile/modelConstructInfoCors.htm`),
                  (c = { versionId: this.optionConfig.versionId }))
                : ((a = `${this.optionConfig.urlIp}/console/bimfile/modelConstructInfoCors`),
                  (c = { viewToken: this.optionConfig.viewToken })),
              Bg(a, c).then((t) => {
                let { data: e } = t;
                if (e.success) {
                  if (0 === e.result.jsons.length)
                    return void (this.errorMsg = '模型或者图纸未转换完成');
                  let t,
                    n = '',
                    i = new eg(Gf);
                  for (let r = 0, o = e.result.jsons.length; r < o; r++) {
                    let o = e.result.jsons[r];
                    n || (n = o.URI.split('.com/')[0] + '.com/');
                    let s = new gm();
                    s.setType(o.resultType),
                      s.setURL(o.URI),
                      s.setFileSize(o.FileSize),
                      i.addFileIndex(s),
                      13 === s.getType() && (t = s),
                      s.url.includes('ProjectInfo.json') &&
                        (s.setType('json'), (t = s));
                  }
                  if ((i.setCloudURL(n), !t))
                    return (
                      (this.errorMsg = '协议文件丢失'),
                      void console.error(this.errorMsg)
                    );
                  let r = this.bimViewer.getRenderContext().getTextureLoader();
                  switch (((r.fileLoader = i), t.getType())) {
                    case 13:
                      this.fileDataInterface = new Wb(r, this);
                      break;
                    case 'json':
                      this.fileDataInterface = new S_(r, this);
                  }
                  if (!this.fileDataInterface)
                    return void (this.errorMsg = '无法解析的协议版本');
                  console.log('Head protocol type.' + t.getType().toString());
                  let o = { version: this.optionConfig.viewToken, headFile: t };
                  this.fileDataInterface
                    .createModel(o, (t) => {
                      let e = document.getElementById(
                        'ccbim__basic__progress__div',
                      );
                      if (
                        (e &&
                          ((e.style.width = t + '%'), (e.innerHTML = t + '%')),
                        t >= 100)
                      ) {
                        let t = document.getElementById(
                          'ccbim__basic__progress',
                        );
                        t && t.parentNode && t.parentNode.removeChild(t);
                      }
                    })
                    .then((t) => {
                      p_(this),
                        (this.eventManager = new A_(
                          this.bimViewer.renderContext.renderer.domElement,
                          this,
                        )),
                        this.eventManager.init(),
                        this.bimViewer.getModelScene().addModel(t);
                      let e = this.bimViewer.getMainCamera();
                      e.makeLookAt(
                        new J(0, 0, 1),
                        new J(0, 0, 0),
                        new J(0, 1, 0),
                      ),
                        e.setAsOrthographic();
                      let n = this.dwgDefaultView,
                        i = new Nt();
                      (i.min.x = -n.Width / 2),
                        (i.min.y = -n.Height / 2),
                        (i.min.z = 0),
                        (i.max.x = n.Width / 2),
                        (i.max.y = n.Height / 2),
                        (i.max.z = 0),
                        e.makeLookAtBoundingBoxDwg(i),
                        this.bimViewer.cameraChanged(),
                        this.bimViewer.setProgressiveRendering(!1);
                    })
                    .catch((t) => {
                      console.log(t);
                    }),
                    (this.viewer = new P_(this));
                } else
                  (this.errorCode = e.errorCode),
                    !(function (t) {
                      if ('string' == typeof t)
                        try {
                          let e = JSON.parse(t);
                          return !('object' != typeof e || !e);
                        } catch (e) {
                          return console.log('error：' + t + '!!!' + e), !1;
                        }
                      console.log('It is not a string!');
                    })(e.errorMsg)
                      ? (this.errorMsg = e.errorMsg)
                      : (this.errorMsg = JSON.parse(e.errorMsg)),
                    Vg(
                      this.optionConfig.dom,
                      this.errorCode,
                      this.errorMsg,
                      () => {
                        Bg(
                          `${this.optionConfig.urlIp}/front/bimfile/reconvert.htm`,
                          { viewToken: this.optionConfig.viewToken },
                        ).then((t) => {
                          t.data.success && (this.dispose(), this.addView());
                        });
                      },
                    );
              });
          } else alert('webGL不支持，请重启浏览器或安装谷歌浏览器。');
      }
      getViewer() {
        return this.viewer;
      }
      dispose() {
        if (this.fileDataInterface) {
          this.fileDataInterface.getFileLoader().cancelAxios(),
            this.fileDataInterface.cancelCreateModelAsync();
        }
        let t = this.bimViewer.getModelScene();
        const e = t.getModelArray();
        t.removeModel(e[0]);
        let n = this.bimViewer.renderContext.getSceneList();
        (n.progressive1 = []),
          (n.progressive2 = []),
          f_(this.optionConfig.dom),
          (this.optionConfig.dom.innerHTML = ''),
          console.log('销毁成功');
      }
      renderFinish() {
        const t = this.bimViewer.getModelScene().getModelArray();
        let e = new Map();
        const n = t[0].modelTree.getRootNode();
        let i;
        this.initFloorTreeUI([n], e),
          (this.floorIdFromNameMap = e),
          this.isPhone ||
            (this.bimViewer.getMinimapScene().setBackgroundColor(0, 0, 0),
            this.bimViewer.getMinimapScene().setShowCameraType(1),
            this.bimViewer.getMinimapScene().setCameraFiledColor(1, 1, 1));
        let r = localStorage.getItem('ccbim_switchShowPoint');
        r && (i = JSON.parse(r)),
          i && cg(i.checkedShowPoint, this),
          this.bimViewer.cameraChanged();
      }
      initFloorTreeUI(t, e) {
        for (let n = 0; n < t.length; n++) {
          let i = t[n];
          e.set(i.floorName, i.floorID),
            (i.checked = !0),
            (i.checkedHalf = !1),
            (i.opened = !1),
            i.type === tm && (i.opened = !0),
            i.childArray && this.initFloorTreeUI(i.childArray, e);
        }
      }
    }),
    (t.WebAppDwgConfig = class {
      constructor() {
        (this.dom = null),
          (this.urlIp = 'https://open.ccbim.com'),
          (this.viewToken = ''),
          (this.versionId = ''),
          (this.operationBar = {
            showBar: !0,
            buttons: [
              'Home',
              'DwgMeasure',
              'DwgLayout',
              'DwgLayers',
              'DwgMap',
              'DwgSetting',
              'FullScreen',
            ],
          }),
          (this.selectEntityAction = { visible: !1, list: [] }),
          (this.viewWidth = null),
          (this.viewHeight = null);
      }
    }),
    (t.WebAppModel = class extends e {
      constructor(t) {
        super(),
          this.init(t),
          window.addEventListener('resize', () => {
            this.onResize();
          });
      }
      init(t) {
        (this.optionConfig = t),
          (this.hasWebGL = !1),
          (this.type = 'model'),
          (this.parentElementId = this.optionConfig.dom.id),
          (this.isSingleClick = !0),
          (this.scale = 1),
          (this.uiState = {}),
          (this.viewDevices = new Ig(this)),
          (this.isPhone = this.viewDevices.getIsPhone()),
          Cg(this.optionConfig.dom);
      }
      onResize() {
        console.log('窗口改变'),
          this.viewDevices.setDevicesWidthHeight(this.optionConfig.dom),
          this.viewDevices.resize();
      }
      addView() {
        (this.errorMsg = ''), (this.errorCode = '');
        const t = new Eg();
        if (t.isIe()) return !1;
        if (t.webgl) {
          (this.hasWebGL = !0),
            this.viewDevices.setDevicesWidthHeight(this.optionConfig.dom);
          let t = this.viewDevices.getDevicesWidthHeight();
          this.optionConfig.viewWidth
            ? (this.optionConfig.dom.style.width =
                this.optionConfig.viewWidth + 'px')
            : (this.optionConfig.viewWidth = t.w),
            this.optionConfig.viewHeight
              ? (this.optionConfig.dom.style.height =
                  this.optionConfig.viewHeight + 'px')
              : (this.optionConfig.viewHeight = t.h),
            this.viewDevices.setDevicesWidthHeight(this.optionConfig.dom);
          let e = {
            dom: this.optionConfig.dom,
            width: this.optionConfig.viewWidth,
            height: this.optionConfig.viewHeight,
          };
          if (
            ((this.bimViewer = new tg(e)),
            this.bimViewer.getMinimapScene().setVisible(!1),
            !this.optionConfig.backgroundAlpha)
          ) {
            const t = new fe(this.optionConfig.backgroundColor.topColor);
            let e = new J(t.r, t.g, t.b);
            const n = new fe(this.optionConfig.backgroundColor.bottomColor);
            let i = new J(n.r, n.g, n.b);
            if (
              (this.bimViewer.setBackgroundColor(e, i),
              '#f5f5f5' !== this.optionConfig.backgroundColor.topColor &&
                '#f5f5f5' !== this.optionConfig.backgroundColor.bottomColor)
            )
              lg(
                this,
                this.optionConfig.backgroundColor.topColor,
                this.optionConfig.backgroundColor.bottomColor,
              ),
                this.optionConfig.backgroundColor.topColor ===
                this.optionConfig.backgroundColor.bottomColor
                  ? localStorage.setItem(
                      'ccbim_switchBgColor',
                      JSON.stringify({
                        pureColor: !0,
                        pureColorVal:
                          this.optionConfig.backgroundColor.topColor,
                      }),
                    )
                  : localStorage.setItem(
                      'ccbim_switchBgColor',
                      JSON.stringify({
                        gradientColor: !0,
                        gradientColorTopVal:
                          this.optionConfig.backgroundColor.topColor,
                        gradientColorBottomVal:
                          this.optionConfig.backgroundColor.bottomColor,
                      }),
                    );
            else {
              let t,
                e = localStorage.getItem('ccbim_switchBgColor');
              e && (t = JSON.parse(e)),
                t &&
                  (t.pureColor && lg(this, t.pureColorVal, t.pureColorVal),
                  t.gradientColor &&
                    lg(this, t.gradientColorTopVal, t.gradientColorBottomVal));
            }
          }
          this.optionConfig.wireframe
            ? (this.bimViewer.setWireframeVisible(!0),
              localStorage.setItem(
                'ccbim_switchBorder',
                JSON.stringify({ checkedBorder: !0 }),
              ))
            : localStorage.removeItem('ccbim_switchBorder');
          const n = this.optionConfig.viewBoxVisible;
          this.bimViewer.setViewBoxVisible(n);
          const i = new Pg();
          let r, o;
          this.bimViewer.setOperator(i),
            this.bimViewer.requestFrameUpdate(),
            this.isPhone && this.bimViewer.setViewBoxVisible(!1),
            this.optionConfig.versionId
              ? ((r = `${this.optionConfig.urlIp}/front/bimfile/modelConstructInfoCors.htm`),
                (o = { versionId: this.optionConfig.versionId }))
              : ((r = `${this.optionConfig.urlIp}/console/bimfile/modelConstructInfoCors`),
                (o = { viewToken: this.optionConfig.viewToken })),
            Bg(r, o).then((t) => {
              let { data: e } = t;
              if (e.success) {
                if (0 === e.result.jsons.length)
                  return void (this.errorMsg = '模型或者图纸未转换完成');
                let t,
                  n = '',
                  i = new eg(Gf);
                for (let r = 0, o = e.result.jsons.length; r < o; r++) {
                  let o = e.result.jsons[r];
                  n || (n = o.URI.split('.com/')[0] + '.com/');
                  let s = new gm();
                  s.setType(o.resultType),
                    s.setURL(o.URI),
                    s.setFileSize(o.FileSize),
                    i.addFileIndex(s);
                  let a = s.getType();
                  (9 !== a && 13 !== a) || (t = s);
                }
                if ((i.setCloudURL(n), !t))
                  return (
                    (this.errorMsg = '协议文件丢失'),
                    void console.error(this.errorMsg)
                  );
                let r = this.bimViewer.getRenderContext().getTextureLoader();
                switch (((r.fileLoader = i), t.getType())) {
                  case 9:
                    this.fileDataInterface = new Gm(r, this);
                    break;
                  case 13:
                    this.fileDataInterface = new Wb(r, this);
                }
                if (!this.fileDataInterface)
                  return void (this.errorMsg = '无法解析的协议版本');
                console.log('Head protocol type.' + t.getType().toString());
                let o = { version: this.optionConfig.viewToken, headFile: t };
                this.fileDataInterface
                  .createModel(o, (t) => {
                    let e = document.getElementById(
                      'ccbim__basic__progress__div',
                    );
                    if (
                      (e &&
                        ((e.style.width = t + '%'), (e.innerHTML = t + '%')),
                      t >= 100)
                    ) {
                      let t = document.getElementById('ccbim__basic__progress');
                      t && t.parentNode && t.parentNode.removeChild(t);
                    }
                  })
                  .then((t) => {
                    p_(this),
                      (this.eventManager = new A_(
                        this.bimViewer.renderContext.renderer.domElement,
                        this,
                      )),
                      this.eventManager.init();
                    let e = this.bimViewer.getModelScene();
                    e.addModel(t);
                    let n = this.bimViewer.getMainCamera();
                    n.makeLookAt(
                      new J(1, -1, 1),
                      new J(0, 0, 0),
                      new J(0, 0, 1),
                    );
                    let i = e.getBoundingBox();
                    n.makeLookAtBoundingBox(i),
                      this.bimViewer.cameraChanged(),
                      this.bimViewer.setProgressiveRendering(!1),
                      (this.viewer = new B_(this));
                  })
                  .catch((t) => {
                    console.log(t);
                  });
              } else
                (this.errorCode = e.errorCode),
                  !(function (t) {
                    if ('string' == typeof t)
                      try {
                        let e = JSON.parse(t);
                        return !('object' != typeof e || !e);
                      } catch (e) {
                        return console.log('error：' + t + '!!!' + e), !1;
                      }
                    console.log('It is not a string!');
                  })(e.errorMsg)
                    ? (this.errorMsg = e.errorMsg)
                    : (this.errorMsg = JSON.parse(e.errorMsg)),
                  Vg(
                    this.optionConfig.dom,
                    this.errorCode,
                    this.errorMsg,
                    () => {
                      Bg(
                        `${this.optionConfig.urlIp}/front/bimfile/reconvert.htm`,
                        { viewToken: this.optionConfig.viewToken },
                      ).then((t) => {
                        t.data.success && (this.dispose(), this.addView());
                      });
                    },
                  );
            });
        } else alert('webGL不支持，请重启浏览器或安装谷歌浏览器。');
      }
      getViewer() {
        return this.viewer;
      }
      dispose() {
        if (this.fileDataInterface) {
          this.fileDataInterface.getFileLoader().cancelAxios(),
            this.fileDataInterface.cancelCreateModelAsync();
        }
        let t = this.bimViewer.getModelScene();
        const e = t.getModelArray();
        t.removeModel(e[0]);
        let n = this.bimViewer.renderContext.getSceneList();
        (n.progressive1 = []),
          (n.progressive2 = []),
          f_(this.optionConfig.dom),
          (this.optionConfig.dom.innerHTML = ''),
          console.log('销毁成功');
      }
      renderFinish() {
        const t = this.bimViewer.getModelScene().getModelArray();
        let e = new Map();
        const n = t[0].modelTree.getRootNode();
        this.initFloorTreeUI([n], e), (this.floorIdFromNameMap = e);
        const i = t[0].modelTree.getLayerArray();
        let r;
        i.length > 1 && t[0].modelTree.setCurrentLayer(i[0].id);
        let o,
          s = localStorage.getItem('ccbim_switchBorder');
        s && (r = JSON.parse(s)),
          r &&
            (r.checkedBorder
              ? this.bimViewer.setWireframeVisible(!0)
              : this.bimViewer.setWireframeVisible(!1));
        let a,
          c = localStorage.getItem('ccbim_switchShadow');
        c && (o = JSON.parse(c)), o && (o.checkedShadow ? ig(this) : og(this));
        let l,
          h = localStorage.getItem('ccbim_switchTexture');
        h && (a = JSON.parse(h)),
          a && (a.checkedColor ? ag(this) : a.checkedTexture && sg(this));
        let u = localStorage.getItem('ccbim_switchShowPoint');
        u && (l = JSON.parse(u)),
          l && cg(l.checkedShowPoint, this),
          this.bimViewer.cameraChanged();
      }
      initFloorTreeUI(t, e) {
        for (let n = 0; n < t.length; n++) {
          let i = t[n];
          e.set(i.floorName, i.floorID),
            (i.checked = !0),
            (i.checkedHalf = !1),
            (i.opened = !1),
            i.type === tm && (i.opened = !0),
            i.childArray && this.initFloorTreeUI(i.childArray, e);
        }
      }
    }),
    (t.WebAppModelConfig = class {
      constructor() {
        (this.dom = null),
          (this.urlIp = 'https://open.ccbim.com'),
          (this.viewToken = ''),
          (this.versionId = ''),
          (this.operationBar = { showBar: !0, buttons: [] }),
          (this.selectEntityAction = { visible: !1, list: [] }),
          (this.viewWidth = null),
          (this.viewHeight = null),
          (this.wireframe = !1),
          (this.backgroundAlpha = !1),
          (this.backgroundColor = {
            topColor: '#f5f5f5',
            bottomColor: '#f5f5f5',
          }),
          (this.viewBoxVisible = !0);
      }
    }),
    (t.WebAppPanorama = class extends e {
      constructor(t) {
        super(), this.init(t);
      }
      init(t) {
        let e = { urlIp: t.urlIp, versionId: t.versionId };
        this.panorama = new jf(t.dom, e);
      }
      addView() {
        this.panorama.run(),
          this.panorama.addEventListener(n.renderFinish, (t) => {
            t.object &&
              this.dispatchEvent({ type: n.renderFinish, object: !0 });
          });
      }
    }),
    (t.WebAppPanoramaConfig = class {
      constructor() {
        (this.dom = null),
          (this.urlIp = 'https://open.ccbim.com'),
          (this.viewToken = ''),
          (this.versionId = '');
      }
    }),
    Object.defineProperty(t, '__esModule', { value: !0 });
});
